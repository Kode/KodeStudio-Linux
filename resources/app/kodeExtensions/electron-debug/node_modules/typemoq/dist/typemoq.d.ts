// Generated by dts-bundle v0.7.2

declare module 'typemoq' {
    export { MockBehavior } from "typemoq/Api/MockBehavior";
    export { MockApi as Mock } from "typemoq/Api/MockApi";
    export { IMock } from "typemoq/Api/IMock";
    export { It } from "typemoq/Api/It";
    export { Times } from "typemoq/Api/Times";
    export { ExpectedCallType } from "typemoq/Api/ExpectedCallType";
    export { GlobalMockApi as GlobalMock } from "typemoq/Api/GlobalMockApi";
    export { IGlobalMock } from "typemoq/Api/IGlobalMock";
    export { GlobalScopeApi as GlobalScope } from "typemoq/Api/GlobalScopeApi";
    export { MockException } from "typemoq/Error/MockException";
}

declare module 'typemoq/Api/MockBehavior' {
    export enum MockBehavior {
        Loose = 0,
        Strict = 1,
    }
}

declare module 'typemoq/Api/MockApi' {
    import * as common from "typemoq/Common/_all";
    import { MockBehavior } from "typemoq/Api/MockBehavior";
    import { IMock } from "typemoq/Api/IMock";
    export class MockApi {
        static ofInstance<U>(targetInstance: U, behavior?: MockBehavior, shouldOverrideTarget?: boolean): IMock<U>;
        static ofType<U>(targetConstructor?: common.CtorWithArgs<U>, behavior?: MockBehavior, shouldOverrideTarget?: boolean, ...targetConstructorArgs: any[]): IMock<U>;
        static ofType2<U>(targetConstructor: common.CtorWithArgs<U>, targetConstructorArgs: any[], behavior?: MockBehavior, shouldOverrideTarget?: boolean): IMock<U>;
    }
}

declare module 'typemoq/Api/IMock' {
    import * as common from "typemoq/Common/_all";
    import { MethodCallReturn } from "typemoq/MethodCallReturn";
    import { MockBehavior } from "typemoq/Api/MockBehavior";
    import { Times } from "typemoq/Api/Times";
    export interface IMock<T> {
        readonly object: T;
        readonly target: T;
        readonly name: string;
        readonly behavior: MockBehavior;
        callBase: boolean;
        setup<TResult>(expression: common.IFunc2<T, TResult>): MethodCallReturn<T, TResult>;
        verify<TResult>(expression: common.IFunc2<T, TResult>, times: Times): void;
        verifyAll(): void;
        reset(): void;
    }
}

declare module 'typemoq/Api/It' {
    import * as common from "typemoq/Common/_all";
    export class It {
        static isValue<T>(x: T): T;
        static isObjectWith<T>(x: {
            [P in keyof T]?: T[P];
        }): T;
        static isAnyObject<T>(x: common.Ctor<T>): T;
        static isAny(): any;
        static isAnyString(): string;
        static isAnyNumber(): number;
        static is<T>(predicate: common.IFunc2<T, boolean>): T;
    }
}

declare module 'typemoq/Api/Times' {
    import * as proxy from "typemoq/Proxy/_all";
    export class Times {
        readonly min: number;
        readonly max: number;
        failMessage(call: proxy.ICallContext): string;
        verify(callCount: number): boolean;
        static exactly(n: number): Times;
        static atLeast(n: number): Times;
        static atMost(n: number): Times;
        static never(): Times;
        static once(): Times;
        static atLeastOnce(): Times;
        static atMostOnce(): Times;
        toString(): string;
    }
}

declare module 'typemoq/Api/ExpectedCallType' {
    export enum ExpectedCallType {
        InAnyOrder = 0,
        InSequence = 1,
    }
}

declare module 'typemoq/Api/GlobalMockApi' {
    import * as common from "typemoq/Common/_all";
    import { MockBehavior } from "typemoq/Api/MockBehavior";
    import { IGlobalMock } from "typemoq/Api/IGlobalMock";
    export class GlobalMockApi {
        static ofInstance<U>(targetInstance: U, globalName?: string, container?: Object, behavior?: MockBehavior): IGlobalMock<U>;
        static ofType<U>(targetConstructor: common.Ctor<U>, container?: Object, behavior?: MockBehavior): IGlobalMock<U>;
        static ofType2<U>(globalName: string, container?: Object, behavior?: MockBehavior): IGlobalMock<U>;
    }
}

declare module 'typemoq/Api/IGlobalMock' {
    import { IMock } from "typemoq/Api/IMock";
    import { GlobalType } from "typemoq/GlobalMock";
    export interface IGlobalMock<T> extends IMock<T> {
        readonly mock: IMock<T>;
        readonly type: GlobalType;
        readonly container: Object;
    }
}

declare module 'typemoq/Api/GlobalScopeApi' {
    import * as all from "typemoq/Api/_all";
    import { IUsingResult } from "typemoq/Api/IUsing";
    export class GlobalScopeApi {
        static using(...args: all.IGlobalMock<any>[]): IUsingResult;
    }
}

declare module 'typemoq/Error/MockException' {
    import { Exception } from "typemoq/Error/Exception";
    export enum MockExceptionReason {
        NoSetup,
        MoreThanOneSetup,
        InvalidArg,
        InvalidSetup,
        InvalidMatcher,
        UnknownGlobalType,
        CallCountVerificationFailed,
        CallOrderVerificationFailed,
        InvalidDynamicProxyRuntime,
    }
    export class MockException extends Exception {
        readonly reason: MockExceptionReason;
        readonly ctx: any;
        readonly message: string;
        constructor(reason: MockExceptionReason, ctx: any, message?: string);
        toString(): string;
    }
}

declare module 'typemoq/Common/_all' {
    export * from "typemoq/Common/Ctor";
    export * from "typemoq/Common/Func";
    export * from "typemoq/Common/PropertyRetriever";
    export * from "typemoq/Common/PropDescriptor";
    export * from "typemoq/Common/Utils";
}

declare module 'typemoq/MethodCallReturn' {
    import * as all from "typemoq/_all";
    import { MockBase } from "typemoq/MockBase";
    import { MethodCall } from "typemoq/MethodCall";
    export class MethodCallReturn<T, TResult> extends MethodCall<T, TResult> implements all.ISetup<T, TResult>, all.IReturnsResult<T> {
        protected _returnValueFunc: all.IFuncN<any, TResult>;
        hasReturnValue: boolean;
        protected _callBase: boolean;
        static ofStaticMock<U, UResult>(mock: MockBase<U>, setupExpression: all.IFunc2<U, UResult>): MethodCallReturn<U, UResult>;
        static ofDynamicMock<U, UResult>(mock: MockBase<U>, setupExpression: all.IFunc2<U, UResult>): MethodCallReturn<U, UResult>;
        execute(call: all.ICallContext): void;
        callback(action: all.IActionN<any>): all.IReturnsThrows<T, TResult>;
        throws(exception: Error): all.IThrowsResult;
        returns(valueFunc: all.IFuncN<any, TResult>): all.IReturnsResult<T>;
        callBase(): all.IReturnsResult<T>;
    }
}

declare module 'typemoq/Proxy/_all' {
    export * from "typemoq/Proxy/ICallContext";
    export * from "typemoq/Proxy/ICallInterceptor";
    export * from "typemoq/Proxy/Invocation";
    export * from "typemoq/Proxy/IProxyCall";
    export * from "typemoq/Proxy/IProxy";
    export * from "typemoq/Proxy/ProxyES5";
    export * from "typemoq/Proxy/ProxyES6";
    export * from "typemoq/Proxy/ProxyFactory";
}

declare module 'typemoq/GlobalMock' {
    import * as all from "typemoq/_all";
    import { MockBehavior } from "typemoq/_all";
    import { MethodCallReturn } from "typemoq/MethodCallReturn";
    export enum GlobalType {
        Class = 0,
        Function = 1,
        Value = 2,
    }
    export class GlobalMock<T> implements all.IGlobalMock<T> {
        mock: all.IMock<T>;
        container: Object;
        constructor(mock: all.IMock<T>, _name: string, _type: GlobalType, container: Object);
        readonly object: T;
        readonly target: T;
        readonly name: string;
        readonly behavior: MockBehavior;
        callBase: boolean;
        readonly type: GlobalType;
        setup<TResult>(expression: all.IFunc2<T, TResult>): MethodCallReturn<T, TResult>;
        verify<TResult>(expression: all.IFunc2<T, TResult>, times: all.Times): void;
        verifyAll(): void;
        reset(): void;
    }
}

declare module 'typemoq/Api/_all' {
    export * from "typemoq/Api/ICallback";
    export * from "typemoq/Api/IGlobalMock";
    export * from "typemoq/Api/IMock";
    export * from "typemoq/Api/IReturns";
    export * from "typemoq/Api/ISetup";
    export * from "typemoq/Api/IThrows";
    export * from "typemoq/Api/IUsing";
    export * from "typemoq/Api/IVerifies";
    export * from "typemoq/Api/MockBehavior";
    export * from "typemoq/Api/ExpectedCallType";
    export * from "typemoq/Api/Times";
}

declare module 'typemoq/Api/IUsing' {
    import * as common from "typemoq/Common/_all";
    export interface IUsingResult {
        with(action: common.IAction): void;
    }
}

declare module 'typemoq/Error/Exception' {
    export class Exception extends Error {
        name: string;
        constructor(name: string, message: string);
        toString(): string;
    }
}

declare module 'typemoq/Common/Ctor' {
    export type Ctor<T> = {
        new (): T;
        prototype: Object;
    };
    export type CtorWithArgs<T> = {
        new (...ctorArgs: any[]): T;
        prototype: Object;
    };
}

declare module 'typemoq/Common/Func' {
    export type IAction = () => void;
    export type IAction1<T> = (x: T) => void;
    export type IActionN<T> = (...x: T[]) => void;
    export type IFunc1<TResult> = () => TResult;
    export type IFunc2<T, TResult> = (x: T) => TResult;
    export type IFuncN<T, TResult> = (...x: T[]) => TResult;
}

declare module 'typemoq/Common/PropertyRetriever' {
    import { PropDescriptor } from "typemoq/Common/PropDescriptor";
    export class PropertyRetriever {
        static getOwnEnumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getOwnNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getOwnEnumerablesAndNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getPrototypeEnumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getPrototypeNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getPrototypeEnumerablesAndNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getOwnAndPrototypeEnumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getOwnAndPrototypeNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
        static getOwnAndPrototypeEnumerablesAndNonenumerables(obj: any): {
            name: string;
            desc: PropDescriptor;
        }[];
    }
}

declare module 'typemoq/Common/PropDescriptor' {
    export interface PropDescriptor {
        configurable?: boolean;
        enumerable?: boolean;
        value?: any;
        writable?: boolean;
        get?(): any;
        set?(v: any): void;
    }
    export interface PropDescriptorMap {
        [s: string]: PropDescriptor;
    }
}

declare module 'typemoq/Common/Utils' {
    import { CtorWithArgs } from "typemoq/Common/Ctor";
    export class Utils {
        static functionName(fun: Object): string;
        static objectName(obj: Object): string;
        static argsName(args: IArguments): string;
        static conthunktor<U>(ctor: CtorWithArgs<U>, args: any[]): U;
        static clone(target: Object, source: Object): void;
    }
}

declare module 'typemoq/_all' {
    export * from "typemoq/Api/_all";
    export * from "typemoq/Common/_all";
    export * from "typemoq/Error/_all";
    export * from "typemoq/Match/_all";
    export * from "typemoq/Proxy/_all";
}

declare module 'typemoq/MockBase' {
    import * as all from "typemoq/_all";
    import { InterceptorExecute } from "typemoq/InterceptorExecute";
    import { MethodCallReturn } from "typemoq/MethodCallReturn";
    export abstract class MockBase<T> implements all.IMock<T> {
        readonly target: T;
        readonly canOverrideTarget: boolean;
        readonly behavior: all.MockBehavior;
        protected _name: string;
        protected _interceptor: InterceptorExecute<T>;
        protected _proxy: T;
        constructor(target: T, canOverrideTarget: boolean, behavior?: all.MockBehavior);
        readonly object: T;
        readonly name: string;
        callBase: boolean;
        abstract setup<TResult>(expression: all.IFunc2<T, TResult>): MethodCallReturn<T, TResult>;
        abstract verify<TResult>(expression: all.IFunc2<T, TResult>, times: all.Times): void;
        verifyAll(): void;
        reset(): void;
    }
}

declare module 'typemoq/MethodCall' {
    import * as all from "typemoq/_all";
    import { MockBase } from "typemoq/MockBase";
    import { InterceptorSetup } from "typemoq/InterceptorSetup";
    export class MethodCall<T, TResult> implements all.IProxyCall<T>, all.IVerifies {
        mock: MockBase<T>;
        protected _id: string;
        protected _setupCall: all.ICallContext;
        protected _setupCallback: all.IAction;
        protected _isVerifiable: boolean;
        protected _expectedCallCount: all.Times;
        protected _expectedCallType: all.ExpectedCallType;
        protected _isInvoked: boolean;
        protected _callCount: number;
        protected _thrownException: Error;
        protected _evaluatedSuccessfully: boolean;
        protected constructor(mock: MockBase<T>, _setupExpression: all.IFunc2<T, TResult>, interceptor: InterceptorSetup<T>, proxy: T);
        static ofStaticMock<U, UResult>(mock: MockBase<U>, setupExpression: all.IFunc2<U, UResult>): MethodCall<U, UResult>;
        static ofDynamicMock<U, UResult>(mock: MockBase<U>, setupExpression: all.IFunc2<U, UResult>): MethodCall<U, UResult>;
        readonly id: string;
        readonly setupExpression: all.IAction1<T>;
        readonly setupCall: all.ICallContext;
        readonly isVerifiable: boolean;
        readonly isInSequence: boolean;
        readonly expectedCallCount: all.Times;
        readonly isInvoked: boolean;
        readonly callCount: number;
        setVerifiable(times?: all.Times, expectedCallType?: all.ExpectedCallType): void;
        evaluatedSuccessfully(): void;
        matches(call: all.ICallContext): boolean;
        execute(call: all.ICallContext): void;
        verifiable(times?: all.Times, expectedCallType?: all.ExpectedCallType): void;
        toString(): string;
    }
}

declare module 'typemoq/Proxy/ICallContext' {
    import { IPropertyInfo, InvocationType } from "typemoq/Proxy/Invocation";
    export enum CallType {
        UNKNOWN = 0,
        PROPERTY = 1,
        FUNCTION = 2,
    }
    export enum ProxyType {
        STATIC = 0,
        DYNAMIC = 1,
    }
    export interface ICallContext {
        args: IArguments;
        property: IPropertyInfo;
        returnValue: any;
        invokeBase(): void;
        invocationType: InvocationType;
        callType: CallType;
        proxyType: ProxyType;
        isAnUnknownDynamicCallAtExecution: boolean;
    }
}

declare module 'typemoq/Proxy/ICallInterceptor' {
    import { ICallContext } from "typemoq/Proxy/ICallContext";
    export interface ICallInterceptor {
        intercept(context: ICallContext): void;
        removeInvocation(context: ICallContext): void;
    }
}

declare module 'typemoq/Proxy/Invocation' {
    import * as common from "typemoq/Common/_all";
    import { ICallContext, CallType, ProxyType } from "typemoq/Proxy/ICallContext";
    export enum InvocationType {
        NONE = 0,
        SETUP = 1,
        EXECUTE = 2,
    }
    export abstract class BaseInvocation implements ICallContext {
        readonly proxyType: ProxyType;
        callType: CallType;
        returnValue: any;
        invocationType: InvocationType;
        constructor(proxyType: ProxyType, callType: CallType);
        abstract args: IArguments;
        readonly abstract property: IPropertyInfo;
        abstract invokeBase(): void;
        readonly isAnUnknownDynamicCallAtExecution: boolean;
    }
    export class MethodInvocation extends BaseInvocation {
        constructor(_that: Object, _property: MethodInfo, args?: IArguments, proxyType?: ProxyType, callType?: CallType);
        args: IArguments;
        readonly property: IPropertyInfo;
        invokeBase(): void;
        toString(): string;
    }
    export class ValueGetterInvocation extends BaseInvocation {
        readonly value: any;
        constructor(_property: IPropertyInfo, value: any, proxyType?: ProxyType, callType?: CallType);
        args: IArguments;
        readonly property: IPropertyInfo;
        invokeBase(): void;
        toString(): string;
    }
    export class DynamicGetInvocation extends ValueGetterInvocation {
        constructor(property: IPropertyInfo, value: any);
    }
    export class ValueSetterInvocation extends BaseInvocation {
        constructor(_property: IPropertyInfo, args: IArguments, proxyType?: ProxyType, callType?: CallType);
        args: IArguments;
        readonly property: IPropertyInfo;
        invokeBase(): void;
        toString(): string;
    }
    export class MethodGetterInvocation extends BaseInvocation {
        constructor(_property: IPropertyInfo, _getter: () => any, proxyType?: ProxyType, callType?: CallType);
        args: IArguments;
        readonly property: IPropertyInfo;
        invokeBase(): void;
        toString(): string;
    }
    export class MethodSetterInvocation extends BaseInvocation {
        constructor(_property: IPropertyInfo, _setter: (v: any) => void, args: IArguments, proxyType?: ProxyType, callType?: CallType);
        args: IArguments;
        readonly property: IPropertyInfo;
        invokeBase(): void;
        toString(): string;
    }
    export class MethodInfo implements IPropertyInfo {
        readonly obj: any;
        readonly name: string;
        readonly desc: common.PropDescriptor;
        constructor(obj: any, name: string, desc?: common.PropDescriptor);
        readonly toFunc: Function;
        toString(): string;
    }
    export class PropertyInfo implements IPropertyInfo {
        readonly obj: Object;
        readonly name: string;
        readonly desc: common.PropDescriptor;
        constructor(obj: Object, name: string, desc?: common.PropDescriptor);
        toString(): string;
    }
    export interface IPropertyInfo {
        obj: Object;
        name: string;
        desc?: common.PropDescriptor;
    }
}

declare module 'typemoq/Proxy/IProxyCall' {
    import * as common from "typemoq/Common/_all";
    import * as api from "typemoq/Api/_all";
    import { ICallContext } from "typemoq/Proxy/ICallContext";
    export interface IProxyCall<T> {
        id: string;
        setupExpression: common.IAction1<T>;
        setupCall: ICallContext;
        isVerifiable: boolean;
        isInSequence: boolean;
        expectedCallCount: api.Times;
        isInvoked: boolean;
        callCount: number;
        setVerifiable(times?: api.Times, expectedCallType?: api.ExpectedCallType): void;
        evaluatedSuccessfully(): void;
        matches(call: ICallContext): boolean;
        execute(call: ICallContext): void;
    }
}

declare module 'typemoq/Proxy/IProxy' {
    export interface IProxy {
        ___id: string;
    }
}

declare module 'typemoq/Proxy/ProxyES5' {
    import { IProxy } from "typemoq/Proxy/IProxy";
    import { ICallInterceptor } from "typemoq/Proxy/ICallInterceptor";
    export class ProxyES5<T> implements IProxy {
        readonly ___id: string;
        static of<U>(target: U, interceptor: ICallInterceptor): ProxyES5<U>;
        static isProxy(obj: any): boolean;
    }
}

declare module 'typemoq/Proxy/ProxyES6' {
    import { IProxy } from "typemoq/Proxy/IProxy";
    import { IProxyHandler } from "typemoq/Proxy/IProxyHandler";
    export class ProxyES6<T> implements IProxy {
        readonly ___id: string;
        static of<U>(target: U, handler: IProxyHandler<U>): ProxyES6<U>;
    }
}

declare module 'typemoq/Proxy/ProxyFactory' {
    import { ICallInterceptor } from "typemoq/Proxy/ICallInterceptor";
    export class ProxyFactory {
        static createProxy<T>(target: T, interceptor: ICallInterceptor): T;
        static createProxyES6<T>(target: T, interceptor: ICallInterceptor): T;
    }
}

declare module 'typemoq/Api/ICallback' {
    import * as common from "typemoq/Common/_all";
    import { IReturnsThrows } from "typemoq/Api/IReturns";
    export interface ICallback<T, TResult> {
        callback(action: common.IAction): IReturnsThrows<T, TResult>;
        callback(action: common.IAction1<T>): IReturnsThrows<T, TResult>;
    }
}

declare module 'typemoq/Api/IReturns' {
    import * as common from "typemoq/Common/_all";
    import { IVerifies } from "typemoq/Api/IVerifies";
    import { IThrows } from "typemoq/Api/IThrows";
    export interface IReturns<T, TResult> {
        returns(valueFunction: common.IFuncN<any, TResult>): IReturnsResult<T>;
        callBase(): IReturnsResult<T>;
    }
    export interface IReturnsResult<T> extends IVerifies {
    }
    export interface IReturnsThrows<T, TResult> extends IReturns<T, TResult>, IVerifies, IThrows {
    }
}

declare module 'typemoq/Api/ISetup' {
    import { ICallback } from "typemoq/Api/ICallback";
    import { IReturnsThrows } from "typemoq/Api/IReturns";
    import { IVerifies } from "typemoq/Api/IVerifies";
    export interface ISetup<T, TResult> extends ICallback<T, TResult>, IReturnsThrows<T, TResult>, IVerifies {
    }
}

declare module 'typemoq/Api/IThrows' {
    import { IVerifies } from "typemoq/Api/IVerifies";
    export interface IThrows {
        throws<T extends Error>(exception: T): IThrowsResult;
    }
    export interface IThrowsResult extends IVerifies {
    }
}

declare module 'typemoq/Api/IVerifies' {
    import { Times } from "typemoq/Api/Times";
    export interface IVerifies {
        verifiable(times?: Times): void;
    }
}

declare module 'typemoq/Error/_all' {
    export * from "typemoq/Error/Exception";
    export * from "typemoq/Error/MockException";
}

declare module 'typemoq/Match/_all' {
    export * from "typemoq/Match/IMatch";
    export * from "typemoq/Match/Match";
    export * from "typemoq/Match/MatchAny";
    export * from "typemoq/Match/MatchPred";
    export * from "typemoq/Match/MatchValue";
    export * from "typemoq/Match/MatchObjectWith";
}

declare module 'typemoq/InterceptorExecute' {
    import * as all from "typemoq/_all";
    import { InterceptorContext } from "typemoq/InterceptorContext";
    export class InterceptorExecute<T> implements all.ICallInterceptor {
        constructor(mock: all.IMock<T>);
        readonly interceptorContext: InterceptorContext<T>;
        intercept(invocation: all.ICallContext): void;
        removeInvocation(invocation: all.ICallContext): void;
        addExpectedCall(call: all.IProxyCall<T>): void;
        verify(): void;
        verifyCallCount<T>(call: all.IProxyCall<T>, times: all.Times): void;
        reset(): void;
    }
}

declare module 'typemoq/InterceptorSetup' {
    import * as all from "typemoq/_all";
    export class InterceptorSetup<T> implements all.ICallInterceptor {
        readonly interceptedCall: all.ICallContext;
        intercept(invocation: all.ICallContext): void;
        removeInvocation(invocation: all.ICallContext): void;
    }
}

declare module 'typemoq/Proxy/IProxyHandler' {
    import * as common from "typemoq/Common/_all";
    export type PropKey = string | number | symbol;
    export interface IProxyHandler<T> {
        getPrototypeOf?(target: T): Object | null;
        setPrototypeOf?(target: T, v: any): boolean;
        isExtensible?(target: T): boolean;
        preventExtensions?(target: T): boolean;
        getOwnPropertyDescriptor?(target: T, p: PropKey): common.PropDescriptor;
        has?(target: T, p: PropKey): boolean;
        get?(target: T, p: PropKey, receiver: any): any;
        set?(target: T, p: PropKey, value: any, receiver: any): boolean;
        deleteProperty?(target: T, p: PropKey): boolean;
        defineProperty?(target: T, p: PropKey, attributes: common.PropDescriptor): boolean;
        enumerate?(target: T): PropKey[];
        ownKeys?(target: T): PropKey[];
        apply?(target: T, thisArg: any, argArray?: any): any;
        construct?(target: T, argArray: any, newTarget?: any): Object;
    }
}

declare module 'typemoq/Match/IMatch' {
    export interface IMatch {
        readonly ___id: string;
        ___matches(object: Object): boolean;
    }
}

declare module 'typemoq/Match/Match' {
    export class Match {
        static isMatcher(x: any): boolean;
    }
}

declare module 'typemoq/Match/MatchAny' {
    import * as common from "typemoq/Common/_all";
    import { IMatch } from "typemoq/Match/IMatch";
    export class MatchAnyObject<T> implements IMatch {
        readonly ___id: string;
        constructor(_ctor: common.Ctor<T>);
        ___matches(object: Object): boolean;
        toString(): string;
    }
    export class MatchAny implements IMatch {
        readonly ___id: string;
        ___matches(object: Object): boolean;
        toString(): string;
    }
    export class MatchAnyString implements IMatch {
        readonly ___id: string;
        ___matches(object: Object): boolean;
        toString(): string;
    }
    export class MatchAnyNumber implements IMatch {
        readonly ___id: string;
        ___matches(object: Object): boolean;
        toString(): string;
    }
}

declare module 'typemoq/Match/MatchPred' {
    import * as common from "typemoq/Common/_all";
    import { IMatch } from "typemoq/Match/IMatch";
    export class MatchPred<T> implements IMatch {
        readonly ___id: string;
        constructor(_pred: common.IFunc2<T, boolean>);
        ___matches(object: Object): boolean;
        toString(): string;
    }
}

declare module 'typemoq/Match/MatchValue' {
    import { IMatch } from "typemoq/Match/IMatch";
    export class MatchValue<T> implements IMatch {
        readonly ___id: string;
        constructor(value: T);
        ___matches(object: any): boolean;
        toString(): string;
    }
}

declare module 'typemoq/Match/MatchObjectWith' {
    import { IMatch } from "typemoq/Match/IMatch";
    export class MatchObjectWith<T> implements IMatch {
        readonly ___id: string;
        constructor(value: T);
        ___matches(object: Object): boolean;
        toString(): string;
    }
}

declare module 'typemoq/InterceptorContext' {
    import * as all from "typemoq/_all";
    import { CurrentInterceptContext } from "typemoq/CurrentInterceptContext";
    export enum InterceptionAction {
        Continue = 0,
        Stop = 1,
    }
    export interface IInterceptStrategy<T> {
        handleIntercept(invocation: all.ICallContext, ctx: InterceptorContext<T>, localCtx: CurrentInterceptContext<T>): InterceptionAction;
    }
    export class InterceptorContext<T> {
        mock: all.IMock<T>;
        constructor(mock: all.IMock<T>);
        readonly behavior: all.MockBehavior;
        addInvocation(invocation: all.ICallContext): void;
        removeInvocation(invocation: all.ICallContext): void;
        actualInvocations(): all.ICallContext[];
        addExpectedCall(call: all.IProxyCall<T>): void;
        removeExpectedCall(call: all.IProxyCall<T>): void;
        expectedCalls(): all.IProxyCall<T>[];
        reset(): void;
    }
}

declare module 'typemoq/CurrentInterceptContext' {
    import * as all from "typemoq/_all";
    export class CurrentInterceptContext<T> {
        call: all.IProxyCall<T>;
    }
}

