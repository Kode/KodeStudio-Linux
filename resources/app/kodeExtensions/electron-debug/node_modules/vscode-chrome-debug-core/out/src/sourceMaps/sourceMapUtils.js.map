{"version":3,"sources":["../src/sourceMaps/sourceMapUtils.ts"],"names":[],"mappings":"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","file":"sourceMapUtils.js","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\nimport * as url from 'url';\n\nimport * as utils from '../utils';\nimport { logger } from 'vscode-debugadapter';\nimport { ISourceMapPathOverrides } from '../debugAdapterInterfaces';\n\n/**\n * Resolves a relative path in terms of another file\n */\nexport function resolveRelativeToFile(absPath: string, relPath: string): string {\n    return path.resolve(path.dirname(absPath), relPath);\n}\n\n/**\n * Determine the absolute path to the sourceRoot.\n */\nexport function getComputedSourceRoot(sourceRoot: string, generatedPath: string, webRoot = ''): string {\n    let absSourceRoot: string;\n    if (sourceRoot) {\n        if (sourceRoot.startsWith('file:///')) {\n            // sourceRoot points to a local path like \"file:///c:/project/src\", make it an absolute path\n            absSourceRoot = utils.canonicalizeUrl(sourceRoot);\n        } else if (sourceRoot.startsWith('/')) {\n            // sourceRoot is like \"/src\", would be like http://localhost/src, resolve to a local path under webRoot\n            // note that C:/src (or /src as an absolute local path) is not a valid sourceroot\n            absSourceRoot = path.join(webRoot, sourceRoot);\n        } else {\n            // sourceRoot is like \"src\" or \"../src\", relative to the script\n            if (path.isAbsolute(generatedPath)) {\n                absSourceRoot = resolveRelativeToFile(generatedPath, sourceRoot);\n            } else {\n                // generatedPath is a URL so runtime script is not on disk, resolve the sourceRoot location on disk\n                const genDirname = path.dirname(url.parse(generatedPath).pathname);\n                absSourceRoot = path.join(webRoot, genDirname, sourceRoot);\n            }\n        }\n\n        logger.log(`SourceMap: resolved sourceRoot ${sourceRoot} -> ${absSourceRoot}`);\n    } else if (path.isAbsolute(generatedPath)) {\n        absSourceRoot = path.dirname(generatedPath);\n        logger.log(`SourceMap: no sourceRoot specified, using script dirname: ${absSourceRoot}`);\n    } else {\n        // runtime script is not on disk, resolve the sourceRoot location on disk\n        const urlPath = url.parse(generatedPath).pathname;\n        const scriptPathDirname = urlPath ? path.dirname(urlPath) : ''; // could be debugadapter://123, no other info.\n        absSourceRoot = path.join(webRoot, scriptPathDirname);\n        logger.log(`SourceMap: no sourceRoot specified, using webRoot + script path dirname: ${absSourceRoot}`);\n    }\n\n    absSourceRoot = utils.stripTrailingSlash(absSourceRoot);\n    absSourceRoot = utils.fixDriveLetterAndSlashes(absSourceRoot);\n\n    return absSourceRoot;\n}\n\n/**\n * Applies a set of path pattern mappings to the given path. See tests for examples.\n * Returns something validated to be an absolute path.\n */\nexport function applySourceMapPathOverrides(sourcePath: string, sourceMapPathOverrides: ISourceMapPathOverrides): string {\n    const forwardSlashSourcePath = sourcePath.replace(/\\\\/g, '/');\n\n    // Sort the overrides by length, large to small\n    const sortedOverrideKeys = Object.keys(sourceMapPathOverrides)\n        .sort((a, b) => b.length - a.length);\n\n    // Iterate the key/vals, only apply the first one that matches.\n    for (let leftPattern of sortedOverrideKeys) {\n        const rightPattern = sourceMapPathOverrides[leftPattern];\n        const entryStr = `\"${leftPattern}\": \"${rightPattern}\"`;\n\n        const asterisks = leftPattern.match(/\\*/g) || [];\n        if (asterisks.length > 1) {\n            logger.log(`Warning: only one asterisk allowed in a sourceMapPathOverrides entry - ${entryStr}`);\n            continue;\n        }\n\n        const replacePatternAsterisks = rightPattern.match(/\\*/g) || [];\n        if (replacePatternAsterisks.length > asterisks.length) {\n            logger.log(`Warning: the right side of a sourceMapPathOverrides entry must have 0 or 1 asterisks - ${entryStr}}`);\n            continue;\n        }\n\n        // Does it match?\n        const escapedLeftPattern = utils.escapeRegexSpecialChars(leftPattern, '/*');\n        const leftRegexSegment = escapedLeftPattern\n            .replace(/\\*/g, '(.*)')\n            .replace(/\\\\\\\\/g, '/');\n        const leftRegex = new RegExp(`^${leftRegexSegment}$`, 'i');\n        const overridePatternMatches = forwardSlashSourcePath.match(leftRegex);\n        if (!overridePatternMatches)\n            continue;\n\n        // Grab the value of the wildcard from the match above, replace the wildcard in the\n        // replacement pattern, and return the result.\n        const wildcardValue = overridePatternMatches[1];\n        let mappedPath = rightPattern.replace(/\\*/g, wildcardValue);\n        mappedPath = path.join(mappedPath); // Fix any ..\n        logger.log(`SourceMap: mapping ${sourcePath} => ${mappedPath}, via sourceMapPathOverrides entry - ${entryStr}`);\n        return mappedPath;\n    }\n\n    return sourcePath;\n}\n\nexport function resolveMapPath(pathToGenerated: string, mapPath: string): string {\n    if (!utils.isURL(mapPath)) {\n        if (utils.isURL(pathToGenerated)) {\n            const scriptUrl = url.parse(pathToGenerated);\n            const scriptPath = scriptUrl.pathname;\n            if (!scriptPath) {\n                return null;\n            }\n\n            // runtime script is not on disk, map won't be either, resolve a URL for the map relative to the script\n            const mapUrlPathSegment = mapPath.startsWith('/') ? mapPath : path.posix.join(path.dirname(scriptPath), mapPath);\n            mapPath = `${scriptUrl.protocol}//${scriptUrl.host}${mapUrlPathSegment}`;\n        } else if (path.isAbsolute(pathToGenerated)) {\n            // mapPath needs to be resolved to an absolute path or a URL\n            // runtime script is on disk, so map should be too\n            mapPath = resolveRelativeToFile(pathToGenerated, mapPath);\n        }\n    }\n\n    return mapPath;\n}\n\nexport function getFullSourceEntry(sourceRoot: string | undefined, sourcePath: string): string {\n    if (!sourceRoot) {\n        return sourcePath;\n    }\n\n    if (!sourceRoot.endsWith('/')) {\n        sourceRoot += '/';\n    }\n\n    return sourceRoot + sourcePath;\n}\n"],"sourceRoot":"../.."}