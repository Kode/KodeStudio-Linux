{"version":3,"sources":["../src/transformers/baseSourceMapTransformer.ts"],"names":[],"mappings":"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","file":"baseSourceMapTransformer.js","sourceRoot":"../..","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\nimport { DebugProtocol } from 'vscode-debugprotocol';\n\nimport { ISetBreakpointsArgs, ILaunchRequestArgs, IAttachRequestArgs,\n    ISetBreakpointsResponseBody, IInternalStackTraceResponseBody, IScopesResponseBody, IInternalStackFrame } from '../debugAdapterInterfaces';\nimport { MappedPosition, ISourcePathDetails } from '../sourceMaps/sourceMap';\nimport { SourceMaps } from '../sourceMaps/sourceMaps';\nimport * as utils from '../utils';\nimport { logger } from 'vscode-debugadapter';\nimport { ISourceContainer } from '../chrome/chromeDebugAdapter';\n\nimport * as nls from 'vscode-nls';\nconst localize = nls.loadMessageBundle();\n\ninterface ISavedSetBreakpointsArgs {\n    generatedPath: string;\n    authoredPath: string;\n    originalBPs: DebugProtocol.Breakpoint[];\n}\n\nexport interface ISourceLocation {\n    source: DebugProtocol.Source;\n    line: number;\n    column: number;\n    isSourceMapped?: boolean; // compat with stack frame\n}\n\n/**\n * If sourcemaps are enabled, converts from source files on the client side to runtime files on the target side\n */\nexport class BaseSourceMapTransformer {\n    protected _sourceMaps: SourceMaps;\n    protected _sourceHandles: utils.ReverseHandles<ISourceContainer>;\n    private _enableSourceMapCaching: boolean;\n\n    private _requestSeqToSetBreakpointsArgs: Map<number, ISavedSetBreakpointsArgs>;\n    private _allRuntimeScriptPaths: Set<string>;\n    private _authoredPathsToMappedBPs: Map<string, DebugProtocol.SourceBreakpoint[]>;\n\n    protected _preLoad = Promise.resolve();\n    private _processingNewSourceMap: Promise<any> = Promise.resolve();\n\n    public caseSensitivePaths: boolean;\n\n    constructor(sourceHandles: utils.ReverseHandles<ISourceContainer>, enableSourceMapCaching?: boolean) {\n        this._sourceHandles = sourceHandles;\n        this._enableSourceMapCaching = enableSourceMapCaching;\n    }\n\n    public get sourceMaps(): SourceMaps {\n        return this._sourceMaps;\n    }\n\n    public launch(args: ILaunchRequestArgs): void {\n        this.init(args);\n    }\n\n    public attach(args: IAttachRequestArgs): void {\n        this.init(args);\n    }\n\n    protected init(args: ILaunchRequestArgs | IAttachRequestArgs): void {\n        if (args.sourceMaps) {\n            this._sourceMaps = new SourceMaps(args.webRoot, args.sourceMapPathOverrides, this._enableSourceMapCaching);\n            this._requestSeqToSetBreakpointsArgs = new Map<number, ISavedSetBreakpointsArgs>();\n            this._allRuntimeScriptPaths = new Set<string>();\n            this._authoredPathsToMappedBPs = new Map<string, DebugProtocol.SourceBreakpoint[]>();\n        }\n    }\n\n    public clearTargetContext(): void {\n        this._allRuntimeScriptPaths = new Set<string>();\n    }\n\n    /**\n     * Apply sourcemapping to the setBreakpoints request path/lines.\n     * Returns true if completed successfully, and setBreakpoint should continue.\n     */\n    public setBreakpoints(args: ISetBreakpointsArgs, requestSeq: number): ISetBreakpointsArgs {\n        if (!this._sourceMaps) {\n            return args;\n        }\n\n        const originalBPs = JSON.parse(JSON.stringify(args.breakpoints));\n\n        if (args.source.sourceReference) {\n            // If the source contents were inlined, then args.source has no path, but we\n            // stored it in the handle\n            const handle = this._sourceHandles.get(args.source.sourceReference);\n            if (handle && handle.mappedPath) {\n                args.source.path = handle.mappedPath;\n            }\n        }\n\n        if (args.source.path) {\n            const argsPath = args.source.path;\n            const mappedPath = this._sourceMaps.getGeneratedPathFromAuthoredPath(argsPath);\n            if (mappedPath) {\n                logger.log(`SourceMaps.setBP: Mapped ${argsPath} to ${mappedPath}`);\n                args.authoredPath = argsPath;\n                args.source.path = mappedPath;\n\n                // DebugProtocol doesn't send cols yet, but they need to be added from sourcemaps\n                args.breakpoints.forEach(bp => {\n                    const { line, column = 0 } = bp;\n                    const mapped = this._sourceMaps.mapToGenerated(argsPath, line, column);\n                    if (mapped) {\n                        logger.log(`SourceMaps.setBP: Mapped ${argsPath}:${line + 1}:${column + 1} to ${mappedPath}:${mapped.line + 1}:${mapped.column + 1}`);\n                        bp.line = mapped.line;\n                        bp.column = mapped.column;\n                    } else {\n                        logger.log(`SourceMaps.setBP: Mapped ${argsPath} but not line ${line + 1}, column 1`);\n                        bp.column = column; // take 0 default if needed\n                    }\n                });\n\n                this._authoredPathsToMappedBPs.set(argsPath, args.breakpoints);\n\n                // Include BPs from other files that map to the same file. Ensure the current file's breakpoints go first\n                this._sourceMaps.allMappedSources(mappedPath).forEach(sourcePath => {\n                    if (sourcePath === argsPath) {\n                        return;\n                    }\n\n                    const sourceBPs = this._authoredPathsToMappedBPs.get(sourcePath);\n                    if (sourceBPs) {\n                        // Don't modify the cached array\n                        args.breakpoints = args.breakpoints.concat(sourceBPs);\n                    }\n                });\n            } else if (this.isRuntimeScript(argsPath)) {\n                // It's a generated file which is loaded\n                logger.log(`SourceMaps.setBP: SourceMaps are enabled but ${argsPath} is a runtime script`);\n            } else {\n                // Source (or generated) file which is not loaded.\n                logger.log(`SourceMaps.setBP: ${argsPath} can't be resolved to a loaded script. It may just not be loaded yet.`);\n            }\n        } else {\n            // No source.path\n        }\n\n        this._requestSeqToSetBreakpointsArgs.set(requestSeq, {\n            originalBPs,\n            authoredPath: args.authoredPath,\n            generatedPath: args.source.path\n        });\n\n        return args;\n    }\n\n    /**\n     * Apply sourcemapping back to authored files from the response\n     */\n    public setBreakpointsResponse(response: ISetBreakpointsResponseBody, requestSeq: number): void {\n        if (this._sourceMaps && this._requestSeqToSetBreakpointsArgs.has(requestSeq)) {\n            const args = this._requestSeqToSetBreakpointsArgs.get(requestSeq);\n            if (args.authoredPath) {\n                // authoredPath is set, so the file was mapped to source.\n                // Remove breakpoints from files that map to the same file, and map back to source.\n                response.breakpoints = response.breakpoints.filter((_, i) => i < args.originalBPs.length);\n                response.breakpoints.forEach((bp, i) => {\n                    const mapped = this._sourceMaps.mapToAuthored(args.generatedPath, bp.line, bp.column);\n                    if (mapped) {\n                        logger.log(`SourceMaps.setBP: Mapped ${args.generatedPath}:${bp.line + 1}:${bp.column + 1} to ${mapped.source}:${mapped.line + 1}`);\n                        bp.line = mapped.line;\n                        bp.column = mapped.column;\n                    } else {\n                        logger.log(`SourceMaps.setBP: Can't map ${args.generatedPath}:${bp.line + 1}:${bp.column + 1}, keeping original line numbers.`);\n                        bp.line = args.originalBPs[i].line;\n                        bp.column = args.originalBPs[i].column;\n                    }\n\n                    this._requestSeqToSetBreakpointsArgs.delete(requestSeq);\n                });\n            }\n        }\n    }\n\n    /**\n     * Apply sourcemapping to the stacktrace response\n     */\n    public async stackTraceResponse(response: IInternalStackTraceResponseBody): Promise<void> {\n        if (this._sourceMaps) {\n            await this._processingNewSourceMap;\n            for (let stackFrame of response.stackFrames) {\n                await this.fixSourceLocation(stackFrame);\n            }\n        }\n    }\n\n    public async fixSourceLocation(sourceLocation: ISourceLocation|IInternalStackFrame): Promise<void> {\n        if (!this._sourceMaps) {\n            return;\n        }\n\n        if (!sourceLocation.source) {\n            return;\n        }\n\n        await this._processingNewSourceMap;\n\n        const mapped = this._sourceMaps.mapToAuthored(sourceLocation.source.path, sourceLocation.line, sourceLocation.column);\n        if (mapped && utils.existsSync(mapped.source)) {\n            // Script was mapped to a valid path\n            sourceLocation.source.path = mapped.source;\n            sourceLocation.source.sourceReference = undefined;\n            sourceLocation.source.name = path.basename(mapped.source);\n            sourceLocation.line = mapped.line;\n            sourceLocation.column = mapped.column;\n            sourceLocation.isSourceMapped = true;\n        } else {\n            const inlinedSource = mapped && this._sourceMaps.sourceContentFor(mapped.source);\n            if (mapped && inlinedSource) {\n                // Clear the path and set the sourceReference - the client will ask for\n                // the source later and it will be returned from the sourcemap\n                sourceLocation.source.name = path.basename(mapped.source);\n                sourceLocation.source.path = mapped.source;\n                sourceLocation.source.sourceReference = this.getSourceReferenceForScriptPath(mapped.source, inlinedSource);\n                sourceLocation.source.origin = localize('origin.inlined.source.map', 'read-only inlined content from source map');\n                sourceLocation.line = mapped.line;\n                sourceLocation.column = mapped.column;\n                sourceLocation.isSourceMapped = true;\n            } else if (utils.existsSync(sourceLocation.source.path)) {\n                // Script could not be mapped, but does exist on disk. Keep it and clear the sourceReference.\n                sourceLocation.source.sourceReference = undefined;\n                sourceLocation.source.origin = undefined;\n            }\n        }\n    }\n\n    /**\n     * Get the existing handle for this script, identified by runtime scriptId, or create a new one\n     */\n    private getSourceReferenceForScriptPath(mappedPath: string, contents: string): number {\n        return this._sourceHandles.lookupF(container => container.mappedPath === mappedPath) ||\n            this._sourceHandles.create({ contents, mappedPath });\n    }\n\n    public async scriptParsed(pathToGenerated: string, sourceMapURL: string): Promise<string[]> {\n        if (this._sourceMaps) {\n            this._allRuntimeScriptPaths.add(this.fixPathCasing(pathToGenerated));\n\n            if (!sourceMapURL) return null;\n\n            // Load the sourcemap for this new script and log its sources\n            const processNewSourceMapP = this._sourceMaps.processNewSourceMap(pathToGenerated, sourceMapURL);\n            this._processingNewSourceMap = Promise.all([this._processingNewSourceMap, processNewSourceMapP]);\n            await processNewSourceMapP;\n\n            const sources = this._sourceMaps.allMappedSources(pathToGenerated);\n            if (sources) {\n                logger.log(`SourceMaps.scriptParsed: ${pathToGenerated} was just loaded and has mapped sources: ${JSON.stringify(sources) }`);\n            }\n\n            return sources;\n        } else {\n            return null;\n        }\n    }\n\n    public breakpointResolved(bp: DebugProtocol.Breakpoint, scriptPath: string): void {\n        if (this._sourceMaps) {\n            const mapped = this._sourceMaps.mapToAuthored(scriptPath, bp.line, bp.column);\n            if (mapped) {\n                // No need to send back the path, the bp can only move within its script\n                bp.line = mapped.line;\n                bp.column = mapped.column;\n            }\n        }\n    }\n\n    public scopesResponse(pathToGenerated: string, scopesResponse: IScopesResponseBody): void {\n        if (this._sourceMaps) {\n            scopesResponse.scopes.forEach(scope => this.mapScopeLocations(pathToGenerated, scope));\n        }\n    }\n\n    private mapScopeLocations(pathToGenerated: string, scope: DebugProtocol.Scope): void {\n        if (typeof scope.line !== 'number') {\n            return;\n        }\n\n        let mappedStart = this._sourceMaps.mapToAuthored(pathToGenerated, scope.line, scope.column);\n        let shiftedScopeStartForward = false;\n\n        // If the scope is an async function, then the function declaration line may be missing a source mapping.\n        // So if we failed, try to get the next line.\n        if (!mappedStart) {\n            mappedStart = this._sourceMaps.mapToAuthored(pathToGenerated, scope.line + 1, scope.column);\n            shiftedScopeStartForward = true;\n        }\n\n        if (mappedStart) {\n            // Only apply changes if both mappings are found\n            const mappedEnd = this._sourceMaps.mapToAuthored(pathToGenerated, scope.endLine, scope.endColumn);\n            if (mappedEnd) {\n                scope.line = mappedStart.line;\n                if (shiftedScopeStartForward) {\n                    scope.line--;\n                }\n                scope.column = mappedStart.column;\n\n                scope.endLine = mappedEnd.line;\n                scope.endColumn = mappedEnd.column;\n            }\n        }\n    }\n\n    public async mapToGenerated(authoredPath: string, line: number, column: number): Promise<MappedPosition> {\n        if (!this._sourceMaps) return null;\n\n        await this.wait();\n        return this._sourceMaps.mapToGenerated(authoredPath, line, column);\n    }\n\n    public async mapToAuthored(pathToGenerated: string, line: number, column: number): Promise<MappedPosition> {\n        if (!this._sourceMaps) return null;\n\n        await this.wait();\n        return this._sourceMaps.mapToAuthored(pathToGenerated, line, column);\n    }\n\n    public async getGeneratedPathFromAuthoredPath(authoredPath: string): Promise<string> {\n        if (!this._sourceMaps) return authoredPath;\n\n        await this.wait();\n\n        // Find the generated path, or check whether this script is actually a runtime path - if so, return that\n        return this._sourceMaps.getGeneratedPathFromAuthoredPath(authoredPath) ||\n            (this.isRuntimeScript(authoredPath) ? authoredPath : null);\n    }\n\n    public async allSources(pathToGenerated: string): Promise<string[]> {\n        if (!this._sourceMaps) return [];\n\n        await this.wait();\n        return this._sourceMaps.allMappedSources(pathToGenerated) || [];\n    }\n\n    public async allSourcePathDetails(pathToGenerated: string): Promise<ISourcePathDetails[]> {\n        if (!this._sourceMaps) return [];\n\n        await this.wait();\n        return this._sourceMaps.allSourcePathDetails(pathToGenerated) || [];\n    }\n\n    private wait(): Promise<any> {\n        return Promise.all([this._preLoad, this._processingNewSourceMap]);\n    }\n\n    private isRuntimeScript(scriptPath: string): boolean {\n        return this._allRuntimeScriptPaths.has(this.fixPathCasing(scriptPath));\n    }\n\n    private fixPathCasing(str: string): string {\n        return str && (this.caseSensitivePaths ? str : str.toLowerCase());\n    }\n}\n"]}