/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function() {
var __m = ["exports","require","vs/base/common/uri","vs/base/common/event","vs/workbench/api/node/extHost.protocol","vs/base/common/strings","vs/base/common/platform","vs/workbench/api/node/extHostTypes","vs/base/common/lifecycle","vs/base/common/arrays","path","vs/base/common/async","vs/base/common/paths","vs/base/common/objects","vs/base/common/errors","vs/nls","vs/nls!vs/workbench/node/extensionHostProcess","vs/base/common/cancellation","vs/base/common/types","vs/platform/instantiation/common/instantiation","vs/base/common/winjs.base","vs/workbench/api/node/extHostTypeConverters","vs/base/common/map","vs/base/common/glob","vs/base/common/resources","child_process","vs/base/common/network","fs","vs/base/common/amd","vs/base/common/severity","os","vs/base/node/extfs","vs/workbench/services/search/node/search","vs/platform/log/common/log","vs/platform/configuration/common/configurationRegistry","vs/base/common/errorMessage","vs/base/common/stopwatch","vs/platform/registry/common/platform","vs/base/common/linkedList","vs/workbench/services/search/node/ripgrepSearchUtils","vs/workbench/services/search/node/textSearchManager","vs/platform/search/common/search","vs/editor/common/core/position","vs/workbench/api/node/extHostExtensionActivator","vs/base/parts/ipc/node/ipc","vs/base/common/normalization","vs/workbench/services/extensions/common/extensions","vs/base/node/pfs","vs/base/common/assert","vs/base/common/uuid","vs/platform/node/product","vs/workbench/services/search/node/ripgrepTextSearchEngine","vs/base/parts/quickopen/common/quickOpenScorer","vs/editor/common/core/range","vs/editor/common/model/wordHelper","vs/editor/common/modes/languageSelector","vs/base/node/flow","string_decoder","vs/platform/files/node/files","vs/platform/contextkey/common/contextkey","vs/base/common/htmlContent","vs/platform/log/node/spdlogService","vs/platform/markers/common/markers","vs/platform/node/package","net","vs/platform/configuration/common/configuration","vs/platform/configuration/common/configurationModels","vs/base/common/comparers","vs/workbench/api/node/extHostDocumentData","vs/base/node/encoding","vs/workbench/api/node/extHostTextEditor","vs/workbench/services/extensions/node/proxyIdentifier","vs/base/common/iterator","vs/workbench/api/node/extHostDebugService","vs/base/common/functional","vs/base/common/decorators","vs/workbench/services/search/node/fileSearch","vs/workbench/parts/debug/common/debugUtils","vs/nls!vs/platform/extensionManagement/common/extensionManagement","vs/nls!vs/platform/markers/common/markers","vs/nls!vs/platform/workspaces/common/workspaces","vs/nls!vs/workbench/api/node/extHost.api.impl","vs/nls!vs/workbench/api/node/extHostDebugService","vs/nls!vs/workbench/api/node/extHostDiagnostics","vs/nls!vs/workbench/api/node/extHostExtensionActivator","vs/nls!vs/workbench/api/node/extHostProgress","vs/nls!vs/workbench/api/node/extHostTask","vs/nls!vs/workbench/api/node/extHostTreeViews","vs/nls!vs/workbench/api/node/extHostWorkspace","vs/nls!vs/workbench/node/extensionHostMain","vs/nls!vs/workbench/parts/debug/node/debugAdapter","vs/nls!vs/workbench/parts/debug/node/terminals","vs/nls!vs/workbench/services/configurationResolver/node/variableResolver","vs/editor/common/core/uint","vs/base/node/console","vs/editor/common/services/modelService","vs/editor/common/modes/languageFeatureRegistry","vs/editor/common/modes","vs/platform/commands/common/commands","vs/editor/common/model","vs/platform/extensionManagement/common/extensionManagement","vs/platform/files/common/files","vs/base/parts/ipc/node/ipc.net","vs/editor/common/modes/languageConfiguration","vs/base/node/stream","vs/editor/common/modes/tokenizationRegistry","vs/editor/common/viewModel/prefixSumComputer","vs/platform/notification/common/notification","vs/platform/output/node/outputAppender","vs/platform/progress/common/progress","vs/base/common/labels","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/base/common/marshalling","vs/editor/common/model/mirrorTextModel","vs/nls!vs/base/common/errorMessage","vs/base/common/filters","vs/platform/workspaces/common/workspaces","vs/platform/workspace/common/workspace","assert","vs/workbench/api/node/extHostHeapService","vs/base/common/date","vs/workbench/parts/tasks/common/tasks","vs/workbench/common/extensionHostProtocol","vs/editor/common/core/selection","vs/workbench/parts/debug/node/debugAdapter","vs/workbench/parts/debug/node/terminals","vs/workbench/parts/terminal/common/terminal","vs/workbench/parts/terminal/node/terminalEnvironment","vs/workbench/parts/terminal/node/terminalProcess","vs/workbench/services/configuration/common/configurationModels","vs/workbench/api/node/extHostConfiguration","vs/workbench/services/configurationResolver/node/variableResolver","vs/workbench/services/editor/common/editorService","vs/base/common/numbers","vs/workbench/api/node/apiCommands","vs/workbench/api/node/extHostApiCommands","vs/workbench/api/node/extHostDocumentSaveParticipant","vs/workbench/api/node/extHostProgress","vs/nls!vs/base/common/severity","vs/base/common/json","vs/workbench/api/node/extHostLogService","vs/workbench/api/node/extHostTreeViews","vs/workbench/services/extensions/node/extensionDescriptionRegistry","vs/workbench/services/extensions/node/lazyPromise","vs/base/node/decoder","vs/nls!vs/base/node/processes","vs/workbench/api/node/extHostClipboard","vs/workbench/api/node/extHostCommands","vs/workbench/api/node/extHostComments","vs/base/node/processes","vs/workbench/api/node/extHostDecorations","vs/workbench/api/node/extHostDiagnostics","vs/workbench/api/node/extHostDialogs","vs/workbench/api/node/extHostDocumentContentProviders","vs/workbench/api/node/extHostDocuments","vs/workbench/api/node/extHostDocumentsAndEditors","vs/workbench/api/node/extHostFileSystem","vs/workbench/api/node/extHostFileSystemEventService","vs/workbench/api/node/extHostLanguageFeatures","vs/workbench/api/node/extHostLanguages","vs/workbench/api/node/extHostMessageService","vs/workbench/api/node/extHostOutputService","vs/workbench/api/node/extHostQuickOpen","vs/workbench/api/node/extHostSCM","vs/workbench/api/node/extHostStatusBar","vs/workbench/api/node/extHostStorage","vs/workbench/api/node/extHostTask","vs/workbench/api/node/extHostTerminalService","vs/workbench/api/node/extHostTextEditors","vs/workbench/api/node/extHostUrls","vs/workbench/api/node/extHostWebview","vs/workbench/api/node/extHostWindow","vs/workbench/api/node/extHostWorkspace","vs/workbench/services/extensions/node/rpcProtocol","vs/workbench/services/search/node/legacy/textSearch","vs/workbench/services/search/node/legacy/worker/searchWorkerIpc","vs/workbench/services/search/node/legacy/textSearchWorkerProvider","vs/base/common/idGenerator","vs/base/parts/ipc/node/ipc.cp","vs/workbench/api/node/extHostSearch.fileIndex","vs/workbench/services/search/node/fileSearchManager","vs/nls!vs/editor/common/config/editorOptions","vs/workbench/node/proxyResolver","vs/workbench/services/search/node/ripgrepFileSearch","vscode-ripgrep","vs/editor/common/config/editorOptions","vs/workbench/services/search/node/legacy/rawLegacyTextSearchService","graceful-fs","vs/nls!vs/platform/configuration/common/configurationRegistry","vs/workbench/services/search/node/ripgrepSearchProvider","vs/workbench/services/search/node/textSearchAdapter","vs/workbench/services/search/node/rawSearchService","vs/workbench/api/node/extHostSearch","vs/workbench/api/node/extHost.api.impl","vs/workbench/api/node/extHostExtensionService","vs/workbench/node/extensionHostMain","https","events","url","vscode-proxy-agent","iconv-lite","node-pty","crypto","stream","http","vs/workbench/node/extensionHostProcess"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[48/*vs/base/common/assert*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[75/*vs/base/common/decorators*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDecorator(mapFn) {
        return function (target, key, descriptor) {
            var fnKey = null;
            var fn = null;
            if (typeof descriptor.value === 'function') {
                fnKey = 'value';
                fn = descriptor.value;
            }
            else if (typeof descriptor.get === 'function') {
                fnKey = 'get';
                fn = descriptor.get;
            }
            if (!fn) {
                throw new Error('not supported');
            }
            descriptor[fnKey] = mapFn(fn, key);
        };
    }
    exports.createDecorator = createDecorator;
    function memoize(target, key, descriptor) {
        var fnKey = null;
        var fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
            if (fn.length !== 0) {
                console.warn('Memoize should only be used in functions with zero parameters');
            }
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        var memoizeKey = "$memoize$" + key;
        descriptor[fnKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.hasOwnProperty(memoizeKey)) {
                Object.defineProperty(this, memoizeKey, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: fn.apply(this, args)
                });
            }
            return this[memoizeKey];
        };
    }
    exports.memoize = memoize;
    function debounce(delay, reducer, initialValueProvider) {
        return createDecorator(function (fn, key) {
            var timerKey = "$debounce$" + key;
            var resultKey = "$debounce$result$" + key;
            return function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }
                clearTimeout(this[timerKey]);
                if (reducer) {
                    this[resultKey] = reducer.apply(void 0, [this[resultKey]].concat(args));
                    args = [this[resultKey]];
                }
                this[timerKey] = setTimeout(function () {
                    fn.apply(_this, args);
                    _this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }, delay);
            };
        });
    }
    exports.debounce = debounce;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[74/*vs/base/common/functional*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[177/*vs/base/common/idGenerator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IdGenerator = /** @class */ (function () {
        function IdGenerator(prefix) {
            this._prefix = prefix;
            this._lastId = 0;
        }
        IdGenerator.prototype.nextId = function () {
            return this._prefix + (++this._lastId);
        };
        return IdGenerator;
    }());
    exports.IdGenerator = IdGenerator;
    exports.defaultGenerator = new IdGenerator('id#');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define(__m[72/*vs/base/common/iterator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIN = { done: true, value: undefined };
    var Iterator;
    (function (Iterator) {
        var _empty = {
            next: function () {
                return exports.FIN;
            }
        };
        function empty() {
            return _empty;
        }
        Iterator.empty = empty;
        function fromArray(array, index, length) {
            if (index === void 0) { index = 0; }
            if (length === void 0) { length = array.length; }
            return {
                next: function () {
                    if (index >= length) {
                        return exports.FIN;
                    }
                    return { done: false, value: array[index++] };
                }
            };
        }
        Iterator.fromArray = fromArray;
        function from(elements) {
            if (!elements) {
                return Iterator.empty();
            }
            else if (Array.isArray(elements)) {
                return Iterator.fromArray(elements);
            }
            else {
                return elements;
            }
        }
        Iterator.from = from;
        function map(iterator, fn) {
            return {
                next: function () {
                    var element = iterator.next();
                    if (element.done) {
                        return exports.FIN;
                    }
                    else {
                        return { done: false, value: fn(element.value) };
                    }
                }
            };
        }
        Iterator.map = map;
        function filter(iterator, fn) {
            return {
                next: function () {
                    while (true) {
                        var element = iterator.next();
                        if (element.done) {
                            return exports.FIN;
                        }
                        if (fn(element.value)) {
                            return { done: false, value: element.value };
                        }
                    }
                }
            };
        }
        Iterator.filter = filter;
        function forEach(iterator, fn) {
            for (var next = iterator.next(); !next.done; next = iterator.next()) {
                fn(next.value);
            }
        }
        Iterator.forEach = forEach;
        function collect(iterator) {
            var result = [];
            forEach(iterator, function (value) { return result.push(value); });
            return result;
        }
        Iterator.collect = collect;
    })(Iterator = exports.Iterator || (exports.Iterator = {}));
    function getSequenceIterator(arg) {
        if (Array.isArray(arg)) {
            return Iterator.fromArray(arg);
        }
        else {
            return arg;
        }
    }
    exports.getSequenceIterator = getSequenceIterator;
    var ArrayIterator = /** @class */ (function () {
        function ArrayIterator(items, start, end, index) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = items.length; }
            if (index === void 0) { index = start - 1; }
            this.items = items;
            this.start = start;
            this.end = end;
            this.index = index;
        }
        ArrayIterator.prototype.first = function () {
            this.index = this.start;
            return this.current();
        };
        ArrayIterator.prototype.next = function () {
            this.index = Math.min(this.index + 1, this.end);
            return this.current();
        };
        ArrayIterator.prototype.current = function () {
            if (this.index === this.start - 1 || this.index === this.end) {
                return null;
            }
            return this.items[this.index];
        };
        return ArrayIterator;
    }());
    exports.ArrayIterator = ArrayIterator;
    var ArrayNavigator = /** @class */ (function (_super) {
        __extends(ArrayNavigator, _super);
        function ArrayNavigator(items, start, end, index) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = items.length; }
            if (index === void 0) { index = start - 1; }
            return _super.call(this, items, start, end, index) || this;
        }
        ArrayNavigator.prototype.current = function () {
            return _super.prototype.current.call(this);
        };
        ArrayNavigator.prototype.previous = function () {
            this.index = Math.max(this.index - 1, this.start - 1);
            return this.current();
        };
        ArrayNavigator.prototype.first = function () {
            this.index = this.start;
            return this.current();
        };
        ArrayNavigator.prototype.last = function () {
            this.index = this.end - 1;
            return this.current();
        };
        ArrayNavigator.prototype.parent = function () {
            return null;
        };
        return ArrayNavigator;
    }(ArrayIterator));
    exports.ArrayNavigator = ArrayNavigator;
    var MappedIterator = /** @class */ (function () {
        function MappedIterator(iterator, fn) {
            this.iterator = iterator;
            this.fn = fn;
            // noop
        }
        MappedIterator.prototype.next = function () { return this.fn(this.iterator.next()); };
        return MappedIterator;
    }());
    exports.MappedIterator = MappedIterator;
    var MappedNavigator = /** @class */ (function (_super) {
        __extends(MappedNavigator, _super);
        function MappedNavigator(navigator, fn) {
            var _this = _super.call(this, navigator, fn) || this;
            _this.navigator = navigator;
            return _this;
        }
        MappedNavigator.prototype.current = function () { return this.fn(this.navigator.current()); };
        MappedNavigator.prototype.previous = function () { return this.fn(this.navigator.previous()); };
        MappedNavigator.prototype.parent = function () { return this.fn(this.navigator.parent()); };
        MappedNavigator.prototype.first = function () { return this.fn(this.navigator.first()); };
        MappedNavigator.prototype.last = function () { return this.fn(this.navigator.last()); };
        MappedNavigator.prototype.next = function () { return this.fn(this.navigator.next()); };
        return MappedNavigator;
    }(MappedIterator));
    exports.MappedNavigator = MappedNavigator;
});

define(__m[139/*vs/base/common/json*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScanError;
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
        ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError = exports.ScanError || (exports.ScanError = {}));
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
        SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
    })(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));
    var ParseErrorCode;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
        ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
        ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
        ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
        ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
        ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));
    var ParseOptions;
    (function (ParseOptions) {
        ParseOptions.DEFAULT = {
            allowTrailingComma: true
        };
    })(ParseOptions = exports.ParseOptions || (exports.ParseOptions = {}));
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = 16 /* Unknown */, scanError = 0 /* None */;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = 16 /* Unknown */;
            scanError = 0 /* None */;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === 48 /* _0 */) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = 3 /* UnexpectedEndOfNumber */;
                    return text.substring(start, pos);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = 3 /* UnexpectedEndOfNumber */;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === 34 /* doubleQuote */) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = 2 /* UnexpectedEndOfString */;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 34 /* doubleQuote */:
                            result += '\"';
                            break;
                        case 92 /* backslash */:
                            result += '\\';
                            break;
                        case 47 /* slash */:
                            result += '/';
                            break;
                        case 98 /* b */:
                            result += '\b';
                            break;
                        case 102 /* f */:
                            result += '\f';
                            break;
                        case 110 /* n */:
                            result += '\n';
                            break;
                        case 114 /* r */:
                            result += '\r';
                            break;
                        case 116 /* t */:
                            result += '\t';
                            break;
                        case 117 /* u */:
                            var ch_1 = scanHexDigits(4, true);
                            if (ch_1 >= 0) {
                                result += String.fromCharCode(ch_1);
                            }
                            else {
                                scanError = 4 /* InvalidUnicode */;
                            }
                            break;
                        default:
                            scanError = 5 /* InvalidEscapeCharacter */;
                    }
                    start = pos;
                    continue;
                }
                if (ch >= 0 && ch <= 0x1f) {
                    if (isLineBreak(ch)) {
                        result += text.substring(start, pos);
                        scanError = 2 /* UnexpectedEndOfString */;
                        break;
                    }
                    else {
                        scanError = 6 /* InvalidCharacter */;
                        // mark as error but continue with string
                    }
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = 0 /* None */;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = 17 /* EOF */;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = 15 /* Trivia */;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                    pos++;
                    value += '\n';
                }
                return token = 14 /* LineBreakTrivia */;
            }
            switch (code) {
                // tokens: []{}:,
                case 123 /* openBrace */:
                    pos++;
                    return token = 1 /* OpenBraceToken */;
                case 125 /* closeBrace */:
                    pos++;
                    return token = 2 /* CloseBraceToken */;
                case 91 /* openBracket */:
                    pos++;
                    return token = 3 /* OpenBracketToken */;
                case 93 /* closeBracket */:
                    pos++;
                    return token = 4 /* CloseBracketToken */;
                case 58 /* colon */:
                    pos++;
                    return token = 6 /* ColonToken */;
                case 44 /* comma */:
                    pos++;
                    return token = 5 /* CommaToken */;
                // strings
                case 34 /* doubleQuote */:
                    pos++;
                    value = scanString();
                    return token = 10 /* StringLiteral */;
                // comments
                case 47 /* slash */:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = 12 /* LineCommentTrivia */;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = 1 /* UnexpectedEndOfComment */;
                        }
                        value = text.substring(start, pos);
                        return token = 13 /* BlockCommentTrivia */;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = 16 /* Unknown */;
                // numbers
                case 45 /* minus */:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = 16 /* Unknown */;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case 48 /* _0 */:
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    value += scanNumber();
                    return token = 11 /* NumericLiteral */;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = 8 /* TrueKeyword */;
                            case 'false': return token = 9 /* FalseKeyword */;
                            case 'null': return token = 7 /* NullKeyword */;
                        }
                        return token = 16 /* Unknown */;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = 16 /* Unknown */;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case 125 /* closeBrace */:
                case 93 /* closeBracket */:
                case 123 /* openBrace */:
                case 91 /* openBracket */:
                case 34 /* doubleQuote */:
                case 58 /* colon */:
                case 44 /* comma */:
                case 47 /* slash */:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
            ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
            ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
    }
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
     */
    function getLocation(text, position) {
        var segments = []; // strings or numbers
        var earlyReturnException = new Object();
        var previousNode = void 0;
        var previousNodeInst = {
            value: {},
            offset: 0,
            length: 0,
            type: 'object',
            parent: void 0
        };
        var isAtPropertyKey = false;
        function setPreviousNode(value, offset, length, type) {
            previousNodeInst.value = value;
            previousNodeInst.offset = offset;
            previousNodeInst.length = length;
            previousNodeInst.type = type;
            previousNodeInst.colonOffset = void 0;
            previousNode = previousNodeInst;
        }
        try {
            visit(text, {
                onObjectBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    isAtPropertyKey = position > offset;
                    segments.push(''); // push a placeholder (will be replaced)
                },
                onObjectProperty: function (name, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(name, offset, length, 'property');
                    segments[segments.length - 1] = name;
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onObjectEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onArrayBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.push(0);
                },
                onArrayEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onLiteralValue: function (value, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(value, offset, length, getLiteralNodeType(value));
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onSeparator: function (sep, offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    if (sep === ':' && previousNode && previousNode.type === 'property') {
                        previousNode.colonOffset = offset;
                        isAtPropertyKey = false;
                        previousNode = void 0;
                    }
                    else if (sep === ',') {
                        var last = segments[segments.length - 1];
                        if (typeof last === 'number') {
                            segments[segments.length - 1] = last + 1;
                        }
                        else {
                            isAtPropertyKey = true;
                            segments[segments.length - 1] = '';
                        }
                        previousNode = void 0;
                    }
                }
            });
        }
        catch (e) {
            if (e !== earlyReturnException) {
                throw e;
            }
        }
        return {
            path: segments,
            previousNode: previousNode,
            isAtPropertyKey: isAtPropertyKey,
            matches: function (pattern) {
                var k = 0;
                for (var i = 0; k < pattern.length && i < segments.length; i++) {
                    if (pattern[k] === segments[i] || pattern[k] === '*') {
                        k++;
                    }
                    else if (pattern[k] !== '**') {
                        return false;
                    }
                }
                return k === pattern.length;
            }
        };
    }
    exports.getLocation = getLocation;
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function parse(text, errors, options) {
        if (errors === void 0) { errors = []; }
        if (options === void 0) { options = ParseOptions.DEFAULT; }
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error, offset, length) {
                errors.push({ error: error, offset: offset, length: length });
            }
        };
        visit(text, visitor, options);
        return currentParent[0];
    }
    exports.parse = parse;
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function parseTree(text, errors, options) {
        if (errors === void 0) { errors = []; }
        if (options === void 0) { options = ParseOptions.DEFAULT; }
        var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: void 0 }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            return valueNode;
        }
        var visitor = {
            onObjectBegin: function (offset) {
                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: function (name, offset, length) {
                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
            },
            onObjectEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onArrayBegin: function (offset, length) {
                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onLiteralValue: function (value, offset, length) {
                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
                ensurePropertyComplete(offset + length);
            },
            onSeparator: function (sep, offset, length) {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.colonOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: function (error, offset, length) {
                errors.push({ error: error, offset: offset, length: length });
            }
        };
        visit(text, visitor, options);
        var result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    exports.parseTree = parseTree;
    /**
     * Finds the node at the given path in a JSON DOM.
     */
    function findNodeAtLocation(root, path) {
        if (!root) {
            return void 0;
        }
        var node = root;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var segment = path_1[_i];
            if (typeof segment === 'string') {
                if (node.type !== 'object' || !Array.isArray(node.children)) {
                    return void 0;
                }
                var found = false;
                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                    var propertyNode = _b[_a];
                    if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return void 0;
                }
            }
            else {
                var index = segment;
                if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                    return void 0;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    exports.findNodeAtLocation = findNodeAtLocation;
    /**
     * Gets the JSON path of the given JSON DOM node
     */
    function getNodePath(node) {
        if (!node.parent || !node.parent.children) {
            return [];
        }
        var path = getNodePath(node.parent);
        if (node.parent.type === 'property') {
            var key = node.parent.children[0].value;
            path.push(key);
        }
        else if (node.parent.type === 'array') {
            var index = node.parent.children.indexOf(node);
            if (index !== -1) {
                path.push(index);
            }
        }
        return path;
    }
    exports.getNodePath = getNodePath;
    /**
     * Evaluates the JavaScript object of the given JSON DOM node
     */
    function getNodeValue(node) {
        switch (node.type) {
            case 'array':
                return node.children.map(getNodeValue);
            case 'object':
                var obj = Object.create(null);
                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    var valueNode = prop.children[1];
                    if (valueNode) {
                        obj[prop.children[0].value] = getNodeValue(valueNode);
                    }
                }
                return obj;
            case 'null':
            case 'string':
            case 'number':
            case 'boolean':
                return node.value;
            default:
                return void 0;
        }
    }
    exports.getNodeValue = getNodeValue;
    function contains(node, offset, includeRightBound) {
        if (includeRightBound === void 0) { includeRightBound = false; }
        return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
    }
    exports.contains = contains;
    /**
     * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
     */
    function findNodeAtOffset(node, offset, includeRightBound) {
        if (includeRightBound === void 0) { includeRightBound = false; }
        if (contains(node, offset, includeRightBound)) {
            var children = node.children;
            if (Array.isArray(children)) {
                for (var i = 0; i < children.length && children[i].offset <= offset; i++) {
                    var item = findNodeAtOffset(children[i], offset, includeRightBound);
                    if (item) {
                        return item;
                    }
                }
            }
            return node;
        }
        return void 0;
    }
    exports.findNodeAtOffset = findNodeAtOffset;
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function visit(text, visitor, options) {
        if (options === void 0) { options = ParseOptions.DEFAULT; }
        var _scanner = createScanner(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
        var disallowComments = options && options.disallowComments;
        var allowTrailingComma = options && options.allowTrailingComma;
        function scanNext() {
            while (true) {
                var token = _scanner.scan();
                switch (_scanner.getTokenError()) {
                    case 4 /* InvalidUnicode */:
                        handleError(14 /* InvalidUnicode */);
                        break;
                    case 5 /* InvalidEscapeCharacter */:
                        handleError(15 /* InvalidEscapeCharacter */);
                        break;
                    case 3 /* UnexpectedEndOfNumber */:
                        handleError(13 /* UnexpectedEndOfNumber */);
                        break;
                    case 1 /* UnexpectedEndOfComment */:
                        if (!disallowComments) {
                            handleError(11 /* UnexpectedEndOfComment */);
                        }
                        break;
                    case 2 /* UnexpectedEndOfString */:
                        handleError(12 /* UnexpectedEndOfString */);
                        break;
                    case 6 /* InvalidCharacter */:
                        handleError(16 /* InvalidCharacter */);
                        break;
                }
                switch (token) {
                    case 12 /* LineCommentTrivia */:
                    case 13 /* BlockCommentTrivia */:
                        if (disallowComments) {
                            handleError(10 /* InvalidCommentToken */);
                        }
                        else {
                            onComment();
                        }
                        break;
                    case 16 /* Unknown */:
                        handleError(1 /* InvalidSymbol */);
                        break;
                    case 15 /* Trivia */:
                    case 14 /* LineBreakTrivia */:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== 17 /* EOF */) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            var value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case 11 /* NumericLiteral */:
                    var value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(2 /* InvalidNumberFormat */);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(2 /* InvalidNumberFormat */);
                    }
                    onLiteralValue(value);
                    break;
                case 7 /* NullKeyword */:
                    onLiteralValue(null);
                    break;
                case 8 /* TrueKeyword */:
                    onLiteralValue(true);
                    break;
                case 9 /* FalseKeyword */:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (_scanner.getToken() !== 10 /* StringLiteral */) {
                handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                return false;
            }
            parseString(false);
            if (_scanner.getToken() === 6 /* ColonToken */) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                }
            }
            else {
                handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            return true;
        }
        function parseObject() {
            onObjectBegin();
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {
                if (_scanner.getToken() === 5 /* CommaToken */) {
                    if (!needsComma) {
                        handleError(4 /* ValueExpected */, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(6 /* CommaExpected */, [], []);
                }
                if (!parseProperty()) {
                    handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
                handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            onArrayBegin();
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {
                if (_scanner.getToken() === 5 /* CommaToken */) {
                    if (!needsComma) {
                        handleError(4 /* ValueExpected */, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(6 /* CommaExpected */, [], []);
                }
                if (!parseValue()) {
                    handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
                handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            switch (_scanner.getToken()) {
                case 3 /* OpenBracketToken */:
                    return parseArray();
                case 1 /* OpenBraceToken */:
                    return parseObject();
                case 10 /* StringLiteral */:
                    return parseString(true);
                default:
                    return parseLiteral();
            }
        }
        scanNext();
        if (_scanner.getToken() === 17 /* EOF */) {
            return true;
        }
        if (!parseValue()) {
            handleError(4 /* ValueExpected */, [], []);
            return false;
        }
        if (_scanner.getToken() !== 17 /* EOF */) {
            handleError(9 /* EndOfFileExpected */, [], []);
        }
        return true;
    }
    exports.visit = visit;
    /**
     * Takes JSON with JavaScript-style comments and remove
     * them. Optionally replaces every none-newline character
     * of comments with a replaceCharacter
     */
    function stripComments(text, replaceCh) {
        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
        do {
            pos = _scanner.getPosition();
            kind = _scanner.scan();
            switch (kind) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                case 17 /* EOF */:
                    if (offset !== pos) {
                        parts.push(text.substring(offset, pos));
                    }
                    if (replaceCh !== void 0) {
                        parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                    }
                    offset = _scanner.getPosition();
                    break;
            }
        } while (kind !== 17 /* EOF */);
        return parts.join('');
    }
    exports.stripComments = stripComments;
    function getLiteralNodeType(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            default: return 'null';
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[8/*vs/base/common/lifecycle*/], __M([1/*require*/,0/*exports*/,74/*vs/base/common/functional*/]), function (require, exports, functional_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDisposable(thing) {
        return typeof thing.dispose === 'function'
            && thing.dispose.length === 0;
    }
    exports.isDisposable = isDisposable;
    function dispose(first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (Array.isArray(first)) {
            first.forEach(function (d) { return d && d.dispose(); });
            return [];
        }
        else if (rest.length === 0) {
            if (first) {
                first.dispose();
                return first;
            }
            return undefined;
        }
        else {
            dispose(first);
            dispose(rest);
            return [];
        }
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable(fn) {
        return { dispose: function () { fn(); } };
    }
    exports.toDisposable = toDisposable;
    var Disposable = /** @class */ (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Object.defineProperty(Disposable.prototype, "toDispose", {
            get: function () { return this._toDispose; },
            enumerable: true,
            configurable: true
        });
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        Disposable.None = Object.freeze({ dispose: function () { } });
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var ReferenceCollection = /** @class */ (function () {
        function ReferenceCollection() {
            this.references = Object.create(null);
        }
        ReferenceCollection.prototype.acquire = function (key) {
            var _this = this;
            var reference = this.references[key];
            if (!reference) {
                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };
            }
            var object = reference.object;
            var dispose = functional_1.once(function () {
                if (--reference.counter === 0) {
                    _this.destroyReferencedObject(key, reference.object);
                    delete _this.references[key];
                }
            });
            reference.counter++;
            return { object: object, dispose: dispose };
        };
        return ReferenceCollection;
    }());
    exports.ReferenceCollection = ReferenceCollection;
    var ImmortalReference = /** @class */ (function () {
        function ImmortalReference(object) {
            this.object = object;
        }
        ImmortalReference.prototype.dispose = function () { };
        return ImmortalReference;
    }());
    exports.ImmortalReference = ImmortalReference;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[38/*vs/base/common/linkedList*/], __M([1/*require*/,0/*exports*/,72/*vs/base/common/iterator*/]), function (require, exports, iterator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Node = /** @class */ (function () {
        function Node(element) {
            this.element = element;
        }
        return Node;
    }());
    var LinkedList = /** @class */ (function () {
        function LinkedList() {
        }
        LinkedList.prototype.isEmpty = function () {
            return !this._first;
        };
        LinkedList.prototype.clear = function () {
            this._first = undefined;
            this._last = undefined;
        };
        LinkedList.prototype.unshift = function (element) {
            return this.insert(element, false);
        };
        LinkedList.prototype.push = function (element) {
            return this.insert(element, true);
        };
        LinkedList.prototype.insert = function (element, atTheEnd) {
            var _this = this;
            var newNode = new Node(element);
            if (!this._first) {
                this._first = newNode;
                this._last = newNode;
            }
            else if (atTheEnd) {
                // push
                var oldLast = this._last;
                this._last = newNode;
                newNode.prev = oldLast;
                oldLast.next = newNode;
            }
            else {
                // unshift
                var oldFirst = this._first;
                this._first = newNode;
                newNode.next = oldFirst;
                oldFirst.prev = newNode;
            }
            return function () {
                var candidate = _this._first;
                while (candidate instanceof Node) {
                    if (candidate !== newNode) {
                        candidate = candidate.next;
                        continue;
                    }
                    if (candidate.prev && candidate.next) {
                        // middle
                        var anchor = candidate.prev;
                        anchor.next = candidate.next;
                        candidate.next.prev = anchor;
                    }
                    else if (!candidate.prev && !candidate.next) {
                        // only node
                        _this._first = undefined;
                        _this._last = undefined;
                    }
                    else if (!candidate.next) {
                        // last
                        _this._last = _this._last.prev;
                        _this._last.next = undefined;
                    }
                    else if (!candidate.prev) {
                        // first
                        _this._first = _this._first.next;
                        _this._first.prev = undefined;
                    }
                    // done
                    break;
                }
            };
        };
        LinkedList.prototype.iterator = function () {
            var element;
            var node = this._first;
            return {
                next: function () {
                    if (!node) {
                        return iterator_1.FIN;
                    }
                    if (!element) {
                        element = { done: false, value: node.element };
                    }
                    else {
                        element.value = node.element;
                    }
                    node = node.next;
                    return element;
                }
            };
        };
        LinkedList.prototype.toArray = function () {
            var result = [];
            for (var node = this._first; node instanceof Node; node = node.next) {
                result.push(node.element);
            }
            return result;
        };
        return LinkedList;
    }());
    exports.LinkedList = LinkedList;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[26/*vs/base/common/network*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        /**
         * A walk-through document.
         */
        Schemas.walkThrough = 'walkThrough';
        /**
         * An embedded code snippet.
         */
        Schemas.walkThroughSnippet = 'walkThroughSnippet';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
        Schemas.mailto = 'mailto';
        Schemas.untitled = 'untitled';
        Schemas.data = 'data';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[133/*vs/base/common/numbers*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
    exports.clamp = clamp;
    function rot(index, modulo) {
        return (modulo + (index % modulo)) % modulo;
    }
    exports.rot = rot;
    var Counter = /** @class */ (function () {
        function Counter() {
            this._next = 0;
        }
        Counter.prototype.getNext = function () {
            return this._next++;
        };
        return Counter;
    }());
    exports.Counter = Counter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[6/*vs/base/common/platform*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isNative = false;
    var _isWeb = false;
    var _locale = undefined;
    var _language = undefined;
    var _translationsConfigFile = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    var isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');
    // OS detection
    if (typeof navigator === 'object' && !isElectronRenderer) {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
    }
    else if (typeof process === 'object') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _locale = exports.LANGUAGE_DEFAULT;
        _language = exports.LANGUAGE_DEFAULT;
        var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
        if (rawNlsConfig) {
            try {
                var nlsConfig = JSON.parse(rawNlsConfig);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
                _translationsConfigFile = nlsConfig._translationsConfigFile;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    var Platform;
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(Platform = exports.Platform || (exports.Platform = {}));
    function PlatformToString(platform) {
        switch (platform) {
            case 0 /* Web */: return 'Web';
            case 1 /* Mac */: return 'Mac';
            case 2 /* Linux */: return 'Linux';
            case 3 /* Windows */: return 'Windows';
        }
    }
    exports.PlatformToString = PlatformToString;
    var _platform = 0 /* Web */;
    if (_isNative) {
        if (_isMacintosh) {
            _platform = 1 /* Mac */;
        }
        else if (_isWindows) {
            _platform = 3 /* Windows */;
        }
        else if (_isLinux) {
            _platform = 2 /* Linux */;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.platform = _platform;
    function isRootUser() {
        return _isNative && !_isWindows && (process.getuid() === 0);
    }
    exports.isRootUser = isRootUser;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    /**
     * The translatios that are available through language packs.
     */
    exports.translationsConfigFile = _translationsConfigFile;
    var _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
    exports.globals = _globals;
    var _setImmediate = null;
    function setImmediate(callback) {
        if (_setImmediate === null) {
            if (exports.globals.setImmediate) {
                _setImmediate = exports.globals.setImmediate.bind(exports.globals);
            }
            else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                _setImmediate = process.nextTick.bind(process);
            }
            else {
                _setImmediate = exports.globals.setTimeout.bind(exports.globals);
            }
        }
        return _setImmediate(callback);
    }
    exports.setImmediate = setImmediate;
    var OperatingSystem;
    (function (OperatingSystem) {
        OperatingSystem[OperatingSystem["Windows"] = 1] = "Windows";
        OperatingSystem[OperatingSystem["Macintosh"] = 2] = "Macintosh";
        OperatingSystem[OperatingSystem["Linux"] = 3] = "Linux";
    })(OperatingSystem = exports.OperatingSystem || (exports.OperatingSystem = {}));
    exports.OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
    var AccessibilitySupport;
    (function (AccessibilitySupport) {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
        AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
        AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
    })(AccessibilitySupport = exports.AccessibilitySupport || (exports.AccessibilitySupport = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[36/*vs/base/common/stopwatch*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasPerformanceNow = (platform_1.globals.performance && typeof platform_1.globals.performance.now === 'function');
    var StopWatch = /** @class */ (function () {
        function StopWatch(highResolution) {
            this._highResolution = hasPerformanceNow && highResolution;
            this._startTime = this._now();
            this._stopTime = -1;
        }
        StopWatch.create = function (highResolution) {
            if (highResolution === void 0) { highResolution = true; }
            return new StopWatch(highResolution);
        };
        StopWatch.prototype.stop = function () {
            this._stopTime = this._now();
        };
        StopWatch.prototype.elapsed = function () {
            if (this._stopTime !== -1) {
                return this._stopTime - this._startTime;
            }
            return this._now() - this._startTime;
        };
        StopWatch.prototype._now = function () {
            return this._highResolution ? platform_1.globals.performance.now() : new Date().getTime();
        };
        return StopWatch;
    }());
    exports.StopWatch = StopWatch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[5/*vs/base/common/strings*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The empty string.
     */
    exports.empty = '';
    function isFalsyOrWhitespace(str) {
        if (!str || typeof str !== 'string') {
            return true;
        }
        return str.trim().length === 0;
    }
    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\[\]\(\)\#]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0;
        while (haystack.indexOf(needle, offset) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        if (haystack === needle) {
            return true;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.indexOf(needle, diff) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, options) {
        if (options === void 0) { options = {}; }
        if (!searchString) {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = escapeRegExpCharacters(searchString);
        }
        if (options.wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (options.global) {
            modifiers += 'g';
        }
        if (!options.matchCase) {
            modifiers += 'i';
        }
        if (options.multiline) {
            modifiers += 'm';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return !!(match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    function regExpContainsBackreference(regexpValue) {
        return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
    }
    exports.regExpContainsBackreference = regExpContainsBackreference;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = str.length; }
        for (var i = start; i < end; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return str.substring(start, i);
            }
        }
        return str.substring(start, end);
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compare = compare;
    function compareIgnoreCase(a, b) {
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                // equal
                continue;
            }
            if (isUpperAsciiLetter(codeA)) {
                codeA += 32;
            }
            if (isUpperAsciiLetter(codeB)) {
                codeB += 32;
            }
            var diff = codeA - codeB;
            if (diff === 0) {
                // equal -> ignoreCase
                continue;
            }
            else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
                //
                return diff;
            }
            else {
                return compare(a.toLowerCase(), b.toLowerCase());
            }
        }
        if (a.length < b.length) {
            return -1;
        }
        else if (a.length > b.length) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compareIgnoreCase = compareIgnoreCase;
    function isLowerAsciiLetter(code) {
        return code >= 97 /* a */ && code <= 122 /* z */;
    }
    exports.isLowerAsciiLetter = isLowerAsciiLetter;
    function isUpperAsciiLetter(code) {
        return code >= 65 /* A */ && code <= 90 /* Z */;
    }
    exports.isUpperAsciiLetter = isUpperAsciiLetter;
    function isAsciiLetter(code) {
        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a ? a.length : 0;
        var len2 = b ? b.length : 0;
        if (len1 !== len2) {
            return false;
        }
        return doEqualsIgnoreCase(a, b);
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    function doEqualsIgnoreCase(a, b, stopAt) {
        if (stopAt === void 0) { stopAt = a.length; }
        if (typeof a !== 'string' || typeof b !== 'string') {
            return false;
        }
        for (var i = 0; i < stopAt; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            // a-z A-Z
            if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            // Any other charcode
            else {
                if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    function startsWithIgnoreCase(str, candidate) {
        var candidateLength = candidate.length;
        if (candidate.length > str.length) {
            return false;
        }
        return doEqualsIgnoreCase(str, candidate, candidateLength);
    }
    exports.startsWithIgnoreCase = startsWithIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {
        while (aStart < aEnd && bStart < bEnd) {
            if (a[aStart] !== b[bStart]) {
                return false;
            }
            aStart += 1;
            bStart += 1;
        }
        return true;
    }
    /**
     * Return the overlap between the suffix of `a` and the prefix of `b`.
     * For instance `overlap("foobar", "arr, I'm a pirate") === 2`.
     */
    function overlap(a, b) {
        var aEnd = a.length;
        var bEnd = b.length;
        var aStart = aEnd - bEnd;
        if (aStart === 0) {
            return a === b ? aEnd : 0;
        }
        else if (aStart < 0) {
            bEnd += aStart;
            aStart = 0;
        }
        while (aStart < aEnd && bEnd > 0) {
            if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {
                return bEnd;
            }
            bEnd -= 1;
            aStart += 1;
        }
        return 0;
    }
    exports.overlap = overlap;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    exports.isLowSurrogate = isLowSurrogate;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
     */
    var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
    /**
     * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
     */
    function containsRTL(str) {
        return CONTAINS_RTL.test(str);
    }
    exports.containsRTL = containsRTL;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
     */
    var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;
    function containsEmoji(str) {
        return CONTAINS_EMOJI.test(str);
    }
    exports.containsEmoji = containsEmoji;
    var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    /**
     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
     */
    function isBasicASCII(str) {
        return IS_BASIC_ASCII.test(str);
    }
    exports.isBasicASCII = isBasicASCII;
    function containsFullWidthCharacter(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (isFullWidthCharacter(str.charCodeAt(i))) {
                return true;
            }
        }
        return false;
    }
    exports.containsFullWidthCharacter = containsFullWidthCharacter;
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80  2EFF   CJK Radicals Supplement
        //          2F00  2FDF   Kangxi Radicals
        //          2FF0  2FFF   Ideographic Description Characters
        //          3000  303F   CJK Symbols and Punctuation
        //          3040  309F   Hiragana
        //          30A0  30FF   Katakana
        //          3100  312F   Bopomofo
        //          3130  318F   Hangul Compatibility Jamo
        //          3190  319F   Kanbun
        //          31A0  31BF   Bopomofo Extended
        //          31F0  31FF   Katakana Phonetic Extensions
        //          3200  32FF   Enclosed CJK Letters and Months
        //          3300  33FF   CJK Compatibility
        //          3400  4DBF   CJK Unified Ideographs Extension A
        //          4DC0  4DFF   Yijing Hexagram Symbols
        //          4E00  9FFF   CJK Unified Ideographs
        //          A000  A48F   Yi Syllables
        //          A490  A4CF   Yi Radicals
        //          AC00  D7AF   Hangul Syllables
        // [IGNORE] D800  DB7F   High Surrogates
        // [IGNORE] DB80  DBFF   High Private Use Surrogates
        // [IGNORE] DC00  DFFF   Low Surrogates
        // [IGNORE] E000  F8FF   Private Use Area
        //          F900  FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00  FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50  FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00  FE0F   Variation Selectors
        // [IGNORE] FE20  FE2F   Combining Half Marks
        // [IGNORE] FE30  FE4F   CJK Compatibility Forms
        // [IGNORE] FE50  FE6F   Small Form Variants
        // [IGNORE] FE70  FEFF   Arabic Presentation Forms-B
        //          FF00  FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0  FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var re = /\b/g;
        var i = 0;
        while (re.test(text)) {
            if (text.length - re.lastIndex < n) {
                break;
            }
            i = re.lastIndex;
            re.lastIndex += 1;
        }
        return text.substring(i).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    function startsWithUTF8BOM(str) {
        return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    function stripUTF8BOM(str) {
        return startsWithUTF8BOM(str) ? str.substr(1) : str;
    }
    exports.stripUTF8BOM = stripUTF8BOM;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
    /**
     * Checks if the characters of the provided query string are included in the
     * target string. The characters do not have to be contiguous within the string.
     */
    function fuzzyContains(target, query) {
        if (!target || !query) {
            return false; // return early if target or query are undefined
        }
        if (target.length < query.length) {
            return false; // impossible for query to be contained in target
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.fuzzyContains = fuzzyContains;
    function containsUppercaseCharacter(target, ignoreEscapedChars) {
        if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }
        if (!target) {
            return false;
        }
        if (ignoreEscapedChars) {
            target = target.replace(/\\./g, '');
        }
        return target.toLowerCase() !== target;
    }
    exports.containsUppercaseCharacter = containsUppercaseCharacter;
    function uppercaseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    exports.uppercaseFirstLetter = uppercaseFirstLetter;
    function getNLines(str, n) {
        if (n === void 0) { n = 1; }
        if (n === 0) {
            return '';
        }
        var idx = -1;
        do {
            idx = str.indexOf('\n', idx + 1);
            n--;
        } while (n > 0 && idx >= 0);
        return idx >= 0 ?
            str.substr(0, idx) :
            str;
    }
    exports.getNLines = getNLines;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[120/*vs/base/common/date*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/strings*/]), function (require, exports, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toLocalISOString(date) {
        return date.getFullYear() +
            '-' + strings_1.pad(date.getMonth() + 1, 2) +
            '-' + strings_1.pad(date.getDate(), 2) +
            'T' + strings_1.pad(date.getHours(), 2) +
            ':' + strings_1.pad(date.getMinutes(), 2) +
            ':' + strings_1.pad(date.getSeconds(), 2) +
            '.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +
            'Z';
    }
    exports.toLocalISOString = toLocalISOString;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[12/*vs/base/common/paths*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/platform*/,5/*vs/base/common/strings*/]), function (require, exports, platform_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    /**
     * @param path the path to get the dirname from
     * @param separator the separator to use
     * @returns the directory name of a path.
     *
     */
    function dirname(path, separator) {
        if (separator === void 0) { separator = exports.nativeSep; }
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else if (~idx === path.length - 1) {
            return dirname(path.substring(0, path.length - 1));
        }
        else {
            var res = path.substring(0, ~idx);
            if (platform_1.isWindows && res[res.length - 1] === ':') {
                res += separator; // make sure drive letters end with backslash
            }
            return res;
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns `.far` from `boo.far` or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = !!(platform_1.isWindows && toOSPath);
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            code = path.charCodeAt(1);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === 58 /* Colon */) {
                code = path.charCodeAt(2);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        // Not using a function with var-args because of how TS compiles
        // them to JS - it would result in 2*n runtime cost instead
        // of 1*n, where n is parts.length.
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                    var next = part.charCodeAt(0);
                    if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === 92 /* Backslash */) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === 92 /* Backslash */) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    function isEqual(pathA, pathB, ignoreCase) {
        var identityEquals = (pathA === pathB);
        if (!ignoreCase || identityEquals) {
            return identityEquals;
        }
        if (!pathA || !pathB) {
            return false;
        }
        return strings_1.equalsIgnoreCase(pathA, pathB);
    }
    exports.isEqual = isEqual;
    function isEqualOrParent(path, candidate, ignoreCase, separator) {
        if (separator === void 0) { separator = exports.nativeSep; }
        if (path === candidate) {
            return true;
        }
        if (!path || !candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (ignoreCase) {
            var beginsWith = strings_1.startsWithIgnoreCase(path, candidate);
            if (!beginsWith) {
                return false;
            }
            if (candidate.length === path.length) {
                return true; // same path, different casing
            }
            var sepOffset = candidate.length;
            if (candidate.charAt(candidate.length - 1) === separator) {
                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
            }
            return path.charAt(sepOffset) === separator;
        }
        if (candidate.charAt(candidate.length - 1) !== separator) {
            candidate += separator;
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isEqualOrParent = isEqualOrParent;
    /**
     * Adapted from Node's path.isAbsolute functions
     */
    function isAbsolute(path) {
        return platform_1.isWindows ?
            isAbsolute_win32(path) :
            isAbsolute_posix(path);
    }
    exports.isAbsolute = isAbsolute;
    function isAbsolute_win32(path) {
        if (!path) {
            return false;
        }
        var char0 = path.charCodeAt(0);
        if (char0 === 47 /* Slash */ || char0 === 92 /* Backslash */) {
            return true;
        }
        else if ((char0 >= 65 /* A */ && char0 <= 90 /* Z */) || (char0 >= 97 /* a */ && char0 <= 122 /* z */)) {
            if (path.length > 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var char2 = path.charCodeAt(2);
                if (char2 === 47 /* Slash */ || char2 === 92 /* Backslash */) {
                    return true;
                }
            }
        }
        return false;
    }
    exports.isAbsolute_win32 = isAbsolute_win32;
    function isAbsolute_posix(path) {
        return !!(path && path.charCodeAt(0) === 47 /* Slash */);
    }
    exports.isAbsolute_posix = isAbsolute_posix;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[67/*vs/base/common/comparers*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/strings*/,12/*vs/base/common/paths*/]), function (require, exports, strings, paths) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var intlFileNameCollator;
    function setFileNameComparer(collator) {
        intlFileNameCollator = collator;
    }
    exports.setFileNameComparer = setFileNameComparer;
    function compareFileNames(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (intlFileNameCollator) {
            var a = one || '';
            var b = other || '';
            var result = intlFileNameCollator.getValue().collator.compare(a, b);
            // Using the numeric option in the collator will
            // make compare(`foo1`, `foo01`) === 0. We must disambiguate.
            if (intlFileNameCollator.getValue().collatorIsNumeric && result === 0 && a !== b) {
                return a < b ? -1 : 1;
            }
            return result;
        }
        return noIntlCompareFileNames(one, other, caseSensitive);
    }
    exports.compareFileNames = compareFileNames;
    var FileNameMatch = /^(.*?)(\.([^.]*))?$/;
    function noIntlCompareFileNames(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (!caseSensitive) {
            one = one && one.toLowerCase();
            other = other && other.toLowerCase();
        }
        var _a = extractNameAndExtension(one), oneName = _a[0], oneExtension = _a[1];
        var _b = extractNameAndExtension(other), otherName = _b[0], otherExtension = _b[1];
        if (oneName !== otherName) {
            return oneName < otherName ? -1 : 1;
        }
        if (oneExtension === otherExtension) {
            return 0;
        }
        return oneExtension < otherExtension ? -1 : 1;
    }
    exports.noIntlCompareFileNames = noIntlCompareFileNames;
    function compareFileExtensions(one, other) {
        if (intlFileNameCollator) {
            var _a = extractNameAndExtension(one), oneName = _a[0], oneExtension = _a[1];
            var _b = extractNameAndExtension(other), otherName = _b[0], otherExtension = _b[1];
            var result = intlFileNameCollator.getValue().collator.compare(oneExtension, otherExtension);
            if (result === 0) {
                // Using the numeric option in the collator will
                // make compare(`foo1`, `foo01`) === 0. We must disambiguate.
                if (intlFileNameCollator.getValue().collatorIsNumeric && oneExtension !== otherExtension) {
                    return oneExtension < otherExtension ? -1 : 1;
                }
                // Extensions are equal, compare filenames
                result = intlFileNameCollator.getValue().collator.compare(oneName, otherName);
                if (intlFileNameCollator.getValue().collatorIsNumeric && result === 0 && oneName !== otherName) {
                    return oneName < otherName ? -1 : 1;
                }
            }
            return result;
        }
        return noIntlCompareFileExtensions(one, other);
    }
    exports.compareFileExtensions = compareFileExtensions;
    function noIntlCompareFileExtensions(one, other) {
        var _a = extractNameAndExtension(one && one.toLowerCase()), oneName = _a[0], oneExtension = _a[1];
        var _b = extractNameAndExtension(other && other.toLowerCase()), otherName = _b[0], otherExtension = _b[1];
        if (oneExtension !== otherExtension) {
            return oneExtension < otherExtension ? -1 : 1;
        }
        if (oneName === otherName) {
            return 0;
        }
        return oneName < otherName ? -1 : 1;
    }
    function extractNameAndExtension(str) {
        var match = str ? FileNameMatch.exec(str) : [];
        return [(match && match[1]) || '', (match && match[3]) || ''];
    }
    function comparePathComponents(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        if (!caseSensitive) {
            one = one && one.toLowerCase();
            other = other && other.toLowerCase();
        }
        if (one === other) {
            return 0;
        }
        return one < other ? -1 : 1;
    }
    function comparePaths(one, other, caseSensitive) {
        if (caseSensitive === void 0) { caseSensitive = false; }
        var oneParts = one.split(paths.nativeSep);
        var otherParts = other.split(paths.nativeSep);
        var lastOne = oneParts.length - 1;
        var lastOther = otherParts.length - 1;
        var endOne, endOther;
        for (var i = 0;; i++) {
            endOne = lastOne === i;
            endOther = lastOther === i;
            if (endOne && endOther) {
                return compareFileNames(oneParts[i], otherParts[i], caseSensitive);
            }
            else if (endOne) {
                return -1;
            }
            else if (endOther) {
                return 1;
            }
            var result = comparePathComponents(oneParts[i], otherParts[i], caseSensitive);
            if (result !== 0) {
                return result;
            }
        }
    }
    exports.comparePaths = comparePaths;
    function compareAnything(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var prefixCompare = compareByPrefix(one, other, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Sort suffix matches over non suffix matches
        var elementASuffixMatch = strings.endsWith(elementAName, lookFor);
        var elementBSuffixMatch = strings.endsWith(elementBName, lookFor);
        if (elementASuffixMatch !== elementBSuffixMatch) {
            return elementASuffixMatch ? -1 : 1;
        }
        // Understand file names
        var r = compareFileNames(elementAName, elementBName);
        if (r !== 0) {
            return r;
        }
        // Compare by name
        return elementAName.localeCompare(elementBName);
    }
    exports.compareAnything = compareAnything;
    function compareByPrefix(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var elementAPrefixMatch = strings.startsWith(elementAName, lookFor);
        var elementBPrefixMatch = strings.startsWith(elementBName, lookFor);
        if (elementAPrefixMatch !== elementBPrefixMatch) {
            return elementAPrefixMatch ? -1 : 1;
        }
        // Same prefix: Sort shorter matches to the top to have those on top that match more precisely
        else if (elementAPrefixMatch && elementBPrefixMatch) {
            if (elementAName.length < elementBName.length) {
                return -1;
            }
            if (elementAName.length > elementBName.length) {
                return 1;
            }
        }
        return 0;
    }
    exports.compareByPrefix = compareByPrefix;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[18/*vs/base/common/types*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        // The method can't do a type cast since there are type (like strings) which
        // are subclasses of any put not positvely matched by the function. Hence type
        // narrowing results in wrong results.
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[13/*vs/base/common/objects*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/types*/]), function (require, exports, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            // See https://github.com/Microsoft/TypeScript/issues/10990
            return obj;
        }
        var result = Array.isArray(obj) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    function deepFreeze(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var stack = [obj];
        while (stack.length > 0) {
            var obj_1 = stack.shift();
            Object.freeze(obj_1);
            for (var key in obj_1) {
                if (_hasOwnProperty.call(obj_1, key)) {
                    var prop = obj_1[key];
                    if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                        stack.push(prop);
                    }
                }
            }
        }
        return obj;
    }
    exports.deepFreeze = deepFreeze;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (types_1.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (types_1.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (types_1.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (_hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!types_1.isObject(destination)) {
            return source;
        }
        if (types_1.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i;
        var key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
    /**
     * Returns an object that has keys for each value that is different in the base object. Keys
     * that do not exist in the target but in the base object are not considered.
     *
     * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
     * object if they differ.
     *
     * @param base the object to diff against
     * @param obj the object to use for diffing
     */
    function distinct(base, target) {
        var result = Object.create(null);
        if (!base || !target) {
            return result;
        }
        var targetKeys = Object.keys(target);
        targetKeys.forEach(function (k) {
            var baseValue = base[k];
            var targetValue = target[k];
            if (!equals(baseValue, targetValue)) {
                result[k] = targetValue;
            }
        });
        return result;
    }
    exports.distinct = distinct;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[2/*vs/base/common/uri*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a;
    var _schemePattern = /^\w[\w\d+.-]*$/;
    var _singleSlashStart = /^\//;
    var _doubleSlashStart = /^\/\//;
    var _throwOnMissingSchema = true;
    /**
     * @internal
     */
    function setUriThrowOnMissingScheme(value) {
        var old = _throwOnMissingSchema;
        _throwOnMissingSchema = value;
        return old;
    }
    exports.setUriThrowOnMissingScheme = setUriThrowOnMissingScheme;
    function _validateUri(ret) {
        // scheme, must be set
        if (!ret.scheme) {
            if (_throwOnMissingSchema) {
                throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
            }
            else {
                console.warn("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
            }
        }
        // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
        // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
        if (ret.scheme && !_schemePattern.test(ret.scheme)) {
            throw new Error('[UriError]: Scheme contains illegal characters.');
        }
        // path, http://tools.ietf.org/html/rfc3986#section-3.3
        // If a URI contains an authority component, then the path component
        // must either be empty or begin with a slash ("/") character.  If a URI
        // does not contain an authority component, then the path cannot begin
        // with two slash characters ("//").
        if (ret.path) {
            if (ret.authority) {
                if (!_singleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                }
            }
            else {
                if (_doubleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                }
            }
        }
    }
    // implements a bit of https://tools.ietf.org/html/rfc3986#section-5
    function _referenceResolution(scheme, path) {
        // the slash-character is our 'default base' as we don't
        // support constructing URIs relative to other URIs. This
        // also means that we alter and potentially break paths.
        // see https://tools.ietf.org/html/rfc3986#section-5.1.4
        switch (scheme) {
            case 'https':
            case 'http':
            case 'file':
                if (!path) {
                    path = _slash;
                }
                else if (path[0] !== _slash) {
                    path = _slash + path;
                }
                break;
        }
        return path;
    }
    var _empty = '';
    var _slash = '/';
    var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component parts
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     */
    var URI = /** @class */ (function () {
        /**
         * @internal
         */
        function URI(schemeOrData, authority, path, query, fragment) {
            if (typeof schemeOrData === 'object') {
                this.scheme = schemeOrData.scheme || _empty;
                this.authority = schemeOrData.authority || _empty;
                this.path = schemeOrData.path || _empty;
                this.query = schemeOrData.query || _empty;
                this.fragment = schemeOrData.fragment || _empty;
                // no validation because it's this URI
                // that creates uri components.
                // _validateUri(this);
            }
            else {
                this.scheme = schemeOrData || _empty;
                this.authority = authority || _empty;
                this.path = _referenceResolution(this.scheme, path || _empty);
                this.query = query || _empty;
                this.fragment = fragment || _empty;
                _validateUri(this);
            }
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string';
        };
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
             * platform specific path separator.
             *
             * * Will *not* validate the path for invalid characters and semantics.
             * * Will *not* look at the scheme of this URI.
             * * The result shall *not* be used for display purposes but for accessing a file on disk.
             *
             *
             * The *difference* to `URI#path` is the use of the platform specific separator and the handling
             * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
             *
             * ```ts
                const u = URI.parse('file://server/c$/folder/file.txt')
                u.authority === 'server'
                u.path === '/shares/c$/file.txt'
                u.fsPath === '\\server\c$\folder\file.txt'
            ```
             *
             * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
             * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
             * with URIs that represent files on disk (`file` scheme).
             */
            get: function () {
                // if (this.scheme !== 'file') {
                // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
                // }
                return _makeFsPath(this);
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === void 0) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = _empty;
            }
            if (authority === void 0) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = _empty;
            }
            if (path === void 0) {
                path = this.path;
            }
            else if (path === null) {
                path = _empty;
            }
            if (query === void 0) {
                query = this.query;
            }
            else if (query === null) {
                query = _empty;
            }
            if (fragment === void 0) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = _empty;
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            return new _URI(scheme, authority, path, query, fragment);
        };
        // ---- parse & validate ------------------------
        /**
         * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
         * `file:///usr/home`, or `scheme:with/path`.
         *
         * @param value A string which represents an URI (see `URI#toString`).
         */
        URI.parse = function (value) {
            var match = _regexp.exec(value);
            if (!match) {
                return new _URI(_empty, _empty, _empty, _empty, _empty);
            }
            return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty));
        };
        /**
         * Creates a new URI from a file system path, e.g. `c:\my\files`,
         * `/usr/home`, or `\\server\share\some\path`.
         *
         * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
         * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
         * `URI.parse('file://' + path)` because the path might contain characters that are
         * interpreted (# and ?). See the following sample:
         * ```ts
        const good = URI.file('/coding/c#/project1');
        good.scheme === 'file';
        good.path === '/coding/c#/project1';
        good.fragment === '';
        const bad = URI.parse('file://' + '/coding/c#/project1');
        bad.scheme === 'file';
        bad.path === '/coding/c'; // path is now broken
        bad.fragment === '/project1';
        ```
         *
         * @param path A file system path (see `URI#fsPath`)
         */
        URI.file = function (path) {
            var authority = _empty;
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            if (platform_1.isWindows) {
                path = path.replace(/\\/g, _slash);
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === _slash && path[1] === _slash) {
                var idx = path.indexOf(_slash, 2);
                if (idx === -1) {
                    authority = path.substring(2);
                    path = _slash;
                }
                else {
                    authority = path.substring(2, idx);
                    path = path.substring(idx) || _slash;
                }
            }
            return new _URI('file', authority, path, _empty, _empty);
        };
        URI.from = function (components) {
            return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
        };
        // ---- printing/externalize ---------------------------
        /**
         * Creates a string presentation for this URI. It's guaranteed that calling
         * `URI.parse` with the result of this function creates an URI which is equal
         * to this URI.
         *
         * * The result shall *not* be used for display purposes but for externalization or transport.
         * * The result will be encoded using the percentage encoding and encoding happens mostly
         * ignore the scheme-specific encoding rules.
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            return _asFormatted(this, skipEncoding);
        };
        URI.prototype.toJSON = function () {
            return this;
        };
        URI.revive = function (data) {
            if (!data) {
                return data;
            }
            else if (data instanceof URI) {
                return data;
            }
            else {
                var result = new _URI(data);
                result._fsPath = data.fsPath;
                result._formatted = data.external;
                return result;
            }
        };
        return URI;
    }());
    exports.URI = URI;
    // tslint:disable-next-line:class-name
    var _URI = /** @class */ (function (_super) {
        __extends(_URI, _super);
        function _URI() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._formatted = null;
            _this._fsPath = null;
            return _this;
        }
        Object.defineProperty(_URI.prototype, "fsPath", {
            get: function () {
                if (!this._fsPath) {
                    this._fsPath = _makeFsPath(this);
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        _URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = _asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return _asFormatted(this, true);
            }
        };
        _URI.prototype.toJSON = function () {
            var res = {
                $mid: 1
            };
            // cached state
            if (this._fsPath) {
                res.fsPath = this._fsPath;
            }
            if (this._formatted) {
                res.external = this._formatted;
            }
            // uri components
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        return _URI;
    }(URI));
    // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
    var encodeTable = (_a = {},
        _a[58 /* Colon */] = '%3A',
        _a[47 /* Slash */] = '%2F',
        _a[63 /* QuestionMark */] = '%3F',
        _a[35 /* Hash */] = '%23',
        _a[91 /* OpenSquareBracket */] = '%5B',
        _a[93 /* CloseSquareBracket */] = '%5D',
        _a[64 /* AtSign */] = '%40',
        _a[33 /* ExclamationMark */] = '%21',
        _a[36 /* DollarSign */] = '%24',
        _a[38 /* Ampersand */] = '%26',
        _a[39 /* SingleQuote */] = '%27',
        _a[40 /* OpenParen */] = '%28',
        _a[41 /* CloseParen */] = '%29',
        _a[42 /* Asterisk */] = '%2A',
        _a[43 /* Plus */] = '%2B',
        _a[44 /* Comma */] = '%2C',
        _a[59 /* Semicolon */] = '%3B',
        _a[61 /* Equals */] = '%3D',
        _a[32 /* Space */] = '%20',
        _a);
    function encodeURIComponentFast(uriComponent, allowSlash) {
        var res = undefined;
        var nativeEncodePos = -1;
        for (var pos = 0; pos < uriComponent.length; pos++) {
            var code = uriComponent.charCodeAt(pos);
            // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
            if ((code >= 97 /* a */ && code <= 122 /* z */)
                || (code >= 65 /* A */ && code <= 90 /* Z */)
                || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
                || code === 45 /* Dash */
                || code === 46 /* Period */
                || code === 95 /* Underline */
                || code === 126 /* Tilde */
                || (allowSlash && code === 47 /* Slash */)) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // check if we write into a new string (by default we try to return the param)
                if (res !== undefined) {
                    res += uriComponent.charAt(pos);
                }
            }
            else {
                // encoding needed, we need to allocate a new string
                if (res === undefined) {
                    res = uriComponent.substr(0, pos);
                }
                // check with default table first
                var escaped = encodeTable[code];
                if (escaped !== undefined) {
                    // check if we are delaying native encode
                    if (nativeEncodePos !== -1) {
                        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                        nativeEncodePos = -1;
                    }
                    // append escaped variant to result
                    res += escaped;
                }
                else if (nativeEncodePos === -1) {
                    // use native encode only when needed
                    nativeEncodePos = pos;
                }
            }
        }
        if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
        }
        return res !== undefined ? res : uriComponent;
    }
    function encodeURIComponentMinimal(path) {
        var res = undefined;
        for (var pos = 0; pos < path.length; pos++) {
            var code = path.charCodeAt(pos);
            if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
                if (res === undefined) {
                    res = path.substr(0, pos);
                }
                res += encodeTable[code];
            }
            else {
                if (res !== undefined) {
                    res += path[pos];
                }
            }
        }
        return res !== undefined ? res : path;
    }
    /**
     * Compute `fsPath` for the given uri
     * @param uri
     */
    function _makeFsPath(uri) {
        var value;
        if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + uri.authority + uri.path;
        }
        else if (uri.path.charCodeAt(0) === 47 /* Slash */
            && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
            && uri.path.charCodeAt(2) === 58 /* Colon */) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            // other path
            value = uri.path;
        }
        if (platform_1.isWindows) {
            value = value.replace(/\//g, '\\');
        }
        return value;
    }
    /**
     * Create the external version of a uri
     */
    function _asFormatted(uri, skipEncoding) {
        var encoder = !skipEncoding
            ? encodeURIComponentFast
            : encodeURIComponentMinimal;
        var res = '';
        var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
        if (scheme) {
            res += scheme;
            res += ':';
        }
        if (authority || scheme === 'file') {
            res += _slash;
            res += _slash;
        }
        if (authority) {
            var idx = authority.indexOf('@');
            if (idx !== -1) {
                // <user>@<auth>
                var userinfo = authority.substr(0, idx);
                authority = authority.substr(idx + 1);
                idx = userinfo.indexOf(':');
                if (idx === -1) {
                    res += encoder(userinfo, false);
                }
                else {
                    // <user>:<pass>@<auth>
                    res += encoder(userinfo.substr(0, idx), false);
                    res += ':';
                    res += encoder(userinfo.substr(idx + 1), false);
                }
                res += '@';
            }
            authority = authority.toLowerCase();
            idx = authority.indexOf(':');
            if (idx === -1) {
                res += encoder(authority, false);
            }
            else {
                // <auth>:<port>
                res += encoder(authority.substr(0, idx), false);
                res += authority.substr(idx);
            }
        }
        if (path) {
            // lower-case windows drive letters in /C:/fff or C:/fff
            if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
                var code = path.charCodeAt(1);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
                }
            }
            else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var code = path.charCodeAt(0);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
                }
            }
            // encode the rest of the path
            res += encoder(path, true);
        }
        if (query) {
            res += '?';
            res += encoder(query, false);
        }
        if (fragment) {
            res += '#';
            res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
        }
        return res;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[28/*vs/base/common/amd*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getPathFromAmdModule(requirefn, relativePath) {
        return uri_1.URI.parse(requirefn.toUrl(relativePath)).fsPath;
    }
    exports.getPathFromAmdModule = getPathFromAmdModule;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[22/*vs/base/common/map*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,72/*vs/base/common/iterator*/]), function (require, exports, uri_1, iterator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function values(forEachable) {
        var result = [];
        forEachable.forEach(function (value) { return result.push(value); });
        return result;
    }
    exports.values = values;
    function keys(map) {
        var result = [];
        map.forEach(function (value, key) { return result.push(key); });
        return result;
    }
    exports.keys = keys;
    function getOrSet(map, key, value) {
        var result = map.get(key);
        if (result === void 0) {
            result = value;
            map.set(key, result);
        }
        return result;
    }
    exports.getOrSet = getOrSet;
    function mapToString(map) {
        var entries = [];
        map.forEach(function (value, key) {
            entries.push(key + " => " + value);
        });
        return "Map(" + map.size + ") {" + entries.join(', ') + "}";
    }
    exports.mapToString = mapToString;
    function setToString(set) {
        var entries = [];
        set.forEach(function (value) {
            entries.push(value);
        });
        return "Set(" + set.size + ") {" + entries.join(', ') + "}";
    }
    exports.setToString = setToString;
    var StringIterator = /** @class */ (function () {
        function StringIterator() {
            this._value = '';
            this._pos = 0;
        }
        StringIterator.prototype.reset = function (key) {
            this._value = key;
            this._pos = 0;
            return this;
        };
        StringIterator.prototype.next = function () {
            this._pos += 1;
            return this;
        };
        StringIterator.prototype.hasNext = function () {
            return this._pos < this._value.length - 1;
        };
        StringIterator.prototype.cmp = function (a) {
            var aCode = a.charCodeAt(0);
            var thisCode = this._value.charCodeAt(this._pos);
            return aCode - thisCode;
        };
        StringIterator.prototype.value = function () {
            return this._value[this._pos];
        };
        return StringIterator;
    }());
    exports.StringIterator = StringIterator;
    var PathIterator = /** @class */ (function () {
        function PathIterator() {
        }
        PathIterator.prototype.reset = function (key) {
            this._value = key.replace(/\\$|\/$/, '');
            this._from = 0;
            this._to = 0;
            return this.next();
        };
        PathIterator.prototype.hasNext = function () {
            return this._to < this._value.length;
        };
        PathIterator.prototype.next = function () {
            // this._data = key.split(/[\\/]/).filter(s => !!s);
            this._from = this._to;
            var justSeps = true;
            for (; this._to < this._value.length; this._to++) {
                var ch = this._value.charCodeAt(this._to);
                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                    if (justSeps) {
                        this._from++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    justSeps = false;
                }
            }
            return this;
        };
        PathIterator.prototype.cmp = function (a) {
            var aPos = 0;
            var aLen = a.length;
            var thisPos = this._from;
            while (aPos < aLen && thisPos < this._to) {
                var cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);
                if (cmp !== 0) {
                    return cmp;
                }
                aPos += 1;
                thisPos += 1;
            }
            if (aLen === this._to - this._from) {
                return 0;
            }
            else if (aPos < aLen) {
                return -1;
            }
            else {
                return 1;
            }
        };
        PathIterator.prototype.value = function () {
            return this._value.substring(this._from, this._to);
        };
        return PathIterator;
    }());
    exports.PathIterator = PathIterator;
    var TernarySearchTreeNode = /** @class */ (function () {
        function TernarySearchTreeNode() {
        }
        TernarySearchTreeNode.prototype.isEmpty = function () {
            return !this.left && !this.mid && !this.right && !this.value;
        };
        return TernarySearchTreeNode;
    }());
    var TernarySearchTree = /** @class */ (function () {
        function TernarySearchTree(segments) {
            this._iter = segments;
        }
        TernarySearchTree.forPaths = function () {
            return new TernarySearchTree(new PathIterator());
        };
        TernarySearchTree.forStrings = function () {
            return new TernarySearchTree(new StringIterator());
        };
        TernarySearchTree.prototype.clear = function () {
            this._root = undefined;
        };
        TernarySearchTree.prototype.set = function (key, element) {
            var iter = this._iter.reset(key);
            var node;
            if (!this._root) {
                this._root = new TernarySearchTreeNode();
                this._root.segment = iter.value();
            }
            node = this._root;
            while (true) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    if (!node.left) {
                        node.left = new TernarySearchTreeNode();
                        node.left.segment = iter.value();
                    }
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    if (!node.right) {
                        node.right = new TernarySearchTreeNode();
                        node.right.segment = iter.value();
                    }
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    if (!node.mid) {
                        node.mid = new TernarySearchTreeNode();
                        node.mid.segment = iter.value();
                    }
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            var oldElement = node.value;
            node.value = element;
            node.key = key;
            return oldElement;
        };
        TernarySearchTree.prototype.get = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node ? node.value : undefined;
        };
        TernarySearchTree.prototype.delete = function (key) {
            var iter = this._iter.reset(key);
            var stack = [];
            var node = this._root;
            // find and unset node
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    stack.push([1, node]);
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    stack.push([-1, node]);
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    stack.push([0, node]);
                    node = node.mid;
                }
                else {
                    // remove element
                    node.value = undefined;
                    // clean up empty nodes
                    while (stack.length > 0 && node.isEmpty()) {
                        var _a = stack.pop(), dir = _a[0], parent_1 = _a[1];
                        switch (dir) {
                            case 1:
                                parent_1.left = undefined;
                                break;
                            case 0:
                                parent_1.mid = undefined;
                                break;
                            case -1:
                                parent_1.right = undefined;
                                break;
                        }
                        node = parent_1;
                    }
                    break;
                }
            }
        };
        TernarySearchTree.prototype.findSubstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            var candidate = undefined;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    candidate = node.value || candidate;
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node && node.value || candidate;
        };
        TernarySearchTree.prototype.findSuperstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    // collect
                    if (!node.mid) {
                        return undefined;
                    }
                    else {
                        return this._nodeIterator(node.mid);
                    }
                }
            }
            return undefined;
        };
        TernarySearchTree.prototype._nodeIterator = function (node) {
            var _this = this;
            var res;
            var idx;
            var data;
            var next = function () {
                if (!data) {
                    // lazy till first invocation
                    data = [];
                    idx = 0;
                    _this._forEach(node, function (value) { return data.push(value); });
                }
                if (idx >= data.length) {
                    return iterator_1.FIN;
                }
                if (!res) {
                    res = { done: false, value: data[idx++] };
                }
                else {
                    res.value = data[idx++];
                }
                return res;
            };
            return { next: next };
        };
        TernarySearchTree.prototype.forEach = function (callback) {
            this._forEach(this._root, callback);
        };
        TernarySearchTree.prototype._forEach = function (node, callback) {
            if (node) {
                // left
                this._forEach(node.left, callback);
                // node
                if (node.value) {
                    // callback(node.value, this._iter.join(parts));
                    callback(node.value, node.key);
                }
                // mid
                this._forEach(node.mid, callback);
                // right
                this._forEach(node.right, callback);
            }
        };
        return TernarySearchTree;
    }());
    exports.TernarySearchTree = TernarySearchTree;
    var ResourceMap = /** @class */ (function () {
        function ResourceMap() {
            this.map = new Map();
            this.ignoreCase = false; // in the future this should be an uri-comparator
        }
        ResourceMap.prototype.set = function (resource, value) {
            this.map.set(this.toKey(resource), value);
        };
        ResourceMap.prototype.get = function (resource) {
            return this.map.get(this.toKey(resource));
        };
        ResourceMap.prototype.has = function (resource) {
            return this.map.has(this.toKey(resource));
        };
        Object.defineProperty(ResourceMap.prototype, "size", {
            get: function () {
                return this.map.size;
            },
            enumerable: true,
            configurable: true
        });
        ResourceMap.prototype.clear = function () {
            this.map.clear();
        };
        ResourceMap.prototype.delete = function (resource) {
            return this.map.delete(this.toKey(resource));
        };
        ResourceMap.prototype.forEach = function (clb) {
            this.map.forEach(clb);
        };
        ResourceMap.prototype.values = function () {
            return values(this.map);
        };
        ResourceMap.prototype.toKey = function (resource) {
            var key = resource.toString();
            if (this.ignoreCase) {
                key = key.toLowerCase();
            }
            return key;
        };
        ResourceMap.prototype.keys = function () {
            return keys(this.map).map(uri_1.URI.parse);
        };
        ResourceMap.prototype.clone = function () {
            var resourceMap = new ResourceMap();
            this.map.forEach(function (value, key) { return resourceMap.map.set(key, value); });
            return resourceMap;
        };
        return ResourceMap;
    }());
    exports.ResourceMap = ResourceMap;
    var Touch;
    (function (Touch) {
        Touch[Touch["None"] = 0] = "None";
        Touch[Touch["AsOld"] = 1] = "AsOld";
        Touch[Touch["AsNew"] = 2] = "AsNew";
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = /** @class */ (function () {
        function LinkedMap() {
            this._map = new Map();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        }
        LinkedMap.prototype.clear = function () {
            this._map.clear();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        };
        LinkedMap.prototype.isEmpty = function () {
            return !this._head && !this._tail;
        };
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.has = function (key) {
            return this._map.has(key);
        };
        LinkedMap.prototype.get = function (key, touch) {
            if (touch === void 0) { touch = 0 /* None */; }
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            if (touch !== 0 /* None */) {
                this.touch(item, touch);
            }
            return item.value;
        };
        LinkedMap.prototype.set = function (key, value, touch) {
            if (touch === void 0) { touch = 0 /* None */; }
            var item = this._map.get(key);
            if (item) {
                item.value = value;
                if (touch !== 0 /* None */) {
                    this.touch(item, touch);
                }
            }
            else {
                item = { key: key, value: value, next: undefined, previous: undefined };
                switch (touch) {
                    case 0 /* None */:
                        this.addItemLast(item);
                        break;
                    case 1 /* AsOld */:
                        this.addItemFirst(item);
                        break;
                    case 2 /* AsNew */:
                        this.addItemLast(item);
                        break;
                    default:
                        this.addItemLast(item);
                        break;
                }
                this._map.set(key, item);
                this._size++;
            }
        };
        LinkedMap.prototype.delete = function (key) {
            return !!this.remove(key);
        };
        LinkedMap.prototype.remove = function (key) {
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            this._map.delete(key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.shift = function () {
            if (!this._head && !this._tail) {
                return undefined;
            }
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            var item = this._head;
            this._map.delete(item.key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.forEach = function (callbackfn, thisArg) {
            var current = this._head;
            while (current) {
                if (thisArg) {
                    callbackfn.bind(thisArg)(current.value, current.key, this);
                }
                else {
                    callbackfn(current.value, current.key, this);
                }
                current = current.next;
            }
        };
        LinkedMap.prototype.values = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.value);
                current = current.next;
            }
            return result;
        };
        LinkedMap.prototype.keys = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.key);
                current = current.next;
            }
            return result;
        };
        /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator
        public keys(): IterableIterator<K> {
            let current = this._head;
            let iterator: IterableIterator<K> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<K> {
                    if (current) {
                        let result = { value: current.key, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
    
        public values(): IterableIterator<V> {
            let current = this._head;
            let iterator: IterableIterator<V> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<V> {
                    if (current) {
                        let result = { value: current.value, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
        */
        LinkedMap.prototype.trimOld = function (newSize) {
            if (newSize >= this.size) {
                return;
            }
            if (newSize === 0) {
                this.clear();
                return;
            }
            var current = this._head;
            var currentSize = this.size;
            while (current && currentSize > newSize) {
                this._map.delete(current.key);
                current = current.next;
                currentSize--;
            }
            this._head = current;
            this._size = currentSize;
            if (current) {
                current.previous = void 0;
            }
        };
        LinkedMap.prototype.addItemFirst = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._tail = item;
            }
            else if (!this._head) {
                throw new Error('Invalid list');
            }
            else {
                item.next = this._head;
                this._head.previous = item;
            }
            this._head = item;
        };
        LinkedMap.prototype.addItemLast = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._head = item;
            }
            else if (!this._tail) {
                throw new Error('Invalid list');
            }
            else {
                item.previous = this._tail;
                this._tail.next = item;
            }
            this._tail = item;
        };
        LinkedMap.prototype.removeItem = function (item) {
            if (item === this._head && item === this._tail) {
                this._head = void 0;
                this._tail = void 0;
            }
            else if (item === this._head) {
                this._head = item.next;
            }
            else if (item === this._tail) {
                this._tail = item.previous;
            }
            else {
                var next = item.next;
                var previous = item.previous;
                if (!next || !previous) {
                    throw new Error('Invalid list');
                }
                next.previous = previous;
                previous.next = next;
            }
        };
        LinkedMap.prototype.touch = function (item, touch) {
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            if ((touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */)) {
                return;
            }
            if (touch === 1 /* AsOld */) {
                if (item === this._head) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item
                if (item === this._tail) {
                    // previous must be defined since item was not head but is tail
                    // So there are more than on item in the map
                    previous.next = void 0;
                    this._tail = previous;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                // Insert the node at head
                item.previous = void 0;
                item.next = this._head;
                this._head.previous = item;
                this._head = item;
            }
            else if (touch === 2 /* AsNew */) {
                if (item === this._tail) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item.
                if (item === this._head) {
                    // next must be defined since item was not tail but is head
                    // So there are more than on item in the map
                    next.previous = void 0;
                    this._head = next;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                item.next = void 0;
                item.previous = this._tail;
                this._tail.next = item;
                this._tail = item;
            }
        };
        LinkedMap.prototype.toJSON = function () {
            var data = [];
            this.forEach(function (value, key) {
                data.push([key, value]);
            });
            return data;
        };
        LinkedMap.prototype.fromJSON = function (data) {
            this.clear();
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var _a = data_1[_i], key = _a[0], value = _a[1];
                this.set(key, value);
            }
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
    var LRUCache = /** @class */ (function (_super) {
        __extends(LRUCache, _super);
        function LRUCache(limit, ratio) {
            if (ratio === void 0) { ratio = 1; }
            var _this = _super.call(this) || this;
            _this._limit = limit;
            _this._ratio = Math.min(Math.max(0, ratio), 1);
            return _this;
        }
        Object.defineProperty(LRUCache.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LRUCache.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            set: function (ratio) {
                this._ratio = Math.min(Math.max(0, ratio), 1);
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        LRUCache.prototype.get = function (key) {
            return _super.prototype.get.call(this, key, 2 /* AsNew */);
        };
        LRUCache.prototype.peek = function (key) {
            return _super.prototype.get.call(this, key, 0 /* None */);
        };
        LRUCache.prototype.set = function (key, value) {
            _super.prototype.set.call(this, key, value, 2 /* AsNew */);
            this.checkTrim();
        };
        LRUCache.prototype.checkTrim = function () {
            if (this.size > this._limit) {
                this.trimOld(Math.round(this._limit * this._ratio));
            }
        };
        return LRUCache;
    }(LinkedMap));
    exports.LRUCache = LRUCache;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[115/*vs/base/common/filters*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/map*/,5/*vs/base/common/strings*/]), function (require, exports, map_1, strings) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    exports.or = or;
    // Prefix
    exports.matchesStrictPrefix = _matchesPrefix.bind(undefined, false);
    exports.matchesPrefix = _matchesPrefix.bind(undefined, true);
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {
            return null;
        }
        var matches;
        if (ignoreCase) {
            matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);
        }
        else {
            matches = wordToMatchAgainst.indexOf(word) === 0;
        }
        if (!matches) {
            return null;
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function matchesContiguousSubString(word, wordToMatchAgainst) {
        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    exports.matchesContiguousSubString = matchesContiguousSubString;
    // Substring
    function matchesSubString(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    exports.matchesSubString = matchesSubString;
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                var result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
                return null;
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return 97 /* a */ <= code && code <= 122 /* z */;
    }
    function isUpper(code) {
        return 65 /* A */ <= code && code <= 90 /* Z */;
    }
    exports.isUpper = isUpper;
    function isNumber(code) {
        return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;
    }
    function isWhitespace(code) {
        return (code === 32 /* Space */
            || code === 9 /* Tab */
            || code === 10 /* LineFeed */
            || code === 13 /* CarriageReturn */);
    }
    function isAlphanumeric(code) {
        return isLower(code) || isUpper(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (var i = start; i < camelCaseWord.length; i++) {
            var c = camelCaseWord.charCodeAt(i);
            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function analyzeCamelCaseWord(word) {
        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        var upperPercent = upper / word.length;
        var lowerPercent = lower / word.length;
        var alphaPercent = alpha / word.length;
        var numericPercent = numeric / word.length;
        return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };
    }
    function isUpperCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;
        return lowerPercent === 0 && upperPercent > 0.6;
    }
    function isCamelCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        var upper = 0, lower = 0, code = 0, whitespace = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function matchesCamelCase(word, camelCaseWord) {
        if (!camelCaseWord) {
            return null;
        }
        camelCaseWord = camelCaseWord.trim();
        if (camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        if (camelCaseWord.length > 60) {
            return null;
        }
        var analysis = analyzeCamelCaseWord(camelCaseWord);
        if (!isCamelCaseWord(analysis)) {
            if (!isUpperCaseWord(analysis)) {
                return null;
            }
            camelCaseWord = camelCaseWord.toLowerCase();
        }
        var result = null;
        var i = 0;
        word = word.toLowerCase();
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    exports.matchesCamelCase = matchesCamelCase;
    // Matches beginning of words supporting non-ASCII languages
    // If `contiguous` is true then matches word with beginnings of the words in the target. E.g. "pul" will match "Git: Pull"
    // Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. "gp" or "g p" will match "Git: Pull"
    // Useful in cases where the target is words (e.g. command labels)
    function matchesWords(word, target, contiguous) {
        if (contiguous === void 0) { contiguous = false; }
        if (!target || target.length === 0) {
            return null;
        }
        var result = null;
        var i = 0;
        word = word.toLowerCase();
        target = target.toLowerCase();
        while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {
            i = nextWord(target, i + 1);
        }
        return result;
    }
    exports.matchesWords = matchesWords;
    function _matchesWords(word, target, i, j, contiguous) {
        if (i === word.length) {
            return [];
        }
        else if (j === target.length) {
            return null;
        }
        else if (word[i] !== target[j]) {
            return null;
        }
        else {
            var result = null;
            var nextWordIndex = j + 1;
            result = _matchesWords(word, target, i + 1, j + 1, contiguous);
            if (!contiguous) {
                while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
                    result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
                    nextWordIndex++;
                }
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    function nextWord(word, start) {
        for (var i = start; i < word.length; i++) {
            var c = word.charCodeAt(i);
            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return word.length;
    }
    // Fuzzy
    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);
    var fuzzyRegExpCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
            return null; // return early for invalid input
        }
        // Form RegExp for wildcard matches
        var regexp = fuzzyRegExpCache.get(word);
        if (!regexp) {
            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');
            fuzzyRegExpCache.set(word, regexp);
        }
        // RegExp Filter
        var match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    exports.matchesFuzzy = matchesFuzzy;
    function anyScore(pattern, word, patternMaxWhitespaceIgnore) {
        pattern = pattern.toLowerCase();
        word = word.toLowerCase();
        var matches = [];
        var idx = 0;
        for (var pos = 0; pos < pattern.length; ++pos) {
            var thisIdx = word.indexOf(pattern.charAt(pos), idx);
            if (thisIdx >= 0) {
                matches.push(thisIdx);
                idx = thisIdx + 1;
            }
        }
        return [matches.length, matches];
    }
    exports.anyScore = anyScore;
    //#region --- fuzzyScore ---
    function createMatches(offsetOrScore) {
        var ret = [];
        if (!offsetOrScore) {
            return ret;
        }
        var offsets;
        if (Array.isArray(offsetOrScore[1])) {
            offsets = offsetOrScore[1];
        }
        else {
            offsets = offsetOrScore;
        }
        var last;
        for (var _i = 0, offsets_1 = offsets; _i < offsets_1.length; _i++) {
            var pos = offsets_1[_i];
            if (last && last.end === pos) {
                last.end += 1;
            }
            else {
                last = { start: pos, end: pos + 1 };
                ret.push(last);
            }
        }
        return ret;
    }
    exports.createMatches = createMatches;
    function initTable() {
        var table = [];
        var row = [0];
        for (var i = 1; i <= 100; i++) {
            row.push(-i);
        }
        for (var i = 0; i <= 100; i++) {
            var thisRow = row.slice(0);
            thisRow[0] = -i;
            table.push(thisRow);
        }
        return table;
    }
    var _table = initTable();
    var _scores = initTable();
    var _arrows = initTable();
    var _debug = false;
    function printTable(table, pattern, patternLen, word, wordLen) {
        function pad(s, n, pad) {
            if (pad === void 0) { pad = ' '; }
            while (s.length < n) {
                s = pad + s;
            }
            return s;
        }
        var ret = " |   |" + word.split('').map(function (c) { return pad(c, 3); }).join('|') + "\n";
        for (var i = 0; i <= patternLen; i++) {
            if (i === 0) {
                ret += ' |';
            }
            else {
                ret += pattern[i - 1] + "|";
            }
            ret += table[i].slice(0, wordLen + 1).map(function (n) { return pad(n.toString(), 3); }).join('|') + '\n';
        }
        return ret;
    }
    function isSeparatorAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        var code = value.charCodeAt(index);
        switch (code) {
            case 95 /* Underline */:
            case 45 /* Dash */:
            case 46 /* Period */:
            case 32 /* Space */:
            case 47 /* Slash */:
            case 92 /* Backslash */:
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
            case 58 /* Colon */:
                return true;
            default:
                return false;
        }
    }
    function isWhitespaceAtPos(value, index) {
        if (index < 0 || index >= value.length) {
            return false;
        }
        var code = value.charCodeAt(index);
        switch (code) {
            case 32 /* Space */:
            case 9 /* Tab */:
                return true;
            default:
                return false;
        }
    }
    var Arrow;
    (function (Arrow) {
        Arrow[Arrow["Top"] = 1] = "Top";
        Arrow[Arrow["Diag"] = 2] = "Diag";
        Arrow[Arrow["Left"] = 4] = "Left";
    })(Arrow || (Arrow = {}));
    function fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {
        var patternLen = pattern.length > 100 ? 100 : pattern.length;
        var wordLen = word.length > 100 ? 100 : word.length;
        if (patternPos >= patternLen || wordPos >= wordLen || patternLen > wordLen) {
            return undefined;
        }
        // Run a simple check if the characters of pattern occur
        // (in order) at all in word. If that isn't the case we
        // stop because no match will be possible
        var patternStartPos = patternPos;
        var wordStartPos = wordPos;
        while (patternPos < patternLen && wordPos < wordLen) {
            if (lowPattern[patternPos] === lowWord[wordPos]) {
                patternPos += 1;
            }
            wordPos += 1;
        }
        if (patternPos !== patternLen) {
            return undefined;
        }
        patternPos = patternStartPos;
        wordPos = wordStartPos;
        // There will be a mach, fill in tables
        for (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {
            for (wordPos = 1; wordPos <= wordLen; wordPos++) {
                var score = -1;
                var lowWordChar = lowWord[wordPos - 1];
                if (lowPattern[patternPos - 1] === lowWordChar) {
                    if (wordPos === (patternPos - patternStartPos)) {
                        // common prefix: `foobar <-> foobaz`
                        if (pattern[patternPos - 1] === word[wordPos - 1]) {
                            score = 7;
                        }
                        else {
                            score = 5;
                        }
                    }
                    else if (lowWordChar !== word[wordPos - 1] && (wordPos === 1 || lowWord[wordPos - 2] === word[wordPos - 2])) {
                        // hitting upper-case: `foo <-> forOthers`
                        if (pattern[patternPos - 1] === word[wordPos - 1]) {
                            score = 7;
                        }
                        else {
                            score = 5;
                        }
                    }
                    else if (isSeparatorAtPos(lowWord, wordPos - 2) || isWhitespaceAtPos(lowWord, wordPos - 2)) {
                        // post separator: `foo <-> bar_foo`
                        score = 5;
                    }
                    else {
                        score = 1;
                    }
                }
                _scores[patternPos][wordPos] = score;
                var diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);
                var top_1 = _table[patternPos - 1][wordPos] + -1;
                var left = _table[patternPos][wordPos - 1] + -1;
                if (left >= top_1) {
                    // left or diag
                    if (left > diag) {
                        _table[patternPos][wordPos] = left;
                        _arrows[patternPos][wordPos] = 4 /* Left */;
                    }
                    else if (left === diag) {
                        _table[patternPos][wordPos] = left;
                        _arrows[patternPos][wordPos] = 4 /* Left */ | 2 /* Diag */;
                    }
                    else {
                        _table[patternPos][wordPos] = diag;
                        _arrows[patternPos][wordPos] = 2 /* Diag */;
                    }
                }
                else {
                    // top or diag
                    if (top_1 > diag) {
                        _table[patternPos][wordPos] = top_1;
                        _arrows[patternPos][wordPos] = 1 /* Top */;
                    }
                    else if (top_1 === diag) {
                        _table[patternPos][wordPos] = top_1;
                        _arrows[patternPos][wordPos] = 1 /* Top */ | 2 /* Diag */;
                    }
                    else {
                        _table[patternPos][wordPos] = diag;
                        _arrows[patternPos][wordPos] = 2 /* Diag */;
                    }
                }
            }
        }
        if (_debug) {
            console.log(printTable(_table, pattern, patternLen, word, wordLen));
            console.log(printTable(_arrows, pattern, patternLen, word, wordLen));
            console.log(printTable(_scores, pattern, patternLen, word, wordLen));
        }
        // _bucket is an array of [PrefixArray] we use to keep
        // track of scores and matches. After calling `_findAllMatches`
        // the best match (if available) is the first item in the array
        _matchesCount = 0;
        _topScore = -100;
        _patternStartPos = patternStartPos;
        _firstMatchCanBeWeak = firstMatchCanBeWeak;
        _findAllMatches(patternLen, wordLen, patternLen === wordLen ? 1 : 0, new LazyArray(), false);
        if (_matchesCount === 0) {
            return undefined;
        }
        return [_topScore, _topMatch.toArray()];
    }
    exports.fuzzyScore = fuzzyScore;
    var _matchesCount = 0;
    var _topMatch;
    var _topScore = 0;
    var _patternStartPos = 0;
    var _firstMatchCanBeWeak = false;
    function _findAllMatches(patternPos, wordPos, total, matches, lastMatched) {
        if (_matchesCount >= 10 || total < -25) {
            // stop when having already 10 results, or
            // when a potential alignment as already 5 gaps
            return;
        }
        var simpleMatchCount = 0;
        while (patternPos > _patternStartPos && wordPos > 0) {
            var score = _scores[patternPos][wordPos];
            var arrow = _arrows[patternPos][wordPos];
            if (arrow === 4 /* Left */) {
                // left
                wordPos -= 1;
                if (lastMatched) {
                    total -= 5; // new gap penalty
                }
                else if (!matches.isEmpty()) {
                    total -= 1; // gap penalty after first match
                }
                lastMatched = false;
                simpleMatchCount = 0;
            }
            else if (arrow & 2 /* Diag */) {
                if (arrow & 4 /* Left */) {
                    // left
                    _findAllMatches(patternPos, wordPos - 1, !matches.isEmpty() ? total - 1 : total, // gap penalty after first match
                    matches.slice(), lastMatched);
                }
                // diag
                total += score;
                patternPos -= 1;
                wordPos -= 1;
                matches.unshift(wordPos);
                lastMatched = true;
                // count simple matches and boost a row of
                // simple matches when they yield in a
                // strong match.
                if (score === 1) {
                    simpleMatchCount += 1;
                    if (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {
                        // when the first match is a weak
                        // match we discard it
                        return undefined;
                    }
                }
                else {
                    // boost
                    total += 1 + (simpleMatchCount * (score - 1));
                    simpleMatchCount = 0;
                }
            }
            else {
                return undefined;
            }
        }
        total -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty
        // dynamically keep track of the current top score
        // and insert the current best score at head, the rest at tail
        _matchesCount += 1;
        if (total > _topScore) {
            _topScore = total;
            _topMatch = matches;
        }
    }
    var LazyArray = /** @class */ (function () {
        function LazyArray() {
        }
        LazyArray.prototype.isEmpty = function () {
            return !this._data && (!this._parent || this._parent.isEmpty());
        };
        LazyArray.prototype.unshift = function (n) {
            if (!this._data) {
                this._data = [n];
            }
            else {
                this._data.unshift(n);
            }
        };
        LazyArray.prototype.slice = function () {
            var ret = new LazyArray();
            ret._parent = this;
            ret._parentLen = this._data ? this._data.length : 0;
            return ret;
        };
        LazyArray.prototype.toArray = function () {
            if (!this._data) {
                return this._parent.toArray();
            }
            var bucket = [];
            var element = this;
            while (element) {
                if (element._parent && element._parent._data) {
                    bucket.push(element._parent._data.slice(element._parent._data.length - element._parentLen));
                }
                element = element._parent;
            }
            return Array.prototype.concat.apply(this._data, bucket);
        };
        return LazyArray;
    }());
    //#endregion
    //#region --- graceful ---
    function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {
        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);
    }
    exports.fuzzyScoreGracefulAggressive = fuzzyScoreGracefulAggressive;
    function fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {
        return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);
    }
    exports.fuzzyScoreGraceful = fuzzyScoreGraceful;
    function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {
        var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);
        if (top && !aggressive) {
            // when using the original pattern yield a result we`
            // return it unless we are aggressive and try to find
            // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.
            return top;
        }
        if (pattern.length >= 3) {
            // When the pattern is long enough then try a few (max 7)
            // permutations of the pattern to find a better match. The
            // permutations only swap neighbouring characters, e.g
            // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.
            var tries = Math.min(7, pattern.length - 1);
            for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
                var newPattern = nextTypoPermutation(pattern, movingPatternPos);
                if (newPattern) {
                    var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);
                    if (candidate) {
                        candidate[0] -= 3; // permutation penalty
                        if (!top || candidate[0] > top[0]) {
                            top = candidate;
                        }
                    }
                }
            }
        }
        return top;
    }
    function nextTypoPermutation(pattern, patternPos) {
        if (patternPos + 1 >= pattern.length) {
            return undefined;
        }
        var swap1 = pattern[patternPos];
        var swap2 = pattern[patternPos + 1];
        if (swap1 === swap2) {
            return undefined;
        }
        return pattern.slice(0, patternPos)
            + swap2
            + swap1
            + pattern.slice(patternPos + 2);
    }
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[112/*vs/base/common/marshalling*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        var data = JSON.parse(text);
        data = revive(data, 0);
        return data;
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function revive(obj, depth) {
        if (!obj || depth > 200) {
            return obj;
        }
        if (typeof obj === 'object') {
            switch (obj.$mid) {
                case 1: return uri_1.URI.revive(obj);
                case 2: return new RegExp(obj.source, obj.flags);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    obj[key] = revive(obj[key], depth + 1);
                }
            }
        }
        return obj;
    }
    exports.revive = revive;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[45/*vs/base/common/normalization*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/map*/]), function (require, exports, map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nfcCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        return normalize(str, 'NFC', nfcCache);
    }
    exports.normalizeNFC = normalizeNFC;
    var nfdCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFD(str) {
        return normalize(str, 'NFD', nfdCache);
    }
    exports.normalizeNFD = normalizeNFD;
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    function normalize(str, form, normalizedCache) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize(form);
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[24/*vs/base/common/resources*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/paths*/,2/*vs/base/common/uri*/,5/*vs/base/common/strings*/,26/*vs/base/common/network*/,6/*vs/base/common/platform*/]), function (require, exports, paths, uri_1, strings_1, network_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getComparisonKey(resource) {
        return hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();
    }
    exports.getComparisonKey = getComparisonKey;
    function hasToIgnoreCase(resource) {
        // A file scheme resource is in the same platform as code, so ignore case for non linux platforms
        // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider
        return resource && resource.scheme === network_1.Schemas.file ? !platform_1.isLinux : true;
    }
    exports.hasToIgnoreCase = hasToIgnoreCase;
    function basenameOrAuthority(resource) {
        return basename(resource) || resource.authority;
    }
    exports.basenameOrAuthority = basenameOrAuthority;
    /**
     * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.
     * @param base A uri which is "longer"
     * @param parentCandidate A uri which is "shorter" then `base`
     */
    function isEqualOrParent(base, parentCandidate, ignoreCase) {
        if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(base); }
        if (base.scheme === parentCandidate.scheme) {
            if (base.scheme === network_1.Schemas.file) {
                return paths.isEqualOrParent(fsPath(base), fsPath(parentCandidate), ignoreCase);
            }
            if (isEqualAuthority(base.authority, parentCandidate.authority, ignoreCase)) {
                return paths.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');
            }
        }
        return false;
    }
    exports.isEqualOrParent = isEqualOrParent;
    function isEqualAuthority(a1, a2, ignoreCase) {
        return a1 === a2 || ignoreCase && a1 && a2 && strings_1.equalsIgnoreCase(a1, a2);
    }
    function isEqual(first, second, ignoreCase) {
        if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(first); }
        var identityEquals = (first === second);
        if (identityEquals) {
            return true;
        }
        if (!first || !second) {
            return false;
        }
        if (ignoreCase) {
            return strings_1.equalsIgnoreCase(first.toString(), second.toString());
        }
        return first.toString() === second.toString();
    }
    exports.isEqual = isEqual;
    function basename(resource) {
        return paths.basename(resource.path);
    }
    exports.basename = basename;
    /**
     * Return a URI representing the directory of a URI path.
     *
     * @param resource The input URI.
     * @returns The URI representing the directory of the input URI.
     */
    function dirname(resource) {
        if (resource.scheme === network_1.Schemas.file) {
            return uri_1.URI.file(paths.dirname(fsPath(resource)));
        }
        var dirname = paths.dirname(resource.path, '/');
        if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {
            return null; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash ("/") character
        }
        return resource.with({
            path: dirname
        });
    }
    exports.dirname = dirname;
    /**
     * Join a URI path with a path fragment and normalizes the resulting path.
     *
     * @param resource The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    function joinPath(resource, pathFragment) {
        var joinedPath;
        if (resource.scheme === network_1.Schemas.file) {
            joinedPath = uri_1.URI.file(paths.join(fsPath(resource), pathFragment)).path;
        }
        else {
            joinedPath = paths.join(resource.path, pathFragment);
        }
        return resource.with({
            path: joinedPath
        });
    }
    exports.joinPath = joinPath;
    /**
     * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.
     *
     * @param resource The URI to normalize the path.
     * @returns The URI with the normalized path.
     */
    function normalizePath(resource) {
        var normalizedPath;
        if (resource.scheme === network_1.Schemas.file) {
            normalizedPath = uri_1.URI.file(paths.normalize(fsPath(resource))).path;
        }
        else {
            normalizedPath = paths.normalize(resource.path);
        }
        return resource.with({
            path: normalizedPath
        });
    }
    exports.normalizePath = normalizePath;
    /**
     * Returns the fsPath of an URI where the drive letter is not normalized.
     * See #56403.
     */
    function fsPath(uri) {
        var value;
        if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + uri.authority + uri.path;
        }
        else if (platform_1.isWindows
            && uri.path.charCodeAt(0) === 47 /* Slash */
            && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
            && uri.path.charCodeAt(2) === 58 /* Colon */) {
            value = uri.path.substr(1);
        }
        else {
            // other path
            value = uri.path;
        }
        if (platform_1.isWindows) {
            value = value.replace(/\//g, '\\');
        }
        return value;
    }
    exports.fsPath = fsPath;
    /**
     * Returns true if the URI path is absolute.
     */
    function isAbsolutePath(resource) {
        return paths.isAbsolute(resource.path);
    }
    exports.isAbsolutePath = isAbsolutePath;
    function distinctParents(items, resourceAccessor) {
        var distinctParents = [];
        var _loop_1 = function (i) {
            var candidateResource = resourceAccessor(items[i]);
            if (items.some(function (otherItem, index) {
                if (index === i) {
                    return false;
                }
                return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
            })) {
                return "continue";
            }
            distinctParents.push(items[i]);
        };
        for (var i = 0; i < items.length; i++) {
            _loop_1(i);
        }
        return distinctParents;
    }
    exports.distinctParents = distinctParents;
    /**
     * Tests whether the given URL is a file URI created by `URI.parse` instead of `URI.file`.
     * Such URI have no scheme or scheme that consist of a single letter (windows drive letter)
     * @param candidate The URI to test
     * @returns A corrected, real file URI if the input seems to be malformed.
     * Undefined is returned if the input URI looks fine.
     */
    function isMalformedFileUri(candidate) {
        if (!candidate.scheme || platform_1.isWindows && candidate.scheme.match(/^[a-zA-Z]$/)) {
            return uri_1.URI.file((candidate.scheme ? candidate.scheme + ':' : '') + candidate.path);
        }
        return void 0;
    }
    exports.isMalformedFileUri = isMalformedFileUri;
    /**
     * Data URI related helpers.
     */
    var DataUri;
    (function (DataUri) {
        DataUri.META_DATA_LABEL = 'label';
        DataUri.META_DATA_DESCRIPTION = 'description';
        DataUri.META_DATA_SIZE = 'size';
        DataUri.META_DATA_MIME = 'mime';
        function parseMetaData(dataUri) {
            var metadata = new Map();
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the metadata is: size:2313;label:SomeLabel;description:SomeDescription
            var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));
            meta.split(';').forEach(function (property) {
                var _a = property.split(':'), key = _a[0], value = _a[1];
                if (key && value) {
                    metadata.set(key, value);
                }
            });
            // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...
            // the mime is: image/png
            var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));
            if (mime) {
                metadata.set(DataUri.META_DATA_MIME, mime);
            }
            return metadata;
        }
        DataUri.parseMetaData = parseMetaData;
    })(DataUri = exports.DataUri || (exports.DataUri = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[110/*vs/base/common/labels*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,12/*vs/base/common/paths*/,5/*vs/base/common/strings*/,26/*vs/base/common/network*/,6/*vs/base/common/platform*/,24/*vs/base/common/resources*/]), function (require, exports, uri_1, paths_1, strings_1, network_1, platform_1, resources_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @deprecated use LabelService instead
     */
    function getPathLabel(resource, userHomeProvider, rootProvider) {
        if (typeof resource === 'string') {
            resource = uri_1.URI.file(resource);
        }
        // return early if we can resolve a relative path label from the root
        if (rootProvider) {
            var baseResource = rootProvider.getWorkspaceFolder(resource);
            if (baseResource) {
                var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;
                var pathLabel = void 0;
                if (resources_1.isEqual(baseResource.uri, resource, !platform_1.isLinux)) {
                    pathLabel = ''; // no label if paths are identical
                }
                else {
                    pathLabel = paths_1.normalize(strings_1.ltrim(resource.path.substr(baseResource.uri.path.length), paths_1.sep), true);
                }
                if (hasMultipleRoots) {
                    var rootName = (baseResource && baseResource.name) ? baseResource.name : paths_1.basename(baseResource.uri.fsPath);
                    pathLabel = pathLabel ? (rootName + '  ' + pathLabel) : rootName; // always show root basename if there are multiple
                }
                return pathLabel;
            }
        }
        // return if the resource is neither file:// nor untitled:// and no baseResource was provided
        if (resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.untitled) {
            return resource.with({ query: null, fragment: null }).toString(true);
        }
        // convert c:\something => C:\something
        if (hasDriveLetter(resource.fsPath)) {
            return paths_1.normalize(normalizeDriveLetter(resource.fsPath), true);
        }
        // normalize and tildify (macOS, Linux only)
        var res = paths_1.normalize(resource.fsPath, true);
        if (!platform_1.isWindows && userHomeProvider) {
            res = tildify(res, userHomeProvider.userHome);
        }
        return res;
    }
    exports.getPathLabel = getPathLabel;
    function getBaseLabel(resource) {
        if (!resource) {
            return undefined;
        }
        if (typeof resource === 'string') {
            resource = uri_1.URI.file(resource);
        }
        var base = paths_1.basename(resource.path) || (resource.scheme === network_1.Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;
        // convert c: => C:
        if (hasDriveLetter(base)) {
            return normalizeDriveLetter(base);
        }
        return base;
    }
    exports.getBaseLabel = getBaseLabel;
    function hasDriveLetter(path) {
        return !!(platform_1.isWindows && path && path[1] === ':');
    }
    function normalizeDriveLetter(path) {
        if (hasDriveLetter(path)) {
            return path.charAt(0).toUpperCase() + path.slice(1);
        }
        return path;
    }
    exports.normalizeDriveLetter = normalizeDriveLetter;
    var normalizedUserHomeCached = Object.create(null);
    function tildify(path, userHome) {
        if (platform_1.isWindows || !path || !userHome) {
            return path; // unsupported
        }
        // Keep a normalized user home path as cache to prevent accumulated string creation
        var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : void 0;
        if (!normalizedUserHome) {
            normalizedUserHome = "" + strings_1.rtrim(userHome, paths_1.sep) + paths_1.sep;
            normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
        }
        // Linux: case sensitive, macOS: case insensitive
        if (platform_1.isLinux ? strings_1.startsWith(path, normalizedUserHome) : strings_1.startsWithIgnoreCase(path, normalizedUserHome)) {
            path = "~/" + path.substr(normalizedUserHome.length);
        }
        return path;
    }
    exports.tildify = tildify;
    function untildify(path, userHome) {
        return path.replace(/^~($|\/|\\)/, userHome + "$1");
    }
    exports.untildify = untildify;
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     *
     * Algorithm for shortening paths is as follows:
     * 1. For every path in list, find unique substring of that path.
     * 2. Unique substring along with ellipsis is shortened path of that path.
     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
     *    and if present segment is not substring to any other paths then present segment is unique path,
     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
     *    if it is true take present segment as unique path.
     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
     *
     * Example 1
     * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
     * 2. find unique path of first path,
     * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
     * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
     * 	c. 'd\\c' is suffix of path2.
     *  d. 'b\\c' is not suffix of present path.
     *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
     * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
     *
     * Example 2
     * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
     * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
     */
    var ellipsis = '\u2026';
    var unc = '\\\\';
    var home = '~';
    function shorten(paths) {
        var shortenedPaths = new Array(paths.length);
        // for every path
        var match = false;
        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            var path = paths[pathIndex];
            if (path === '') {
                shortenedPaths[pathIndex] = "." + paths_1.nativeSep;
                continue;
            }
            if (!path) {
                shortenedPaths[pathIndex] = path;
                continue;
            }
            match = true;
            // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
            var prefix = '';
            if (path.indexOf(unc) === 0) {
                prefix = path.substr(0, path.indexOf(unc) + unc.length);
                path = path.substr(path.indexOf(unc) + unc.length);
            }
            else if (path.indexOf(paths_1.nativeSep) === 0) {
                prefix = path.substr(0, path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
                path = path.substr(path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
            }
            else if (path.indexOf(home) === 0) {
                prefix = path.substr(0, path.indexOf(home) + home.length);
                path = path.substr(path.indexOf(home) + home.length);
            }
            // pick the first shortest subpath found
            var segments = path.split(paths_1.nativeSep);
            for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                    match = false;
                    var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                    // that is unique to any other path
                    for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                            var isSubpathEnding = (start + subpathLength === segments.length);
                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
                            var subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(paths_1.nativeSep) > -1) ? paths_1.nativeSep + subpath : subpath;
                            var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);
                            match = !isSubpathEnding || isOtherPathEnding;
                        }
                    }
                    // found unique subpath
                    if (!match) {
                        var result = '';
                        // preserve disk drive or root prefix
                        if (strings_1.endsWith(segments[0], ':') || prefix !== '') {
                            if (start === 1) {
                                // extend subpath to include disk drive prefix
                                start = 0;
                                subpathLength++;
                                subpath = segments[0] + paths_1.nativeSep + subpath;
                            }
                            if (start > 0) {
                                result = segments[0] + paths_1.nativeSep;
                            }
                            result = prefix + result;
                        }
                        // add ellipsis at the beginning if neeeded
                        if (start > 0) {
                            result = result + ellipsis + paths_1.nativeSep;
                        }
                        result = result + subpath;
                        // add ellipsis at the end if needed
                        if (start + subpathLength < segments.length) {
                            result = result + paths_1.nativeSep + ellipsis;
                        }
                        shortenedPaths[pathIndex] = result;
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    exports.shorten = shorten;
    var Type;
    (function (Type) {
        Type[Type["TEXT"] = 0] = "TEXT";
        Type[Type["VARIABLE"] = 1] = "VARIABLE";
        Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
    })(Type || (Type = {}));
    /**
     * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
     * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
     * @param value string to which templating is applied
     * @param values the values of the templates to use
     */
    function template(template, values) {
        if (values === void 0) { values = Object.create(null); }
        var segments = [];
        var inVariable = false;
        var char;
        var curVal = '';
        for (var i = 0; i < template.length; i++) {
            char = template[i];
            // Beginning of variable
            if (char === '$' || (inVariable && char === '{')) {
                if (curVal) {
                    segments.push({ value: curVal, type: Type.TEXT });
                }
                curVal = '';
                inVariable = true;
            }
            // End of variable
            else if (char === '}' && inVariable) {
                var resolved = values[curVal];
                // Variable
                if (typeof resolved === 'string') {
                    if (resolved.length) {
                        segments.push({ value: resolved, type: Type.VARIABLE });
                    }
                }
                // Separator
                else if (resolved) {
                    var prevSegment = segments[segments.length - 1];
                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                    }
                }
                curVal = '';
                inVariable = false;
            }
            // Text or Variable Name
            else {
                curVal += char;
            }
        }
        // Tail
        if (curVal && !inVariable) {
            segments.push({ value: curVal, type: Type.TEXT });
        }
        return segments.filter(function (segment, index) {
            // Only keep separator if we have values to the left and right
            if (segment.type === Type.SEPARATOR) {
                var left = segments[index - 1];
                var right = segments[index + 1];
                return [left, right].every(function (segment) { return segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0; });
            }
            // accept any TEXT and VARIABLE
            return true;
        }).map(function (segment) { return segment.value; }).join('');
    }
    exports.template = template;
    /**
     * Handles mnemonics for menu items. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via & character (replace && with &)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicMenuLabel(label, forceDisableMnemonics) {
        if (platform_1.isMacintosh || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, '&');
    }
    exports.mnemonicMenuLabel = mnemonicMenuLabel;
    /**
     * Handles mnemonics for buttons. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via _ character (replace && with _)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicButtonLabel(label) {
        if (platform_1.isMacintosh) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, platform_1.isWindows ? '&' : '_');
    }
    exports.mnemonicButtonLabel = mnemonicButtonLabel;
    function unmnemonicLabel(label) {
        return label.replace(/&/g, '&&');
    }
    exports.unmnemonicLabel = unmnemonicLabel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[49/*vs/base/common/uuid*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = /** @class */ (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        return ValueUUID;
    }());
    var V4UUID = /** @class */ (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            return _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join('')) || this;
        }
        V4UUID._oneOf = function (array) {
            return array[Math.floor(array.length * Math.random())];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
        return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!isUUID(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the MIT License.
 */
var __winjs_exports;

(function() {

var _modules = Object.create(null);//{};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    var actualSetImmediate = null;

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: function (callback) {
            // BEGIN monaco change
            if (actualSetImmediate === null) {
                if (_Global.setImmediate) {
                    actualSetImmediate = _Global.setImmediate.bind(_Global);
                } else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                    actualSetImmediate = process.nextTick.bind(process);
                } else {
                    actualSetImmediate = _Global.setTimeout.bind(_Global);
                }
            }
            actualSetImmediate(callback);
            // END monaco change
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            // BEGIN monaco change
            if (this.then !== Promise_then) {
                this.then(onComplete, onError, onProgress);
                return;
            }
            // END monaco change
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

__winjs_exports = _modules["WinJS/Core/_WinJS"];
__winjs_exports.TPromise = __winjs_exports.Promise;
__winjs_exports.PPromise = __winjs_exports.Promise;

// ESM-comment-begin
if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base", [], __winjs_exports);
} else {
    module.exports = __winjs_exports;
}
// ESM-comment-end

})();

// ESM-uncomment-begin
// export var Promise = __winjs_exports.Promise;
// export var TPromise = __winjs_exports.TPromise;
// export var PPromise = __winjs_exports.PPromise;
// ESM-uncomment-end

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[14/*vs/base/common/errors*/], __M([1/*require*/,0/*exports*/,20/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ BEGIN Hook up error listeners to winjs promises
    var outstandingPromiseErrors = {};
    function promiseErrorHandler(e) {
        //
        // e.detail looks like: { exception, error, promise, handler, id, parent }
        //
        var details = e.detail;
        var id = details.id;
        // If the error has a parent promise then this is not the origination of the
        //  error so we check if it has a handler, and if so we mark that the error
        //  was handled by removing it from outstandingPromiseErrors
        //
        if (details.parent) {
            if (details.handler && outstandingPromiseErrors) {
                delete outstandingPromiseErrors[id];
            }
            return;
        }
        // Indicate that this error was originated and needs to be handled
        outstandingPromiseErrors[id] = details;
        // The first time the queue fills up this iteration, schedule a timeout to
        // check if any errors are still unhandled.
        if (Object.keys(outstandingPromiseErrors).length === 1) {
            setTimeout(function () {
                var errors = outstandingPromiseErrors;
                outstandingPromiseErrors = {};
                Object.keys(errors).forEach(function (errorId) {
                    var error = errors[errorId];
                    if (error.exception) {
                        onUnexpectedError(error.exception);
                    }
                    else if (error.error) {
                        onUnexpectedError(error.error);
                    }
                    console.log('WARNING: Promise with no error callback:' + error.id);
                    console.log(error);
                    if (error.exception) {
                        console.log(error.exception.stack);
                    }
                });
            }, 0);
        }
    }
    winjs_base_1.TPromise.addEventListener('error', promiseErrorHandler);
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = /** @class */ (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        // For external errors, we don't want the listeners to be called
        ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
            this.unexpectedErrorHandler(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
        return undefined;
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedExternalError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedExternalError(e);
        }
        return undefined;
    }
    exports.onUnexpectedExternalError = onUnexpectedExternalError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    function illegalArgument(name) {
        if (name) {
            return new Error("Illegal argument: " + name);
        }
        else {
            return new Error('Illegal argument');
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error("Illegal state: " + name);
        }
        else {
            return new Error('Illegal state');
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function disposed(what) {
        var result = new Error(what + " has been disposed");
        result.name = 'DISPOSED';
        return result;
    }
    exports.disposed = disposed;
    function getErrorMessage(err) {
        if (!err) {
            return 'Error';
        }
        if (err.message) {
            return err.message;
        }
        if (err.stack) {
            return err.stack.split('\n')[0];
        }
        return String(err);
    }
    exports.getErrorMessage = getErrorMessage;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[9/*vs/base/common/arrays*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default is zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    function tail2(arr) {
        if (arr.length === 0) {
            throw new Error('Invalid tail call');
        }
        return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
    }
    exports.tail2 = tail2;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one === other) {
            return true;
        }
        if (!one || !other) {
            return false;
        }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirstInSorted(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirstInSorted = findFirstInSorted;
    /**
     * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
     * so only use this when actually needing stable sort.
     */
    function mergeSort(data, compare) {
        _sort(data, compare, 0, data.length - 1, []);
        return data;
    }
    exports.mergeSort = mergeSort;
    function _merge(a, compare, lo, mid, hi, aux) {
        var leftIdx = lo, rightIdx = mid + 1;
        for (var i = lo; i <= hi; i++) {
            aux[i] = a[i];
        }
        for (var i = lo; i <= hi; i++) {
            if (leftIdx > mid) {
                // left side consumed
                a[i] = aux[rightIdx++];
            }
            else if (rightIdx > hi) {
                // right side consumed
                a[i] = aux[leftIdx++];
            }
            else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {
                // right element is less -> comes first
                a[i] = aux[rightIdx++];
            }
            else {
                // left element comes first (less or equal)
                a[i] = aux[leftIdx++];
            }
        }
    }
    function _sort(a, compare, lo, hi, aux) {
        if (hi <= lo) {
            return;
        }
        var mid = lo + ((hi - lo) / 2) | 0;
        _sort(a, compare, lo, mid, aux);
        _sort(a, compare, mid + 1, hi, aux);
        if (compare(a[mid], a[mid + 1]) <= 0) {
            // left and right are sorted and if the last-left element is less
            // or equals than the first-right element there is nothing else
            // to do
            return;
        }
        _merge(a, compare, lo, mid, hi, aux);
    }
    function groupBy(data, compare) {
        var result = [];
        var currentGroup = undefined;
        for (var _i = 0, _a = mergeSort(data.slice(0), compare); _i < _a.length; _i++) {
            var element = _a[_i];
            if (!currentGroup || compare(currentGroup[0], element) !== 0) {
                currentGroup = [element];
                result.push(currentGroup);
            }
            else {
                currentGroup.push(element);
            }
        }
        return result;
    }
    exports.groupBy = groupBy;
    /**
     * Diffs two *sorted* arrays and computes the splices which apply the diff.
     */
    function sortedDiff(before, after, compare) {
        var result = [];
        function pushSplice(start, deleteCount, toInsert) {
            var _a;
            if (deleteCount === 0 && toInsert.length === 0) {
                return;
            }
            var latest = result[result.length - 1];
            if (latest && latest.start + latest.deleteCount === start) {
                latest.deleteCount += deleteCount;
                (_a = latest.toInsert).push.apply(_a, toInsert);
            }
            else {
                result.push({ start: start, deleteCount: deleteCount, toInsert: toInsert });
            }
        }
        var beforeIdx = 0;
        var afterIdx = 0;
        while (true) {
            if (beforeIdx === before.length) {
                pushSplice(beforeIdx, 0, after.slice(afterIdx));
                break;
            }
            if (afterIdx === after.length) {
                pushSplice(beforeIdx, before.length - beforeIdx, []);
                break;
            }
            var beforeElement = before[beforeIdx];
            var afterElement = after[afterIdx];
            var n = compare(beforeElement, afterElement);
            if (n === 0) {
                // equal
                beforeIdx += 1;
                afterIdx += 1;
            }
            else if (n < 0) {
                // beforeElement is smaller -> before element removed
                pushSplice(beforeIdx, 1, []);
                beforeIdx += 1;
            }
            else if (n > 0) {
                // beforeElement is greater -> after element added
                pushSplice(beforeIdx, 0, [afterElement]);
                afterIdx += 1;
            }
        }
        return result;
    }
    exports.sortedDiff = sortedDiff;
    /**
     * Takes two *sorted* arrays and computes their delta (removed, added elements).
     * Finishes in `Math.min(before.length, after.length)` steps.
     * @param before
     * @param after
     * @param compare
     */
    function delta(before, after, compare) {
        var splices = sortedDiff(before, after, compare);
        var removed = [];
        var added = [];
        for (var _i = 0, splices_1 = splices; _i < splices_1.length; _i++) {
            var splice = splices_1[_i];
            removed.push.apply(removed, before.slice(splice.start, splice.start + splice.deleteCount));
            added.push.apply(added, splice.toInsert);
        }
        return { removed: removed, added: added };
    }
    exports.delta = delta;
    /**
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @return The first n elemnts from array when sorted with compare.
     */
    function top(array, compare, n) {
        if (n === 0) {
            return [];
        }
        var result = array.slice(0, n).sort(compare);
        topStep(array, compare, result, n, array.length);
        return result;
    }
    exports.top = top;
    /**
     * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
     *
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @param batch The number of elements to examine before yielding to the event loop.
     * @return The first n elemnts from array when sorted with compare.
     */
    function topAsync(array, compare, n, batch, token) {
        var _this = this;
        if (n === 0) {
            return Promise.resolve([]);
        }
        return new Promise(function (resolve, reject) {
            (function () { return __awaiter(_this, void 0, void 0, function () {
                var o, result, i, m;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            o = array.length;
                            result = array.slice(0, n).sort(compare);
                            i = n, m = Math.min(n + batch, o);
                            _a.label = 1;
                        case 1:
                            if (!(i < o)) return [3 /*break*/, 5];
                            if (!(i > n)) return [3 /*break*/, 3];
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve); })];
                        case 2:
                            _a.sent(); // nextTick() would starve I/O.
                            _a.label = 3;
                        case 3:
                            if (token && token.isCancellationRequested) {
                                throw errors_1.canceled();
                            }
                            topStep(array, compare, result, i, m);
                            _a.label = 4;
                        case 4:
                            i = m, m = Math.min(m + batch, o);
                            return [3 /*break*/, 1];
                        case 5: return [2 /*return*/, result];
                    }
                });
            }); })()
                .then(resolve, reject);
        });
    }
    exports.topAsync = topAsync;
    function topStep(array, compare, result, i, m) {
        var _loop_1 = function (n) {
            var element = array[i];
            if (compare(element, result[n - 1]) < 0) {
                result.pop();
                var j = findFirstInSorted(result, function (e) { return compare(element, e) < 0; });
                result.splice(j, 0, element);
            }
        };
        for (var n = result.length; i < m; i++) {
            _loop_1(n);
        }
    }
    /**
     * @returns a new array with all falsy values removed. The original array IS NOT modified.
     */
    function coalesce(array) {
        if (!array) {
            return array;
        }
        return array.filter(function (e) { return !!e; });
    }
    exports.coalesce = coalesce;
    /**
     * Remove all falsey values from `array`. The original array IS modified.
     */
    function coalesceInPlace(array) {
        if (!array) {
            return;
        }
        var to = 0;
        for (var i = 0; i < array.length; i++) {
            if (!!array[i]) {
                array[to] = array[i];
                to += 1;
            }
        }
        array.length = to;
    }
    exports.coalesceInPlace = coalesceInPlace;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        var _a;
        return (_a = []).concat.apply(_a, arr);
    }
    exports.flatten = flatten;
    function range(arg, to) {
        var from = typeof to === 'number' ? arg : 0;
        if (typeof to === 'number') {
            from = arg;
        }
        else {
            from = 0;
            to = arg;
        }
        var result = [];
        if (from <= to) {
            for (var i = from; i < to; i++) {
                result.push(i);
            }
        }
        else {
            for (var i = from; i > to; i--) {
                result.push(i);
            }
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer, merger) {
        if (merger === void 0) { merger = function (t) { return t; }; }
        return array.reduce(function (r, t) {
            var key = indexer(t);
            r[key] = merger(t, r[key]);
            return r;
        }, Object.create(null));
    }
    exports.index = index;
    /**
     * Inserts an element into an array. Returns a function which, when
     * called, will remove that element from the array.
     */
    function insert(array, element) {
        array.push(element);
        return function () {
            var index = array.indexOf(element);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
    }
    exports.insert = insert;
    /**
     * Insert `insertArr` inside `target` at `insertIndex`.
     * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
     */
    function arrayInsert(target, insertIndex, insertArr) {
        var before = target.slice(0, insertIndex);
        var after = target.slice(insertIndex);
        return before.concat(insertArr, after);
    }
    exports.arrayInsert = arrayInsert;
    /**
     * Uses Fisher-Yates shuffle to shuffle the given array
     * @param array
     */
    function shuffle(array, _seed) {
        var rand;
        if (typeof _seed === 'number') {
            var seed_1 = _seed;
            // Seeded random number generator in JS. Modified from:
            // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
            rand = function () {
                var x = Math.sin(seed_1++) * 179426549; // throw away most significant digits and reduce any potential bias
                return x - Math.floor(x);
            };
        }
        else {
            rand = Math.random;
        }
        for (var i = array.length - 1; i > 0; i -= 1) {
            var j = Math.floor(rand() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    exports.shuffle = shuffle;
    /**
     * Pushes an element to the start of the array, if found.
     */
    function pushToStart(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.unshift(value);
        }
    }
    exports.pushToStart = pushToStart;
    /**
     * Pushes an element to the end of the array, if found.
     */
    function pushToEnd(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.push(value);
        }
    }
    exports.pushToEnd = pushToEnd;
    function find(arr, predicate) {
        for (var i = 0; i < arr.length; i++) {
            var element = arr[i];
            if (predicate(element, i, arr)) {
                return element;
            }
        }
        return undefined;
    }
    exports.find = find;
    function mapArrayOrNot(items, fn) {
        return Array.isArray(items) ?
            items.map(fn) :
            fn(items);
    }
    exports.mapArrayOrNot = mapArrayOrNot;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
















































define(__m[3/*vs/base/common/event*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/errors*/,74/*vs/base/common/functional*/,8/*vs/base/common/lifecycle*/,38/*vs/base/common/linkedList*/,20/*vs/base/common/winjs.base*/]), function (require, exports, errors_1, functional_1, lifecycle_1, linkedList_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event = exports.Event || (exports.Event = {}));
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = /** @class */ (function () {
        function Emitter(_options) {
            if (_options === void 0) { _options = null; }
            this._options = _options;
            this._event = null;
            this._disposed = false;
            this._deliveryQueue = null;
            this._listeners = null;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._listeners) {
                            _this._listeners = new linkedList_1.LinkedList();
                        }
                        var firstListener = _this._listeners.isEmpty();
                        if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                        if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                            _this._options.onFirstListenerDidAdd(_this);
                        }
                        if (_this._options && _this._options.onListenerDidAdd) {
                            _this._options.onListenerDidAdd(_this, listener, thisArgs);
                        }
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    remove();
                                    if (_this._options && _this._options.onLastListenerRemove) {
                                        var hasListeners = (_this._listeners && !_this._listeners.isEmpty());
                                        if (!hasListeners) {
                                            _this._options.onLastListenerRemove(_this);
                                        }
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._listeners) {
                // put all [listener,event]-pairs into delivery queue
                // then emit all event. an inner/nested event might be
                // the driver of this
                if (!this._deliveryQueue) {
                    this._deliveryQueue = [];
                }
                for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                    this._deliveryQueue.push([e.value, event]);
                }
                while (this._deliveryQueue.length > 0) {
                    var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];
                    try {
                        if (typeof listener === 'function') {
                            listener.call(undefined, event_1);
                        }
                        else {
                            listener[0].call(listener[1], event_1);
                        }
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                }
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._listeners) {
                this._listeners = null;
            }
            if (this._deliveryQueue) {
                this._deliveryQueue.length = 0;
            }
            this._disposed = true;
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    var AsyncEmitter = /** @class */ (function (_super) {
        __extends(AsyncEmitter, _super);
        function AsyncEmitter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsyncEmitter.prototype.fireAsync = function (eventFn) {
            return __awaiter(this, void 0, void 0, function () {
                var iter, e, thenables, _a, listener, event_2, thenables;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._listeners) {
                                return [2 /*return*/];
                            }
                            // put all [listener,event]-pairs into delivery queue
                            // then emit all event. an inner/nested event might be
                            // the driver of this
                            if (!this._asyncDeliveryQueue) {
                                this._asyncDeliveryQueue = [];
                            }
                            for (iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                                thenables = [];
                                this._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);
                            }
                            _b.label = 1;
                        case 1:
                            if (!(this._asyncDeliveryQueue.length > 0)) return [3 /*break*/, 3];
                            _a = this._asyncDeliveryQueue.shift(), listener = _a[0], event_2 = _a[1], thenables = _a[2];
                            try {
                                if (typeof listener === 'function') {
                                    listener.call(undefined, event_2);
                                }
                                else {
                                    listener[0].call(listener[1], event_2);
                                }
                            }
                            catch (e) {
                                errors_1.onUnexpectedError(e);
                                return [3 /*break*/, 1];
                            }
                            // freeze thenables-collection to enforce sync-calls to
                            // wait until and then wait for all thenables to resolve
                            Object.freeze(thenables);
                            return [4 /*yield*/, Promise.all(thenables)];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return AsyncEmitter;
    }(Emitter));
    exports.AsyncEmitter = AsyncEmitter;
    var EventMultiplexer = /** @class */ (function () {
        function EventMultiplexer() {
            var _this = this;
            this.hasListeners = false;
            this.events = [];
            this.emitter = new Emitter({
                onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
                onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
            });
        }
        Object.defineProperty(EventMultiplexer.prototype, "event", {
            get: function () {
                return this.emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        EventMultiplexer.prototype.add = function (event) {
            var _this = this;
            var e = { event: event, listener: null };
            this.events.push(e);
            if (this.hasListeners) {
                this.hook(e);
            }
            var dispose = function () {
                if (_this.hasListeners) {
                    _this.unhook(e);
                }
                var idx = _this.events.indexOf(e);
                _this.events.splice(idx, 1);
            };
            return lifecycle_1.toDisposable(functional_1.once(dispose));
        };
        EventMultiplexer.prototype.onFirstListenerAdd = function () {
            var _this = this;
            this.hasListeners = true;
            this.events.forEach(function (e) { return _this.hook(e); });
        };
        EventMultiplexer.prototype.onLastListenerRemove = function () {
            var _this = this;
            this.hasListeners = false;
            this.events.forEach(function (e) { return _this.unhook(e); });
        };
        EventMultiplexer.prototype.hook = function (e) {
            var _this = this;
            e.listener = e.event(function (r) { return _this.emitter.fire(r); });
        };
        EventMultiplexer.prototype.unhook = function (e) {
            if (e.listener) {
                e.listener.dispose();
            }
            e.listener = null;
        };
        EventMultiplexer.prototype.dispose = function () {
            this.emitter.dispose();
        };
        return EventMultiplexer;
    }());
    exports.EventMultiplexer = EventMultiplexer;
    function fromPromise(promise) {
        var emitter = new Emitter();
        var shouldEmit = false;
        promise
            .then(undefined, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(); }, 0);
            }
            else {
                emitter.fire();
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    exports.fromPromise = fromPromise;
    function toPromise(event) {
        return new winjs_base_1.TPromise(function (c) { return once(event)(c); });
    }
    exports.toPromise = toPromise;
    function toNativePromise(event) {
        return new Promise(function (c) { return once(event)(c); });
    }
    exports.toNativePromise = toNativePromise;
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            // we need this, in case the event fires during the listener call
            var didFire = false;
            var result = event(function (e) {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    exports.once = once;
    function anyEvent() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return lifecycle_1.combinedDisposable(events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));
        };
    }
    exports.anyEvent = anyEvent;
    function debounceEvent(event, merger, delay, leading) {
        if (delay === void 0) { delay = 100; }
        if (leading === void 0) { leading = false; }
        var subscription;
        var output = undefined;
        var handle = undefined;
        var numDebouncedCalls = 0;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    numDebouncedCalls++;
                    output = merger(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                    }
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.wrapEvent(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.bufferEvents(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = /** @class */ (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            var r = fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
            return r;
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function forEach(event, each) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);
        };
    }
    exports.forEach = forEach;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    function signalEvent(event) {
        return event;
    }
    exports.signalEvent = signalEvent;
    var ChainableEvent = /** @class */ (function () {
        function ChainableEvent(_event) {
            this._event = _event;
        }
        Object.defineProperty(ChainableEvent.prototype, "event", {
            get: function () { return this._event; },
            enumerable: true,
            configurable: true
        });
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(mapEvent(this._event, fn));
        };
        ChainableEvent.prototype.forEach = function (fn) {
            return new ChainableEvent(forEach(this._event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filterEvent(this._event, fn));
        };
        ChainableEvent.prototype.latch = function () {
            return new ChainableEvent(latch(this._event));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this._event(listener, thisArgs, disposables);
        };
        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {
            return once(this._event)(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    exports.chain = chain;
    function stopwatch(event) {
        var start = new Date().getTime();
        return mapEvent(once(event), function (_) { return new Date().getTime() - start; });
    }
    exports.stopwatch = stopwatch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, _buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (_buffer === void 0) { _buffer = []; }
        var buffer = _buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            if (buffer) {
                buffer.forEach(function (e) { return emitter.fire(e); });
            }
            buffer = null;
        };
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            }
        });
        return emitter.event;
    }
    exports.buffer = buffer;
    /**
     * Similar to `buffer` but it buffers indefinitely and repeats
     * the buffered events to every new listener.
     */
    function echo(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        event(function (e) {
            buffer.push(e);
            emitter.fire(e);
        });
        var flush = function (listener, thisArgs) { return buffer.forEach(function (e) { return listener.call(thisArgs, e); }); };
        var emitter = new Emitter({
            onListenerDidAdd: function (emitter, listener, thisArgs) {
                if (nextTick) {
                    setTimeout(function () { return flush(listener, thisArgs); });
                }
                else {
                    flush(listener, thisArgs);
                }
            }
        });
        return emitter.event;
    }
    exports.echo = echo;
    var Relay = /** @class */ (function () {
        function Relay() {
            var _this = this;
            this.listening = false;
            this.inputEvent = Event.None;
            this.inputEventListener = lifecycle_1.Disposable.None;
            this.emitter = new Emitter({
                onFirstListenerDidAdd: function () {
                    _this.listening = true;
                    _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);
                },
                onLastListenerRemove: function () {
                    _this.listening = false;
                    _this.inputEventListener.dispose();
                }
            });
            this.event = this.emitter.event;
        }
        Object.defineProperty(Relay.prototype, "input", {
            set: function (event) {
                this.inputEvent = event;
                if (this.listening) {
                    this.inputEventListener.dispose();
                    this.inputEventListener = event(this.emitter.fire, this.emitter);
                }
            },
            enumerable: true,
            configurable: true
        });
        Relay.prototype.dispose = function () {
            this.inputEventListener.dispose();
            this.emitter.dispose();
        };
        return Relay;
    }());
    exports.Relay = Relay;
    function fromNodeEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };
        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    exports.fromNodeEventEmitter = fromNodeEventEmitter;
    function latch(event) {
        var firstCall = true;
        var cache;
        return filterEvent(event, function (value) {
            var shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    exports.latch = latch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[17/*vs/base/common/cancellation*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/]), function (require, exports, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var CancellationToken;
    (function (CancellationToken) {
        function isCancellationToken(thing) {
            if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
                return true;
            }
            if (thing instanceof MutableToken) {
                return true;
            }
            if (!thing || typeof thing !== 'object') {
                return false;
            }
            return typeof thing.isCancellationRequested === 'boolean'
                && typeof thing.onCancellationRequested === 'function';
        }
        CancellationToken.isCancellationToken = isCancellationToken;
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.Event.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: shortcutEvent
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var MutableToken = /** @class */ (function () {
        function MutableToken() {
            this._isCancelled = false;
            this._emitter = null;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this.dispose();
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        MutableToken.prototype.dispose = function () {
            if (this._emitter) {
                this._emitter.dispose();
                this._emitter = null;
            }
        };
        return MutableToken;
    }());
    var CancellationTokenSource = /** @class */ (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else if (this._token instanceof MutableToken) {
                // actually cancel
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            if (!this._token) {
                // ensure to initialize with an empty token if we had none
                this._token = CancellationToken.None;
            }
            else if (this._token instanceof MutableToken) {
                // actually dispose
                this._token.dispose();
            }
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[11/*vs/base/common/async*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,20/*vs/base/common/winjs.base*/]), function (require, exports, cancellation_1, errors, event_1, lifecycle_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    exports.isThenable = isThenable;
    function createCancelablePromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        var thenable = callback(source.token);
        var promise = new Promise(function (resolve, reject) {
            source.token.onCancellationRequested(function () {
                reject(errors.canceled());
            });
            Promise.resolve(thenable).then(function (value) {
                source.dispose();
                resolve(value);
            }, function (err) {
                source.dispose();
                reject(err);
            });
        });
        return new /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.cancel = function () {
                source.cancel();
            };
            class_1.prototype.then = function (resolve, reject) {
                return promise.then(resolve, reject);
            };
            class_1.prototype.catch = function (reject) {
                return this.then(undefined, reject);
            };
            return class_1;
        }());
    }
    exports.createCancelablePromise = createCancelablePromise;
    function asThenable(callback) {
        return new Promise(function (resolve, reject) {
            var item = callback();
            if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        });
    }
    exports.asThenable = asThenable;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = /** @class */ (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.TPromise(function (c) {
                        _this.activePromise.then(onComplete_1, onComplete_1).then(c);
                    });
                }
                return new winjs_base_1.TPromise(function (c, e) {
                    _this.queuedPromise.then(c, e);
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.TPromise(function (c, e) {
                _this.activePromise.then(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                });
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = /** @class */ (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.wrap(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = /** @class */ (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.doResolve = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.TPromise(function (c, e) {
                    _this.doResolve = c;
                    _this.doReject = e;
                }).then(function () {
                    _this.completionPromise = null;
                    _this.doResolve = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.doResolve(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.doReject(errors.canceled());
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        Delayer.prototype.dispose = function () {
            this.cancelTimeout();
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * The mail man is clever and waits for a certain amount of time, before going
     * out to deliver letters. While the mail man is going out, more letters arrive
     * and can only be delivered once he is back. Once he is back the mail man will
     * do one more trip to deliver the letters that have accumulated while he was out.
     */
    var ThrottledDelayer = /** @class */ (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            var _this = _super.call(this, defaultDelay) || this;
            _this.throttler = new Throttler();
            return _this;
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * A barrier that is initially closed and then becomes opened permanently.
     */
    var Barrier = /** @class */ (function () {
        function Barrier() {
            var _this = this;
            this._isOpen = false;
            this._promise = new winjs_base_1.TPromise(function (c, e) {
                _this._completePromise = c;
            });
        }
        Barrier.prototype.isOpen = function () {
            return this._isOpen;
        };
        Barrier.prototype.open = function () {
            this._isOpen = true;
            this._completePromise(true);
        };
        Barrier.prototype.wait = function () {
            return this._promise;
        };
        return Barrier;
    }());
    exports.Barrier = Barrier;
    function timeout(millis, token) {
        if (!token) {
            return createCancelablePromise(function (token) { return timeout(millis, token); });
        }
        return new Promise(function (resolve, reject) {
            var handle = setTimeout(resolve, millis);
            token.onCancellationRequested(function () {
                clearTimeout(handle);
                reject(errors.canceled());
            });
        });
    }
    exports.timeout = timeout;
    function disposableTimeout(handler, timeout) {
        if (timeout === void 0) { timeout = 0; }
        var timer = setTimeout(handler, timeout);
        return {
            dispose: function () {
                clearTimeout(timer);
            }
        };
    }
    exports.disposableTimeout = disposableTimeout;
    /**
     * Returns a new promise that joins the provided promise. Upon completion of
     * the provided promise the provided function will always be called. This
     * method is comparable to a try-finally code block.
     * @param promise a promise
     * @param callback a function that will be call in the success and error case.
     */
    function always(promise, callback) {
        function safeCallback() {
            try {
                callback();
            }
            catch (err) {
                errors.onUnexpectedError(err);
            }
        }
        promise.then(function (_) { return safeCallback(); }, function (_) { return safeCallback(); });
        return Promise.resolve(promise);
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactories) {
        var results = [];
        var index = 0;
        var len = promiseFactories.length;
        function next() {
            return index < len ? promiseFactories[index++]() : null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return Promise.resolve(results);
        }
        return Promise.resolve(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function first(promiseFactories, shouldStop, defaultValue) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        if (defaultValue === void 0) { defaultValue = null; }
        var index = 0;
        var len = promiseFactories.length;
        var loop = function () {
            if (index >= len) {
                return Promise.resolve(defaultValue);
            }
            var factory = promiseFactories[index++];
            var promise = Promise.resolve(factory());
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return Promise.resolve(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first = first;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = /** @class */ (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
            this._onFinished = new event_1.Emitter();
        }
        Object.defineProperty(Limiter.prototype, "onFinished", {
            get: function () {
                return this._onFinished.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Limiter.prototype, "size", {
            get: function () {
                return this.runningPromises + this.outstandingPromises.length;
            },
            enumerable: true,
            configurable: true
        });
        Limiter.prototype.queue = function (factory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                _this.outstandingPromises.push({ factory: factory, c: c, e: e });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.then(iLimitedTask.c, iLimitedTask.e);
                promise.then(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            if (this.outstandingPromises.length > 0) {
                this.consume();
            }
            else {
                this._onFinished.fire();
            }
        };
        Limiter.prototype.dispose = function () {
            this._onFinished.dispose();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    var Queue = /** @class */ (function (_super) {
        __extends(Queue, _super);
        function Queue() {
            return _super.call(this, 1) || this;
        }
        return Queue;
    }(Limiter));
    exports.Queue = Queue;
    /**
     * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
     * by disposing them once the queue is empty.
     */
    var ResourceQueue = /** @class */ (function () {
        function ResourceQueue() {
            this.queues = Object.create(null);
        }
        ResourceQueue.prototype.queueFor = function (resource) {
            var _this = this;
            var key = resource.toString();
            if (!this.queues[key]) {
                var queue_1 = new Queue();
                queue_1.onFinished(function () {
                    queue_1.dispose();
                    delete _this.queues[key];
                });
                this.queues[key] = queue_1;
            }
            return this.queues[key];
        };
        return ResourceQueue;
    }());
    exports.ResourceQueue = ResourceQueue;
    var TimeoutTimer = /** @class */ (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer(runner, timeout) {
            var _this = _super.call(this) || this;
            _this._token = -1;
            if (typeof runner === 'function' && typeof timeout === 'number') {
                _this.setIfNotSet(runner, timeout);
            }
            return _this;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = /** @class */ (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = /** @class */ (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.doRun();
            }
        };
        RunOnceScheduler.prototype.doRun = function () {
            if (this.runner) {
                this.runner();
            }
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    var RunOnceWorker = /** @class */ (function (_super) {
        __extends(RunOnceWorker, _super);
        function RunOnceWorker(runner, timeout) {
            var _this = _super.call(this, runner, timeout) || this;
            _this.units = [];
            return _this;
        }
        RunOnceWorker.prototype.work = function (unit) {
            this.units.push(unit);
            if (!this.isScheduled()) {
                this.schedule();
            }
        };
        RunOnceWorker.prototype.doRun = function () {
            var units = this.units;
            this.units = [];
            if (this.runner) {
                this.runner(units);
            }
        };
        RunOnceWorker.prototype.dispose = function () {
            this.units = [];
            _super.prototype.dispose.call(this);
        };
        return RunOnceWorker;
    }(RunOnceScheduler));
    exports.RunOnceWorker = RunOnceWorker;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.ninvoke = ninvoke;
    (function () {
        if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
            var dummyIdle_1 = Object.freeze({
                didTimeout: true,
                timeRemaining: function () { return 15; }
            });
            exports.runWhenIdle = function (runner, timeout) {
                if (timeout === void 0) { timeout = 0; }
                var handle = setTimeout(function () { return runner(dummyIdle_1); }, timeout);
                var disposed = false;
                return {
                    dispose: function () {
                        if (disposed) {
                            return;
                        }
                        disposed = true;
                        clearTimeout(handle);
                    }
                };
            };
        }
        else {
            exports.runWhenIdle = function (runner, timeout) {
                var handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout: timeout } : undefined);
                var disposed = false;
                return {
                    dispose: function () {
                        if (disposed) {
                            return;
                        }
                        disposed = true;
                        cancelIdleCallback(handle);
                    }
                };
            };
        }
    })();
    /**
     * An implementation of the "idle-until-urgent"-strategy as introduced
     * here: https://philipwalton.com/articles/idle-until-urgent/
     */
    var IdleValue = /** @class */ (function () {
        function IdleValue(executor) {
            var _this = this;
            this._executor = function () {
                try {
                    _this._value = executor();
                }
                catch (err) {
                    _this._error = err;
                }
                finally {
                    _this._didRun = true;
                }
            };
            this._handle = exports.runWhenIdle(function () { return _this._executor(); });
        }
        IdleValue.prototype.dispose = function () {
            this._handle.dispose();
        };
        IdleValue.prototype.getValue = function () {
            if (!this._didRun) {
                this._handle.dispose();
                this._executor();
            }
            if (this._error) {
                throw this._error;
            }
            return this._value;
        };
        return IdleValue;
    }());
    exports.IdleValue = IdleValue;
});
//#endregion

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[23/*vs/base/common/glob*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/arrays*/,5/*vs/base/common/strings*/,12/*vs/base/common/paths*/,22/*vs/base/common/map*/,20/*vs/base/common/winjs.base*/,11/*vs/base/common/async*/]), function (require, exports, arrays, strings, paths, map_1, winjs_base_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getEmptyExpression() {
        return Object.create(null);
    }
    exports.getEmptyExpression = getEmptyExpression;
    var GLOBSTAR = '**';
    var GLOB_SPLIT = '/';
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    var ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, GLOB_SPLIT);
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === GLOBSTAR; })) {
            regEx = '.*';
        }
        // Build regex over segments
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === GLOBSTAR) {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                        var res = void 0;
                        // range operator
                        if (char === '-') {
                            res = char;
                        }
                        // negation operator (only valid on first index in bracket)
                        else if ((char === '^' || char === '!') && !bracketVal) {
                            res = '^';
                        }
                        // glob split matching is not allowed within character ranges
                        // see http://man7.org/linux/man-pages/man7/glob.7.html
                        else if (char === GLOB_SPLIT) {
                            res = '';
                        }
                        // anything else gets escaped
                        else {
                            res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar
                // For example if pattern: some/**/*.js we want the "/" after some to be included in the RegEx to prevent
                // a folder called "something" to match as well.
                // However, if pattern: some/**, we tolerate that we also match on "something" because our globstar behaviour
                // is to match 0-N segments.
                if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    var CACHE = new map_1.LRUCache(10000); // bounded to 10000 elements
    var FALSE = function () {
        return false;
    };
    var NULL = function () {
        return null;
    };
    function parsePattern(arg1, options) {
        if (!arg1) {
            return NULL;
        }
        // Handle IRelativePattern
        var pattern;
        if (typeof arg1 !== 'string') {
            pattern = arg1.pattern;
        }
        else {
            pattern = arg1;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var patternKey = pattern + "_" + !!options.trimForExclusions;
        var parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return wrapRelativePattern(parsedPattern, arg1);
        }
        // Check for Trivias
        var match;
        if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check
            var base_1 = pattern.substr(4); // '**/*'.length === 4
            parsedPattern = function (path, basename) {
                return path && strings.endsWith(path, base_1) ? pattern : null;
            };
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        // Otherwise convert to pattern
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return wrapRelativePattern(parsedPattern, arg1);
    }
    function wrapRelativePattern(parsedPattern, arg2) {
        if (typeof arg2 === 'string') {
            return parsedPattern;
        }
        return function (path, basename) {
            if (!paths.isEqualOrParent(path, arg2.base)) {
                return null;
            }
            return parsedPattern(arg2.pathToRelative(arg2.base, path), basename);
        };
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, originalPattern) {
        var slashBase = "/" + base;
        var backslashBase = "\\" + base;
        var parsedPattern = function (path, basename) {
            if (!path) {
                return null;
            }
            if (basename) {
                return basename === base ? originalPattern : null;
            }
            return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
        };
        var basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [originalPattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
            .map(function (pattern) { return parsePattern(pattern, options); })
            .filter(function (pattern) { return pattern !== NULL; }), pattern);
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (n === 1) {
            return parsedPatterns[0];
        }
        var parsedPattern = function (path, basename) {
            for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(path, pattern, matchPathEnds) {
        var nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
        var nativePathEnd = paths.nativeSep + nativePath;
        var parsedPattern = matchPathEnds ? function (path, basename) {
            return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        } : function (path, basename) {
            return path && path === nativePath ? pattern : null;
        };
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
            return function (path, basename) {
                regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return path && regExp_1.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function match(arg1, path, hasSibling) {
        if (!arg1 || !path) {
            return false;
        }
        return parse(arg1)(path, undefined, hasSibling);
    }
    exports.match = match;
    function parse(arg1, options) {
        if (options === void 0) { options = {}; }
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
            var parsedPattern_1 = parsePattern(arg1, options);
            if (parsedPattern_1 === NULL) {
                return FALSE;
            }
            var resultPattern = function (path, basename) {
                return !!parsedPattern_1(path, basename);
            };
            if (parsedPattern_1.allBasenames) {
                resultPattern.allBasenames = parsedPattern_1.allBasenames;
            }
            if (parsedPattern_1.allPaths) {
                resultPattern.allPaths = parsedPattern_1.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    exports.parse = parse;
    function hasSiblingPromiseFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                siblings = (siblingsFn() || winjs_base_1.TPromise.as([]))
                    .then(function (list) { return list ? listToMap(list) : {}; });
            }
            return siblings.then(function (map) { return !!map[name]; });
        };
    }
    exports.hasSiblingPromiseFn = hasSiblingPromiseFn;
    function hasSiblingFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                var list = siblingsFn();
                siblings = list ? listToMap(list) : {};
            }
            return !!siblings[name];
        };
    }
    exports.hasSiblingFn = hasSiblingFn;
    function listToMap(list) {
        var map = {};
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var key = list_1[_i];
            map[key] = true;
        }
        return map;
    }
    function isRelativePattern(obj) {
        var rp = obj;
        return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string' && typeof rp.pathToRelative === 'function';
    }
    exports.isRelativePattern = isRelativePattern;
    /**
     * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise
     */
    function parseToAsync(expression, options) {
        var parsedExpression = parse(expression, options);
        return function (path, basename, hasSibling) {
            var result = parsedExpression(path, basename, hasSibling);
            return result instanceof winjs_base_1.TPromise ? result : winjs_base_1.TPromise.as(result);
        };
    }
    exports.parseToAsync = parseToAsync;
    function getBasenameTerms(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    exports.getBasenameTerms = getBasenameTerms;
    function getPathTerms(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    exports.getPathTerms = getPathTerms;
    function parsedExpression(expression, options) {
        var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
            .filter(function (pattern) { return pattern !== NULL; }));
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (!parsedPatterns.some(function (parsedPattern) { return !!parsedPattern.requiresSiblings; })) {
            if (n === 1) {
                return parsedPatterns[0];
            }
            var resultExpression_1 = function (path, basename) {
                for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                    // Pattern matches path
                    var result = parsedPatterns[i](path, basename);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
            if (withBasenames_1) {
                resultExpression_1.allBasenames = withBasenames_1.allBasenames;
            }
            var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
            if (allPaths_1.length) {
                resultExpression_1.allPaths = allPaths_1;
            }
            return resultExpression_1;
        }
        var resultExpression = function (path, basename, hasSibling) {
            var name = undefined;
            for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
                // Pattern matches path
                var parsedPattern = parsedPatterns[i];
                if (parsedPattern.requiresSiblings && hasSibling) {
                    if (!basename) {
                        basename = paths.basename(path);
                    }
                    if (!name) {
                        name = basename.substr(0, basename.length - paths.extname(path).length);
                    }
                }
                var result = parsedPattern(path, basename, name, hasSibling);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        var parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            var when_1 = value.when;
            if (typeof when_1 === 'string') {
                var result = function (path, basename, name, hasSibling) {
                    if (!hasSibling || !parsedPattern(path, basename)) {
                        return null;
                    }
                    var clausePattern = when_1.replace('$(basename)', name);
                    var matched = hasSibling(clausePattern);
                    return async_1.isThenable(matched) ?
                        matched.then(function (m) { return m ? pattern : null; }) :
                        matched ? pattern : null;
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is Anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        var basenames = basenamePatterns.reduce(function (all, current) {
            var basenames = current.basenames;
            return basenames ? all.concat(basenames) : all;
        }, []);
        var patterns;
        if (result) {
            patterns = [];
            for (var i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce(function (all, current) {
                var patterns = current.patterns;
                return patterns ? all.concat(patterns) : all;
            }, []);
        }
        var aggregate = function (path, basename) {
            if (!path) {
                return null;
            }
            if (!basename) {
                var i = void 0;
                for (i = path.length; i > 0; i--) {
                    var ch = path.charCodeAt(i - 1);
                    if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            var index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[60/*vs/base/common/htmlContent*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/arrays*/]), function (require, exports, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MarkdownString = /** @class */ (function () {
        function MarkdownString(value) {
            if (value === void 0) { value = ''; }
            this.value = value;
        }
        MarkdownString.prototype.appendText = function (value) {
            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
            this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
            return this;
        };
        MarkdownString.prototype.appendMarkdown = function (value) {
            this.value += value;
            return this;
        };
        MarkdownString.prototype.appendCodeblock = function (langId, code) {
            this.value += '\n```';
            this.value += langId;
            this.value += '\n';
            this.value += code;
            this.value += '\n```\n';
            return this;
        };
        return MarkdownString;
    }());
    exports.MarkdownString = MarkdownString;
    function isEmptyMarkdownString(oneOrMany) {
        if (isMarkdownString(oneOrMany)) {
            return !oneOrMany.value;
        }
        else if (Array.isArray(oneOrMany)) {
            return oneOrMany.every(isEmptyMarkdownString);
        }
        else {
            return true;
        }
    }
    exports.isEmptyMarkdownString = isEmptyMarkdownString;
    function isMarkdownString(thing) {
        if (thing instanceof MarkdownString) {
            return true;
        }
        else if (thing && typeof thing === 'object') {
            return typeof thing.value === 'string'
                && (typeof thing.isTrusted === 'boolean' || thing.isTrusted === void 0);
        }
        return false;
    }
    exports.isMarkdownString = isMarkdownString;
    function markedStringsEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else if (Array.isArray(a) && Array.isArray(b)) {
            return arrays_1.equals(a, b, markdownStringEqual);
        }
        else if (isMarkdownString(a) && isMarkdownString(b)) {
            return markdownStringEqual(a, b);
        }
        else {
            return false;
        }
    }
    exports.markedStringsEquals = markedStringsEquals;
    function markdownStringEqual(a, b) {
        if (a === b) {
            return true;
        }
        else if (!a || !b) {
            return false;
        }
        else {
            return a.value === b.value && a.isTrusted === b.isTrusted;
        }
    }
    function removeMarkdownEscapes(text) {
        if (!text) {
            return text;
        }
        return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
    }
    exports.removeMarkdownEscapes = removeMarkdownEscapes;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[94/*vs/base/node/console*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isRemoteConsoleLog(obj) {
        var entry = obj;
        return entry && typeof entry.type === 'string' && typeof entry.severity === 'string';
    }
    exports.isRemoteConsoleLog = isRemoteConsoleLog;
    function parse(entry) {
        var args = [];
        var stack;
        // Parse Entry
        try {
            var parsedArguments = JSON.parse(entry.arguments);
            // Check for special stack entry as last entry
            var stackArgument = parsedArguments[parsedArguments.length - 1];
            if (stackArgument && stackArgument.__$stack) {
                parsedArguments.pop(); // stack is handled specially
                stack = stackArgument.__$stack;
            }
            args.push.apply(args, parsedArguments);
        }
        catch (error) {
            args.push('Unable to log remote console arguments', entry.arguments);
        }
        return { args: args, stack: stack };
    }
    exports.parse = parse;
    function getFirstFrame(arg0) {
        if (typeof arg0 !== 'string') {
            return getFirstFrame(parse(arg0).stack);
        }
        // Parse a source information out of the stack if we have one. Format can be:
        // at vscode.commands.registerCommand (/Users/someone/Desktop/test-ts/out/src/extension.js:18:17)
        // or
        // at /Users/someone/Desktop/test-ts/out/src/extension.js:18:17
        // or
        // at c:\Users\someone\Desktop\end-js\extension.js:19:17
        // or
        // at e.$executeContributedCommand(c:\Users\someone\Desktop\end-js\extension.js:19:17)
        var stack = arg0;
        if (stack) {
            var topFrame = findFirstFrame(stack);
            // at [^\/]* => line starts with "at" followed by any character except '/' (to not capture unix paths too late)
            // (?:(?:[a-zA-Z]+:)|(?:[\/])|(?:\\\\) => windows drive letter OR unix root OR unc root
            // (?:.+) => simple pattern for the path, only works because of the line/col pattern after
            // :(?:\d+):(?:\d+) => :line:column data
            var matches = /at [^\/]*((?:(?:[a-zA-Z]+:)|(?:[\/])|(?:\\\\))(?:.+)):(\d+):(\d+)/.exec(topFrame || '');
            if (matches && matches.length === 4) {
                return {
                    uri: uri_1.URI.file(matches[1]),
                    line: Number(matches[2]),
                    column: Number(matches[3])
                };
            }
        }
        return void 0;
    }
    exports.getFirstFrame = getFirstFrame;
    function findFirstFrame(stack) {
        if (!stack) {
            return stack;
        }
        var newlineIndex = stack.indexOf('\n');
        if (newlineIndex === -1) {
            return stack;
        }
        return stack.substring(0, newlineIndex);
    }
    function log(entry, label) {
        var _a = parse(entry), args = _a.args, stack = _a.stack;
        var isOneStringArg = typeof args[0] === 'string' && args.length === 1;
        var topFrame = findFirstFrame(stack);
        if (topFrame) {
            topFrame = "(" + topFrame.trim() + ")";
        }
        var consoleArgs = [];
        // First arg is a string
        if (typeof args[0] === 'string') {
            if (topFrame && isOneStringArg) {
                consoleArgs = ["%c[" + label + "] %c" + args[0] + " %c" + topFrame, color('blue'), color('black'), color('grey')];
            }
            else {
                consoleArgs = ["%c[" + label + "] %c" + args[0], color('blue'), color('black')].concat(args.slice(1));
            }
        }
        // First arg is something else, just apply all
        else {
            consoleArgs = ["%c[" + label + "]%", color('blue')].concat(args);
        }
        // Stack: add to args unless already aded
        if (topFrame && !isOneStringArg) {
            consoleArgs.push(topFrame);
        }
        // Log it
        console[entry.severity].apply(console, consoleArgs);
    }
    exports.log = log;
    function color(color) {
        return "color: " + color;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[144/*vs/base/node/decoder*/], __M([1/*require*/,0/*exports*/,57/*string_decoder*/]), function (require, exports, sd) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Convenient way to iterate over output line by line. This helper accommodates for the fact that
     * a buffer might not end with new lines all the way.
     *
     * To use:
     * - call the write method
     * - forEach() over the result to get the lines
     */
    var LineDecoder = /** @class */ (function () {
        function LineDecoder(encoding) {
            if (encoding === void 0) { encoding = 'utf8'; }
            this.stringDecoder = new sd.StringDecoder(encoding);
            this.remaining = null;
        }
        LineDecoder.prototype.write = function (buffer) {
            var result = [];
            var value = this.remaining
                ? this.remaining + this.stringDecoder.write(buffer)
                : this.stringDecoder.write(buffer);
            if (value.length < 1) {
                return result;
            }
            var start = 0;
            var ch;
            var idx = start;
            while (idx < value.length) {
                ch = value.charCodeAt(idx);
                if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
                    result.push(value.substring(start, idx));
                    idx++;
                    if (idx < value.length) {
                        var lastChar = ch;
                        ch = value.charCodeAt(idx);
                        if ((lastChar === 13 /* CarriageReturn */ && ch === 10 /* LineFeed */) || (lastChar === 10 /* LineFeed */ && ch === 13 /* CarriageReturn */)) {
                            idx++;
                        }
                    }
                    start = idx;
                }
                else {
                    idx++;
                }
            }
            this.remaining = start < value.length ? value.substr(start) : null;
            return result;
        };
        LineDecoder.prototype.end = function () {
            return this.remaining;
        };
        return LineDecoder;
    }());
    exports.LineDecoder = LineDecoder;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[56/*vs/base/node/flow*/], __M([1/*require*/,0/*exports*/,118/*assert*/]), function (require, exports, assert) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as
     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.
     */
    function parallel(list, fn, callback) {
        var results = new Array(list.length);
        var errors = new Array(list.length);
        var didErrorOccur = false;
        var doneCount = 0;
        if (list.length === 0) {
            return callback(null, []);
        }
        list.forEach(function (item, index) {
            fn(item, function (error, result) {
                if (error) {
                    didErrorOccur = true;
                    results[index] = null;
                    errors[index] = error;
                }
                else {
                    results[index] = result;
                    errors[index] = null;
                }
                if (++doneCount === list.length) {
                    return callback(didErrorOccur ? errors : null, results);
                }
            });
        });
    }
    exports.parallel = parallel;
    function loop(param, fn, callback) {
        // Assert
        assert.ok(param, 'Missing first parameter');
        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');
        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');
        // Param is function, execute to retrieve array
        if (typeof (param) === 'function') {
            try {
                param(function (error, result) {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        loop(result, fn, callback);
                    }
                });
            }
            catch (error) {
                callback(error, null);
            }
        }
        // Expect the param to be an array and loop over it
        else {
            var results_1 = [];
            var looper_1 = function (i) {
                // Still work to do
                if (i < param.length) {
                    // Execute function on array element
                    try {
                        fn(param[i], function (error, result) {
                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                            if (error === true || error === false) {
                                result = error;
                                error = null;
                            }
                            // Quit looping on error
                            if (error) {
                                callback(error, null);
                            }
                            // Otherwise push result on stack and continue looping
                            else {
                                if (result) { //Could be that provided function is not returning a result
                                    results_1.push(result);
                                }
                                process.nextTick(function () {
                                    looper_1(i + 1);
                                });
                            }
                        }, i, param.length);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                }
                // Done looping, pass back results too callback function
                else {
                    callback(null, results_1);
                }
            };
            // Start looping with first element in array
            looper_1(0);
        }
    }
    exports.loop = loop;
    function Sequence(sequences) {
        // Assert
        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');
        sequences.forEach(function (sequence) {
            assert.ok(typeof (sequence) === 'function');
        });
        // Execute in Loop
        var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler
        var sequenceResult = null;
        loop(sequences, function (sequence, clb) {
            var sequenceFunction = function (error, result) {
                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                if (error === true || error === false) {
                    result = error;
                    error = null;
                }
                // Handle Error and Result
                if (error) {
                    clb(error, null);
                }
                else {
                    sequenceResult = result; //Remember result of sequence
                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it
                }
            };
            // We call the sequence function setting "this" to be the callback we define here
            // and we pass in the "sequenceResult" as first argument. Doing all this avoids having
            // to pass in a callback to the sequence because the callback is already "this".
            try {
                sequence.call(sequenceFunction, sequenceResult);
            }
            catch (error) {
                clb(error, null);
            }
        }, function (error, result) {
            if (error) {
                errorHandler(error);
            }
        });
    }
    function sequence(sequences) {
        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));
    }
    exports.sequence = sequence;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[104/*vs/base/node/stream*/], __M([1/*require*/,0/*exports*/,27/*fs*/]), function (require, exports, fs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Reads totalBytes from the provided file.
     */
    function readExactlyByFile(file, totalBytes) {
        return new Promise(function (resolve, reject) {
            fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return reject(err);
                }
                function end(err, resultBuffer, bytesRead) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return reject(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return reject(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return resolve({ buffer: resultBuffer, bytesRead: bytesRead });
                    });
                }
                var buffer = Buffer.allocUnsafe(totalBytes);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, totalBytes - offset, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null, 0);
                        }
                        if (bytesRead === 0) {
                            return end(null, buffer, offset);
                        }
                        offset += bytesRead;
                        if (offset === totalBytes) {
                            return end(null, buffer, offset);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readExactlyByFile = readExactlyByFile;
    /**
     * Reads a file until a matching string is found.
     *
     * @param file The file to read.
     * @param matchingString The string to search for.
     * @param chunkBytes The number of bytes to read each iteration.
     * @param maximumBytesToRead The maximum number of bytes to read before giving up.
     * @param callback The finished callback.
     */
    function readToMatchingString(file, matchingString, chunkBytes, maximumBytesToRead) {
        return new Promise(function (resolve, reject) {
            return fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return reject(err);
                }
                function end(err, result) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return reject(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return reject(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return resolve(result);
                    });
                }
                var buffer = Buffer.allocUnsafe(maximumBytesToRead);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, chunkBytes, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null);
                        }
                        if (bytesRead === 0) {
                            return end(null, null);
                        }
                        offset += bytesRead;
                        var newLineIndex = buffer.indexOf(matchingString);
                        if (newLineIndex >= 0) {
                            return end(null, buffer.toString('utf8').substr(0, newLineIndex));
                        }
                        if (offset >= maximumBytesToRead) {
                            return end(new Error("Could not find " + matchingString + " in first " + maximumBytesToRead + " bytes of " + file), null);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readToMatchingString = readToMatchingString;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[69/*vs/base/node/encoding*/], __M([1/*require*/,0/*exports*/,104/*vs/base/node/stream*/,200/*iconv-lite*/,6/*vs/base/common/platform*/,25/*child_process*/,203/*stream*/]), function (require, exports, stream, iconv, platform_1, child_process_1, stream_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UTF8 = 'utf8';
    exports.UTF8_with_bom = 'utf8bom';
    exports.UTF16be = 'utf16be';
    exports.UTF16le = 'utf16le';
    function toDecodeStream(readable, options) {
        if (!options.minBytesRequiredForDetection) {
            options.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;
        }
        if (!options.overwriteEncoding) {
            options.overwriteEncoding = function (detected) { return detected || exports.UTF8; };
        }
        return new Promise(function (resolve, reject) {
            readable.on('error', reject);
            readable.pipe(new /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1(opts) {
                    var _this = _super.call(this, opts) || this;
                    _this._buffer = [];
                    _this._bytesBuffered = 0;
                    _this.once('finish', function () { return _this._finish(); });
                    return _this;
                }
                class_1.prototype._write = function (chunk, encoding, callback) {
                    if (!Buffer.isBuffer(chunk)) {
                        callback(new Error('data must be a buffer'));
                    }
                    if (this._decodeStream) {
                        // just a forwarder now
                        this._decodeStream.write(chunk, callback);
                        return;
                    }
                    this._buffer.push(chunk);
                    this._bytesBuffered += chunk.length;
                    if (this._decodeStreamConstruction) {
                        // waiting for the decoder to be ready
                        this._decodeStreamConstruction.then(function (_) { return callback(); }, function (err) { return callback(err); });
                    }
                    else if (typeof options.minBytesRequiredForDetection === 'number' && this._bytesBuffered >= options.minBytesRequiredForDetection) {
                        // buffered enough data, create stream and forward data
                        this._startDecodeStream(callback);
                    }
                    else {
                        // only buffering
                        callback();
                    }
                };
                class_1.prototype._startDecodeStream = function (callback) {
                    var _this = this;
                    this._decodeStreamConstruction = Promise.resolve(detectEncodingFromBuffer({
                        buffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered
                    }, options.guessEncoding)).then(function (detected) {
                        detected.encoding = options.overwriteEncoding(detected.encoding);
                        _this._decodeStream = decodeStream(detected.encoding);
                        for (var _i = 0, _a = _this._buffer; _i < _a.length; _i++) {
                            var buffer = _a[_i];
                            _this._decodeStream.write(buffer);
                        }
                        callback();
                        resolve({ detected: detected, stream: _this._decodeStream });
                    }, function (err) {
                        _this.emit('error', err);
                        callback(err);
                    });
                };
                class_1.prototype._finish = function () {
                    var _this = this;
                    if (this._decodeStream) {
                        // normal finish
                        this._decodeStream.end();
                    }
                    else {
                        // we were still waiting for data...
                        this._startDecodeStream(function () { return _this._decodeStream.end(); });
                    }
                };
                return class_1;
            }(stream_1.Writable)));
        });
    }
    exports.toDecodeStream = toDecodeStream;
    function bomLength(encoding) {
        switch (encoding) {
            case exports.UTF8:
                return 3;
            case exports.UTF16be:
            case exports.UTF16le:
                return 2;
        }
        return 0;
    }
    exports.bomLength = bomLength;
    function decode(buffer, encoding) {
        return iconv.decode(buffer, toNodeEncoding(encoding));
    }
    exports.decode = decode;
    function encode(content, encoding, options) {
        return iconv.encode(content, toNodeEncoding(encoding), options);
    }
    exports.encode = encode;
    function encodingExists(encoding) {
        return iconv.encodingExists(toNodeEncoding(encoding));
    }
    exports.encodingExists = encodingExists;
    function decodeStream(encoding) {
        return iconv.decodeStream(toNodeEncoding(encoding));
    }
    exports.decodeStream = decodeStream;
    function encodeStream(encoding, options) {
        return iconv.encodeStream(toNodeEncoding(encoding), options);
    }
    exports.encodeStream = encodeStream;
    function toNodeEncoding(enc) {
        if (enc === exports.UTF8_with_bom) {
            return exports.UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it
        }
        return enc;
    }
    function detectEncodingByBOMFromBuffer(buffer, bytesRead) {
        if (!buffer || bytesRead < 2) {
            return null;
        }
        var b0 = buffer.readUInt8(0);
        var b1 = buffer.readUInt8(1);
        // UTF-16 BE
        if (b0 === 0xFE && b1 === 0xFF) {
            return exports.UTF16be;
        }
        // UTF-16 LE
        if (b0 === 0xFF && b1 === 0xFE) {
            return exports.UTF16le;
        }
        if (bytesRead < 3) {
            return null;
        }
        var b2 = buffer.readUInt8(2);
        // UTF-8
        if (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {
            return exports.UTF8;
        }
        return null;
    }
    exports.detectEncodingByBOMFromBuffer = detectEncodingByBOMFromBuffer;
    /**
     * Detects the Byte Order Mark in a given file.
     * If no BOM is detected, null will be passed to callback.
     */
    function detectEncodingByBOM(file) {
        return stream.readExactlyByFile(file, 3).then(function (_a) {
            var buffer = _a.buffer, bytesRead = _a.bytesRead;
            return detectEncodingByBOMFromBuffer(buffer, bytesRead);
        });
    }
    exports.detectEncodingByBOM = detectEncodingByBOM;
    var MINIMUM_THRESHOLD = 0.2;
    var IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];
    /**
     * Guesses the encoding from buffer.
     */
    function guessEncodingByBuffer(buffer) {
        return new Promise(function (resolve_1, reject_1) { require(['jschardet'], resolve_1, reject_1); }).then(function (jschardet) {
            jschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;
            var guessed = jschardet.detect(buffer);
            if (!guessed || !guessed.encoding) {
                return null;
            }
            var enc = guessed.encoding.toLowerCase();
            // Ignore encodings that cannot guess correctly
            // (http://chardet.readthedocs.io/en/latest/supported-encodings.html)
            if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {
                return null;
            }
            return toIconvLiteEncoding(guessed.encoding);
        });
    }
    exports.guessEncodingByBuffer = guessEncodingByBuffer;
    var JSCHARDET_TO_ICONV_ENCODINGS = {
        'ibm866': 'cp866',
        'big5': 'cp950'
    };
    function toIconvLiteEncoding(encodingName) {
        var normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        var mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];
        return mapped || normalizedEncodingName;
    }
    /**
     * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.
     * See https://encoding.spec.whatwg.org/#names-and-labels
     * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.
     */
    function toCanonicalName(enc) {
        switch (enc) {
            case 'shiftjis':
                return 'shift-jis';
            case 'utf16le':
                return 'utf-16le';
            case 'utf16be':
                return 'utf-16be';
            case 'big5hkscs':
                return 'big5-hkscs';
            case 'eucjp':
                return 'euc-jp';
            case 'euckr':
                return 'euc-kr';
            case 'koi8r':
                return 'koi8-r';
            case 'koi8u':
                return 'koi8-u';
            case 'macroman':
                return 'x-mac-roman';
            case 'utf8bom':
                return 'utf8';
            default:
                var m = enc.match(/windows(\d+)/);
                if (m) {
                    return 'windows-' + m[1];
                }
                return enc;
        }
    }
    exports.toCanonicalName = toCanonicalName;
    var ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not
    var NO_GUESS_BUFFER_MAX_LEN = 512; // when not auto guessing the encoding, small number of bytes are enough
    var AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; // with auto guessing we want a lot more content to be read for guessing
    function detectEncodingFromBuffer(_a, autoGuessEncoding) {
        var buffer = _a.buffer, bytesRead = _a.bytesRead;
        // Always first check for BOM to find out about encoding
        var encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);
        // Detect 0 bytes to see if file is binary or UTF-16 LE/BE
        // unless we already know that this file has a UTF-16 encoding
        var seemsBinary = false;
        if (encoding !== exports.UTF16be && encoding !== exports.UTF16le) {
            var couldBeUTF16LE = true; // e.g. 0xAA 0x00
            var couldBeUTF16BE = true; // e.g. 0x00 0xAA
            var containsZeroByte = false;
            // This is a simplified guess to detect UTF-16 BE or LE by just checking if
            // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE
            // this would be the odd byte index and for UTF-16 BE the even one.
            // Note: this can produce false positives (a binary file that uses a 2-byte
            // encoding of the same format as UTF-16) and false negatives (a UTF-16 file
            // that is using 4 bytes to encode a character).
            for (var i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {
                var isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16
                var isZeroByte = (buffer.readInt8(i) === 0);
                if (isZeroByte) {
                    containsZeroByte = true;
                }
                // UTF-16 LE: expect e.g. 0xAA 0x00
                if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {
                    couldBeUTF16LE = false;
                }
                // UTF-16 BE: expect e.g. 0x00 0xAA
                if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {
                    couldBeUTF16BE = false;
                }
                // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary
                if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {
                    break;
                }
            }
            // Handle case of 0-byte included
            if (containsZeroByte) {
                if (couldBeUTF16LE) {
                    encoding = exports.UTF16le;
                }
                else if (couldBeUTF16BE) {
                    encoding = exports.UTF16be;
                }
                else {
                    seemsBinary = true;
                }
            }
        }
        // Auto guess encoding if configured
        if (autoGuessEncoding && !seemsBinary && !encoding) {
            return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(function (guessedEncoding) {
                return {
                    seemsBinary: false,
                    encoding: guessedEncoding
                };
            });
        }
        return { seemsBinary: seemsBinary, encoding: encoding };
    }
    exports.detectEncodingFromBuffer = detectEncodingFromBuffer;
    // https://ss64.com/nt/chcp.html
    var windowsTerminalEncodings = {
        '437': 'cp437',
        '850': 'cp850',
        '852': 'cp852',
        '855': 'cp855',
        '857': 'cp857',
        '860': 'cp860',
        '861': 'cp861',
        '863': 'cp863',
        '865': 'cp865',
        '866': 'cp866',
        '869': 'cp869',
        '936': 'cp936',
        '1252': 'cp1252' // West European Latin
    };
    function resolveTerminalEncoding(verbose) {
        var rawEncodingPromise;
        // Support a global environment variable to win over other mechanics
        var cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];
        if (cliEncodingEnv) {
            if (verbose) {
                console.log("Found VSCODE_CLI_ENCODING variable: " + cliEncodingEnv);
            }
            rawEncodingPromise = Promise.resolve(cliEncodingEnv);
        }
        // Linux/Mac: use "locale charmap" command
        else if (platform_1.isLinux || platform_1.isMacintosh) {
            rawEncodingPromise = new Promise(function (resolve) {
                if (verbose) {
                    console.log('Running "locale charmap" to detect terminal encoding...');
                }
                child_process_1.exec('locale charmap', function (err, stdout, stderr) { return resolve(stdout); });
            });
        }
        // Windows: educated guess
        else {
            rawEncodingPromise = new Promise(function (resolve) {
                if (verbose) {
                    console.log('Running "chcp" to detect terminal encoding...');
                }
                child_process_1.exec('chcp', function (err, stdout, stderr) {
                    if (stdout) {
                        var windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);
                        for (var i = 0; i < windowsTerminalEncodingKeys.length; i++) {
                            var key = windowsTerminalEncodingKeys[i];
                            if (stdout.indexOf(key) >= 0) {
                                return resolve(windowsTerminalEncodings[key]);
                            }
                        }
                    }
                    return resolve(void 0);
                });
            });
        }
        return rawEncodingPromise.then(function (rawEncoding) {
            if (verbose) {
                console.log("Detected raw terminal encoding: " + rawEncoding);
            }
            if (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === exports.UTF8) {
                return exports.UTF8;
            }
            var iconvEncoding = toIconvLiteEncoding(rawEncoding);
            if (iconv.encodingExists(iconvEncoding)) {
                return iconvEncoding;
            }
            if (verbose) {
                console.log('Unsupported terminal encoding, falling back to UTF-8.');
            }
            return exports.UTF8;
        });
    }
    exports.resolveTerminalEncoding = resolveTerminalEncoding;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[31/*vs/base/node/extfs*/], __M([1/*require*/,0/*exports*/,27/*fs*/,10/*path*/,11/*vs/base/common/async*/,45/*vs/base/common/normalization*/,6/*vs/base/common/platform*/,5/*vs/base/common/strings*/,49/*vs/base/common/uuid*/,69/*vs/base/node/encoding*/,56/*vs/base/node/flow*/,8/*vs/base/common/lifecycle*/,20/*vs/base/common/winjs.base*/]), function (require, exports, fs, paths, async_1, normalization_1, platform, strings, uuid, encoding_1, flow, lifecycle_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var loop = flow.loop;
    function readdirSync(path) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdirSync(path).map(function (c) { return normalization_1.normalizeNFC(c); });
        }
        return fs.readdirSync(path);
    }
    exports.readdirSync = readdirSync;
    function readdir(path, callback) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdir(path, function (error, children) {
                if (error) {
                    return callback(error, null);
                }
                return callback(null, children.map(function (c) { return normalization_1.normalizeNFC(c); }));
            });
        }
        return fs.readdir(path, callback);
    }
    exports.readdir = readdir;
    function statLink(path, callback) {
        fs.lstat(path, function (error, lstat) {
            if (error || lstat.isSymbolicLink()) {
                fs.stat(path, function (error, stat) {
                    if (error) {
                        return callback(error, null);
                    }
                    callback(null, { stat: stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });
                });
            }
            else {
                callback(null, { stat: lstat, isSymbolicLink: false });
            }
        });
    }
    exports.statLink = statLink;
    function copy(source, target, callback, copiedSources) {
        if (!copiedSources) {
            copiedSources = Object.create(null);
        }
        fs.stat(source, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (!stat.isDirectory()) {
                return doCopyFile(source, target, stat.mode & 511, callback);
            }
            if (copiedSources[source]) {
                return callback(null); // escape when there are cycles (can happen with symlinks)
            }
            copiedSources[source] = true; // remember as copied
            var proceed = function () {
                readdir(source, function (err, files) {
                    loop(files, function (file, clb) {
                        copy(paths.join(source, file), paths.join(target, file), function (error) { return clb(error, void 0); }, copiedSources);
                    }, callback);
                });
            };
            mkdirp(target, stat.mode & 511).then(proceed, proceed);
        });
    }
    exports.copy = copy;
    function doCopyFile(source, target, mode, callback) {
        var reader = fs.createReadStream(source);
        var writer = fs.createWriteStream(target, { mode: mode });
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases, pass to callback
                if (error) {
                    callback(error);
                }
                // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                else {
                    fs.chmod(target, mode, callback);
                }
            }
        };
        // handle errors properly
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // we are done (underlying fd has been closed)
        writer.once('close', function () { return finish(); });
        // start piping
        reader.pipe(writer);
    }
    function mkdirp(path, mode, token) {
        var mkdir = function () {
            return async_1.nfcall(fs.mkdir, path, mode).then(null, function (mkdirErr) {
                // ENOENT: a parent folder does not exist yet
                if (mkdirErr.code === 'ENOENT') {
                    return winjs_base_1.TPromise.wrapError(mkdirErr);
                }
                // Any other error: check if folder exists and
                // return normally in that case if its a folder
                return async_1.nfcall(fs.stat, path).then(function (stat) {
                    if (!stat.isDirectory()) {
                        return winjs_base_1.TPromise.wrapError(new Error("'" + path + "' exists and is not a directory."));
                    }
                    return null;
                }, function (statErr) {
                    return winjs_base_1.TPromise.wrapError(mkdirErr); // bubble up original mkdir error
                });
            });
        };
        // stop at root
        if (path === paths.dirname(path)) {
            return winjs_base_1.TPromise.as(true);
        }
        // recursively mkdir
        return mkdir().then(null, function (err) {
            // Respect cancellation
            if (token && token.isCancellationRequested) {
                return winjs_base_1.TPromise.as(false);
            }
            // ENOENT: a parent folder does not exist yet, continue
            // to create the parent folder and then try again.
            if (err.code === 'ENOENT') {
                return mkdirp(paths.dirname(path), mode).then(mkdir);
            }
            // Any other error
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.mkdirp = mkdirp;
    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
    function del(path, tmpFolder, callback, done) {
        fs.exists(path, function (exists) {
            if (!exists) {
                return callback(null);
            }
            fs.stat(path, function (err, stat) {
                if (err || !stat) {
                    return callback(err);
                }
                // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                    return rmRecursive(path, callback);
                }
                var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
                fs.rename(path, pathInTemp, function (error) {
                    if (error) {
                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                    }
                    // Return early since the move succeeded
                    callback(null);
                    // do the heavy deletion outside the callers callback
                    rmRecursive(pathInTemp, function (error) {
                        if (error) {
                            console.error(error);
                        }
                        if (done) {
                            done(error);
                        }
                    });
                });
            });
        });
    }
    exports.del = del;
    function rmRecursive(path, callback) {
        if (path === '\\' || path === '/') {
            return callback(new Error('Will not delete root!'));
        }
        fs.exists(path, function (exists) {
            if (!exists) {
                callback(null);
            }
            else {
                fs.lstat(path, function (err, stat) {
                    if (err || !stat) {
                        callback(err);
                    }
                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                        var mode = stat.mode;
                        if (!(mode & 128)) { // 128 === 0200
                            fs.chmod(path, mode | 128, function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    fs.unlink(path, callback);
                                }
                            });
                        }
                        else {
                            fs.unlink(path, callback);
                        }
                    }
                    else {
                        readdir(path, function (err, children) {
                            if (err || !children) {
                                callback(err);
                            }
                            else if (children.length === 0) {
                                fs.rmdir(path, callback);
                            }
                            else {
                                var firstError_1 = null;
                                var childrenLeft_1 = children.length;
                                children.forEach(function (child) {
                                    rmRecursive(paths.join(path, child), function (err) {
                                        childrenLeft_1--;
                                        if (err) {
                                            firstError_1 = firstError_1 || err;
                                        }
                                        if (childrenLeft_1 === 0) {
                                            if (firstError_1) {
                                                callback(firstError_1);
                                            }
                                            else {
                                                fs.rmdir(path, callback);
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    }
                });
            }
        });
    }
    function delSync(path) {
        try {
            var stat = fs.lstatSync(path);
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                readdirSync(path).forEach(function (child) { return delSync(paths.join(path, child)); });
                fs.rmdirSync(path);
            }
            else {
                fs.unlinkSync(path);
            }
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return; // not found
            }
            throw err;
        }
    }
    exports.delSync = delSync;
    function mv(source, target, callback) {
        if (source === target) {
            return callback(null);
        }
        function updateMtime(err) {
            if (err) {
                return callback(err);
            }
            fs.stat(target, function (error, stat) {
                if (error) {
                    return callback(error);
                }
                if (stat.isDirectory()) {
                    return callback(null);
                }
                fs.open(target, 'a', null, function (err, fd) {
                    if (err) {
                        return callback(err);
                    }
                    fs.futimes(fd, stat.atime, new Date(), function (err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.close(fd, callback);
                    });
                });
            });
        }
        // Try native rename()
        fs.rename(source, target, function (err) {
            if (!err) {
                return updateMtime(null);
            }
            // In two cases we fallback to classic copy and delete:
            //
            // 1.) The EXDEV error indicates that source and target are on different devices
            // In this case, fallback to using a copy() operation as there is no way to
            // rename() between different devices.
            //
            // 2.) The user tries to rename a file/folder that ends with a dot. This is not
            // really possible to move then, at least on UNC devices.
            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
                return copy(source, target, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    rmRecursive(source, updateMtime);
                });
            }
            return callback(err);
        });
    }
    exports.mv = mv;
    var canFlush = true;
    function writeFileAndFlush(path, data, options, callback) {
        options = ensureOptions(options);
        if (typeof data === 'string' || Buffer.isBuffer(data)) {
            doWriteFileAndFlush(path, data, options, callback);
        }
        else {
            doWriteFileStreamAndFlush(path, data, options, callback);
        }
    }
    exports.writeFileAndFlush = writeFileAndFlush;
    function doWriteFileStreamAndFlush(path, reader, options, callback) {
        // finish only once
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases we need to manually close streams
                // if the write stream was successfully opened
                if (error) {
                    if (isOpen) {
                        writer.once('close', function () { return callback(error); });
                        writer.close();
                    }
                    else {
                        callback(error);
                    }
                }
                // otherwise just return without error
                else {
                    callback();
                }
            }
        };
        // create writer to target. we set autoClose: false because we want to use the streams
        // file descriptor to call fs.fdatasync to ensure the data is flushed to disk
        var writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });
        // Event: 'open'
        // Purpose: save the fd for later use and start piping
        // Notes: will not be called when there is an error opening the file descriptor!
        var fd;
        var isOpen;
        writer.once('open', function (descriptor) {
            fd = descriptor;
            isOpen = true;
            // if an encoding is provided, we need to pipe the stream through
            // an encoder stream and forward the encoding related options
            if (options.encoding) {
                reader = reader.pipe(encoding_1.encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));
            }
            // start data piping only when we got a successful open. this ensures that we do
            // not consume the stream when an error happens and helps to fix this issue:
            // https://github.com/Microsoft/vscode/issues/42542
            reader.pipe(writer);
        });
        // Event: 'error'
        // Purpose: to return the error to the outside and to close the write stream (does not happen automatically)
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // Event: 'finish'
        // Purpose: use fs.fdatasync to flush the contents to disk
        // Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()
        // because we have created the WriteStream with autoClose: false
        writer.once('finish', function () {
            // flush to disk
            if (canFlush && isOpen) {
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    writer.close();
                });
            }
            else {
                writer.close();
            }
        });
        // Event: 'close'
        // Purpose: signal we are done to the outside
        // Notes: event is called when the writer's filedescriptor is closed
        writer.once('close', function () { return finish(); });
    }
    // Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk
    // We do this in cases where we want to make sure the data is really on disk and
    // not in some cache.
    //
    // See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194
    function doWriteFileAndFlush(path, data, options, callback) {
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);
        }
        // Open the file with same flags and mode as fs.writeFile()
        fs.open(path, options.flag, options.mode, function (openError, fd) {
            if (openError) {
                return callback(openError);
            }
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFile(fd, data, function (writeError) {
                if (writeError) {
                    return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!
                }
                // Flush contents (not metadata) of the file to disk
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    return fs.close(fd, function (closeError) { return callback(closeError); });
                });
            });
        });
    }
    function writeFileAndFlushSync(path, data, options) {
        options = ensureOptions(options);
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });
        }
        // Open the file with same flags and mode as fs.writeFile()
        var fd = fs.openSync(path, options.flag, options.mode);
        try {
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFileSync(fd, data);
            // Flush contents (not metadata) of the file to disk
            try {
                fs.fdatasyncSync(fd);
            }
            catch (syncError) {
                console.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);
                canFlush = false;
            }
        }
        finally {
            fs.closeSync(fd);
        }
    }
    exports.writeFileAndFlushSync = writeFileAndFlushSync;
    function ensureOptions(options) {
        if (!options) {
            return { mode: 438, flag: 'w' };
        }
        var ensuredOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };
        if (typeof ensuredOptions.mode !== 'number') {
            ensuredOptions.mode = 438;
        }
        if (typeof ensuredOptions.flag !== 'string') {
            ensuredOptions.flag = 'w';
        }
        return ensuredOptions;
    }
    /**
     * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83
     *
     * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.
     * On a case insensitive file system, the returned path might differ from the original path by character casing.
     * On a case sensitive file system, the returned path will always be identical to the original path.
     * In case of errors, null is returned. But you cannot use this function to verify that a path exists.
     * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.
     */
    function realcaseSync(path) {
        var dir = paths.dirname(path);
        if (path === dir) { // end recursion
            return path;
        }
        var name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();
        try {
            var entries = readdirSync(dir);
            var found = entries.filter(function (e) { return e.toLowerCase() === name; }); // use a case insensitive search
            if (found.length === 1) {
                // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition
                var prefix = realcaseSync(dir); // recurse
                if (prefix) {
                    return paths.join(prefix, found[0]);
                }
            }
            else if (found.length > 1) {
                // must be a case sensitive $filesystem
                var ix = found.indexOf(name);
                if (ix >= 0) { // case sensitive
                    var prefix = realcaseSync(dir); // recurse
                    if (prefix) {
                        return paths.join(prefix, found[ix]);
                    }
                }
            }
        }
        catch (error) {
            // silently ignore error
        }
        return null;
    }
    exports.realcaseSync = realcaseSync;
    function realpathSync(path) {
        try {
            return fs.realpathSync(path);
        }
        catch (error) {
            // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error
            return normalizedPath;
        }
    }
    exports.realpathSync = realpathSync;
    function realpath(path, callback) {
        return fs.realpath(path, function (error, realpath) {
            if (!error) {
                return callback(null, realpath);
            }
            // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            return fs.access(normalizedPath, fs.constants.R_OK, function (error) {
                return callback(error, normalizedPath);
            });
        });
    }
    exports.realpath = realpath;
    function normalizePath(path) {
        return strings.rtrim(paths.normalize(path), paths.sep);
    }
    function watch(path, onChange, onError) {
        try {
            var watcher_1 = fs.watch(path);
            watcher_1.on('change', function (type, raw) {
                var file = null;
                if (raw) { // https://github.com/Microsoft/vscode/issues/38191
                    file = raw.toString();
                    if (platform.isMacintosh) {
                        // Mac: uses NFD unicode form on disk, but we want NFC
                        // See also https://github.com/nodejs/node/issues/2165
                        file = normalization_1.normalizeNFC(file);
                    }
                }
                onChange(type, file);
            });
            watcher_1.on('error', function (code, signal) { return onError("Failed to watch " + path + " for changes (" + code + ", " + signal + ")"); });
            return lifecycle_1.toDisposable(function () {
                watcher_1.removeAllListeners();
                watcher_1.close();
            });
        }
        catch (error) {
            fs.exists(path, function (exists) {
                if (exists) {
                    onError("Failed to watch " + path + " for changes (" + error.toString() + ")");
                }
            });
        }
        return lifecycle_1.Disposable.None;
    }
    exports.watch = watch;
    function sanitizeFilePath(candidate, cwd) {
        // Special case: allow to open a drive letter without trailing backslash
        if (platform.isWindows && strings.endsWith(candidate, ':')) {
            candidate += paths.sep;
        }
        // Ensure absolute
        if (!paths.isAbsolute(candidate)) {
            candidate = paths.join(cwd, candidate);
        }
        // Ensure normalized
        candidate = paths.normalize(candidate);
        // Ensure no trailing slash/backslash
        if (platform.isWindows) {
            candidate = strings.rtrim(candidate, paths.sep);
            // Special case: allow to open drive root ('C:\')
            if (strings.endsWith(candidate, ':')) {
                candidate += paths.sep;
            }
        }
        else {
            candidate = strings.rtrim(candidate, paths.sep);
            // Special case: allow to open root ('/')
            if (!candidate) {
                candidate = paths.sep;
            }
        }
        return candidate;
    }
    exports.sanitizeFilePath = sanitizeFilePath;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[47/*vs/base/node/pfs*/], __M([1/*require*/,0/*exports*/,31/*vs/base/node/extfs*/,10/*path*/,11/*vs/base/common/async*/,27/*fs*/,30/*os*/,6/*vs/base/common/platform*/,3/*vs/base/common/event*/,20/*vs/base/common/winjs.base*/]), function (require, exports, extfs, path_1, async_1, fs, os, platform, event_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function readdir(path) {
        return async_1.nfcall(extfs.readdir, path);
    }
    exports.readdir = readdir;
    function exists(path) {
        return new winjs_base_1.TPromise(function (c) { return fs.exists(path, c); });
    }
    exports.exists = exists;
    function chmod(path, mode) {
        return async_1.nfcall(fs.chmod, path, mode);
    }
    exports.chmod = chmod;
    exports.mkdirp = extfs.mkdirp;
    function rimraf(path) {
        return lstat(path).then(function (stat) {
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                return readdir(path)
                    .then(function (children) { return winjs_base_1.TPromise.join(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })
                    .then(function () { return rmdir(path); });
            }
            else {
                return unlink(path);
            }
        }, function (err) {
            if (err.code === 'ENOENT') {
                return void 0;
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.rimraf = rimraf;
    function realpath(path) {
        return async_1.nfcall(extfs.realpath, path);
    }
    exports.realpath = realpath;
    function stat(path) {
        return async_1.nfcall(fs.stat, path);
    }
    exports.stat = stat;
    function statLink(path) {
        return async_1.nfcall(extfs.statLink, path);
    }
    exports.statLink = statLink;
    function lstat(path) {
        return async_1.nfcall(fs.lstat, path);
    }
    exports.lstat = lstat;
    function rename(oldPath, newPath) {
        return async_1.nfcall(fs.rename, oldPath, newPath);
    }
    exports.rename = rename;
    function rmdir(path) {
        return async_1.nfcall(fs.rmdir, path);
    }
    exports.rmdir = rmdir;
    function unlink(path) {
        return async_1.nfcall(fs.unlink, path);
    }
    exports.unlink = unlink;
    function symlink(target, path, type) {
        return async_1.nfcall(fs.symlink, target, path, type);
    }
    exports.symlink = symlink;
    function readlink(path) {
        return async_1.nfcall(fs.readlink, path);
    }
    exports.readlink = readlink;
    function truncate(path, len) {
        return async_1.nfcall(fs.truncate, path, len);
    }
    exports.truncate = truncate;
    function readFile(path, encoding) {
        return async_1.nfcall(fs.readFile, path, encoding);
    }
    exports.readFile = readFile;
    // According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)
    // it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.
    // Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.
    var writeFilePathQueue = Object.create(null);
    function writeFile(path, data, options) {
        var queueKey = toQueueKey(path);
        return ensureWriteFileQueue(queueKey).queue(function () { return async_1.nfcall(extfs.writeFileAndFlush, path, data, options); });
    }
    exports.writeFile = writeFile;
    function toQueueKey(path) {
        var queueKey = path;
        if (platform.isWindows || platform.isMacintosh) {
            queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems
        }
        return queueKey;
    }
    function ensureWriteFileQueue(queueKey) {
        var writeFileQueue = writeFilePathQueue[queueKey];
        if (!writeFileQueue) {
            writeFileQueue = new async_1.Queue();
            writeFilePathQueue[queueKey] = writeFileQueue;
            var onFinish = event_1.once(writeFileQueue.onFinished);
            onFinish(function () {
                delete writeFilePathQueue[queueKey];
                writeFileQueue.dispose();
            });
        }
        return writeFileQueue;
    }
    /**
    * Read a dir and return only subfolders
    */
    function readDirsInDir(dirPath) {
        return readdir(dirPath).then(function (children) {
            return winjs_base_1.TPromise.join(children.map(function (c) { return dirExists(path_1.join(dirPath, c)); })).then(function (exists) {
                return children.filter(function (_, i) { return exists[i]; });
            });
        });
    }
    exports.readDirsInDir = readDirsInDir;
    /**
    * `path` exists and is a directory
    */
    function dirExists(path) {
        return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });
    }
    exports.dirExists = dirExists;
    /**
    * `path` exists and is a file.
    */
    function fileExists(path) {
        return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });
    }
    exports.fileExists = fileExists;
    /**
     * Deletes a path from disk.
     */
    var _tmpDir = null;
    function getTmpDir() {
        if (!_tmpDir) {
            _tmpDir = os.tmpdir();
        }
        return _tmpDir;
    }
    function del(path, tmp) {
        if (tmp === void 0) { tmp = getTmpDir(); }
        return async_1.nfcall(extfs.del, path, tmp);
    }
    exports.del = del;
    function whenDeleted(path) {
        // Complete when wait marker file is deleted
        return new winjs_base_1.TPromise(function (c) {
            var running = false;
            var interval = setInterval(function () {
                if (!running) {
                    running = true;
                    fs.exists(path, function (exists) {
                        running = false;
                        if (!exists) {
                            clearInterval(interval);
                            c(null);
                        }
                    });
                }
            }, 1000);
        });
    }
    exports.whenDeleted = whenDeleted;
    function copy(source, target) {
        return async_1.nfcall(extfs.copy, source, target);
    }
    exports.copy = copy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[44/*vs/base/parts/ipc/node/ipc*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/lifecycle*/,3/*vs/base/common/event*/,11/*vs/base/common/async*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/]), function (require, exports, lifecycle_1, event_1, async_1, cancellation_1, errors) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RequestType;
    (function (RequestType) {
        RequestType[RequestType["Promise"] = 100] = "Promise";
        RequestType[RequestType["PromiseCancel"] = 101] = "PromiseCancel";
        RequestType[RequestType["EventListen"] = 102] = "EventListen";
        RequestType[RequestType["EventDispose"] = 103] = "EventDispose";
    })(RequestType = exports.RequestType || (exports.RequestType = {}));
    var ResponseType;
    (function (ResponseType) {
        ResponseType[ResponseType["Initialize"] = 200] = "Initialize";
        ResponseType[ResponseType["PromiseSuccess"] = 201] = "PromiseSuccess";
        ResponseType[ResponseType["PromiseError"] = 202] = "PromiseError";
        ResponseType[ResponseType["PromiseErrorObj"] = 203] = "PromiseErrorObj";
        ResponseType[ResponseType["EventFire"] = 204] = "EventFire";
    })(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
    var State;
    (function (State) {
        State[State["Uninitialized"] = 0] = "Uninitialized";
        State[State["Idle"] = 1] = "Idle";
    })(State || (State = {}));
    var BodyType;
    (function (BodyType) {
        BodyType[BodyType["Undefined"] = 0] = "Undefined";
        BodyType[BodyType["String"] = 1] = "String";
        BodyType[BodyType["Buffer"] = 2] = "Buffer";
        BodyType[BodyType["Object"] = 3] = "Object";
    })(BodyType || (BodyType = {}));
    var empty = Buffer.allocUnsafe(0);
    function serializeBody(body) {
        if (typeof body === 'undefined') {
            return { buffer: empty, type: BodyType.Undefined };
        }
        else if (typeof body === 'string') {
            return { buffer: Buffer.from(body), type: BodyType.String };
        }
        else if (Buffer.isBuffer(body)) {
            return { buffer: body, type: BodyType.Buffer };
        }
        else {
            return { buffer: Buffer.from(JSON.stringify(body)), type: BodyType.Object };
        }
    }
    function serialize(header, body) {
        if (body === void 0) { body = undefined; }
        var headerSizeBuffer = Buffer.allocUnsafe(4);
        var _a = serializeBody(body), bodyBuffer = _a.buffer, bodyType = _a.type;
        var headerBuffer = Buffer.from(JSON.stringify([header, bodyType]));
        headerSizeBuffer.writeUInt32BE(headerBuffer.byteLength, 0);
        return Buffer.concat([headerSizeBuffer, headerBuffer, bodyBuffer]);
    }
    function deserializeBody(bodyBuffer, bodyType) {
        switch (bodyType) {
            case BodyType.Undefined: return undefined;
            case BodyType.String: return bodyBuffer.toString();
            case BodyType.Buffer: return bodyBuffer;
            case BodyType.Object: return JSON.parse(bodyBuffer.toString());
        }
    }
    function deserialize(buffer) {
        var headerSize = buffer.readUInt32BE(0);
        var headerBuffer = buffer.slice(4, 4 + headerSize);
        var bodyBuffer = buffer.slice(4 + headerSize);
        var _a = JSON.parse(headerBuffer.toString()), header = _a[0], bodyType = _a[1];
        var body = deserializeBody(bodyBuffer, bodyType);
        return { header: header, body: body };
    }
    var ChannelServer = /** @class */ (function () {
        function ChannelServer(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.channels = new Map();
            this.activeRequests = new Map();
            this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onRawMessage(msg); });
            this.sendResponse({ type: 200 /* Initialize */ });
        }
        ChannelServer.prototype.registerChannel = function (channelName, channel) {
            this.channels.set(channelName, channel);
        };
        ChannelServer.prototype.sendResponse = function (response) {
            switch (response.type) {
                case 200 /* Initialize */:
                    return this.sendBuffer(serialize([response.type]));
                case 201 /* PromiseSuccess */:
                case 202 /* PromiseError */:
                case 204 /* EventFire */:
                case 203 /* PromiseErrorObj */:
                    return this.sendBuffer(serialize([response.type, response.id], response.data));
            }
        };
        ChannelServer.prototype.sendBuffer = function (message) {
            try {
                this.protocol.send(message);
            }
            catch (err) {
                // noop
            }
        };
        ChannelServer.prototype.onRawMessage = function (message) {
            var _a = deserialize(message), header = _a.header, body = _a.body;
            var type = header[0];
            switch (type) {
                case 100 /* Promise */:
                    return this.onPromise({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });
                case 102 /* EventListen */:
                    return this.onEventListen({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });
                case 101 /* PromiseCancel */:
                    return this.disposeActiveRequest({ type: type, id: header[1] });
                case 103 /* EventDispose */:
                    return this.disposeActiveRequest({ type: type, id: header[1] });
            }
        };
        ChannelServer.prototype.onPromise = function (request) {
            var _this = this;
            var channel = this.channels.get(request.channelName);
            var cancellationTokenSource = new cancellation_1.CancellationTokenSource();
            var promise;
            try {
                promise = channel.call(request.name, request.arg, cancellationTokenSource.token);
            }
            catch (err) {
                promise = Promise.reject(err);
            }
            var id = request.id;
            promise.then(function (data) {
                _this.sendResponse({ id: id, data: data, type: 201 /* PromiseSuccess */ });
                _this.activeRequests.delete(request.id);
            }, function (err) {
                if (err instanceof Error) {
                    _this.sendResponse({
                        id: id, data: {
                            message: err.message,
                            name: err.name,
                            stack: err.stack ? (err.stack.split ? err.stack.split('\n') : err.stack) : void 0
                        }, type: 202 /* PromiseError */
                    });
                }
                else {
                    _this.sendResponse({ id: id, data: err, type: 203 /* PromiseErrorObj */ });
                }
                _this.activeRequests.delete(request.id);
            });
            var disposable = lifecycle_1.toDisposable(function () { return cancellationTokenSource.cancel(); });
            this.activeRequests.set(request.id, disposable);
        };
        ChannelServer.prototype.onEventListen = function (request) {
            var _this = this;
            var channel = this.channels.get(request.channelName);
            var id = request.id;
            var event = channel.listen(request.name, request.arg);
            var disposable = event(function (data) { return _this.sendResponse({ id: id, data: data, type: 204 /* EventFire */ }); });
            this.activeRequests.set(request.id, disposable);
        };
        ChannelServer.prototype.disposeActiveRequest = function (request) {
            var disposable = this.activeRequests.get(request.id);
            if (disposable) {
                disposable.dispose();
                this.activeRequests.delete(request.id);
            }
        };
        ChannelServer.prototype.dispose = function () {
            if (this.protocolListener) {
                this.protocolListener.dispose();
                this.protocolListener = null;
            }
            this.activeRequests.forEach(function (d) { return d.dispose(); });
            this.activeRequests.clear();
        };
        return ChannelServer;
    }());
    exports.ChannelServer = ChannelServer;
    var ChannelClient = /** @class */ (function () {
        function ChannelClient(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.state = State.Uninitialized;
            this.activeRequests = new Set();
            this.handlers = new Map();
            this.lastRequestId = 0;
            this._onDidInitialize = new event_1.Emitter();
            this.onDidInitialize = this._onDidInitialize.event;
            this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onBuffer(msg); });
        }
        ChannelClient.prototype.getChannel = function (channelName) {
            var that = this;
            return {
                call: function (command, arg, cancellationToken) {
                    return that.requestPromise(channelName, command, arg, cancellationToken);
                },
                listen: function (event, arg) {
                    return that.requestEvent(channelName, event, arg);
                }
            };
        };
        ChannelClient.prototype.requestPromise = function (channelName, name, arg, cancellationToken) {
            var _this = this;
            if (cancellationToken === void 0) { cancellationToken = cancellation_1.CancellationToken.None; }
            var id = this.lastRequestId++;
            var type = 100 /* Promise */;
            var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };
            if (cancellationToken.isCancellationRequested) {
                return Promise.reject(errors.canceled());
            }
            var disposable;
            var result = new Promise(function (c, e) {
                if (cancellationToken.isCancellationRequested) {
                    return e(errors.canceled());
                }
                var uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });
                uninitializedPromise.then(function () {
                    uninitializedPromise = null;
                    var handler = function (response) {
                        switch (response.type) {
                            case 201 /* PromiseSuccess */:
                                _this.handlers.delete(id);
                                c(response.data);
                                break;
                            case 202 /* PromiseError */:
                                _this.handlers.delete(id);
                                var error = new Error(response.data.message);
                                error.stack = response.data.stack;
                                error.name = response.data.name;
                                e(error);
                                break;
                            case 203 /* PromiseErrorObj */:
                                _this.handlers.delete(id);
                                e(response.data);
                                break;
                        }
                    };
                    _this.handlers.set(id, handler);
                    _this.sendRequest(request);
                });
                var cancel = function () {
                    if (uninitializedPromise) {
                        uninitializedPromise.cancel();
                        uninitializedPromise = null;
                    }
                    else {
                        _this.sendRequest({ id: id, type: 101 /* PromiseCancel */ });
                    }
                    e(errors.canceled());
                };
                var cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);
                disposable = lifecycle_1.combinedDisposable([lifecycle_1.toDisposable(cancel), cancellationTokenListener]);
                _this.activeRequests.add(disposable);
            });
            async_1.always(result, function () { return _this.activeRequests.delete(disposable); });
            return result;
        };
        ChannelClient.prototype.requestEvent = function (channelName, name, arg) {
            var _this = this;
            var id = this.lastRequestId++;
            var type = 102 /* EventListen */;
            var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };
            var uninitializedPromise = null;
            var emitter = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });
                    uninitializedPromise.then(function () {
                        uninitializedPromise = null;
                        _this.activeRequests.add(emitter);
                        _this.sendRequest(request);
                    });
                },
                onLastListenerRemove: function () {
                    if (uninitializedPromise) {
                        uninitializedPromise.cancel();
                        uninitializedPromise = null;
                    }
                    else {
                        _this.activeRequests.delete(emitter);
                        _this.sendRequest({ id: id, type: 103 /* EventDispose */ });
                    }
                }
            });
            var handler = function (res) { return emitter.fire(res.data); };
            this.handlers.set(id, handler);
            return emitter.event;
        };
        ChannelClient.prototype.sendRequest = function (request) {
            switch (request.type) {
                case 100 /* Promise */:
                case 102 /* EventListen */:
                    return this.sendBuffer(serialize([request.type, request.id, request.channelName, request.name], request.arg));
                case 101 /* PromiseCancel */:
                case 103 /* EventDispose */:
                    return this.sendBuffer(serialize([request.type, request.id]));
            }
        };
        ChannelClient.prototype.sendBuffer = function (message) {
            try {
                this.protocol.send(message);
            }
            catch (err) {
                // noop
            }
        };
        ChannelClient.prototype.onBuffer = function (message) {
            var _a = deserialize(message), header = _a.header, body = _a.body;
            var type = header[0];
            switch (type) {
                case 200 /* Initialize */:
                    return this.onResponse({ type: header[0] });
                case 201 /* PromiseSuccess */:
                case 202 /* PromiseError */:
                case 204 /* EventFire */:
                case 203 /* PromiseErrorObj */:
                    return this.onResponse({ type: header[0], id: header[1], data: body });
            }
        };
        ChannelClient.prototype.onResponse = function (response) {
            if (response.type === 200 /* Initialize */) {
                this.state = State.Idle;
                this._onDidInitialize.fire();
                return;
            }
            var handler = this.handlers.get(response.id);
            if (handler) {
                handler(response);
            }
        };
        ChannelClient.prototype.whenInitialized = function () {
            if (this.state === State.Idle) {
                return Promise.resolve();
            }
            else {
                return event_1.toNativePromise(this.onDidInitialize);
            }
        };
        ChannelClient.prototype.dispose = function () {
            if (this.protocolListener) {
                this.protocolListener.dispose();
                this.protocolListener = null;
            }
            this.activeRequests.forEach(function (p) { return p.dispose(); });
            this.activeRequests.clear();
        };
        return ChannelClient;
    }());
    exports.ChannelClient = ChannelClient;
    /**
     * An `IPCServer` is both a channel server and a routing channel
     * client.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCServer = /** @class */ (function () {
        function IPCServer(onDidClientConnect) {
            var _this = this;
            this.channels = new Map();
            this.channelClients = new Map();
            this.onClientAdded = new event_1.Emitter();
            onDidClientConnect(function (_a) {
                var protocol = _a.protocol, onDidClientDisconnect = _a.onDidClientDisconnect;
                var onFirstMessage = event_1.once(protocol.onMessage);
                onFirstMessage(function (rawId) {
                    var channelServer = new ChannelServer(protocol);
                    var channelClient = new ChannelClient(protocol);
                    _this.channels.forEach(function (channel, name) { return channelServer.registerChannel(name, channel); });
                    var id = rawId.toString();
                    if (_this.channelClients.has(id)) {
                        console.warn("IPC client with id '" + id + "' is already registered.");
                    }
                    _this.channelClients.set(id, channelClient);
                    _this.onClientAdded.fire(id);
                    onDidClientDisconnect(function () {
                        channelServer.dispose();
                        channelClient.dispose();
                        _this.channelClients.delete(id);
                    });
                });
            });
        }
        Object.defineProperty(IPCServer.prototype, "clientKeys", {
            get: function () {
                var result = [];
                this.channelClients.forEach(function (_, key) { return result.push(key); });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        IPCServer.prototype.getChannel = function (channelName, router) {
            var that = this;
            return {
                call: function (command, arg, cancellationToken) {
                    var channelPromise = router.routeCall(that.clientKeys, command, arg)
                        .then(function (id) { return that.getClient(id); })
                        .then(function (client) { return client.getChannel(channelName); });
                    return getDelayedChannel(channelPromise)
                        .call(command, arg, cancellationToken);
                },
                listen: function (event, arg) {
                    var channelPromise = router.routeEvent(that.clientKeys, event, arg)
                        .then(function (id) { return that.getClient(id); })
                        .then(function (client) { return client.getChannel(channelName); });
                    return getDelayedChannel(channelPromise)
                        .listen(event, arg);
                }
            };
        };
        IPCServer.prototype.registerChannel = function (channelName, channel) {
            this.channels.set(channelName, channel);
        };
        IPCServer.prototype.getClient = function (clientId) {
            var _this = this;
            if (!clientId) {
                return Promise.reject(new Error('Client id should be provided'));
            }
            var client = this.channelClients.get(clientId);
            if (client) {
                return Promise.resolve(client);
            }
            return new Promise(function (c) {
                var onClient = event_1.once(event_1.filterEvent(_this.onClientAdded.event, function (id) { return id === clientId; }));
                onClient(function () { return c(_this.channelClients.get(clientId)); });
            });
        };
        IPCServer.prototype.dispose = function () {
            this.channels.clear();
            this.channelClients.clear();
            this.onClientAdded.dispose();
        };
        return IPCServer;
    }());
    exports.IPCServer = IPCServer;
    /**
     * An `IPCClient` is both a channel client and a channel server.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCClient = /** @class */ (function () {
        function IPCClient(protocol, id) {
            protocol.send(Buffer.from(id));
            this.channelClient = new ChannelClient(protocol);
            this.channelServer = new ChannelServer(protocol);
        }
        IPCClient.prototype.getChannel = function (channelName) {
            return this.channelClient.getChannel(channelName);
        };
        IPCClient.prototype.registerChannel = function (channelName, channel) {
            this.channelServer.registerChannel(channelName, channel);
        };
        IPCClient.prototype.dispose = function () {
            this.channelClient.dispose();
            this.channelServer.dispose();
        };
        return IPCClient;
    }());
    exports.IPCClient = IPCClient;
    function getDelayedChannel(promise) {
        return {
            call: function (command, arg, cancellationToken) {
                return promise.then(function (c) { return c.call(command, arg, cancellationToken); });
            },
            listen: function (event, arg) {
                var relay = new event_1.Relay();
                promise.then(function (c) { return relay.input = c.listen(event, arg); });
                return relay.event;
            }
        };
    }
    exports.getDelayedChannel = getDelayedChannel;
    function getNextTickChannel(channel) {
        var didTick = false;
        return {
            call: function (command, arg, cancellationToken) {
                if (didTick) {
                    return channel.call(command, arg, cancellationToken);
                }
                return async_1.timeout(0)
                    .then(function () { return didTick = true; })
                    .then(function () { return channel.call(command, arg, cancellationToken); });
            },
            listen: function (event, arg) {
                if (didTick) {
                    return channel.listen(event, arg);
                }
                var relay = new event_1.Relay();
                async_1.timeout(0)
                    .then(function () { return didTick = true; })
                    .then(function () { return relay.input = channel.listen(event, arg); });
                return relay.event;
            }
        };
    }
    exports.getNextTickChannel = getNextTickChannel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[102/*vs/base/parts/ipc/node/ipc.net*/], __M([1/*require*/,0/*exports*/,64/*net*/,3/*vs/base/common/event*/,44/*vs/base/parts/ipc/node/ipc*/,10/*path*/,30/*os*/,49/*vs/base/common/uuid*/,11/*vs/base/common/async*/]), function (require, exports, net_1, event_1, ipc_1, path_1, os_1, uuid_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateRandomPipeName() {
        var randomSuffix = uuid_1.generateUuid();
        if (process.platform === 'win32') {
            return "\\\\.\\pipe\\vscode-ipc-" + randomSuffix + "-sock";
        }
        else {
            // Mac/Unix: use socket file
            return path_1.join(os_1.tmpdir(), "vscode-ipc-" + randomSuffix + ".sock");
        }
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    /**
     * A message has the following format:
     *
     * 		[bodyLen|message]
     * 		[header^|data^^^]
     * 		[u32be^^|buffer^]
     */
    var Protocol = /** @class */ (function () {
        function Protocol(_socket, firstDataChunk) {
            var _this = this;
            this._socket = _socket;
            this._onMessage = new event_1.Emitter();
            this.onMessage = this._onMessage.event;
            this._onClose = new event_1.Emitter();
            this.onClose = this._onClose.event;
            this._writeBuffer = new /** @class */ (function () {
                function class_1() {
                    this._data = [];
                    this._totalLength = 0;
                }
                class_1.prototype.add = function (head, body) {
                    var wasEmpty = this._totalLength === 0;
                    this._data.push(head, body);
                    this._totalLength += head.length + body.length;
                    return wasEmpty;
                };
                class_1.prototype.take = function () {
                    var ret = Buffer.concat(this._data, this._totalLength);
                    this._data.length = 0;
                    this._totalLength = 0;
                    return ret;
                };
                return class_1;
            }());
            this._isDisposed = false;
            this._chunks = [];
            var totalLength = 0;
            var state = {
                readHead: true,
                bodyLen: -1,
            };
            var acceptChunk = function (data) {
                _this._chunks.push(data);
                totalLength += data.length;
                while (totalLength > 0) {
                    if (state.readHead) {
                        // expecting header -> read 5bytes for header
                        // information: `bodyIsJson` and `bodyLen`
                        if (totalLength >= Protocol._headerLen) {
                            var all = Buffer.concat(_this._chunks);
                            state.bodyLen = all.readUInt32BE(0);
                            state.readHead = false;
                            var rest = all.slice(Protocol._headerLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                        }
                        else {
                            break;
                        }
                    }
                    if (!state.readHead) {
                        // expecting body -> read bodyLen-bytes for
                        // the actual message or wait for more data
                        if (totalLength >= state.bodyLen) {
                            var all = Buffer.concat(_this._chunks);
                            var buffer = all.slice(0, state.bodyLen);
                            // ensure the getBuffer returns a valid value if invoked from the event listeners
                            var rest = all.slice(state.bodyLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                            state.bodyLen = -1;
                            state.readHead = true;
                            _this._onMessage.fire(buffer);
                            if (_this._isDisposed) {
                                // check if an event listener lead to our disposal
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            };
            var acceptFirstDataChunk = function () {
                if (firstDataChunk && firstDataChunk.length > 0) {
                    var tmp = firstDataChunk;
                    firstDataChunk = undefined;
                    acceptChunk(tmp);
                }
            };
            // Make sure to always handle the firstDataChunk if no more `data` event comes in
            this._firstChunkTimer = new async_1.TimeoutTimer();
            this._firstChunkTimer.setIfNotSet(function () {
                acceptFirstDataChunk();
            }, 0);
            this._socketDataListener = function (data) {
                acceptFirstDataChunk();
                acceptChunk(data);
            };
            _socket.on('data', this._socketDataListener);
            this._socketEndListener = function () {
                acceptFirstDataChunk();
            };
            _socket.on('end', this._socketEndListener);
            this._socketCloseListener = function () {
                _this._onClose.fire();
            };
            _socket.once('close', this._socketCloseListener);
        }
        Protocol.prototype.dispose = function () {
            this._isDisposed = true;
            this._firstChunkTimer.dispose();
            this._socket.removeListener('data', this._socketDataListener);
            this._socket.removeListener('end', this._socketEndListener);
            this._socket.removeListener('close', this._socketCloseListener);
        };
        Protocol.prototype.end = function () {
            this._socket.end();
        };
        Protocol.prototype.getBuffer = function () {
            return Buffer.concat(this._chunks);
        };
        Protocol.prototype.send = function (buffer) {
            var header = Buffer.allocUnsafe(Protocol._headerLen);
            header.writeUInt32BE(buffer.length, 0, true);
            this._writeSoon(header, buffer);
        };
        Protocol.prototype._writeSoon = function (header, data) {
            var _this = this;
            if (this._writeBuffer.add(header, data)) {
                setImmediate(function () {
                    // return early if socket has been destroyed in the meantime
                    if (_this._socket.destroyed) {
                        return;
                    }
                    // we ignore the returned value from `write` because we would have to cached the data
                    // anyways and nodejs is already doing that for us:
                    // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
                    // > However, the false return value is only advisory and the writable stream will unconditionally
                    // > accept and buffer chunk even if it has not not been allowed to drain.
                    _this._socket.write(_this._writeBuffer.take());
                });
            }
        };
        Protocol._headerLen = 4;
        return Protocol;
    }());
    exports.Protocol = Protocol;
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server(server) {
            var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;
            _this.server = server;
            return _this;
        }
        Server.toClientConnectionEvent = function (server) {
            var onConnection = event_1.fromNodeEventEmitter(server, 'connection');
            return event_1.mapEvent(onConnection, function (socket) { return ({
                protocol: new Protocol(socket),
                onDidClientDisconnect: event_1.once(event_1.fromNodeEventEmitter(socket, 'close'))
            }); });
        };
        Server.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.server) {
                this.server.close();
                this.server = null;
            }
        };
        return Server;
    }(ipc_1.IPCServer));
    exports.Server = Server;
    var Client = /** @class */ (function (_super) {
        __extends(Client, _super);
        function Client(protocol, id) {
            var _this = _super.call(this, protocol, id) || this;
            _this.protocol = protocol;
            return _this;
        }
        Client.fromSocket = function (socket, id) {
            return new Client(new Protocol(socket), id);
        };
        Object.defineProperty(Client.prototype, "onClose", {
            get: function () { return this.protocol.onClose; },
            enumerable: true,
            configurable: true
        });
        Client.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.protocol.end();
        };
        return Client;
    }(ipc_1.IPCClient));
    exports.Client = Client;
    function serve(hook) {
        return new Promise(function (c, e) {
            var server = net_1.createServer();
            server.on('error', e);
            server.listen(hook, function () {
                server.removeListener('error', e);
                c(new Server(server));
            });
        });
    }
    exports.serve = serve;
    function connect(hook, clientId) {
        return new Promise(function (c, e) {
            var socket = net_1.createConnection(hook, function () {
                socket.removeListener('error', e);
                c(Client.fromSocket(socket, clientId));
            });
            socket.once('error', e);
        });
    }
    exports.connect = connect;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[52/*vs/base/parts/quickopen/common/quickOpenScorer*/], __M([1/*require*/,0/*exports*/,67/*vs/base/common/comparers*/,115/*vs/base/common/filters*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,5/*vs/base/common/strings*/]), function (require, exports, comparers_1, filters_1, paths_1, platform_1, strings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NO_MATCH = 0;
    var NO_SCORE = [NO_MATCH, []];
    // const DEBUG = false;
    // const DEBUG_MATRIX = false;
    function score(target, query, queryLower, fuzzy) {
        if (!target || !query) {
            return NO_SCORE; // return early if target or query are undefined
        }
        var targetLength = target.length;
        var queryLength = query.length;
        if (targetLength < queryLength) {
            return NO_SCORE; // impossible for query to be contained in target
        }
        // if (DEBUG) {
        // 	console.group(`Target: ${target}, Query: ${query}`);
        // }
        var targetLower = target.toLowerCase();
        // When not searching fuzzy, we require the query to be contained fully
        // in the target string contiguously.
        if (!fuzzy) {
            var indexOfQueryInTarget = targetLower.indexOf(queryLower);
            if (indexOfQueryInTarget === -1) {
                // if (DEBUG) {
                // 	console.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);
                // }
                return NO_SCORE;
            }
        }
        var res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);
        // if (DEBUG) {
        // 	console.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');
        // 	console.groupEnd();
        // }
        return res;
    }
    exports.score = score;
    function doScore(query, queryLower, queryLength, target, targetLower, targetLength) {
        var scores = [];
        var matches = [];
        //
        // Build Scorer Matrix:
        //
        // The matrix is composed of query q and target t. For each index we score
        // q[i] with t[i] and compare that with the previous score. If the score is
        // equal or larger, we keep the match. In addition to the score, we also keep
        // the length of the consecutive matches to use as boost for the score.
        //
        //      t   a   r   g   e   t
        //  q
        //  u
        //  e
        //  r
        //  y
        //
        for (var queryIndex_1 = 0; queryIndex_1 < queryLength; queryIndex_1++) {
            for (var targetIndex_1 = 0; targetIndex_1 < targetLength; targetIndex_1++) {
                var currentIndex = queryIndex_1 * targetLength + targetIndex_1;
                var leftIndex = currentIndex - 1;
                var diagIndex = (queryIndex_1 - 1) * targetLength + targetIndex_1 - 1;
                var leftScore = targetIndex_1 > 0 ? scores[leftIndex] : 0;
                var diagScore = queryIndex_1 > 0 && targetIndex_1 > 0 ? scores[diagIndex] : 0;
                var matchesSequenceLength = queryIndex_1 > 0 && targetIndex_1 > 0 ? matches[diagIndex] : 0;
                // If we are not matching on the first query character any more, we only produce a
                // score if we had a score previously for the last query index (by looking at the diagScore).
                // This makes sure that the query always matches in sequence on the target. For example
                // given a target of "ede" and a query of "de", we would otherwise produce a wrong high score
                // for query[1] ("e") matching on target[0] ("e") because of the "beginning of word" boost.
                var score_1 = void 0;
                if (!diagScore && queryIndex_1 > 0) {
                    score_1 = 0;
                }
                else {
                    score_1 = computeCharScore(query, queryLower, queryIndex_1, target, targetLower, targetIndex_1, matchesSequenceLength);
                }
                // We have a score and its equal or larger than the left score
                // Match: sequence continues growing from previous diag value
                // Score: increases by diag score value
                if (score_1 && diagScore + score_1 >= leftScore) {
                    matches[currentIndex] = matchesSequenceLength + 1;
                    scores[currentIndex] = diagScore + score_1;
                }
                // We either have no score or the score is lower than the left score
                // Match: reset to 0
                // Score: pick up from left hand side
                else {
                    matches[currentIndex] = NO_MATCH;
                    scores[currentIndex] = leftScore;
                }
            }
        }
        // Restore Positions (starting from bottom right of matrix)
        var positions = [];
        var queryIndex = queryLength - 1;
        var targetIndex = targetLength - 1;
        while (queryIndex >= 0 && targetIndex >= 0) {
            var currentIndex = queryIndex * targetLength + targetIndex;
            var match = matches[currentIndex];
            if (match === NO_MATCH) {
                targetIndex--; // go left
            }
            else {
                positions.push(targetIndex);
                // go up and left
                queryIndex--;
                targetIndex--;
            }
        }
        // Print matrix
        // if (DEBUG_MATRIX) {
        // printMatrix(query, target, matches, scores);
        // }
        return [scores[queryLength * targetLength - 1], positions.reverse()];
    }
    function computeCharScore(query, queryLower, queryIndex, target, targetLower, targetIndex, matchesSequenceLength) {
        var score = 0;
        if (queryLower[queryIndex] !== targetLower[targetIndex]) {
            return score; // no match of characters
        }
        // Character match bonus
        score += 1;
        // if (DEBUG) {
        // 	console.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');
        // }
        // Consecutive match bonus
        if (matchesSequenceLength > 0) {
            score += (matchesSequenceLength * 5);
            // if (DEBUG) {
            // 	console.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));
            // }
        }
        // Same case bonus
        if (query[queryIndex] === target[targetIndex]) {
            score += 1;
            // if (DEBUG) {
            // 	console.log('Same case bonus: +1');
            // }
        }
        // Start of word bonus
        if (targetIndex === 0) {
            score += 8;
            // if (DEBUG) {
            // 	console.log('Start of word bonus: +8');
            // }
        }
        else {
            // After separator bonus
            var separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));
            if (separatorBonus) {
                score += separatorBonus;
                // if (DEBUG) {
                // 	console.log('After separtor bonus: +4');
                // }
            }
            // Inside word upper case bonus (camel case)
            else if (filters_1.isUpper(target.charCodeAt(targetIndex))) {
                score += 1;
                // if (DEBUG) {
                // 	console.log('Inside word upper case bonus: +1');
                // }
            }
        }
        // if (DEBUG) {
        // 	console.groupEnd();
        // }
        return score;
    }
    function scoreSeparatorAtPos(charCode) {
        switch (charCode) {
            case 47 /* Slash */:
            case 92 /* Backslash */:
                return 5; // prefer path separators...
            case 95 /* Underline */:
            case 45 /* Dash */:
            case 46 /* Period */:
            case 32 /* Space */:
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
            case 58 /* Colon */:
                return 4; // ...over other separators
            default:
                return 0;
        }
    }
    var NO_ITEM_SCORE = Object.freeze({ score: 0 });
    var PATH_IDENTITY_SCORE = 1 << 18;
    var LABEL_PREFIX_SCORE = 1 << 17;
    var LABEL_CAMELCASE_SCORE = 1 << 16;
    var LABEL_SCORE_THRESHOLD = 1 << 15;
    /**
     * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.
     */
    function prepareQuery(original) {
        var lowercase;
        var containsPathSeparator;
        var value;
        if (original) {
            value = strings_1.stripWildcards(original).replace(/\s/g, ''); // get rid of all wildcards and whitespace
            if (platform_1.isWindows) {
                value = value.replace(/\//g, paths_1.nativeSep); // Help Windows users to search for paths when using slash
            }
            lowercase = value.toLowerCase();
            containsPathSeparator = value.indexOf(paths_1.nativeSep) >= 0;
        }
        return { original: original, value: value, lowercase: lowercase, containsPathSeparator: containsPathSeparator };
    }
    exports.prepareQuery = prepareQuery;
    function scoreItem(item, query, fuzzy, accessor, cache) {
        if (!item || !query.value) {
            return NO_ITEM_SCORE; // we need an item and query to score on at least
        }
        var label = accessor.getItemLabel(item);
        if (!label) {
            return NO_ITEM_SCORE; // we need a label at least
        }
        var description = accessor.getItemDescription(item);
        var cacheHash;
        if (description) {
            cacheHash = "" + label + description + query.value + fuzzy;
        }
        else {
            cacheHash = "" + label + query.value + fuzzy;
        }
        var cached = cache[cacheHash];
        if (cached) {
            return cached;
        }
        var itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);
        cache[cacheHash] = itemScore;
        return itemScore;
    }
    exports.scoreItem = scoreItem;
    function doScoreItem(label, description, path, query, fuzzy) {
        // 1.) treat identity matches on full path highest
        if (path && platform_1.isLinux ? query.original === path : strings_1.equalsIgnoreCase(query.original, path)) {
            return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : void 0 };
        }
        // We only consider label matches if the query is not including file path separators
        var preferLabelMatches = !path || !query.containsPathSeparator;
        if (preferLabelMatches) {
            // 2.) treat prefix matches on the label second highest
            var prefixLabelMatch = filters_1.matchesPrefix(query.value, label);
            if (prefixLabelMatch) {
                return { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };
            }
            // 3.) treat camelcase matches on the label third highest
            var camelcaseLabelMatch = filters_1.matchesCamelCase(query.value, label);
            if (camelcaseLabelMatch) {
                return { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };
            }
            // 4.) prefer scores on the label if any
            var _a = score(label, query.value, query.lowercase, fuzzy), labelScore = _a[0], labelPositions = _a[1];
            if (labelScore) {
                return { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: filters_1.createMatches(labelPositions) };
            }
        }
        // 5.) finally compute description + label scores if we have a description
        if (description) {
            var descriptionPrefix = description;
            if (!!path) {
                descriptionPrefix = "" + description + paths_1.nativeSep; // assume this is a file path
            }
            var descriptionPrefixLength_1 = descriptionPrefix.length;
            var descriptionAndLabel = "" + descriptionPrefix + label;
            var _b = score(descriptionAndLabel, query.value, query.lowercase, fuzzy), labelDescriptionScore = _b[0], labelDescriptionPositions = _b[1];
            if (labelDescriptionScore) {
                var labelDescriptionMatches = filters_1.createMatches(labelDescriptionPositions);
                var labelMatch_1 = [];
                var descriptionMatch_1 = [];
                // We have to split the matches back onto the label and description portions
                labelDescriptionMatches.forEach(function (h) {
                    // Match overlaps label and description part, we need to split it up
                    if (h.start < descriptionPrefixLength_1 && h.end > descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: 0, end: h.end - descriptionPrefixLength_1 });
                        descriptionMatch_1.push({ start: h.start, end: descriptionPrefixLength_1 });
                    }
                    // Match on label part
                    else if (h.start >= descriptionPrefixLength_1) {
                        labelMatch_1.push({ start: h.start - descriptionPrefixLength_1, end: h.end - descriptionPrefixLength_1 });
                    }
                    // Match on description part
                    else {
                        descriptionMatch_1.push(h);
                    }
                });
                return { score: labelDescriptionScore, labelMatch: labelMatch_1, descriptionMatch: descriptionMatch_1 };
            }
        }
        return NO_ITEM_SCORE;
    }
    function compareItemsByScore(itemA, itemB, query, fuzzy, accessor, cache, fallbackComparer) {
        if (fallbackComparer === void 0) { fallbackComparer = fallbackCompare; }
        var itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);
        var itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);
        var scoreA = itemScoreA.score;
        var scoreB = itemScoreB.score;
        // 1.) prefer identity matches
        if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;
            }
        }
        // 2.) prefer label prefix matches
        if (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_PREFIX_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer shorter names when both match on label prefix
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 3.) prefer camelcase matches
        if (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {
            if (scoreA !== scoreB) {
                return scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;
            }
            var labelA = accessor.getItemLabel(itemA);
            var labelB = accessor.getItemLabel(itemB);
            // prefer more compact camel case matches over longer
            var comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);
            if (comparedByMatchLength !== 0) {
                return comparedByMatchLength;
            }
            // prefer shorter names when both match on label camelcase
            if (labelA.length !== labelB.length) {
                return labelA.length - labelB.length;
            }
        }
        // 4.) prefer label scores
        if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {
            if (scoreB < LABEL_SCORE_THRESHOLD) {
                return -1;
            }
            if (scoreA < LABEL_SCORE_THRESHOLD) {
                return 1;
            }
        }
        // 5.) compare by score
        if (scoreA !== scoreB) {
            return scoreA > scoreB ? -1 : 1;
        }
        // 6.) scores are identical, prefer more compact matches (label and description)
        var itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);
        var itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);
        if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {
            return itemBMatchDistance > itemAMatchDistance ? -1 : 1;
        }
        // 7.) at this point, scores are identical and match compactness as well
        // for both items so we start to use the fallback compare
        return fallbackComparer(itemA, itemB, query, accessor);
    }
    exports.compareItemsByScore = compareItemsByScore;
    function computeLabelAndDescriptionMatchDistance(item, score, accessor) {
        var hasLabelMatches = (score.labelMatch && score.labelMatch.length);
        var hasDescriptionMatches = (score.descriptionMatch && score.descriptionMatch.length);
        var matchStart = -1;
        var matchEnd = -1;
        // If we have description matches, the start is first of description match
        if (hasDescriptionMatches) {
            matchStart = score.descriptionMatch[0].start;
        }
        // Otherwise, the start is the first label match
        else if (hasLabelMatches) {
            matchStart = score.labelMatch[0].start;
        }
        // If we have label match, the end is the last label match
        // If we had a description match, we add the length of the description
        // as offset to the end to indicate this.
        if (hasLabelMatches) {
            matchEnd = score.labelMatch[score.labelMatch.length - 1].end;
            if (hasDescriptionMatches) {
                var itemDescription = accessor.getItemDescription(item);
                if (itemDescription) {
                    matchEnd += itemDescription.length;
                }
            }
        }
        // If we have just a description match, the end is the last description match
        else if (hasDescriptionMatches) {
            matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;
        }
        return matchEnd - matchStart;
    }
    function compareByMatchLength(matchesA, matchesB) {
        if ((!matchesA && !matchesB) || (!matchesA.length && !matchesB.length)) {
            return 0; // make sure to not cause bad comparing when matches are not provided
        }
        if (!matchesB || !matchesB.length) {
            return -1;
        }
        if (!matchesA || !matchesA.length) {
            return 1;
        }
        // Compute match length of A (first to last match)
        var matchStartA = matchesA[0].start;
        var matchEndA = matchesA[matchesA.length - 1].end;
        var matchLengthA = matchEndA - matchStartA;
        // Compute match length of B (first to last match)
        var matchStartB = matchesB[0].start;
        var matchEndB = matchesB[matchesB.length - 1].end;
        var matchLengthB = matchEndB - matchStartB;
        // Prefer shorter match length
        return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;
    }
    function fallbackCompare(itemA, itemB, query, accessor) {
        // check for label + description length and prefer shorter
        var labelA = accessor.getItemLabel(itemA);
        var labelB = accessor.getItemLabel(itemB);
        var descriptionA = accessor.getItemDescription(itemA);
        var descriptionB = accessor.getItemDescription(itemB);
        var labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);
        var labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);
        if (labelDescriptionALength !== labelDescriptionBLength) {
            return labelDescriptionALength - labelDescriptionBLength;
        }
        // check for path length and prefer shorter
        var pathA = accessor.getItemPath(itemA);
        var pathB = accessor.getItemPath(itemB);
        if (pathA && pathB && pathA.length !== pathB.length) {
            return pathA.length - pathB.length;
        }
        // 7.) finally we have equal scores and equal length, we fallback to comparer
        // compare by label
        if (labelA !== labelB) {
            return comparers_1.compareAnything(labelA, labelB, query.value);
        }
        // compare by description
        if (descriptionA && descriptionB && descriptionA !== descriptionB) {
            return comparers_1.compareAnything(descriptionA, descriptionB, query.value);
        }
        // compare by path
        if (pathA && pathB && pathA !== pathB) {
            return comparers_1.compareAnything(pathA, pathB, query.value);
        }
        // equal
        return 0;
    }
    exports.fallbackCompare = fallbackCompare;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[42/*vs/editor/common/core/position*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A position in the editor.
     */
    var Position = /** @class */ (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        /**
         * Create a new postion from this position.
         *
         * @param newLineNumber new line number
         * @param newColumn new column
         */
        Position.prototype.with = function (newLineNumber, newColumn) {
            if (newLineNumber === void 0) { newLineNumber = this.lineNumber; }
            if (newColumn === void 0) { newColumn = this.column; }
            if (newLineNumber === this.lineNumber && newColumn === this.column) {
                return this;
            }
            else {
                return new Position(newLineNumber, newColumn);
            }
        };
        /**
         * Derive a new position from this position.
         *
         * @param deltaLineNumber line number delta
         * @param deltaColumn column delta
         */
        Position.prototype.delta = function (deltaLineNumber, deltaColumn) {
            if (deltaLineNumber === void 0) { deltaLineNumber = 0; }
            if (deltaColumn === void 0) { deltaColumn = 0; }
            return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
        };
        /**
         * Test if this position equals other position
         */
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        /**
         * Test if position `a` equals position `b`
         */
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be false.
         */
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be true.
         */
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        /**
         * A function that compares positions, useful for sorting
         */
        Position.compare = function (a, b) {
            var aLineNumber = a.lineNumber | 0;
            var bLineNumber = b.lineNumber | 0;
            if (aLineNumber === bLineNumber) {
                var aColumn = a.column | 0;
                var bColumn = b.column | 0;
                return aColumn - bColumn;
            }
            return aLineNumber - bLineNumber;
        };
        /**
         * Clone this position.
         */
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        /**
         * Convert to a human-readable representation.
         */
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        /**
         * Create a `Position` from an `IPosition`.
         */
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        /**
         * Test if `obj` is an `IPosition`.
         */
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[53/*vs/editor/common/core/range*/], __M([1/*require*/,0/*exports*/,42/*vs/editor/common/core/position*/]), function (require, exports, position_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
     */
    var Range = /** @class */ (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        /**
         * Test if this range is empty.
         */
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        /**
         * Test if `range` is empty.
         */
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        /**
         * Test if `position` is in `range`. If the position is at the edges, will return true.
         */
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        /**
         * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
         */
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.plusRange = function (a, b) {
            var startLineNumber;
            var startColumn;
            var endLineNumber;
            var endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber;
            var resultStartColumn = a.startColumn;
            var resultEndLineNumber = a.endLineNumber;
            var resultEndColumn = a.endColumn;
            var otherStartLineNumber = b.startLineNumber;
            var otherStartColumn = b.startColumn;
            var otherEndLineNumber = b.endLineNumber;
            var otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        /**
         * Test if this range equals other.
         */
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        /**
         * Test if range `a` equals `b`.
         */
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        /**
         * Transform to a user presentable string representation.
         */
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        /**
         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
         */
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        /**
         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
         */
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.prototype.collapseToStart = function () {
            return Range.collapseToStart(this);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.collapseToStart = function (range) {
            return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        };
        // ---
        Range.fromPositions = function (start, end) {
            if (end === void 0) { end = start; }
            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        /**
         * Test if `obj` is an `IRange`.
         */
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        /**
         * Test if the two ranges are touching in any way.
         */
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * Test if the two ranges are intersecting. If the ranges are touching it returns true.
         */
        Range.areIntersecting = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            if (a && b) {
                var aStartLineNumber = a.startLineNumber | 0;
                var bStartLineNumber = b.startLineNumber | 0;
                if (aStartLineNumber === bStartLineNumber) {
                    var aStartColumn = a.startColumn | 0;
                    var bStartColumn = b.startColumn | 0;
                    if (aStartColumn === bStartColumn) {
                        var aEndLineNumber = a.endLineNumber | 0;
                        var bEndLineNumber = b.endLineNumber | 0;
                        if (aEndLineNumber === bEndLineNumber) {
                            var aEndColumn = a.endColumn | 0;
                            var bEndColumn = b.endColumn | 0;
                            return aEndColumn - bEndColumn;
                        }
                        return aEndLineNumber - bEndLineNumber;
                    }
                    return aStartColumn - bStartColumn;
                }
                return aStartLineNumber - bStartLineNumber;
            }
            var aExists = (a ? 1 : 0);
            var bExists = (b ? 1 : 0);
            return aExists - bExists;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        /**
         * Test if the range spans multiple lines.
         */
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        return Range;
    }());
    exports.Range = Range;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[123/*vs/editor/common/core/selection*/], __M([1/*require*/,0/*exports*/,42/*vs/editor/common/core/position*/,53/*vs/editor/common/core/range*/]), function (require, exports, position_1, range_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The direction of a selection.
     */
    var SelectionDirection;
    (function (SelectionDirection) {
        /**
         * The selection starts above where it ends.
         */
        SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
        /**
         * The selection starts below where it ends.
         */
        SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
    })(SelectionDirection = exports.SelectionDirection || (exports.SelectionDirection = {}));
    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    var Selection = /** @class */ (function (_super) {
        __extends(Selection, _super);
        function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            var _this = _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) || this;
            _this.selectionStartLineNumber = selectionStartLineNumber;
            _this.selectionStartColumn = selectionStartColumn;
            _this.positionLineNumber = positionLineNumber;
            _this.positionColumn = positionColumn;
            return _this;
        }
        /**
         * Clone this selection.
         */
        Selection.prototype.clone = function () {
            return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);
        };
        /**
         * Transform to a human-readable representation.
         */
        Selection.prototype.toString = function () {
            return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
        };
        /**
         * Test if equals other selection.
         */
        Selection.prototype.equalsSelection = function (other) {
            return (Selection.selectionsEqual(this, other));
        };
        /**
         * Test if the two selections are equal.
         */
        Selection.selectionsEqual = function (a, b) {
            return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
                a.selectionStartColumn === b.selectionStartColumn &&
                a.positionLineNumber === b.positionLineNumber &&
                a.positionColumn === b.positionColumn);
        };
        /**
         * Get directions (LTR or RTL).
         */
        Selection.prototype.getDirection = function () {
            if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
                return 0 /* LTR */;
            }
            return 1 /* RTL */;
        };
        /**
         * Create a new selection with a different `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
            if (this.getDirection() === 0 /* LTR */) {
                return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        };
        /**
         * Get the position at `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.getPosition = function () {
            return new position_1.Position(this.positionLineNumber, this.positionColumn);
        };
        /**
         * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
         */
        Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
            if (this.getDirection() === 0 /* LTR */) {
                return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
            }
            return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        };
        // ----
        /**
         * Create a `Selection` from one or two positions
         */
        Selection.fromPositions = function (start, end) {
            if (end === void 0) { end = start; }
            return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        /**
         * Create a `Selection` from an `ISelection`.
         */
        Selection.liftSelection = function (sel) {
            return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        };
        /**
         * `a` equals `b`.
         */
        Selection.selectionsArrEqual = function (a, b) {
            if (a && !b || !a && b) {
                return false;
            }
            if (!a && !b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0, len = a.length; i < len; i++) {
                if (!this.selectionsEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Test if `obj` is an `ISelection`.
         */
        Selection.isISelection = function (obj) {
            return (obj
                && (typeof obj.selectionStartLineNumber === 'number')
                && (typeof obj.selectionStartColumn === 'number')
                && (typeof obj.positionLineNumber === 'number')
                && (typeof obj.positionColumn === 'number'));
        };
        /**
         * Create with a direction.
         */
        Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
            if (direction === 0 /* LTR */) {
                return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        };
        return Selection;
    }(range_1.Range));
    exports.Selection = Selection;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[93/*vs/editor/common/core/uint*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Uint8Matrix = /** @class */ (function () {
        function Uint8Matrix(rows, cols, defaultValue) {
            var data = new Uint8Array(rows * cols);
            for (var i = 0, len = rows * cols; i < len; i++) {
                data[i] = defaultValue;
            }
            this._data = data;
            this.rows = rows;
            this.cols = cols;
        }
        Uint8Matrix.prototype.get = function (row, col) {
            return this._data[row * this.cols + col];
        };
        Uint8Matrix.prototype.set = function (row, col, value) {
            this._data[row * this.cols + col] = value;
        };
        return Uint8Matrix;
    }());
    exports.Uint8Matrix = Uint8Matrix;
    var Constants;
    (function (Constants) {
        /**
         * MAX SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
        /**
         * MIN SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
        /**
         * Max unsigned integer that fits on 8 bits.
         */
        Constants[Constants["MAX_UINT_8"] = 255] = "MAX_UINT_8";
        /**
         * Max unsigned integer that fits on 16 bits.
         */
        Constants[Constants["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
        /**
         * Max unsigned integer that fits on 32 bits.
         */
        Constants[Constants["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
    })(Constants = exports.Constants || (exports.Constants = {}));
    function toUint8(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 255 /* MAX_UINT_8 */) {
            return 255 /* MAX_UINT_8 */;
        }
        return v | 0;
    }
    exports.toUint8 = toUint8;
    function toUint32(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 4294967295 /* MAX_UINT_32 */) {
            return 4294967295 /* MAX_UINT_32 */;
        }
        return v | 0;
    }
    exports.toUint32 = toUint32;
    function toUint32Array(arr) {
        var len = arr.length;
        var r = new Uint32Array(len);
        for (var i = 0; i < len; i++) {
            r[i] = toUint32(arr[i]);
        }
        return r;
    }
    exports.toUint32Array = toUint32Array;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[99/*vs/editor/common/model*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    var OverviewRulerLane;
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(OverviewRulerLane = exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    /**
     * End of line character preference.
     */
    var EndOfLinePreference;
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(EndOfLinePreference = exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    /**
     * The default end of line to use when instantiating models.
     */
    var DefaultEndOfLine;
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(DefaultEndOfLine = exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    /**
     * End of line character preference.
     */
    var EndOfLineSequence;
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(EndOfLineSequence = exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var TextModelResolvedOptions = /** @class */ (function () {
        /**
         * @internal
         */
        function TextModelResolvedOptions(src) {
            this.tabSize = src.tabSize | 0;
            this.insertSpaces = Boolean(src.insertSpaces);
            this.defaultEOL = src.defaultEOL | 0;
            this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        }
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.equals = function (other) {
            return (this.tabSize === other.tabSize
                && this.insertSpaces === other.insertSpaces
                && this.defaultEOL === other.defaultEOL
                && this.trimAutoWhitespace === other.trimAutoWhitespace);
        };
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                tabSize: this.tabSize !== newOpts.tabSize,
                insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
                trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
            };
        };
        return TextModelResolvedOptions;
    }());
    exports.TextModelResolvedOptions = TextModelResolvedOptions;
    var FindMatch = /** @class */ (function () {
        /**
         * @internal
         */
        function FindMatch(range, matches) {
            this.range = range;
            this.matches = matches;
        }
        return FindMatch;
    }());
    exports.FindMatch = FindMatch;
    /**
     * Describes the behavior of decorations when typing/editing near their edges.
     * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
     */
    var TrackedRangeStickiness;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(TrackedRangeStickiness = exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    /**
     * @internal
     */
    var ApplyEditsResult = /** @class */ (function () {
        function ApplyEditsResult(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {
            this.reverseEdits = reverseEdits;
            this.changes = changes;
            this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;
        }
        return ApplyEditsResult;
    }());
    exports.ApplyEditsResult = ApplyEditsResult;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[54/*vs/editor/common/model/wordHelper*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    /**
     * Create a word definition regular expression based on default word separators.
     * Optionally provide allowed separators that should be included in words.
     *
     * The default would look like this:
     * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        var source = '(-?\\d*\\.\\d\\w*)|([^';
        for (var i = 0; i < exports.USUAL_WORD_SEPARATORS.length; i++) {
            if (allowInWords.indexOf(exports.USUAL_WORD_SEPARATORS[i]) >= 0) {
                continue;
            }
            source += '\\' + exports.USUAL_WORD_SEPARATORS[i];
        }
        source += '\\s]+)';
        return new RegExp(source, 'g');
    }
    // catches numbers (including floating numbers) in the first group, and alphanum in the second
    exports.DEFAULT_WORD_REGEXP = createWordRegExp();
    function ensureValidWordDefinition(wordDefinition) {
        var result = exports.DEFAULT_WORD_REGEXP;
        if (wordDefinition && (wordDefinition instanceof RegExp)) {
            if (!wordDefinition.global) {
                var flags = 'g';
                if (wordDefinition.ignoreCase) {
                    flags += 'i';
                }
                if (wordDefinition.multiline) {
                    flags += 'm';
                }
                result = new RegExp(wordDefinition.source, flags);
            }
            else {
                result = wordDefinition;
            }
        }
        result.lastIndex = 0;
        return result;
    }
    exports.ensureValidWordDefinition = ensureValidWordDefinition;
    function getWordAtPosFast(column, wordDefinition, text, textOffset) {
        // find whitespace enclosed text around column and match from there
        var pos = column - 1 - textOffset;
        var start = text.lastIndexOf(' ', pos - 1) + 1;
        var end = text.indexOf(' ', pos);
        if (end === -1) {
            end = text.length;
        }
        wordDefinition.lastIndex = start;
        var match;
        while (match = wordDefinition.exec(text)) {
            var matchIndex = match.index || 0;
            if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + matchIndex,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
        // matches all words starting at the beginning
        // of the input until it finds a match that encloses
        // the desired column. slow but correct
        var pos = column - 1 - textOffset;
        wordDefinition.lastIndex = 0;
        var match;
        while (match = wordDefinition.exec(text)) {
            var matchIndex = match.index || 0;
            if (matchIndex > pos) {
                // |nW -> matched only after the pos
                return null;
            }
            else if (wordDefinition.lastIndex >= pos) {
                // W|W -> match encloses pos
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + matchIndex,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtText(column, wordDefinition, text, textOffset) {
        // if `words` can contain whitespace character we have to use the slow variant
        // otherwise we use the fast variant of finding a word
        wordDefinition.lastIndex = 0;
        var match = wordDefinition.exec(text);
        if (!match) {
            return null;
        }
        // todo@joh the `match` could already be the (first) word
        var ret = match[0].indexOf(' ') >= 0
            // did match a word which contains a space character -> use slow word find
            ? getWordAtPosSlow(column, wordDefinition, text, textOffset)
            // sane word definition -> use fast word find
            : getWordAtPosFast(column, wordDefinition, text, textOffset);
        // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
        // in an undefined state and to not confuse other users of the wordDefinition
        // we reset the lastIndex
        wordDefinition.lastIndex = 0;
        return ret;
    }
    exports.getWordAtText = getWordAtText;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[103/*vs/editor/common/modes/languageConfiguration*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    var IndentAction;
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(IndentAction = exports.IndentAction || (exports.IndentAction = {}));
    /**
     * @internal
     */
    var StandardAutoClosingPairConditional = /** @class */ (function () {
        function StandardAutoClosingPairConditional(source) {
            this.open = source.open;
            this.close = source.close;
            // initially allowed in all tokens
            this._standardTokenMask = 0;
            if (Array.isArray(source.notIn)) {
                for (var i = 0, len = source.notIn.length; i < len; i++) {
                    var notIn = source.notIn[i];
                    switch (notIn) {
                        case 'string':
                            this._standardTokenMask |= 2 /* String */;
                            break;
                        case 'comment':
                            this._standardTokenMask |= 1 /* Comment */;
                            break;
                        case 'regex':
                            this._standardTokenMask |= 4 /* RegEx */;
                            break;
                    }
                }
            }
        }
        StandardAutoClosingPairConditional.prototype.isOK = function (standardToken) {
            return (this._standardTokenMask & standardToken) === 0;
        };
        return StandardAutoClosingPairConditional;
    }());
    exports.StandardAutoClosingPairConditional = StandardAutoClosingPairConditional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[55/*vs/editor/common/modes/languageSelector*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/glob*/]), function (require, exports, glob_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized) {
        if (Array.isArray(selector)) {
            // array -> take max individual value
            var ret = 0;
            for (var _i = 0, selector_1 = selector; _i < selector_1.length; _i++) {
                var filter = selector_1[_i];
                var value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized);
                if (value === 10) {
                    return value; // already at the highest
                }
                if (value > ret) {
                    ret = value;
                }
            }
            return ret;
        }
        else if (typeof selector === 'string') {
            if (!candidateIsSynchronized) {
                return 0;
            }
            // short-hand notion, desugars to
            // 'fooLang' -> { language: 'fooLang'}
            // '*' -> { language: '*' }
            if (selector === '*') {
                return 5;
            }
            else if (selector === candidateLanguage) {
                return 10;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            // filter -> select accordingly, use defaults for scheme
            var language = selector.language, pattern = selector.pattern, scheme = selector.scheme, hasAccessToAllModels = selector.hasAccessToAllModels;
            if (!candidateIsSynchronized && !hasAccessToAllModels) {
                return 0;
            }
            var ret = 0;
            if (scheme) {
                if (scheme === candidateUri.scheme) {
                    ret = 10;
                }
                else if (scheme === '*') {
                    ret = 5;
                }
                else {
                    return 0;
                }
            }
            if (language) {
                if (language === candidateLanguage) {
                    ret = 10;
                }
                else if (language === '*') {
                    ret = Math.max(ret, 5);
                }
                else {
                    return 0;
                }
            }
            if (pattern) {
                if (pattern === candidateUri.fsPath || glob_1.match(pattern, candidateUri.fsPath)) {
                    ret = 10;
                }
                else {
                    return 0;
                }
            }
            return ret;
        }
        else {
            return 0;
        }
    }
    exports.score = score;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[105/*vs/editor/common/modes/tokenizationRegistry*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/]), function (require, exports, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenizationRegistryImpl = /** @class */ (function () {
        function TokenizationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._map = Object.create(null);
            this._promises = Object.create(null);
            this._colorMap = null;
        }
        TokenizationRegistryImpl.prototype.fire = function (languages) {
            this._onDidChange.fire({
                changedLanguages: languages,
                changedColorMap: false
            });
        };
        TokenizationRegistryImpl.prototype.register = function (language, support) {
            var _this = this;
            this._map[language] = support;
            this.fire([language]);
            return lifecycle_1.toDisposable(function () {
                if (_this._map[language] !== support) {
                    return;
                }
                delete _this._map[language];
                _this.fire([language]);
            });
        };
        TokenizationRegistryImpl.prototype.registerPromise = function (language, supportPromise) {
            var _this = this;
            var promise = this._promises[language] = supportPromise.then(function (support) {
                delete _this._promises[language];
                return _this.register(language, support);
            });
            return promise;
        };
        TokenizationRegistryImpl.prototype.getPromise = function (language) {
            var _this = this;
            var support = this.get(language);
            if (support) {
                return Promise.resolve(support);
            }
            var promise = this._promises[language];
            if (promise) {
                return promise.then(function (_) { return _this.get(language); });
            }
            return null;
        };
        TokenizationRegistryImpl.prototype.get = function (language) {
            return (this._map[language] || null);
        };
        TokenizationRegistryImpl.prototype.setColorMap = function (colorMap) {
            this._colorMap = colorMap;
            this._onDidChange.fire({
                changedLanguages: Object.keys(this._map),
                changedColorMap: true
            });
        };
        TokenizationRegistryImpl.prototype.getColorMap = function () {
            return this._colorMap;
        };
        TokenizationRegistryImpl.prototype.getDefaultBackground = function () {
            if (this._colorMap && this._colorMap.length > 2 /* DefaultBackground */) {
                return this._colorMap[2 /* DefaultBackground */];
            }
            return null;
        };
        return TokenizationRegistryImpl;
    }());
    exports.TokenizationRegistryImpl = TokenizationRegistryImpl;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[106/*vs/editor/common/viewModel/prefixSumComputer*/], __M([1/*require*/,0/*exports*/,93/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PrefixSumIndexOfResult = /** @class */ (function () {
        function PrefixSumIndexOfResult(index, remainder) {
            this.index = index;
            this.remainder = remainder;
        }
        return PrefixSumIndexOfResult;
    }());
    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
    var PrefixSumComputer = /** @class */ (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = new Uint32Array(values.length);
            this.prefixSumValidIndex = new Int32Array(1);
            this.prefixSumValidIndex[0] = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {
            insertIndex = uint_1.toUint32(insertIndex);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            var insertValuesLen = insertValues.length;
            if (insertValuesLen === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length + insertValuesLen);
            this.values.set(oldValues.subarray(0, insertIndex), 0);
            this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
            this.values.set(insertValues, insertIndex);
            if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = insertIndex - 1;
            }
            this.prefixSum = new Uint32Array(this.values.length);
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            index = uint_1.toUint32(index);
            value = uint_1.toUint32(value);
            if (this.values[index] === value) {
                return false;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = index - 1;
            }
            return true;
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            startIndex = uint_1.toUint32(startIndex);
            cnt = uint_1.toUint32(cnt);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            if (startIndex >= oldValues.length) {
                return false;
            }
            var maxCnt = oldValues.length - startIndex;
            if (cnt >= maxCnt) {
                cnt = maxCnt;
            }
            if (cnt === 0) {
                return false;
            }
            this.values = new Uint32Array(oldValues.length - cnt);
            this.values.set(oldValues.subarray(0, startIndex), 0);
            this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
            this.prefixSum = new Uint32Array(this.values.length);
            if (startIndex - 1 < this.prefixSumValidIndex[0]) {
                this.prefixSumValidIndex[0] = startIndex - 1;
            }
            if (this.prefixSumValidIndex[0] >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
            }
            return true;
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this._getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            if (index < 0) {
                return 0;
            }
            index = uint_1.toUint32(index);
            return this._getAccumulatedValue(index);
        };
        PrefixSumComputer.prototype._getAccumulatedValue = function (index) {
            if (index <= this.prefixSumValidIndex[0]) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex[0] + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            // Compute all sums (to get a fully valid prefixSum)
            this.getTotalValue();
            var low = 0;
            var high = this.values.length - 1;
            var mid = 0;
            var midStop = 0;
            var midStart = 0;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.prefixSum[mid];
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
    var PrefixSumComputerWithCache = /** @class */ (function () {
        function PrefixSumComputerWithCache(values) {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
            this._actual = new PrefixSumComputer(values);
            this._bustCache();
        }
        PrefixSumComputerWithCache.prototype._bustCache = function () {
            this._cacheAccumulatedValueStart = 0;
            this._cache = null;
        };
        PrefixSumComputerWithCache.prototype.insertValues = function (insertIndex, insertValues) {
            if (this._actual.insertValues(insertIndex, insertValues)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.changeValue = function (index, value) {
            if (this._actual.changeValue(index, value)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.removeValues = function (startIndex, cnt) {
            if (this._actual.removeValues(startIndex, cnt)) {
                this._bustCache();
            }
        };
        PrefixSumComputerWithCache.prototype.getTotalValue = function () {
            return this._actual.getTotalValue();
        };
        PrefixSumComputerWithCache.prototype.getAccumulatedValue = function (index) {
            return this._actual.getAccumulatedValue(index);
        };
        PrefixSumComputerWithCache.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            if (this._cache !== null) {
                var cacheIndex = accumulatedValue - this._cacheAccumulatedValueStart;
                if (cacheIndex >= 0 && cacheIndex < this._cache.length) {
                    // Cache hit!
                    return this._cache[cacheIndex];
                }
            }
            // Cache miss!
            return this._actual.getIndexOf(accumulatedValue);
        };
        /**
         * Gives a hint that a lot of requests are about to come in for these accumulated values.
         */
        PrefixSumComputerWithCache.prototype.warmUpCache = function (accumulatedValueStart, accumulatedValueEnd) {
            var newCache = [];
            for (var accumulatedValue = accumulatedValueStart; accumulatedValue <= accumulatedValueEnd; accumulatedValue++) {
                newCache[accumulatedValue - accumulatedValueStart] = this.getIndexOf(accumulatedValue);
            }
            this._cache = newCache;
            this._cacheAccumulatedValueStart = accumulatedValueStart;
        };
        return PrefixSumComputerWithCache;
    }());
    exports.PrefixSumComputerWithCache = PrefixSumComputerWithCache;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[113/*vs/editor/common/model/mirrorTextModel*/], __M([1/*require*/,0/*exports*/,42/*vs/editor/common/core/position*/,106/*vs/editor/common/viewModel/prefixSumComputer*/]), function (require, exports, position_1, prefixSumComputer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MirrorTextModel = /** @class */ (function () {
        function MirrorTextModel(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
            this._lineStarts = null;
        }
        MirrorTextModel.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorTextModel.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorTextModel.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorTextModel.prototype.onEvents = function (e) {
            if (e.eol && e.eol !== this._eol) {
                this._eol = e.eol;
                this._lineStarts = null;
            }
            // Update my lines
            var changes = e.changes;
            for (var i = 0, len = changes.length; i < len; i++) {
                var change = changes[i];
                this._acceptDeleteRange(change.range);
                this._acceptInsertText(new position_1.Position(change.range.startLineNumber, change.range.startColumn), change.text);
            }
            this._versionId = e.versionId;
        };
        MirrorTextModel.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var eolLength = this._eol.length;
                var linesLength = this._lines.length;
                var lineStartValues = new Uint32Array(linesLength);
                for (var i = 0; i < linesLength; i++) {
                    lineStartValues[i] = this._lines[i].length + eolLength;
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorTextModel.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorTextModel.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorTextModel.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Uint32Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorTextModel;
    }());
    exports.MirrorTextModel = MirrorTextModel;
});

define(__m[114/*vs/nls!vs/base/common/errorMessage*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/errorMessage", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[35/*vs/base/common/errorMessage*/], __M([1/*require*/,0/*exports*/,114/*vs/nls!vs/base/common/errorMessage*/,18/*vs/base/common/types*/,9/*vs/base/common/arrays*/]), function (require, exports, nls, types, arrays) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function exceptionToErrorMessage(exception, verbose) {
        if (exception.message) {
            if (verbose && (exception.stack || exception.stacktrace)) {
                return nls.localize(0, null, detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);
            }
            return detectSystemErrorMessage(exception);
        }
        return nls.localize(1, null);
    }
    function detectSystemErrorMessage(exception) {
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize(2, null, exception.message);
        }
        return exception.message;
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     *
     * @returns A string containing the error message.
     */
    function toErrorMessage(error, verbose) {
        if (error === void 0) { error = null; }
        if (verbose === void 0) { verbose = false; }
        if (!error) {
            return nls.localize(3, null);
        }
        if (Array.isArray(error)) {
            var errors = arrays.coalesce(error);
            var msg = toErrorMessage(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize(4, null, msg, errors.length);
            }
            return msg;
        }
        if (types.isString(error)) {
            return error;
        }
        if (error.detail) {
            var detail = error.detail;
            if (detail.error) {
                return exceptionToErrorMessage(detail.error, verbose);
            }
            if (detail.exception) {
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize(5, null);
    }
    exports.toErrorMessage = toErrorMessage;
});

define(__m[138/*vs/nls!vs/base/common/severity*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[29/*vs/base/common/severity*/], __M([1/*require*/,0/*exports*/,138/*vs/nls!vs/base/common/severity*/,5/*vs/base/common/strings*/]), function (require, exports, nls, strings) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        var _error = 'error';
        var _warning = 'warning';
        var _warn = 'warn';
        var _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
    })(Severity || (Severity = {}));
    exports.default = Severity;
});

define(__m[145/*vs/nls!vs/base/node/processes*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/base/node/processes", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[149/*vs/base/node/processes*/], __M([1/*require*/,0/*exports*/,10/*path*/,25/*child_process*/,145/*vs/nls!vs/base/node/processes*/,20/*vs/base/common/winjs.base*/,18/*vs/base/common/types*/,13/*vs/base/common/objects*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,144/*vs/base/node/decoder*/,28/*vs/base/common/amd*/]), function (require, exports, path, cp, nls, winjs_base_1, Types, Objects, TPath, Platform, decoder_1, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getWindowsCode(status) {
        switch (status) {
            case 0:
                return 0 /* Success */;
            case 1:
                return 2 /* AccessDenied */;
            case 128:
                return 3 /* ProcessNotFound */;
            default:
                return 1 /* Unknown */;
        }
    }
    function terminateProcess(process, cwd) {
        if (Platform.isWindows) {
            try {
                var options = {
                    stdio: ['pipe', 'pipe', 'ignore']
                };
                if (cwd) {
                    options.cwd = cwd;
                }
                cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            }
            catch (err) {
                return { success: false, error: err, code: err.status ? getWindowsCode(err.status) : 1 /* Unknown */ };
            }
        }
        else if (Platform.isLinux || Platform.isMacintosh) {
            try {
                var cmd = amd_1.getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');
                var result = cp.spawnSync(cmd, [process.pid.toString()]);
                if (result.error) {
                    return { success: false, error: result.error };
                }
            }
            catch (err) {
                return { success: false, error: err };
            }
        }
        else {
            process.kill('SIGKILL');
        }
        return { success: true };
    }
    exports.terminateProcess = terminateProcess;
    function getWindowsShell() {
        return process.env['comspec'] || 'cmd.exe';
    }
    exports.getWindowsShell = getWindowsShell;
    var AbstractProcess = /** @class */ (function () {
        function AbstractProcess(arg1, arg2, arg3, arg4) {
            var _this = this;
            if (arg2 !== void 0 && arg3 !== void 0 && arg4 !== void 0) {
                this.cmd = arg1;
                this.args = arg2;
                this.shell = arg3;
                this.options = arg4;
            }
            else {
                var executable = arg1;
                this.cmd = executable.command;
                this.shell = executable.isShellCommand;
                this.args = executable.args.slice(0);
                this.options = executable.options || {};
            }
            this.childProcess = null;
            this.terminateRequested = false;
            if (this.options.env) {
                var newEnv_1 = Object.create(null);
                Object.keys(process.env).forEach(function (key) {
                    newEnv_1[key] = process.env[key];
                });
                Object.keys(this.options.env).forEach(function (key) {
                    newEnv_1[key] = _this.options.env[key];
                });
                this.options.env = newEnv_1;
            }
        }
        AbstractProcess.prototype.getSanitizedCommand = function () {
            var result = this.cmd.toLowerCase();
            var index = result.lastIndexOf(path.sep);
            if (index !== -1) {
                result = result.substring(index + 1);
            }
            if (AbstractProcess.WellKnowCommands[result]) {
                return result;
            }
            return 'other';
        };
        AbstractProcess.prototype.start = function (pp) {
            var _this = this;
            if (Platform.isWindows && ((this.options && this.options.cwd && TPath.isUNC(this.options.cwd)) || !this.options && TPath.isUNC(process.cwd()))) {
                return winjs_base_1.TPromise.wrapError(new Error(nls.localize(0, null)));
            }
            return this.useExec().then(function (useExec) {
                var cc;
                var ee;
                var result = new winjs_base_1.TPromise(function (c, e) {
                    cc = c;
                    ee = e;
                });
                if (useExec) {
                    var cmd = _this.cmd;
                    if (_this.args) {
                        cmd = cmd + ' ' + _this.args.join(' ');
                    }
                    _this.childProcess = cp.exec(cmd, _this.options, function (error, stdout, stderr) {
                        _this.childProcess = null;
                        var err = error;
                        // This is tricky since executing a command shell reports error back in case the executed command return an
                        // error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we
                        // always parse the output and report success unless the job got killed.
                        if (err && err.killed) {
                            ee({ killed: _this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });
                        }
                        else {
                            _this.handleExec(cc, pp, error, stdout, stderr);
                        }
                    });
                }
                else {
                    var childProcess = null;
                    var closeHandler = function (data) {
                        _this.childProcess = null;
                        _this.childProcessPromise = null;
                        _this.handleClose(data, cc, pp, ee);
                        var result = {
                            terminated: _this.terminateRequested
                        };
                        if (Types.isNumber(data)) {
                            result.cmdCode = data;
                        }
                        cc(result);
                    };
                    if (_this.shell && Platform.isWindows) {
                        var options = Objects.deepClone(_this.options);
                        options.windowsVerbatimArguments = true;
                        options.detached = false;
                        var quotedCommand = false;
                        var quotedArg_1 = false;
                        var commandLine_1 = [];
                        var quoted_1 = _this.ensureQuotes(_this.cmd);
                        commandLine_1.push(quoted_1.value);
                        quotedCommand = quoted_1.quoted;
                        if (_this.args) {
                            _this.args.forEach(function (elem) {
                                quoted_1 = _this.ensureQuotes(elem);
                                commandLine_1.push(quoted_1.value);
                                quotedArg_1 = quotedArg_1 && quoted_1.quoted;
                            });
                        }
                        var args = [
                            '/s',
                            '/c',
                        ];
                        if (quotedCommand) {
                            if (quotedArg_1) {
                                args.push('"' + commandLine_1.join(' ') + '"');
                            }
                            else if (commandLine_1.length > 1) {
                                args.push('"' + commandLine_1[0] + '"' + ' ' + commandLine_1.slice(1).join(' '));
                            }
                            else {
                                args.push('"' + commandLine_1[0] + '"');
                            }
                        }
                        else {
                            args.push(commandLine_1.join(' '));
                        }
                        childProcess = cp.spawn(getWindowsShell(), args, options);
                    }
                    else {
                        if (_this.cmd) {
                            childProcess = cp.spawn(_this.cmd, _this.args, _this.options);
                        }
                    }
                    if (childProcess) {
                        _this.childProcess = childProcess;
                        _this.childProcessPromise = winjs_base_1.TPromise.as(childProcess);
                        if (_this.pidResolve) {
                            _this.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);
                            _this.pidResolve = undefined;
                        }
                        childProcess.on('error', function (error) {
                            _this.childProcess = null;
                            ee({ terminated: _this.terminateRequested, error: error });
                        });
                        if (childProcess.pid) {
                            _this.childProcess.on('close', closeHandler);
                            _this.handleSpawn(childProcess, cc, pp, ee, true);
                        }
                    }
                }
                return result;
            });
        };
        AbstractProcess.prototype.handleClose = function (data, cc, pp, ee) {
            // Default is to do nothing.
        };
        AbstractProcess.prototype.ensureQuotes = function (value) {
            if (AbstractProcess.regexp.test(value)) {
                return {
                    value: '"' + value + '"',
                    quoted: true
                };
            }
            else {
                return {
                    value: value,
                    quoted: value.length > 0 && value[0] === '"' && value[value.length - 1] === '"'
                };
            }
        };
        Object.defineProperty(AbstractProcess.prototype, "pid", {
            get: function () {
                var _this = this;
                if (this.childProcessPromise) {
                    return this.childProcessPromise.then(function (childProcess) { return childProcess.pid; }, function (err) { return -1; });
                }
                else {
                    return new winjs_base_1.TPromise(function (resolve) {
                        _this.pidResolve = resolve;
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        AbstractProcess.prototype.terminate = function () {
            var _this = this;
            if (!this.childProcessPromise) {
                return winjs_base_1.TPromise.as({ success: true });
            }
            return this.childProcessPromise.then(function (childProcess) {
                _this.terminateRequested = true;
                var result = terminateProcess(childProcess, _this.options.cwd);
                if (result.success) {
                    _this.childProcess = null;
                }
                return result;
            }, function (err) {
                return { success: true };
            });
        };
        AbstractProcess.prototype.useExec = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                if (!_this.shell || !Platform.isWindows) {
                    c(false);
                }
                var cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);
                cmdShell.on('error', function (error) {
                    c(true);
                });
                cmdShell.on('exit', function (data) {
                    c(false);
                });
            });
        };
        AbstractProcess.WellKnowCommands = {
            'ant': true,
            'cmake': true,
            'eslint': true,
            'gradle': true,
            'grunt': true,
            'gulp': true,
            'jake': true,
            'jenkins': true,
            'jshint': true,
            'make': true,
            'maven': true,
            'msbuild': true,
            'msc': true,
            'nmake': true,
            'npm': true,
            'rake': true,
            'tsc': true,
            'xbuild': true
        };
        AbstractProcess.regexp = /^[^"].* .*[^"]/;
        return AbstractProcess;
    }());
    exports.AbstractProcess = AbstractProcess;
    var LineProcess = /** @class */ (function (_super) {
        __extends(LineProcess, _super);
        function LineProcess(arg1, arg2, arg3, arg4) {
            return _super.call(this, arg1, arg2, arg3, arg4) || this;
        }
        LineProcess.prototype.handleExec = function (cc, pp, error, stdout, stderr) {
            [stdout, stderr].forEach(function (buffer, index) {
                var lineDecoder = new decoder_1.LineDecoder();
                var lines = lineDecoder.write(buffer);
                lines.forEach(function (line) {
                    pp({ line: line, source: index === 0 ? 0 /* stdout */ : 1 /* stderr */ });
                });
                var line = lineDecoder.end();
                if (line) {
                    pp({ line: line, source: index === 0 ? 0 /* stdout */ : 1 /* stderr */ });
                }
            });
            cc({ terminated: this.terminateRequested, error: error });
        };
        LineProcess.prototype.handleSpawn = function (childProcess, cc, pp, ee, sync) {
            var _this = this;
            this.stdoutLineDecoder = new decoder_1.LineDecoder();
            this.stderrLineDecoder = new decoder_1.LineDecoder();
            childProcess.stdout.on('data', function (data) {
                var lines = _this.stdoutLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: 0 /* stdout */ }); });
            });
            childProcess.stderr.on('data', function (data) {
                var lines = _this.stderrLineDecoder.write(data);
                lines.forEach(function (line) { return pp({ line: line, source: 1 /* stderr */ }); });
            });
        };
        LineProcess.prototype.handleClose = function (data, cc, pp, ee) {
            [this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach(function (line, index) {
                if (line) {
                    pp({ line: line, source: index === 0 ? 0 /* stdout */ : 1 /* stderr */ });
                }
            });
        };
        return LineProcess;
    }(AbstractProcess));
    exports.LineProcess = LineProcess;
    // Wrapper around process.send() that will queue any messages if the internal node.js
    // queue is filled with messages and only continue sending messages when the internal
    // queue is free again to consume messages.
    // On Windows we always wait for the send() method to return before sending the next message
    // to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)
    function createQueuedSender(childProcess) {
        var msgQueue = [];
        var useQueue = false;
        var send = function (msg) {
            if (useQueue) {
                msgQueue.push(msg); // add to the queue if the process cannot handle more messages
                return;
            }
            var result = childProcess.send(msg, function (error) {
                if (error) {
                    console.error(error); // unlikely to happen, best we can do is log this error
                }
                useQueue = false; // we are good again to send directly without queue
                // now send all the messages that we have in our queue and did not send yet
                if (msgQueue.length > 0) {
                    var msgQueueCopy = msgQueue.slice(0);
                    msgQueue = [];
                    msgQueueCopy.forEach(function (entry) { return send(entry); });
                }
            });
            if (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {
                useQueue = true;
            }
        };
        return { send: send };
    }
    exports.createQueuedSender = createQueuedSender;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[178/*vs/base/parts/ipc/node/ipc.cp*/], __M([1/*require*/,0/*exports*/,25/*child_process*/,8/*vs/base/common/lifecycle*/,11/*vs/base/common/async*/,13/*vs/base/common/objects*/,3/*vs/base/common/event*/,149/*vs/base/node/processes*/,44/*vs/base/parts/ipc/node/ipc*/,94/*vs/base/node/console*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/]), function (require, exports, child_process_1, lifecycle_1, async_1, objects_1, event_1, processes_1, ipc_1, console_1, cancellation_1, errors) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This implementation doesn't perform well since it uses base64 encoding for buffers.
     * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.
     */
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server() {
            var _this = _super.call(this, {
                send: function (r) {
                    try {
                        if (process.send) {
                            process.send(r.toString('base64'));
                        }
                    }
                    catch (e) { /* not much to do */ }
                },
                onMessage: event_1.fromNodeEventEmitter(process, 'message', function (msg) { return Buffer.from(msg, 'base64'); })
            }) || this;
            process.once('disconnect', function () { return _this.dispose(); });
            return _this;
        }
        return Server;
    }(ipc_1.ChannelServer));
    exports.Server = Server;
    var Client = /** @class */ (function () {
        function Client(modulePath, options) {
            this.modulePath = modulePath;
            this.options = options;
            this.activeRequests = new Set();
            this.channels = new Map();
            this._onDidProcessExit = new event_1.Emitter();
            this.onDidProcessExit = this._onDidProcessExit.event;
            var timeout = options && options.timeout ? options.timeout : 60000;
            this.disposeDelayer = new async_1.Delayer(timeout);
            this.child = null;
            this._client = null;
        }
        Client.prototype.getChannel = function (channelName) {
            var that = this;
            return {
                call: function (command, arg, cancellationToken) {
                    return that.requestPromise(channelName, command, arg, cancellationToken);
                },
                listen: function (event, arg) {
                    return that.requestEvent(channelName, event, arg);
                }
            };
        };
        Client.prototype.requestPromise = function (channelName, name, arg, cancellationToken) {
            var _this = this;
            if (cancellationToken === void 0) { cancellationToken = cancellation_1.CancellationToken.None; }
            if (!this.disposeDelayer) {
                return Promise.reject(new Error('disposed'));
            }
            if (cancellationToken.isCancellationRequested) {
                return Promise.reject(errors.canceled());
            }
            this.disposeDelayer.cancel();
            var channel = this.getCachedChannel(channelName);
            var result = async_1.createCancelablePromise(function (token) { return channel.call(name, arg, token); });
            var cancellationTokenListener = cancellationToken.onCancellationRequested(function () { return result.cancel(); });
            var disposable = lifecycle_1.toDisposable(function () { return result.cancel(); });
            this.activeRequests.add(disposable);
            async_1.always(result, function () {
                cancellationTokenListener.dispose();
                _this.activeRequests.delete(disposable);
                if (_this.activeRequests.size === 0) {
                    _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });
                }
            });
            return result;
        };
        Client.prototype.requestEvent = function (channelName, name, arg) {
            var _this = this;
            if (!this.disposeDelayer) {
                return event_1.Event.None;
            }
            this.disposeDelayer.cancel();
            var listener;
            var emitter = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    var channel = _this.getCachedChannel(channelName);
                    var event = channel.listen(name, arg);
                    listener = event(emitter.fire, emitter);
                    _this.activeRequests.add(listener);
                },
                onLastListenerRemove: function () {
                    _this.activeRequests.delete(listener);
                    listener.dispose();
                    if (_this.activeRequests.size === 0 && _this.disposeDelayer) {
                        _this.disposeDelayer.trigger(function () { return _this.disposeClient(); });
                    }
                }
            });
            return emitter.event;
        };
        Object.defineProperty(Client.prototype, "client", {
            get: function () {
                var _this = this;
                if (!this._client) {
                    var args = this.options && this.options.args ? this.options.args : [];
                    var forkOpts = Object.create(null);
                    forkOpts.env = objects_1.assign(objects_1.deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });
                    if (this.options && this.options.env) {
                        forkOpts.env = objects_1.assign(forkOpts.env, this.options.env);
                    }
                    if (this.options && this.options.freshExecArgv) {
                        forkOpts.execArgv = [];
                    }
                    if (this.options && typeof this.options.debug === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];
                    }
                    if (this.options && typeof this.options.debugBrk === 'number') {
                        forkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];
                    }
                    this.child = child_process_1.fork(this.modulePath, args, forkOpts);
                    var onMessageEmitter_1 = new event_1.Emitter();
                    var onRawMessage = event_1.fromNodeEventEmitter(this.child, 'message', function (msg) { return msg; });
                    onRawMessage(function (msg) {
                        // Handle remote console logs specially
                        if (console_1.isRemoteConsoleLog(msg)) {
                            console_1.log(msg, "IPC Library: " + _this.options.serverName);
                            return;
                        }
                        // Anything else goes to the outside
                        onMessageEmitter_1.fire(Buffer.from(msg, 'base64'));
                    });
                    var sender_1 = this.options.useQueue ? processes_1.createQueuedSender(this.child) : this.child;
                    var send = function (r) { return _this.child && _this.child.connected && sender_1.send(r.toString('base64')); };
                    var onMessage = onMessageEmitter_1.event;
                    var protocol = { send: send, onMessage: onMessage };
                    this._client = new ipc_1.ChannelClient(protocol);
                    var onExit_1 = function () { return _this.disposeClient(); };
                    process.once('exit', onExit_1);
                    this.child.on('error', function (err) { return console.warn('IPC "' + _this.options.serverName + '" errored with ' + err); });
                    this.child.on('exit', function (code, signal) {
                        process.removeListener('exit', onExit_1);
                        _this.activeRequests.forEach(function (r) { return lifecycle_1.dispose(r); });
                        _this.activeRequests.clear();
                        if (code !== 0 && signal !== 'SIGTERM') {
                            console.warn('IPC "' + _this.options.serverName + '" crashed with exit code ' + code + ' and signal ' + signal);
                        }
                        if (_this.disposeDelayer) {
                            _this.disposeDelayer.cancel();
                        }
                        _this.disposeClient();
                        _this._onDidProcessExit.fire({ code: code, signal: signal });
                    });
                }
                return this._client;
            },
            enumerable: true,
            configurable: true
        });
        Client.prototype.getCachedChannel = function (name) {
            var channel = this.channels.get(name);
            if (!channel) {
                channel = this.client.getChannel(name);
                this.channels.set(name, channel);
            }
            return channel;
        };
        Client.prototype.disposeClient = function () {
            if (this._client) {
                if (this.child) {
                    this.child.kill();
                    this.child = null;
                }
                this._client = null;
                this.channels.clear();
            }
        };
        Client.prototype.dispose = function () {
            this._onDidProcessExit.dispose();
            this.disposeDelayer.cancel();
            this.disposeDelayer = null; // StrictNullOverride: nulling out ok in dispose
            this.disposeClient();
            this.activeRequests.clear();
        };
        return Client;
    }());
    exports.Client = Client;
});

define(__m[181/*vs/nls!vs/editor/common/config/editorOptions*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/editor/common/config/editorOptions", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
define(__m[185/*vs/editor/common/config/editorOptions*/], __M([1/*require*/,0/*exports*/,181/*vs/nls!vs/editor/common/config/editorOptions*/,9/*vs/base/common/arrays*/,13/*vs/base/common/objects*/,6/*vs/base/common/platform*/,54/*vs/editor/common/model/wordHelper*/]), function (require, exports, nls, arrays, objects, platform, wordHelper_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RenderMinimap;
    (function (RenderMinimap) {
        RenderMinimap[RenderMinimap["None"] = 0] = "None";
        RenderMinimap[RenderMinimap["Small"] = 1] = "Small";
        RenderMinimap[RenderMinimap["Large"] = 2] = "Large";
        RenderMinimap[RenderMinimap["SmallBlocks"] = 3] = "SmallBlocks";
        RenderMinimap[RenderMinimap["LargeBlocks"] = 4] = "LargeBlocks";
    })(RenderMinimap = exports.RenderMinimap || (exports.RenderMinimap = {}));
    /**
     * Describes how to indent wrapped lines.
     */
    var WrappingIndent;
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
        /**
         * DeepIndent => wrapped lines get +2 indentation toward the parent.
         */
        WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
    })(WrappingIndent = exports.WrappingIndent || (exports.WrappingIndent = {}));
    /**
     * The kind of animation in which the editor's cursor should be rendered.
     */
    var TextEditorCursorBlinkingStyle;
    (function (TextEditorCursorBlinkingStyle) {
        /**
         * Hidden
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
        /**
         * Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
        /**
         * Blinking with smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
        /**
         * Expand collapse animation on the y axis
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
        /**
         * No-Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
    })(TextEditorCursorBlinkingStyle = exports.TextEditorCursorBlinkingStyle || (exports.TextEditorCursorBlinkingStyle = {}));
    /**
     * @internal
     */
    function blinkingStyleToString(blinkingStyle) {
        if (blinkingStyle === 1 /* Blink */) {
            return 'blink';
        }
        else if (blinkingStyle === 4 /* Expand */) {
            return 'expand';
        }
        else if (blinkingStyle === 3 /* Phase */) {
            return 'phase';
        }
        else if (blinkingStyle === 2 /* Smooth */) {
            return 'smooth';
        }
        else if (blinkingStyle === 5 /* Solid */) {
            return 'solid';
        }
        else {
            throw new Error('blinkingStyleToString: Unknown blinkingStyle');
        }
    }
    exports.blinkingStyleToString = blinkingStyleToString;
    /**
     * The style in which the editor's cursor should be rendered.
     */
    var TextEditorCursorStyle;
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
        /**
         * As a thin vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
        /**
         * As an outlined block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
        /**
         * As a thin horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
    })(TextEditorCursorStyle = exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else if (cursorStyle === TextEditorCursorStyle.LineThin) {
            return 'line-thin';
        }
        else if (cursorStyle === TextEditorCursorStyle.BlockOutline) {
            return 'block-outline';
        }
        else if (cursorStyle === TextEditorCursorStyle.UnderlineThin) {
            return 'underline-thin';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    function _cursorStyleFromString(cursorStyle, defaultValue) {
        if (typeof cursorStyle !== 'string') {
            return defaultValue;
        }
        if (cursorStyle === 'line') {
            return TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return TextEditorCursorStyle.Underline;
        }
        else if (cursorStyle === 'line-thin') {
            return TextEditorCursorStyle.LineThin;
        }
        else if (cursorStyle === 'block-outline') {
            return TextEditorCursorStyle.BlockOutline;
        }
        else if (cursorStyle === 'underline-thin') {
            return TextEditorCursorStyle.UnderlineThin;
        }
        return TextEditorCursorStyle.Line;
    }
    var RenderLineNumbersType;
    (function (RenderLineNumbersType) {
        RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
        RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
        RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
        RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
        RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
    })(RenderLineNumbersType = exports.RenderLineNumbersType || (exports.RenderLineNumbersType = {}));
    /**
     * Internal configuration options (transformed or computed) for the editor.
     */
    var InternalEditorOptions = /** @class */ (function () {
        /**
         * @internal
         */
        function InternalEditorOptions(source) {
            this.canUseLayerHinting = source.canUseLayerHinting;
            this.pixelRatio = source.pixelRatio;
            this.editorClassName = source.editorClassName;
            this.lineHeight = source.lineHeight | 0;
            this.readOnly = source.readOnly;
            this.accessibilitySupport = source.accessibilitySupport;
            this.multiCursorModifier = source.multiCursorModifier;
            this.multiCursorMergeOverlapping = source.multiCursorMergeOverlapping;
            this.wordSeparators = source.wordSeparators;
            this.autoClosingBrackets = source.autoClosingBrackets;
            this.autoClosingQuotes = source.autoClosingQuotes;
            this.autoSurround = source.autoSurround;
            this.autoIndent = source.autoIndent;
            this.useTabStops = source.useTabStops;
            this.tabFocusMode = source.tabFocusMode;
            this.dragAndDrop = source.dragAndDrop;
            this.emptySelectionClipboard = source.emptySelectionClipboard;
            this.copyWithSyntaxHighlighting = source.copyWithSyntaxHighlighting;
            this.layoutInfo = source.layoutInfo;
            this.fontInfo = source.fontInfo;
            this.viewInfo = source.viewInfo;
            this.wrappingInfo = source.wrappingInfo;
            this.contribInfo = source.contribInfo;
            this.showUnused = source.showUnused;
        }
        /**
         * @internal
         */
        InternalEditorOptions.prototype.equals = function (other) {
            return (this.canUseLayerHinting === other.canUseLayerHinting
                && this.pixelRatio === other.pixelRatio
                && this.editorClassName === other.editorClassName
                && this.lineHeight === other.lineHeight
                && this.readOnly === other.readOnly
                && this.accessibilitySupport === other.accessibilitySupport
                && this.multiCursorModifier === other.multiCursorModifier
                && this.multiCursorMergeOverlapping === other.multiCursorMergeOverlapping
                && this.wordSeparators === other.wordSeparators
                && this.autoClosingBrackets === other.autoClosingBrackets
                && this.autoClosingQuotes === other.autoClosingQuotes
                && this.autoSurround === other.autoSurround
                && this.autoIndent === other.autoIndent
                && this.useTabStops === other.useTabStops
                && this.tabFocusMode === other.tabFocusMode
                && this.dragAndDrop === other.dragAndDrop
                && this.showUnused === other.showUnused
                && this.emptySelectionClipboard === other.emptySelectionClipboard
                && this.copyWithSyntaxHighlighting === other.copyWithSyntaxHighlighting
                && InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, other.layoutInfo)
                && this.fontInfo.equals(other.fontInfo)
                && InternalEditorOptions._equalsViewOptions(this.viewInfo, other.viewInfo)
                && InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, other.wrappingInfo)
                && InternalEditorOptions._equalsContribOptions(this.contribInfo, other.contribInfo));
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                canUseLayerHinting: (this.canUseLayerHinting !== newOpts.canUseLayerHinting),
                pixelRatio: (this.pixelRatio !== newOpts.pixelRatio),
                editorClassName: (this.editorClassName !== newOpts.editorClassName),
                lineHeight: (this.lineHeight !== newOpts.lineHeight),
                readOnly: (this.readOnly !== newOpts.readOnly),
                accessibilitySupport: (this.accessibilitySupport !== newOpts.accessibilitySupport),
                multiCursorModifier: (this.multiCursorModifier !== newOpts.multiCursorModifier),
                multiCursorMergeOverlapping: (this.multiCursorMergeOverlapping !== newOpts.multiCursorMergeOverlapping),
                wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
                autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
                autoClosingQuotes: (this.autoClosingQuotes !== newOpts.autoClosingQuotes),
                autoSurround: (this.autoSurround !== newOpts.autoSurround),
                autoIndent: (this.autoIndent !== newOpts.autoIndent),
                useTabStops: (this.useTabStops !== newOpts.useTabStops),
                tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
                dragAndDrop: (this.dragAndDrop !== newOpts.dragAndDrop),
                emptySelectionClipboard: (this.emptySelectionClipboard !== newOpts.emptySelectionClipboard),
                copyWithSyntaxHighlighting: (this.copyWithSyntaxHighlighting !== newOpts.copyWithSyntaxHighlighting),
                layoutInfo: (!InternalEditorOptions._equalsLayoutInfo(this.layoutInfo, newOpts.layoutInfo)),
                fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
                viewInfo: (!InternalEditorOptions._equalsViewOptions(this.viewInfo, newOpts.viewInfo)),
                wrappingInfo: (!InternalEditorOptions._equalsWrappingInfo(this.wrappingInfo, newOpts.wrappingInfo)),
                contribInfo: (!InternalEditorOptions._equalsContribOptions(this.contribInfo, newOpts.contribInfo))
            };
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsLayoutInfo = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.glyphMarginLeft === b.glyphMarginLeft
                && a.glyphMarginWidth === b.glyphMarginWidth
                && a.glyphMarginHeight === b.glyphMarginHeight
                && a.lineNumbersLeft === b.lineNumbersLeft
                && a.lineNumbersWidth === b.lineNumbersWidth
                && a.lineNumbersHeight === b.lineNumbersHeight
                && a.decorationsLeft === b.decorationsLeft
                && a.decorationsWidth === b.decorationsWidth
                && a.decorationsHeight === b.decorationsHeight
                && a.contentLeft === b.contentLeft
                && a.contentWidth === b.contentWidth
                && a.contentHeight === b.contentHeight
                && a.renderMinimap === b.renderMinimap
                && a.minimapLeft === b.minimapLeft
                && a.minimapWidth === b.minimapWidth
                && a.viewportColumn === b.viewportColumn
                && a.verticalScrollbarWidth === b.verticalScrollbarWidth
                && a.horizontalScrollbarHeight === b.horizontalScrollbarHeight
                && this._equalsOverviewRuler(a.overviewRuler, b.overviewRuler));
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsOverviewRuler = function (a, b) {
            return (a.width === b.width
                && a.height === b.height
                && a.top === b.top
                && a.right === b.right);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsViewOptions = function (a, b) {
            return (a.extraEditorClassName === b.extraEditorClassName
                && a.disableMonospaceOptimizations === b.disableMonospaceOptimizations
                && arrays.equals(a.rulers, b.rulers)
                && a.ariaLabel === b.ariaLabel
                && a.renderLineNumbers === b.renderLineNumbers
                && a.renderCustomLineNumbers === b.renderCustomLineNumbers
                && a.selectOnLineNumbers === b.selectOnLineNumbers
                && a.glyphMargin === b.glyphMargin
                && a.revealHorizontalRightPadding === b.revealHorizontalRightPadding
                && a.roundedSelection === b.roundedSelection
                && a.overviewRulerLanes === b.overviewRulerLanes
                && a.overviewRulerBorder === b.overviewRulerBorder
                && a.cursorBlinking === b.cursorBlinking
                && a.mouseWheelZoom === b.mouseWheelZoom
                && a.cursorStyle === b.cursorStyle
                && a.cursorWidth === b.cursorWidth
                && a.hideCursorInOverviewRuler === b.hideCursorInOverviewRuler
                && a.scrollBeyondLastLine === b.scrollBeyondLastLine
                && a.scrollBeyondLastColumn === b.scrollBeyondLastColumn
                && a.smoothScrolling === b.smoothScrolling
                && a.stopRenderingLineAfter === b.stopRenderingLineAfter
                && a.renderWhitespace === b.renderWhitespace
                && a.renderControlCharacters === b.renderControlCharacters
                && a.fontLigatures === b.fontLigatures
                && a.renderIndentGuides === b.renderIndentGuides
                && a.highlightActiveIndentGuide === b.highlightActiveIndentGuide
                && a.renderLineHighlight === b.renderLineHighlight
                && this._equalsScrollbarOptions(a.scrollbar, b.scrollbar)
                && this._equalsMinimapOptions(a.minimap, b.minimap)
                && a.fixedOverflowWidgets === b.fixedOverflowWidgets);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsScrollbarOptions = function (a, b) {
            return (a.arrowSize === b.arrowSize
                && a.vertical === b.vertical
                && a.horizontal === b.horizontal
                && a.useShadows === b.useShadows
                && a.verticalHasArrows === b.verticalHasArrows
                && a.horizontalHasArrows === b.horizontalHasArrows
                && a.handleMouseWheel === b.handleMouseWheel
                && a.horizontalScrollbarSize === b.horizontalScrollbarSize
                && a.horizontalSliderSize === b.horizontalSliderSize
                && a.verticalScrollbarSize === b.verticalScrollbarSize
                && a.verticalSliderSize === b.verticalSliderSize
                && a.mouseWheelScrollSensitivity === b.mouseWheelScrollSensitivity);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsMinimapOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.side === b.side
                && a.showSlider === b.showSlider
                && a.renderCharacters === b.renderCharacters
                && a.maxColumn === b.maxColumn);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalFindOptions = function (a, b) {
            return (a.seedSearchStringFromSelection === b.seedSearchStringFromSelection
                && a.autoFindInSelection === b.autoFindInSelection
                && a.globalFindClipboard === b.globalFindClipboard);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsParameterHintOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.cycle === b.cycle);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsHoverOptions = function (a, b) {
            return (a.enabled === b.enabled
                && a.delay === b.delay
                && a.sticky === b.sticky);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsSuggestOptions = function (a, b) {
            if (a === b) {
                return true;
            }
            else if (!a || !b) {
                return false;
            }
            else {
                return a.filterGraceful === b.filterGraceful
                    && a.snippets === b.snippets
                    && a.snippetsPreventQuickSuggestions === b.snippetsPreventQuickSuggestions
                    && a.localityBonus === b.localityBonus;
            }
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsWrappingInfo = function (a, b) {
            return (a.inDiffEditor === b.inDiffEditor
                && a.isDominatedByLongLines === b.isDominatedByLongLines
                && a.isWordWrapMinified === b.isWordWrapMinified
                && a.isViewportWrapping === b.isViewportWrapping
                && a.wrappingColumn === b.wrappingColumn
                && a.wrappingIndent === b.wrappingIndent
                && a.wordWrapBreakBeforeCharacters === b.wordWrapBreakBeforeCharacters
                && a.wordWrapBreakAfterCharacters === b.wordWrapBreakAfterCharacters
                && a.wordWrapBreakObtrusiveCharacters === b.wordWrapBreakObtrusiveCharacters);
        };
        /**
         * @internal
         */
        InternalEditorOptions._equalsContribOptions = function (a, b) {
            return (a.selectionClipboard === b.selectionClipboard
                && this._equalsHoverOptions(a.hover, b.hover)
                && a.links === b.links
                && a.contextmenu === b.contextmenu
                && InternalEditorOptions._equalsQuickSuggestions(a.quickSuggestions, b.quickSuggestions)
                && a.quickSuggestionsDelay === b.quickSuggestionsDelay
                && this._equalsParameterHintOptions(a.parameterHints, b.parameterHints)
                && a.iconsInSuggestions === b.iconsInSuggestions
                && a.formatOnType === b.formatOnType
                && a.formatOnPaste === b.formatOnPaste
                && a.suggestOnTriggerCharacters === b.suggestOnTriggerCharacters
                && a.acceptSuggestionOnEnter === b.acceptSuggestionOnEnter
                && a.acceptSuggestionOnCommitCharacter === b.acceptSuggestionOnCommitCharacter
                && a.wordBasedSuggestions === b.wordBasedSuggestions
                && a.suggestSelection === b.suggestSelection
                && a.suggestFontSize === b.suggestFontSize
                && a.suggestLineHeight === b.suggestLineHeight
                && a.tabCompletion === b.tabCompletion
                && this._equalsSuggestOptions(a.suggest, b.suggest)
                && a.selectionHighlight === b.selectionHighlight
                && a.occurrencesHighlight === b.occurrencesHighlight
                && a.codeLens === b.codeLens
                && a.folding === b.folding
                && a.foldingStrategy === b.foldingStrategy
                && a.showFoldingControls === b.showFoldingControls
                && a.matchBrackets === b.matchBrackets
                && this._equalFindOptions(a.find, b.find)
                && a.colorDecorators === b.colorDecorators
                && objects.equals(a.codeActionsOnSave, b.codeActionsOnSave)
                && a.codeActionsOnSaveTimeout === b.codeActionsOnSaveTimeout
                && a.lightbulbEnabled === b.lightbulbEnabled);
        };
        InternalEditorOptions._equalsQuickSuggestions = function (a, b) {
            if (typeof a === 'boolean') {
                if (typeof b !== 'boolean') {
                    return false;
                }
                return a === b;
            }
            if (typeof b === 'boolean') {
                return false;
            }
            return (a.comments === b.comments
                && a.other === b.other
                && a.strings === b.strings);
        };
        return InternalEditorOptions;
    }());
    exports.InternalEditorOptions = InternalEditorOptions;
    function _boolean(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        if (value === 'false') {
            // treat the string 'false' as false
            return false;
        }
        return Boolean(value);
    }
    function _booleanMap(value, defaultValue) {
        if (!value) {
            return defaultValue;
        }
        var out = Object.create(null);
        for (var _i = 0, _a = Object.keys(value); _i < _a.length; _i++) {
            var k = _a[_i];
            var v = value[k];
            if (typeof v === 'boolean') {
                out[k] = v;
            }
        }
        return out;
    }
    function _string(value, defaultValue) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        return value;
    }
    function _stringSet(value, defaultValue, allowedValues) {
        if (typeof value !== 'string') {
            return defaultValue;
        }
        if (allowedValues.indexOf(value) === -1) {
            return defaultValue;
        }
        return value;
    }
    function _clampedInt(value, defaultValue, minimum, maximum) {
        var r;
        if (typeof value === 'undefined') {
            r = defaultValue;
        }
        else {
            r = parseInt(value, 10);
            if (isNaN(r)) {
                r = defaultValue;
            }
        }
        r = Math.max(minimum, r);
        r = Math.min(maximum, r);
        return r | 0;
    }
    function _float(value, defaultValue) {
        var r = parseFloat(value);
        if (isNaN(r)) {
            r = defaultValue;
        }
        return r;
    }
    function _wrappingIndentFromString(wrappingIndent, defaultValue) {
        if (typeof wrappingIndent !== 'string') {
            return defaultValue;
        }
        if (wrappingIndent === 'same') {
            return 1 /* Same */;
        }
        else if (wrappingIndent === 'indent') {
            return 2 /* Indent */;
        }
        else if (wrappingIndent === 'deepIndent') {
            return 3 /* DeepIndent */;
        }
        else {
            return 0 /* None */;
        }
    }
    function _cursorBlinkingStyleFromString(cursorBlinkingStyle, defaultValue) {
        if (typeof cursorBlinkingStyle !== 'string') {
            return defaultValue;
        }
        switch (cursorBlinkingStyle) {
            case 'blink':
                return 1 /* Blink */;
            case 'smooth':
                return 2 /* Smooth */;
            case 'phase':
                return 3 /* Phase */;
            case 'expand':
                return 4 /* Expand */;
            case 'visible': // maintain compatibility
            case 'solid':
                return 5 /* Solid */;
        }
        return 1 /* Blink */;
    }
    function _scrollbarVisibilityFromString(visibility, defaultValue) {
        if (typeof visibility !== 'string') {
            return defaultValue;
        }
        switch (visibility) {
            case 'hidden':
                return 2 /* Hidden */;
            case 'visible':
                return 3 /* Visible */;
            default:
                return 1 /* Auto */;
        }
    }
    /**
     * @internal
     */
    var EditorOptionsValidator = /** @class */ (function () {
        function EditorOptionsValidator() {
        }
        /**
         * Validate raw editor options.
         * i.e. since they can be defined by the user, they might be invalid.
         */
        EditorOptionsValidator.validate = function (opts, defaults) {
            var wordWrap = opts.wordWrap;
            {
                // Compatibility with old true or false values
                if (wordWrap === true) {
                    wordWrap = 'on';
                }
                else if (wordWrap === false) {
                    wordWrap = 'off';
                }
                wordWrap = _stringSet(wordWrap, defaults.wordWrap, ['off', 'on', 'wordWrapColumn', 'bounded']);
            }
            var viewInfo = this._sanitizeViewInfo(opts, defaults.viewInfo);
            var contribInfo = this._sanitizeContribInfo(opts, defaults.contribInfo);
            var configuredMulticursorModifier = undefined;
            if (typeof opts.multiCursorModifier === 'string') {
                if (opts.multiCursorModifier === 'ctrlCmd') {
                    configuredMulticursorModifier = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
                }
                else {
                    configuredMulticursorModifier = 'altKey';
                }
            }
            var multiCursorModifier = _stringSet(configuredMulticursorModifier, defaults.multiCursorModifier, ['altKey', 'metaKey', 'ctrlKey']);
            var autoClosingBrackets;
            var autoClosingQuotes;
            var autoSurround;
            if (typeof opts.autoClosingBrackets === 'boolean' && opts.autoClosingBrackets === false) {
                // backwards compatibility: disable all on boolean false
                autoClosingBrackets = 'never';
                autoClosingQuotes = 'never';
                autoSurround = 'never';
            }
            else {
                autoClosingBrackets = _stringSet(opts.autoClosingBrackets, defaults.autoClosingBrackets, ['always', 'languageDefined', 'beforeWhitespace', 'never']);
                autoClosingQuotes = _stringSet(opts.autoClosingQuotes, defaults.autoClosingQuotes, ['always', 'languageDefined', 'beforeWhitespace', 'never']);
                autoSurround = _stringSet(opts.autoSurround, defaults.autoSurround, ['languageDefined', 'brackets', 'quotes', 'never']);
            }
            return {
                inDiffEditor: _boolean(opts.inDiffEditor, defaults.inDiffEditor),
                wordSeparators: _string(opts.wordSeparators, defaults.wordSeparators),
                lineNumbersMinChars: _clampedInt(opts.lineNumbersMinChars, defaults.lineNumbersMinChars, 1, 10),
                lineDecorationsWidth: (typeof opts.lineDecorationsWidth === 'undefined' ? defaults.lineDecorationsWidth : opts.lineDecorationsWidth),
                readOnly: _boolean(opts.readOnly, defaults.readOnly),
                mouseStyle: _stringSet(opts.mouseStyle, defaults.mouseStyle, ['text', 'default', 'copy']),
                disableLayerHinting: _boolean(opts.disableLayerHinting, defaults.disableLayerHinting),
                automaticLayout: _boolean(opts.automaticLayout, defaults.automaticLayout),
                wordWrap: wordWrap,
                wordWrapColumn: _clampedInt(opts.wordWrapColumn, defaults.wordWrapColumn, 1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                wordWrapMinified: _boolean(opts.wordWrapMinified, defaults.wordWrapMinified),
                wrappingIndent: _wrappingIndentFromString(opts.wrappingIndent, defaults.wrappingIndent),
                wordWrapBreakBeforeCharacters: _string(opts.wordWrapBreakBeforeCharacters, defaults.wordWrapBreakBeforeCharacters),
                wordWrapBreakAfterCharacters: _string(opts.wordWrapBreakAfterCharacters, defaults.wordWrapBreakAfterCharacters),
                wordWrapBreakObtrusiveCharacters: _string(opts.wordWrapBreakObtrusiveCharacters, defaults.wordWrapBreakObtrusiveCharacters),
                autoClosingBrackets: autoClosingBrackets,
                autoClosingQuotes: autoClosingQuotes,
                autoSurround: autoSurround,
                autoIndent: _boolean(opts.autoIndent, defaults.autoIndent),
                dragAndDrop: _boolean(opts.dragAndDrop, defaults.dragAndDrop),
                emptySelectionClipboard: _boolean(opts.emptySelectionClipboard, defaults.emptySelectionClipboard),
                copyWithSyntaxHighlighting: _boolean(opts.copyWithSyntaxHighlighting, defaults.copyWithSyntaxHighlighting),
                useTabStops: _boolean(opts.useTabStops, defaults.useTabStops),
                multiCursorModifier: multiCursorModifier,
                multiCursorMergeOverlapping: _boolean(opts.multiCursorMergeOverlapping, defaults.multiCursorMergeOverlapping),
                accessibilitySupport: _stringSet(opts.accessibilitySupport, defaults.accessibilitySupport, ['auto', 'on', 'off']),
                showUnused: _boolean(opts.showUnused, defaults.showUnused),
                viewInfo: viewInfo,
                contribInfo: contribInfo,
            };
        };
        EditorOptionsValidator._sanitizeScrollbarOpts = function (opts, defaults, mouseWheelScrollSensitivity) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            var horizontalScrollbarSize = _clampedInt(opts.horizontalScrollbarSize, defaults.horizontalScrollbarSize, 0, 1000);
            var verticalScrollbarSize = _clampedInt(opts.verticalScrollbarSize, defaults.verticalScrollbarSize, 0, 1000);
            return {
                vertical: _scrollbarVisibilityFromString(opts.vertical, defaults.vertical),
                horizontal: _scrollbarVisibilityFromString(opts.horizontal, defaults.horizontal),
                arrowSize: _clampedInt(opts.arrowSize, defaults.arrowSize, 0, 1000),
                useShadows: _boolean(opts.useShadows, defaults.useShadows),
                verticalHasArrows: _boolean(opts.verticalHasArrows, defaults.verticalHasArrows),
                horizontalHasArrows: _boolean(opts.horizontalHasArrows, defaults.horizontalHasArrows),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: _clampedInt(opts.horizontalSliderSize, horizontalScrollbarSize, 0, 1000),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: _clampedInt(opts.verticalSliderSize, verticalScrollbarSize, 0, 1000),
                handleMouseWheel: _boolean(opts.handleMouseWheel, defaults.handleMouseWheel),
                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
            };
        };
        EditorOptionsValidator._sanitizeMinimapOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                side: _stringSet(opts.side, defaults.side, ['right', 'left']),
                showSlider: _stringSet(opts.showSlider, defaults.showSlider, ['always', 'mouseover']),
                renderCharacters: _boolean(opts.renderCharacters, defaults.renderCharacters),
                maxColumn: _clampedInt(opts.maxColumn, defaults.maxColumn, 1, 10000),
            };
        };
        EditorOptionsValidator._santizeFindOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                seedSearchStringFromSelection: _boolean(opts.seedSearchStringFromSelection, defaults.seedSearchStringFromSelection),
                autoFindInSelection: _boolean(opts.autoFindInSelection, defaults.autoFindInSelection),
                globalFindClipboard: _boolean(opts.globalFindClipboard, defaults.globalFindClipboard)
            };
        };
        EditorOptionsValidator._sanitizeParameterHintOpts = function (opts, defaults) {
            if (typeof opts !== 'object') {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                cycle: _boolean(opts.cycle, defaults.cycle)
            };
        };
        EditorOptionsValidator._santizeHoverOpts = function (_opts, defaults) {
            var opts;
            if (typeof _opts === 'boolean') {
                opts = {
                    enabled: _opts
                };
            }
            else if (typeof _opts === 'object') {
                opts = _opts;
            }
            else {
                return defaults;
            }
            return {
                enabled: _boolean(opts.enabled, defaults.enabled),
                delay: _clampedInt(opts.delay, defaults.delay, 0, 10000),
                sticky: _boolean(opts.sticky, defaults.sticky)
            };
        };
        EditorOptionsValidator._sanitizeSuggestOpts = function (opts, defaults) {
            var suggestOpts = opts.suggest || {};
            return {
                filterGraceful: _boolean(suggestOpts.filterGraceful, defaults.filterGraceful),
                snippets: _stringSet(opts.snippetSuggestions, defaults.snippets, ['top', 'bottom', 'inline', 'none']),
                snippetsPreventQuickSuggestions: _boolean(suggestOpts.snippetsPreventQuickSuggestions, defaults.filterGraceful),
                localityBonus: _boolean(suggestOpts.localityBonus, defaults.localityBonus),
            };
        };
        EditorOptionsValidator._sanitizeTabCompletionOpts = function (opts, defaults) {
            if (opts === false) {
                return 'off';
            }
            else if (opts === true) {
                return 'onlySnippets';
            }
            else {
                return _stringSet(opts, defaults, ['on', 'off', 'onlySnippets']);
            }
        };
        EditorOptionsValidator._sanitizeViewInfo = function (opts, defaults) {
            var rulers = [];
            if (Array.isArray(opts.rulers)) {
                for (var i = 0, len = opts.rulers.length; i < len; i++) {
                    rulers.push(_clampedInt(opts.rulers[i], 0, 0, 10000));
                }
                rulers.sort();
            }
            var renderLineNumbers = defaults.renderLineNumbers;
            var renderCustomLineNumbers = defaults.renderCustomLineNumbers;
            if (typeof opts.lineNumbers !== 'undefined') {
                var lineNumbers = opts.lineNumbers;
                // Compatibility with old true or false values
                if (lineNumbers === true) {
                    lineNumbers = 'on';
                }
                else if (lineNumbers === false) {
                    lineNumbers = 'off';
                }
                if (typeof lineNumbers === 'function') {
                    renderLineNumbers = 4 /* Custom */;
                    renderCustomLineNumbers = lineNumbers;
                }
                else if (lineNumbers === 'interval') {
                    renderLineNumbers = 3 /* Interval */;
                }
                else if (lineNumbers === 'relative') {
                    renderLineNumbers = 2 /* Relative */;
                }
                else if (lineNumbers === 'on') {
                    renderLineNumbers = 1 /* On */;
                }
                else {
                    renderLineNumbers = 0 /* Off */;
                }
            }
            var fontLigatures = _boolean(opts.fontLigatures, defaults.fontLigatures);
            var disableMonospaceOptimizations = _boolean(opts.disableMonospaceOptimizations, defaults.disableMonospaceOptimizations) || fontLigatures;
            var renderWhitespace = opts.renderWhitespace;
            {
                // Compatibility with old true or false values
                if (renderWhitespace === true) {
                    renderWhitespace = 'boundary';
                }
                else if (renderWhitespace === false) {
                    renderWhitespace = 'none';
                }
                renderWhitespace = _stringSet(opts.renderWhitespace, defaults.renderWhitespace, ['none', 'boundary', 'all']);
            }
            var renderLineHighlight = opts.renderLineHighlight;
            {
                // Compatibility with old true or false values
                if (renderLineHighlight === true) {
                    renderLineHighlight = 'line';
                }
                else if (renderLineHighlight === false) {
                    renderLineHighlight = 'none';
                }
                renderLineHighlight = _stringSet(opts.renderLineHighlight, defaults.renderLineHighlight, ['none', 'gutter', 'line', 'all']);
            }
            var mouseWheelScrollSensitivity = _float(opts.mouseWheelScrollSensitivity, defaults.scrollbar.mouseWheelScrollSensitivity);
            if (mouseWheelScrollSensitivity === 0) {
                // Disallow 0, as it would prevent/block scrolling
                mouseWheelScrollSensitivity = 1;
            }
            var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, defaults.scrollbar, mouseWheelScrollSensitivity);
            var minimap = this._sanitizeMinimapOpts(opts.minimap, defaults.minimap);
            return {
                extraEditorClassName: _string(opts.extraEditorClassName, defaults.extraEditorClassName),
                disableMonospaceOptimizations: disableMonospaceOptimizations,
                rulers: rulers,
                ariaLabel: _string(opts.ariaLabel, defaults.ariaLabel),
                renderLineNumbers: renderLineNumbers,
                renderCustomLineNumbers: renderCustomLineNumbers,
                selectOnLineNumbers: _boolean(opts.selectOnLineNumbers, defaults.selectOnLineNumbers),
                glyphMargin: _boolean(opts.glyphMargin, defaults.glyphMargin),
                revealHorizontalRightPadding: _clampedInt(opts.revealHorizontalRightPadding, defaults.revealHorizontalRightPadding, 0, 1000),
                roundedSelection: _boolean(opts.roundedSelection, defaults.roundedSelection),
                overviewRulerLanes: _clampedInt(opts.overviewRulerLanes, defaults.overviewRulerLanes, 0, 3),
                overviewRulerBorder: _boolean(opts.overviewRulerBorder, defaults.overviewRulerBorder),
                cursorBlinking: _cursorBlinkingStyleFromString(opts.cursorBlinking, defaults.cursorBlinking),
                mouseWheelZoom: _boolean(opts.mouseWheelZoom, defaults.mouseWheelZoom),
                cursorStyle: _cursorStyleFromString(opts.cursorStyle, defaults.cursorStyle),
                cursorWidth: _clampedInt(opts.cursorWidth, defaults.cursorWidth, 0, Number.MAX_VALUE),
                hideCursorInOverviewRuler: _boolean(opts.hideCursorInOverviewRuler, defaults.hideCursorInOverviewRuler),
                scrollBeyondLastLine: _boolean(opts.scrollBeyondLastLine, defaults.scrollBeyondLastLine),
                scrollBeyondLastColumn: _clampedInt(opts.scrollBeyondLastColumn, defaults.scrollBeyondLastColumn, 0, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                smoothScrolling: _boolean(opts.smoothScrolling, defaults.smoothScrolling),
                stopRenderingLineAfter: _clampedInt(opts.stopRenderingLineAfter, defaults.stopRenderingLineAfter, -1, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                renderWhitespace: renderWhitespace,
                renderControlCharacters: _boolean(opts.renderControlCharacters, defaults.renderControlCharacters),
                fontLigatures: fontLigatures,
                renderIndentGuides: _boolean(opts.renderIndentGuides, defaults.renderIndentGuides),
                highlightActiveIndentGuide: _boolean(opts.highlightActiveIndentGuide, defaults.highlightActiveIndentGuide),
                renderLineHighlight: renderLineHighlight,
                scrollbar: scrollbar,
                minimap: minimap,
                fixedOverflowWidgets: _boolean(opts.fixedOverflowWidgets, defaults.fixedOverflowWidgets),
            };
        };
        EditorOptionsValidator._sanitizeContribInfo = function (opts, defaults) {
            var quickSuggestions;
            if (typeof opts.quickSuggestions === 'object') {
                quickSuggestions = __assign({ other: true }, opts.quickSuggestions);
            }
            else {
                quickSuggestions = _boolean(opts.quickSuggestions, defaults.quickSuggestions);
            }
            // Compatibility support for acceptSuggestionOnEnter
            if (typeof opts.acceptSuggestionOnEnter === 'boolean') {
                opts.acceptSuggestionOnEnter = opts.acceptSuggestionOnEnter ? 'on' : 'off';
            }
            var find = this._santizeFindOpts(opts.find, defaults.find);
            return {
                selectionClipboard: _boolean(opts.selectionClipboard, defaults.selectionClipboard),
                hover: this._santizeHoverOpts(opts.hover, defaults.hover),
                links: _boolean(opts.links, defaults.links),
                contextmenu: _boolean(opts.contextmenu, defaults.contextmenu),
                quickSuggestions: quickSuggestions,
                quickSuggestionsDelay: _clampedInt(opts.quickSuggestionsDelay, defaults.quickSuggestionsDelay, -1073741824 /* MIN_SAFE_SMALL_INTEGER */, 1073741824 /* MAX_SAFE_SMALL_INTEGER */),
                parameterHints: this._sanitizeParameterHintOpts(opts.parameterHints, defaults.parameterHints),
                iconsInSuggestions: _boolean(opts.iconsInSuggestions, defaults.iconsInSuggestions),
                formatOnType: _boolean(opts.formatOnType, defaults.formatOnType),
                formatOnPaste: _boolean(opts.formatOnPaste, defaults.formatOnPaste),
                suggestOnTriggerCharacters: _boolean(opts.suggestOnTriggerCharacters, defaults.suggestOnTriggerCharacters),
                acceptSuggestionOnEnter: _stringSet(opts.acceptSuggestionOnEnter, defaults.acceptSuggestionOnEnter, ['on', 'smart', 'off']),
                acceptSuggestionOnCommitCharacter: _boolean(opts.acceptSuggestionOnCommitCharacter, defaults.acceptSuggestionOnCommitCharacter),
                wordBasedSuggestions: _boolean(opts.wordBasedSuggestions, defaults.wordBasedSuggestions),
                suggestSelection: _stringSet(opts.suggestSelection, defaults.suggestSelection, ['first', 'recentlyUsed', 'recentlyUsedByPrefix']),
                suggestFontSize: _clampedInt(opts.suggestFontSize, defaults.suggestFontSize, 0, 1000),
                suggestLineHeight: _clampedInt(opts.suggestLineHeight, defaults.suggestLineHeight, 0, 1000),
                tabCompletion: this._sanitizeTabCompletionOpts(opts.tabCompletion, defaults.tabCompletion),
                suggest: this._sanitizeSuggestOpts(opts, defaults.suggest),
                selectionHighlight: _boolean(opts.selectionHighlight, defaults.selectionHighlight),
                occurrencesHighlight: _boolean(opts.occurrencesHighlight, defaults.occurrencesHighlight),
                codeLens: _boolean(opts.codeLens, defaults.codeLens),
                folding: _boolean(opts.folding, defaults.folding),
                foldingStrategy: _stringSet(opts.foldingStrategy, defaults.foldingStrategy, ['auto', 'indentation']),
                showFoldingControls: _stringSet(opts.showFoldingControls, defaults.showFoldingControls, ['always', 'mouseover']),
                matchBrackets: _boolean(opts.matchBrackets, defaults.matchBrackets),
                find: find,
                colorDecorators: _boolean(opts.colorDecorators, defaults.colorDecorators),
                lightbulbEnabled: _boolean(opts.lightbulb ? opts.lightbulb.enabled : false, defaults.lightbulbEnabled),
                codeActionsOnSave: _booleanMap(opts.codeActionsOnSave, {}),
                codeActionsOnSaveTimeout: _clampedInt(opts.codeActionsOnSaveTimeout, defaults.codeActionsOnSaveTimeout, 1, 10000)
            };
        };
        return EditorOptionsValidator;
    }());
    exports.EditorOptionsValidator = EditorOptionsValidator;
    /**
     * @internal
     */
    var InternalEditorOptionsFactory = /** @class */ (function () {
        function InternalEditorOptionsFactory() {
        }
        InternalEditorOptionsFactory._tweakValidatedOptions = function (opts, accessibilitySupport) {
            var accessibilityIsOn = (accessibilitySupport === 2 /* Enabled */);
            var accessibilityIsOff = (accessibilitySupport === 1 /* Disabled */);
            return {
                inDiffEditor: opts.inDiffEditor,
                wordSeparators: opts.wordSeparators,
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineDecorationsWidth: opts.lineDecorationsWidth,
                readOnly: opts.readOnly,
                mouseStyle: opts.mouseStyle,
                disableLayerHinting: opts.disableLayerHinting,
                automaticLayout: opts.automaticLayout,
                wordWrap: opts.wordWrap,
                wordWrapColumn: opts.wordWrapColumn,
                wordWrapMinified: opts.wordWrapMinified,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoClosingQuotes: opts.autoClosingQuotes,
                autoSurround: opts.autoSurround,
                autoIndent: opts.autoIndent,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard,
                copyWithSyntaxHighlighting: opts.copyWithSyntaxHighlighting,
                useTabStops: opts.useTabStops,
                multiCursorModifier: opts.multiCursorModifier,
                multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
                accessibilitySupport: opts.accessibilitySupport,
                showUnused: opts.showUnused,
                viewInfo: {
                    extraEditorClassName: opts.viewInfo.extraEditorClassName,
                    disableMonospaceOptimizations: opts.viewInfo.disableMonospaceOptimizations,
                    rulers: opts.viewInfo.rulers,
                    ariaLabel: (accessibilityIsOff ? nls.localize(0, null) : opts.viewInfo.ariaLabel),
                    renderLineNumbers: opts.viewInfo.renderLineNumbers,
                    renderCustomLineNumbers: opts.viewInfo.renderCustomLineNumbers,
                    selectOnLineNumbers: opts.viewInfo.selectOnLineNumbers,
                    glyphMargin: opts.viewInfo.glyphMargin,
                    revealHorizontalRightPadding: opts.viewInfo.revealHorizontalRightPadding,
                    roundedSelection: (accessibilityIsOn ? false : opts.viewInfo.roundedSelection),
                    overviewRulerLanes: opts.viewInfo.overviewRulerLanes,
                    overviewRulerBorder: opts.viewInfo.overviewRulerBorder,
                    cursorBlinking: opts.viewInfo.cursorBlinking,
                    mouseWheelZoom: opts.viewInfo.mouseWheelZoom,
                    cursorStyle: opts.viewInfo.cursorStyle,
                    cursorWidth: opts.viewInfo.cursorWidth,
                    hideCursorInOverviewRuler: opts.viewInfo.hideCursorInOverviewRuler,
                    scrollBeyondLastLine: opts.viewInfo.scrollBeyondLastLine,
                    scrollBeyondLastColumn: opts.viewInfo.scrollBeyondLastColumn,
                    smoothScrolling: opts.viewInfo.smoothScrolling,
                    stopRenderingLineAfter: opts.viewInfo.stopRenderingLineAfter,
                    renderWhitespace: (accessibilityIsOn ? 'none' : opts.viewInfo.renderWhitespace),
                    renderControlCharacters: (accessibilityIsOn ? false : opts.viewInfo.renderControlCharacters),
                    fontLigatures: (accessibilityIsOn ? false : opts.viewInfo.fontLigatures),
                    renderIndentGuides: (accessibilityIsOn ? false : opts.viewInfo.renderIndentGuides),
                    highlightActiveIndentGuide: opts.viewInfo.highlightActiveIndentGuide,
                    renderLineHighlight: opts.viewInfo.renderLineHighlight,
                    scrollbar: opts.viewInfo.scrollbar,
                    minimap: {
                        enabled: (accessibilityIsOn ? false : opts.viewInfo.minimap.enabled),
                        side: opts.viewInfo.minimap.side,
                        renderCharacters: opts.viewInfo.minimap.renderCharacters,
                        showSlider: opts.viewInfo.minimap.showSlider,
                        maxColumn: opts.viewInfo.minimap.maxColumn
                    },
                    fixedOverflowWidgets: opts.viewInfo.fixedOverflowWidgets
                },
                contribInfo: {
                    selectionClipboard: opts.contribInfo.selectionClipboard,
                    hover: opts.contribInfo.hover,
                    links: (accessibilityIsOn ? false : opts.contribInfo.links),
                    contextmenu: opts.contribInfo.contextmenu,
                    quickSuggestions: opts.contribInfo.quickSuggestions,
                    quickSuggestionsDelay: opts.contribInfo.quickSuggestionsDelay,
                    parameterHints: opts.contribInfo.parameterHints,
                    iconsInSuggestions: opts.contribInfo.iconsInSuggestions,
                    formatOnType: opts.contribInfo.formatOnType,
                    formatOnPaste: opts.contribInfo.formatOnPaste,
                    suggestOnTriggerCharacters: opts.contribInfo.suggestOnTriggerCharacters,
                    acceptSuggestionOnEnter: opts.contribInfo.acceptSuggestionOnEnter,
                    acceptSuggestionOnCommitCharacter: opts.contribInfo.acceptSuggestionOnCommitCharacter,
                    wordBasedSuggestions: opts.contribInfo.wordBasedSuggestions,
                    suggestSelection: opts.contribInfo.suggestSelection,
                    suggestFontSize: opts.contribInfo.suggestFontSize,
                    suggestLineHeight: opts.contribInfo.suggestLineHeight,
                    tabCompletion: opts.contribInfo.tabCompletion,
                    suggest: opts.contribInfo.suggest,
                    selectionHighlight: (accessibilityIsOn ? false : opts.contribInfo.selectionHighlight),
                    occurrencesHighlight: (accessibilityIsOn ? false : opts.contribInfo.occurrencesHighlight),
                    codeLens: (accessibilityIsOn ? false : opts.contribInfo.codeLens),
                    folding: (accessibilityIsOn ? false : opts.contribInfo.folding),
                    foldingStrategy: opts.contribInfo.foldingStrategy,
                    showFoldingControls: opts.contribInfo.showFoldingControls,
                    matchBrackets: (accessibilityIsOn ? false : opts.contribInfo.matchBrackets),
                    find: opts.contribInfo.find,
                    colorDecorators: opts.contribInfo.colorDecorators,
                    lightbulbEnabled: opts.contribInfo.lightbulbEnabled,
                    codeActionsOnSave: opts.contribInfo.codeActionsOnSave,
                    codeActionsOnSaveTimeout: opts.contribInfo.codeActionsOnSaveTimeout
                }
            };
        };
        InternalEditorOptionsFactory.createInternalEditorOptions = function (env, _opts) {
            var accessibilitySupport;
            if (_opts.accessibilitySupport === 'auto') {
                // The editor reads the `accessibilitySupport` from the environment
                accessibilitySupport = env.accessibilitySupport;
            }
            else if (_opts.accessibilitySupport === 'on') {
                accessibilitySupport = 2 /* Enabled */;
            }
            else {
                accessibilitySupport = 1 /* Disabled */;
            }
            // Disable some non critical features to get as best performance as possible
            // See https://github.com/Microsoft/vscode/issues/26730
            var opts = this._tweakValidatedOptions(_opts, accessibilitySupport);
            var lineDecorationsWidth;
            if (typeof opts.lineDecorationsWidth === 'string' && /^\d+(\.\d+)?ch$/.test(opts.lineDecorationsWidth)) {
                var multiple = parseFloat(opts.lineDecorationsWidth.substr(0, opts.lineDecorationsWidth.length - 2));
                lineDecorationsWidth = multiple * env.fontInfo.typicalHalfwidthCharacterWidth;
            }
            else {
                lineDecorationsWidth = _clampedInt(opts.lineDecorationsWidth, 0, 0, 1000);
            }
            if (opts.contribInfo.folding) {
                lineDecorationsWidth += 16;
            }
            var layoutInfo = EditorLayoutProvider.compute({
                outerWidth: env.outerWidth,
                outerHeight: env.outerHeight,
                showGlyphMargin: opts.viewInfo.glyphMargin,
                lineHeight: env.fontInfo.lineHeight,
                showLineNumbers: (opts.viewInfo.renderLineNumbers !== 0 /* Off */),
                lineNumbersMinChars: opts.lineNumbersMinChars,
                lineNumbersDigitCount: env.lineNumbersDigitCount,
                lineDecorationsWidth: lineDecorationsWidth,
                typicalHalfwidthCharacterWidth: env.fontInfo.typicalHalfwidthCharacterWidth,
                maxDigitWidth: env.fontInfo.maxDigitWidth,
                verticalScrollbarWidth: opts.viewInfo.scrollbar.verticalScrollbarSize,
                horizontalScrollbarHeight: opts.viewInfo.scrollbar.horizontalScrollbarSize,
                scrollbarArrowSize: opts.viewInfo.scrollbar.arrowSize,
                verticalScrollbarHasArrows: opts.viewInfo.scrollbar.verticalHasArrows,
                minimap: opts.viewInfo.minimap.enabled,
                minimapSide: opts.viewInfo.minimap.side,
                minimapRenderCharacters: opts.viewInfo.minimap.renderCharacters,
                minimapMaxColumn: opts.viewInfo.minimap.maxColumn,
                pixelRatio: env.pixelRatio
            });
            var bareWrappingInfo = null;
            {
                var wordWrap = opts.wordWrap;
                var wordWrapColumn = opts.wordWrapColumn;
                var wordWrapMinified = opts.wordWrapMinified;
                if (accessibilitySupport === 2 /* Enabled */) {
                    // See https://github.com/Microsoft/vscode/issues/27766
                    // Never enable wrapping when a screen reader is attached
                    // because arrow down etc. will not move the cursor in the way
                    // a screen reader expects.
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
                else if (wordWrapMinified && env.isDominatedByLongLines) {
                    // Force viewport width wrapping if model is dominated by long lines
                    bareWrappingInfo = {
                        isWordWrapMinified: true,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'on') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.max(1, layoutInfo.viewportColumn)
                    };
                }
                else if (wordWrap === 'bounded') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: true,
                        wrappingColumn: Math.min(Math.max(1, layoutInfo.viewportColumn), wordWrapColumn)
                    };
                }
                else if (wordWrap === 'wordWrapColumn') {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: wordWrapColumn
                    };
                }
                else {
                    bareWrappingInfo = {
                        isWordWrapMinified: false,
                        isViewportWrapping: false,
                        wrappingColumn: -1
                    };
                }
            }
            var wrappingInfo = {
                inDiffEditor: opts.inDiffEditor,
                isDominatedByLongLines: env.isDominatedByLongLines,
                isWordWrapMinified: bareWrappingInfo.isWordWrapMinified,
                isViewportWrapping: bareWrappingInfo.isViewportWrapping,
                wrappingColumn: bareWrappingInfo.wrappingColumn,
                wrappingIndent: opts.wrappingIndent,
                wordWrapBreakBeforeCharacters: opts.wordWrapBreakBeforeCharacters,
                wordWrapBreakAfterCharacters: opts.wordWrapBreakAfterCharacters,
                wordWrapBreakObtrusiveCharacters: opts.wordWrapBreakObtrusiveCharacters,
            };
            var className = 'monaco-editor';
            if (opts.viewInfo.extraEditorClassName) {
                className += ' ' + opts.viewInfo.extraEditorClassName;
            }
            if (env.extraEditorClassName) {
                className += ' ' + env.extraEditorClassName;
            }
            if (opts.viewInfo.fontLigatures) {
                className += ' enable-ligatures';
            }
            if (opts.mouseStyle === 'default') {
                className += ' mouse-default';
            }
            else if (opts.mouseStyle === 'copy') {
                className += ' mouse-copy';
            }
            return new InternalEditorOptions({
                canUseLayerHinting: opts.disableLayerHinting ? false : true,
                pixelRatio: env.pixelRatio,
                editorClassName: className,
                lineHeight: env.fontInfo.lineHeight,
                readOnly: opts.readOnly,
                accessibilitySupport: accessibilitySupport,
                multiCursorModifier: opts.multiCursorModifier,
                multiCursorMergeOverlapping: opts.multiCursorMergeOverlapping,
                wordSeparators: opts.wordSeparators,
                autoClosingBrackets: opts.autoClosingBrackets,
                autoClosingQuotes: opts.autoClosingQuotes,
                autoSurround: opts.autoSurround,
                autoIndent: opts.autoIndent,
                useTabStops: opts.useTabStops,
                tabFocusMode: opts.readOnly ? true : env.tabFocusMode,
                dragAndDrop: opts.dragAndDrop,
                emptySelectionClipboard: opts.emptySelectionClipboard && env.emptySelectionClipboard,
                copyWithSyntaxHighlighting: opts.copyWithSyntaxHighlighting,
                layoutInfo: layoutInfo,
                fontInfo: env.fontInfo,
                viewInfo: opts.viewInfo,
                wrappingInfo: wrappingInfo,
                contribInfo: opts.contribInfo,
                showUnused: opts.showUnused,
            });
        };
        return InternalEditorOptionsFactory;
    }());
    exports.InternalEditorOptionsFactory = InternalEditorOptionsFactory;
    /**
     * @internal
     */
    var EditorLayoutProvider = /** @class */ (function () {
        function EditorLayoutProvider() {
        }
        EditorLayoutProvider.compute = function (_opts) {
            var outerWidth = _opts.outerWidth | 0;
            var outerHeight = _opts.outerHeight | 0;
            var showGlyphMargin = _opts.showGlyphMargin;
            var lineHeight = _opts.lineHeight | 0;
            var showLineNumbers = _opts.showLineNumbers;
            var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
            var lineNumbersDigitCount = _opts.lineNumbersDigitCount | 0;
            var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
            var typicalHalfwidthCharacterWidth = _opts.typicalHalfwidthCharacterWidth;
            var maxDigitWidth = _opts.maxDigitWidth;
            var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
            var verticalScrollbarHasArrows = _opts.verticalScrollbarHasArrows;
            var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
            var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
            var minimap = _opts.minimap;
            var minimapSide = _opts.minimapSide;
            var minimapRenderCharacters = _opts.minimapRenderCharacters;
            var minimapMaxColumn = _opts.minimapMaxColumn | 0;
            var pixelRatio = _opts.pixelRatio;
            var lineNumbersWidth = 0;
            if (showLineNumbers) {
                var digitCount = Math.max(lineNumbersDigitCount, lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            var glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight;
            }
            var glyphMarginLeft = 0;
            var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            var contentLeft = decorationsLeft + lineDecorationsWidth;
            var remainingWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            var renderMinimap;
            var minimapLeft;
            var minimapWidth;
            var contentWidth;
            if (!minimap) {
                minimapLeft = 0;
                minimapWidth = 0;
                renderMinimap = 0 /* None */;
                contentWidth = remainingWidth;
            }
            else {
                var minimapCharWidth = void 0;
                if (pixelRatio >= 2) {
                    renderMinimap = minimapRenderCharacters ? 2 /* Large */ : 4 /* LargeBlocks */;
                    minimapCharWidth = 2 / pixelRatio;
                }
                else {
                    renderMinimap = minimapRenderCharacters ? 1 /* Small */ : 3 /* SmallBlocks */;
                    minimapCharWidth = 1 / pixelRatio;
                }
                // Given:
                // (leaving 2px for the cursor to have space after the last character)
                // viewportColumn = (contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth
                // minimapWidth = viewportColumn * minimapCharWidth
                // contentWidth = remainingWidth - minimapWidth
                // What are good values for contentWidth and minimapWidth ?
                // minimapWidth = ((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (contentWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // typicalHalfwidthCharacterWidth * minimapWidth = (remainingWidth - minimapWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // (typicalHalfwidthCharacterWidth + minimapCharWidth) * minimapWidth = (remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth
                // minimapWidth = ((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)
                minimapWidth = Math.max(0, Math.floor(((remainingWidth - verticalScrollbarWidth - 2) * minimapCharWidth) / (typicalHalfwidthCharacterWidth + minimapCharWidth)));
                var minimapColumns = minimapWidth / minimapCharWidth;
                if (minimapColumns > minimapMaxColumn) {
                    minimapWidth = Math.floor(minimapMaxColumn * minimapCharWidth);
                }
                contentWidth = remainingWidth - minimapWidth;
                if (minimapSide === 'left') {
                    minimapLeft = 0;
                    glyphMarginLeft += minimapWidth;
                    lineNumbersLeft += minimapWidth;
                    decorationsLeft += minimapWidth;
                    contentLeft += minimapWidth;
                }
                else {
                    minimapLeft = outerWidth - minimapWidth - verticalScrollbarWidth;
                }
            }
            // (leaving 2px for the cursor to have space after the last character)
            var viewportColumn = Math.max(1, Math.floor((contentWidth - verticalScrollbarWidth - 2) / typicalHalfwidthCharacterWidth));
            var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            return {
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginHeight: outerHeight,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                lineNumbersHeight: outerHeight,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                decorationsHeight: outerHeight,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                contentHeight: outerHeight,
                renderMinimap: renderMinimap,
                minimapLeft: minimapLeft,
                minimapWidth: minimapWidth,
                viewportColumn: viewportColumn,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: {
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                }
            };
        };
        return EditorLayoutProvider;
    }());
    exports.EditorLayoutProvider = EditorLayoutProvider;
    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'monospace\', monospace, \'Droid Sans Fallback\'';
    /**
     * @internal
     */
    exports.EDITOR_FONT_DEFAULTS = {
        fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
        fontWeight: 'normal',
        fontSize: (platform.isMacintosh ? 12 : 14),
        lineHeight: 0,
        letterSpacing: 0,
    };
    /**
     * @internal
     */
    exports.EDITOR_MODEL_DEFAULTS = {
        tabSize: 4,
        insertSpaces: false,
        detectIndentation: true,
        trimAutoWhitespace: true,
        largeFileOptimizations: true
    };
    /**
     * @internal
     */
    exports.EDITOR_DEFAULTS = {
        inDiffEditor: false,
        wordSeparators: wordHelper_1.USUAL_WORD_SEPARATORS,
        lineNumbersMinChars: 5,
        lineDecorationsWidth: 10,
        readOnly: false,
        mouseStyle: 'text',
        disableLayerHinting: false,
        automaticLayout: false,
        wordWrap: 'off',
        wordWrapColumn: 80,
        wordWrapMinified: true,
        wrappingIndent: 1 /* Same */,
        wordWrapBreakBeforeCharacters: '([{+',
        wordWrapBreakAfterCharacters: ' \t})]?|&,;',
        wordWrapBreakObtrusiveCharacters: '.',
        autoClosingBrackets: 'languageDefined',
        autoClosingQuotes: 'languageDefined',
        autoSurround: 'languageDefined',
        autoIndent: true,
        dragAndDrop: true,
        emptySelectionClipboard: true,
        copyWithSyntaxHighlighting: true,
        useTabStops: true,
        multiCursorModifier: 'altKey',
        multiCursorMergeOverlapping: true,
        accessibilitySupport: 'auto',
        showUnused: true,
        viewInfo: {
            extraEditorClassName: '',
            disableMonospaceOptimizations: false,
            rulers: [],
            ariaLabel: nls.localize(1, null),
            renderLineNumbers: 1 /* On */,
            renderCustomLineNumbers: null,
            selectOnLineNumbers: true,
            glyphMargin: true,
            revealHorizontalRightPadding: 30,
            roundedSelection: true,
            overviewRulerLanes: 2,
            overviewRulerBorder: true,
            cursorBlinking: 1 /* Blink */,
            mouseWheelZoom: false,
            cursorStyle: TextEditorCursorStyle.Line,
            cursorWidth: 0,
            hideCursorInOverviewRuler: false,
            scrollBeyondLastLine: true,
            scrollBeyondLastColumn: 5,
            smoothScrolling: false,
            stopRenderingLineAfter: 10000,
            renderWhitespace: 'none',
            renderControlCharacters: false,
            fontLigatures: false,
            renderIndentGuides: true,
            highlightActiveIndentGuide: true,
            renderLineHighlight: 'line',
            scrollbar: {
                vertical: 1 /* Auto */,
                horizontal: 1 /* Auto */,
                arrowSize: 11,
                useShadows: true,
                verticalHasArrows: false,
                horizontalHasArrows: false,
                horizontalScrollbarSize: 10,
                horizontalSliderSize: 10,
                verticalScrollbarSize: 14,
                verticalSliderSize: 14,
                handleMouseWheel: true,
                mouseWheelScrollSensitivity: 1,
            },
            minimap: {
                enabled: true,
                side: 'right',
                showSlider: 'mouseover',
                renderCharacters: true,
                maxColumn: 120
            },
            fixedOverflowWidgets: false,
        },
        contribInfo: {
            selectionClipboard: true,
            hover: {
                enabled: true,
                delay: 300,
                sticky: true
            },
            links: true,
            contextmenu: true,
            quickSuggestions: { other: true, comments: false, strings: false },
            quickSuggestionsDelay: 10,
            parameterHints: {
                enabled: true,
                cycle: false
            },
            iconsInSuggestions: true,
            formatOnType: false,
            formatOnPaste: false,
            suggestOnTriggerCharacters: true,
            acceptSuggestionOnEnter: 'on',
            acceptSuggestionOnCommitCharacter: true,
            wordBasedSuggestions: true,
            suggestSelection: 'recentlyUsed',
            suggestFontSize: 0,
            suggestLineHeight: 0,
            tabCompletion: 'off',
            suggest: {
                filterGraceful: true,
                snippets: 'inline',
                snippetsPreventQuickSuggestions: true,
                localityBonus: false
            },
            selectionHighlight: true,
            occurrencesHighlight: true,
            codeLens: true,
            folding: true,
            foldingStrategy: 'auto',
            showFoldingControls: 'mouseover',
            matchBrackets: true,
            find: {
                seedSearchStringFromSelection: true,
                autoFindInSelection: false,
                globalFindClipboard: false
            },
            colorDecorators: true,
            lightbulbEnabled: true,
            codeActionsOnSave: {},
            codeActionsOnSaveTimeout: 750
        },
    };
});

define(__m[188/*vs/nls!vs/platform/configuration/common/configurationRegistry*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/configuration/common/configurationRegistry", data); });
define(__m[78/*vs/nls!vs/platform/extensionManagement/common/extensionManagement*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/extensionManagement/common/extensionManagement", data); });
define(__m[79/*vs/nls!vs/platform/markers/common/markers*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/markers/common/markers", data); });
define(__m[80/*vs/nls!vs/platform/workspaces/common/workspaces*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/platform/workspaces/common/workspaces", data); });
define(__m[81/*vs/nls!vs/workbench/api/node/extHost.api.impl*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHost.api.impl", data); });
define(__m[82/*vs/nls!vs/workbench/api/node/extHostDebugService*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostDebugService", data); });
define(__m[83/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostDiagnostics", data); });
define(__m[84/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostExtensionActivator", data); });
define(__m[85/*vs/nls!vs/workbench/api/node/extHostProgress*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostProgress", data); });
define(__m[86/*vs/nls!vs/workbench/api/node/extHostTask*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTask", data); });
define(__m[87/*vs/nls!vs/workbench/api/node/extHostTreeViews*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostTreeViews", data); });
define(__m[88/*vs/nls!vs/workbench/api/node/extHostWorkspace*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/api/node/extHostWorkspace", data); });
define(__m[89/*vs/nls!vs/workbench/node/extensionHostMain*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/node/extensionHostMain", data); });
define(__m[90/*vs/nls!vs/workbench/parts/debug/node/debugAdapter*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/parts/debug/node/debugAdapter", data); });
define(__m[91/*vs/nls!vs/workbench/parts/debug/node/terminals*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/parts/debug/node/terminals", data); });
define(__m[92/*vs/nls!vs/workbench/services/configurationResolver/node/variableResolver*/], __M([15/*vs/nls*/,16/*vs/nls!vs/workbench/node/extensionHostProcess*/]), function(nls, data) { return nls.create("vs/workbench/services/configurationResolver/node/variableResolver", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[58/*vs/platform/files/node/files*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // See https://github.com/Microsoft/vscode/issues/30180
    var WIN32_MAX_FILE_SIZE = 300 * 1024 * 1024; // 300 MB
    var GENERAL_MAX_FILE_SIZE = 16 * 1024 * 1024 * 1024; // 16 GB
    // See https://github.com/v8/v8/blob/5918a23a3d571b9625e5cce246bdd5b46ff7cd8b/src/heap/heap.cc#L149
    var WIN32_MAX_HEAP_SIZE = 700 * 1024 * 1024; // 700 MB
    var GENERAL_MAX_HEAP_SIZE = 700 * 2 * 1024 * 1024; // 1400 MB
    exports.MAX_FILE_SIZE = process.arch === 'ia32' ? WIN32_MAX_FILE_SIZE : GENERAL_MAX_FILE_SIZE;
    exports.MAX_HEAP_SIZE = process.arch === 'ia32' ? WIN32_MAX_HEAP_SIZE : GENERAL_MAX_HEAP_SIZE;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[19/*vs/platform/instantiation/common/instantiation*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[95/*vs/editor/common/services/modelService*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IModelService = instantiation_1.createDecorator('modelService');
    function shouldSynchronizeModel(model) {
        return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);
    }
    exports.shouldSynchronizeModel = shouldSynchronizeModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[96/*vs/editor/common/modes/languageFeatureRegistry*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,55/*vs/editor/common/modes/languageSelector*/,95/*vs/editor/common/services/modelService*/]), function (require, exports, event_1, lifecycle_1, languageSelector_1, modelService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isExclusive(selector) {
        if (typeof selector === 'string') {
            return false;
        }
        else if (Array.isArray(selector)) {
            return selector.every(isExclusive);
        }
        else {
            return !!selector.exclusive;
        }
    }
    var LanguageFeatureRegistry = /** @class */ (function () {
        function LanguageFeatureRegistry() {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider) {
            var _this = this;
            var entry = {
                selector: selector,
                provider: provider,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return lifecycle_1.toDisposable(function () {
                if (entry) {
                    var idx = _this._entries.indexOf(entry);
                    if (idx >= 0) {
                        _this._entries.splice(idx, 1);
                        _this._lastCandidate = undefined;
                        _this._onDidChange.fire(_this._entries.length);
                        entry = undefined;
                    }
                }
            });
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model) {
                return;
            }
            this._updateScores(model);
            for (var from = 0; from < this._entries.length; from++) {
                var entry = this._entries[from];
                if (entry._score > 0) {
                    callback(entry);
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.uri.toString(),
                language: model.getLanguageIdentifier().language
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.uri, model.getLanguageIdentifier().language, modelService_1.shouldSynchronizeModel(model));
                if (isExclusive(entry.selector) && entry._score > 0) {
                    // support for one exclusive selector that overwrites
                    // any other selector
                    for (var _b = 0, _c = this._entries; _b < _c.length; _b++) {
                        var entry_1 = _c[_b];
                        entry_1._score = 0;
                    }
                    entry._score = 1000;
                    break;
                }
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    exports.LanguageFeatureRegistry = LanguageFeatureRegistry;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[97/*vs/editor/common/modes*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/types*/,96/*vs/editor/common/modes/languageFeatureRegistry*/,105/*vs/editor/common/modes/tokenizationRegistry*/]), function (require, exports, types_1, languageFeatureRegistry_1, tokenizationRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Open ended enum at runtime
     * @internal
     */
    var LanguageId;
    (function (LanguageId) {
        LanguageId[LanguageId["Null"] = 0] = "Null";
        LanguageId[LanguageId["PlainText"] = 1] = "PlainText";
    })(LanguageId = exports.LanguageId || (exports.LanguageId = {}));
    /**
     * @internal
     */
    var LanguageIdentifier = /** @class */ (function () {
        function LanguageIdentifier(language, id) {
            this.language = language;
            this.id = id;
        }
        return LanguageIdentifier;
    }());
    exports.LanguageIdentifier = LanguageIdentifier;
    /**
     * A font style. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["NotSet"] = -1] = "NotSet";
        FontStyle[FontStyle["None"] = 0] = "None";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Bold"] = 2] = "Bold";
        FontStyle[FontStyle["Underline"] = 4] = "Underline";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * Open ended enum at runtime
     * @internal
     */
    var ColorId;
    (function (ColorId) {
        ColorId[ColorId["None"] = 0] = "None";
        ColorId[ColorId["DefaultForeground"] = 1] = "DefaultForeground";
        ColorId[ColorId["DefaultBackground"] = 2] = "DefaultBackground";
    })(ColorId = exports.ColorId || (exports.ColorId = {}));
    /**
     * A standard token type. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var StandardTokenType;
    (function (StandardTokenType) {
        StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
        StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
        StandardTokenType[StandardTokenType["String"] = 2] = "String";
        StandardTokenType[StandardTokenType["RegEx"] = 4] = "RegEx";
    })(StandardTokenType = exports.StandardTokenType || (exports.StandardTokenType = {}));
    /**
     * Helpers to manage the "collapsed" metadata of an entire StackElement stack.
     * The following assumptions have been made:
     *  - languageId < 256 => needs 8 bits
     *  - unique color count < 512 => needs 9 bits
     *
     * The binary format is:
     * - -------------------------------------------
     *     3322 2222 2222 1111 1111 1100 0000 0000
     *     1098 7654 3210 9876 5432 1098 7654 3210
     * - -------------------------------------------
     *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
     *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
     * - -------------------------------------------
     *  - L = LanguageId (8 bits)
     *  - T = StandardTokenType (3 bits)
     *  - F = FontStyle (3 bits)
     *  - f = foreground color (9 bits)
     *  - b = background color (9 bits)
     *
     * @internal
     */
    var MetadataConsts;
    (function (MetadataConsts) {
        MetadataConsts[MetadataConsts["LANGUAGEID_MASK"] = 255] = "LANGUAGEID_MASK";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_MASK"] = 1792] = "TOKEN_TYPE_MASK";
        MetadataConsts[MetadataConsts["FONT_STYLE_MASK"] = 14336] = "FONT_STYLE_MASK";
        MetadataConsts[MetadataConsts["FOREGROUND_MASK"] = 8372224] = "FOREGROUND_MASK";
        MetadataConsts[MetadataConsts["BACKGROUND_MASK"] = 4286578688] = "BACKGROUND_MASK";
        MetadataConsts[MetadataConsts["LANGUAGEID_OFFSET"] = 0] = "LANGUAGEID_OFFSET";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_OFFSET"] = 8] = "TOKEN_TYPE_OFFSET";
        MetadataConsts[MetadataConsts["FONT_STYLE_OFFSET"] = 11] = "FONT_STYLE_OFFSET";
        MetadataConsts[MetadataConsts["FOREGROUND_OFFSET"] = 14] = "FOREGROUND_OFFSET";
        MetadataConsts[MetadataConsts["BACKGROUND_OFFSET"] = 23] = "BACKGROUND_OFFSET";
    })(MetadataConsts = exports.MetadataConsts || (exports.MetadataConsts = {}));
    /**
     * @internal
     */
    var TokenMetadata = /** @class */ (function () {
        function TokenMetadata() {
        }
        TokenMetadata.getLanguageId = function (metadata) {
            return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;
        };
        TokenMetadata.getTokenType = function (metadata) {
            return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;
        };
        TokenMetadata.getFontStyle = function (metadata) {
            return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;
        };
        TokenMetadata.getForeground = function (metadata) {
            return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;
        };
        TokenMetadata.getBackground = function (metadata) {
            return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;
        };
        TokenMetadata.getClassNameFromMetadata = function (metadata) {
            var foreground = this.getForeground(metadata);
            var className = 'mtk' + foreground;
            var fontStyle = this.getFontStyle(metadata);
            if (fontStyle & 1 /* Italic */) {
                className += ' mtki';
            }
            if (fontStyle & 2 /* Bold */) {
                className += ' mtkb';
            }
            if (fontStyle & 4 /* Underline */) {
                className += ' mtku';
            }
            return className;
        };
        TokenMetadata.getInlineStyleFromMetadata = function (metadata, colorMap) {
            var foreground = this.getForeground(metadata);
            var fontStyle = this.getFontStyle(metadata);
            var result = "color: " + colorMap[foreground] + ";";
            if (fontStyle & 1 /* Italic */) {
                result += 'font-style: italic;';
            }
            if (fontStyle & 2 /* Bold */) {
                result += 'font-weight: bold;';
            }
            if (fontStyle & 4 /* Underline */) {
                result += 'text-decoration: underline;';
            }
            return result;
        };
        return TokenMetadata;
    }());
    exports.TokenMetadata = TokenMetadata;
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
        CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
        CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
        CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
        CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
        CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
        CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
        CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
        CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
        CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
        CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
        CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
        CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
        CompletionItemKind[CompletionItemKind["Snippet"] = 25] = "Snippet";
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    /**
     * @internal
     */
    exports.completionKindToCssClass = (function () {
        var data = Object.create(null);
        data[0 /* Method */] = 'method';
        data[1 /* Function */] = 'function';
        data[2 /* Constructor */] = 'constructor';
        data[3 /* Field */] = 'field';
        data[4 /* Variable */] = 'variable';
        data[5 /* Class */] = 'class';
        data[6 /* Struct */] = 'struct';
        data[7 /* Interface */] = 'interface';
        data[8 /* Module */] = 'module';
        data[9 /* Property */] = 'property';
        data[10 /* Event */] = 'event';
        data[11 /* Operator */] = 'operator';
        data[12 /* Unit */] = 'unit';
        data[13 /* Value */] = 'value';
        data[14 /* Constant */] = 'constant';
        data[15 /* Enum */] = 'enum';
        data[16 /* EnumMember */] = 'enum-member';
        data[17 /* Keyword */] = 'keyword';
        data[25 /* Snippet */] = 'snippet';
        data[18 /* Text */] = 'text';
        data[19 /* Color */] = 'color';
        data[20 /* File */] = 'file';
        data[21 /* Reference */] = 'reference';
        data[22 /* Customcolor */] = 'customcolor';
        data[23 /* Folder */] = 'folder';
        data[24 /* TypeParameter */] = 'type-parameter';
        return function (kind) {
            return data[kind] || 'property';
        };
    })();
    /**
     * @internal
     */
    exports.completionKindFromLegacyString = (function () {
        var data = Object.create(null);
        data['method'] = 0 /* Method */;
        data['function'] = 1 /* Function */;
        data['constructor'] = 2 /* Constructor */;
        data['field'] = 3 /* Field */;
        data['variable'] = 4 /* Variable */;
        data['class'] = 5 /* Class */;
        data['struct'] = 6 /* Struct */;
        data['interface'] = 7 /* Interface */;
        data['module'] = 8 /* Module */;
        data['property'] = 9 /* Property */;
        data['event'] = 10 /* Event */;
        data['operator'] = 11 /* Operator */;
        data['unit'] = 12 /* Unit */;
        data['value'] = 13 /* Value */;
        data['constant'] = 14 /* Constant */;
        data['enum'] = 15 /* Enum */;
        data['enum-member'] = 16 /* EnumMember */;
        data['keyword'] = 17 /* Keyword */;
        data['snippet'] = 25 /* Snippet */;
        data['text'] = 18 /* Text */;
        data['color'] = 19 /* Color */;
        data['file'] = 20 /* File */;
        data['reference'] = 21 /* Reference */;
        data['customcolor'] = 22 /* Customcolor */;
        data['folder'] = 23 /* Folder */;
        data['type-parameter'] = 24 /* TypeParameter */;
        return function (value) {
            return data[value] || 'property';
        };
    })();
    var CompletionItemInsertTextRule;
    (function (CompletionItemInsertTextRule) {
        /**
         * Adjust whitespace/indentation of multiline insert texts to
         * match the current line indentation.
         */
        CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
        /**
         * `insertText` is a snippet.
         */
        CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
    })(CompletionItemInsertTextRule = exports.CompletionItemInsertTextRule || (exports.CompletionItemInsertTextRule = {}));
    /**
     * How a suggest provider was triggered.
     */
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    /**
     * @internal
     */
    var CodeActionTrigger;
    (function (CodeActionTrigger) {
        CodeActionTrigger[CodeActionTrigger["Automatic"] = 1] = "Automatic";
        CodeActionTrigger[CodeActionTrigger["Manual"] = 2] = "Manual";
    })(CodeActionTrigger = exports.CodeActionTrigger || (exports.CodeActionTrigger = {}));
    var SignatureHelpTriggerReason;
    (function (SignatureHelpTriggerReason) {
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["ContentChange"] = 3] = "ContentChange";
    })(SignatureHelpTriggerReason = exports.SignatureHelpTriggerReason || (exports.SignatureHelpTriggerReason = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    /**
     * @internal
     */
    exports.symbolKindToCssClass = (function () {
        var _fromMapping = Object.create(null);
        _fromMapping[0 /* File */] = 'file';
        _fromMapping[1 /* Module */] = 'module';
        _fromMapping[2 /* Namespace */] = 'namespace';
        _fromMapping[3 /* Package */] = 'package';
        _fromMapping[4 /* Class */] = 'class';
        _fromMapping[5 /* Method */] = 'method';
        _fromMapping[6 /* Property */] = 'property';
        _fromMapping[7 /* Field */] = 'field';
        _fromMapping[8 /* Constructor */] = 'constructor';
        _fromMapping[9 /* Enum */] = 'enum';
        _fromMapping[10 /* Interface */] = 'interface';
        _fromMapping[11 /* Function */] = 'function';
        _fromMapping[12 /* Variable */] = 'variable';
        _fromMapping[13 /* Constant */] = 'constant';
        _fromMapping[14 /* String */] = 'string';
        _fromMapping[15 /* Number */] = 'number';
        _fromMapping[16 /* Boolean */] = 'boolean';
        _fromMapping[17 /* Array */] = 'array';
        _fromMapping[18 /* Object */] = 'object';
        _fromMapping[19 /* Key */] = 'key';
        _fromMapping[20 /* Null */] = 'null';
        _fromMapping[21 /* EnumMember */] = 'enum-member';
        _fromMapping[22 /* Struct */] = 'struct';
        _fromMapping[23 /* Event */] = 'event';
        _fromMapping[24 /* Operator */] = 'operator';
        _fromMapping[25 /* TypeParameter */] = 'type-parameter';
        return function toCssClassName(kind) {
            return "symbol-icon " + (_fromMapping[kind] || 'property');
        };
    })();
    var FoldingRangeKind = /** @class */ (function () {
        /**
         * Creates a new [FoldingRangeKind](#FoldingRangeKind).
         *
         * @param value of the kind.
         */
        function FoldingRangeKind(value) {
            this.value = value;
        }
        /**
         * Kind for folding range representing a comment. The value of the kind is 'comment'.
         */
        FoldingRangeKind.Comment = new FoldingRangeKind('comment');
        /**
         * Kind for folding range representing a import. The value of the kind is 'imports'.
         */
        FoldingRangeKind.Imports = new FoldingRangeKind('imports');
        /**
         * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
         * The value of the kind is 'region'.
         */
        FoldingRangeKind.Region = new FoldingRangeKind('region');
        return FoldingRangeKind;
    }());
    exports.FoldingRangeKind = FoldingRangeKind;
    /**
     * @internal
     */
    function isResourceFileEdit(thing) {
        return types_1.isObject(thing) && (Boolean(thing.newUri) || Boolean(thing.oldUri));
    }
    exports.isResourceFileEdit = isResourceFileEdit;
    /**
     * @internal
     */
    function isResourceTextEdit(thing) {
        return types_1.isObject(thing) && thing.resource && Array.isArray(thing.edits);
    }
    exports.isResourceTextEdit = isResourceTextEdit;
    /**
     * @internal
     */
    var CommentThreadCollapsibleState;
    (function (CommentThreadCollapsibleState) {
        /**
         * Determines an item is collapsed
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
        /**
         * Determines an item is expanded
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
    })(CommentThreadCollapsibleState = exports.CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = {}));
    // --- feature registries ------
    /**
     * @internal
     */
    exports.ReferenceProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.RenameProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.CompletionProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.SignatureHelpProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.HoverProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.DocumentSymbolProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.DocumentHighlightProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.DefinitionProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.ImplementationProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.TypeDefinitionProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.CodeLensProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.CodeActionProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.DocumentFormattingEditProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.DocumentRangeFormattingEditProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.OnTypeFormattingEditProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.LinkProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.ColorProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.FoldingRangeProviderRegistry = new languageFeatureRegistry_1.LanguageFeatureRegistry();
    /**
     * @internal
     */
    exports.TokenizationRegistry = new tokenizationRegistry_1.TokenizationRegistryImpl();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[98/*vs/platform/commands/common/commands*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/lifecycle*/,18/*vs/base/common/types*/,19/*vs/platform/instantiation/common/instantiation*/,38/*vs/base/common/linkedList*/]), function (require, exports, lifecycle_1, types_1, instantiation_1, linkedList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ICommandService = instantiation_1.createDecorator('commandService');
    exports.CommandsRegistry = new /** @class */ (function () {
        function class_1() {
            this._commands = new Map();
        }
        class_1.prototype.registerCommand = function (idOrCommand, handler) {
            var _this = this;
            if (!idOrCommand) {
                throw new Error("invalid command");
            }
            if (typeof idOrCommand === 'string') {
                if (!handler) {
                    throw new Error("invalid command");
                }
                return this.registerCommand({ id: idOrCommand, handler: handler });
            }
            // add argument validation if rich command metadata is provided
            if (idOrCommand.description) {
                var constraints_1 = [];
                for (var _i = 0, _a = idOrCommand.description.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    constraints_1.push(arg.constraint);
                }
                var actualHandler_1 = idOrCommand.handler;
                idOrCommand.handler = function (accessor) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    types_1.validateConstraints(args, constraints_1);
                    return actualHandler_1.apply(void 0, [accessor].concat(args));
                };
            }
            // find a place to store the command
            var id = idOrCommand.id;
            var commands = this._commands.get(id);
            if (!commands) {
                commands = new linkedList_1.LinkedList();
                this._commands.set(id, commands);
            }
            var removeFn = commands.unshift(idOrCommand);
            return lifecycle_1.toDisposable(function () {
                removeFn();
                if (_this._commands.get(id).isEmpty()) {
                    _this._commands.delete(id);
                }
            });
        };
        class_1.prototype.registerCommandAlias = function (oldId, newId) {
            return exports.CommandsRegistry.registerCommand(oldId, function (accessor) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _a;
                (_a = accessor.get(exports.ICommandService)).executeCommand.apply(_a, [newId].concat(args));
            });
        };
        class_1.prototype.getCommand = function (id) {
            var list = this._commands.get(id);
            if (!list || list.isEmpty()) {
                return undefined;
            }
            return list.iterator().next().value;
        };
        class_1.prototype.getCommands = function () {
            var _this = this;
            var result = Object.create(null);
            this._commands.forEach(function (value, key) {
                result[key] = _this.getCommand(key);
            });
            return result;
        };
        return class_1;
    }());
    exports.NullCommandService = {
        _serviceBrand: undefined,
        onWillExecuteCommand: function () { return ({ dispose: function () { } }); },
        executeCommand: function () {
            return Promise.resolve(undefined);
        }
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[59/*vs/platform/contextkey/common/contextkey*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/strings*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, strings_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ContextKeyExprType;
    (function (ContextKeyExprType) {
        ContextKeyExprType[ContextKeyExprType["Defined"] = 1] = "Defined";
        ContextKeyExprType[ContextKeyExprType["Not"] = 2] = "Not";
        ContextKeyExprType[ContextKeyExprType["Equals"] = 3] = "Equals";
        ContextKeyExprType[ContextKeyExprType["NotEquals"] = 4] = "NotEquals";
        ContextKeyExprType[ContextKeyExprType["And"] = 5] = "And";
        ContextKeyExprType[ContextKeyExprType["Regex"] = 6] = "Regex";
    })(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));
    var ContextKeyExpr = /** @class */ (function () {
        function ContextKeyExpr() {
        }
        ContextKeyExpr.has = function (key) {
            return new ContextKeyDefinedExpr(key);
        };
        ContextKeyExpr.equals = function (key, value) {
            return new ContextKeyEqualsExpr(key, value);
        };
        ContextKeyExpr.notEquals = function (key, value) {
            return new ContextKeyNotEqualsExpr(key, value);
        };
        ContextKeyExpr.regex = function (key, value) {
            return new ContextKeyRegexExpr(key, value);
        };
        ContextKeyExpr.not = function (key) {
            return new ContextKeyNotExpr(key);
        };
        ContextKeyExpr.and = function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            return new ContextKeyAndExpr(expr);
        };
        ContextKeyExpr.deserialize = function (serialized) {
            var _this = this;
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p); }));
            return result.normalize();
        };
        ContextKeyExpr._deserializeOne = function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('=~') >= 0) {
                var pieces = serializedOne.split('=~');
                return new ContextKeyRegexExpr(pieces[0].trim(), this._deserializeRegexValue(pieces[1]));
            }
            if (/^\!\s*/.test(serializedOne)) {
                return new ContextKeyNotExpr(serializedOne.substr(1).trim());
            }
            return new ContextKeyDefinedExpr(serializedOne);
        };
        ContextKeyExpr._deserializeValue = function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        };
        ContextKeyExpr._deserializeRegexValue = function (serializedValue) {
            if (strings_1.isFalsyOrWhitespace(serializedValue)) {
                console.warn('missing regexp-value for =~-expression');
                return null;
            }
            var start = serializedValue.indexOf('/');
            var end = serializedValue.lastIndexOf('/');
            if (start === end || start < 0 /* || to < 0 */) {
                console.warn("bad regexp-value '" + serializedValue + "', missing /-enclosure");
                return null;
            }
            var value = serializedValue.slice(start + 1, end);
            var caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
            try {
                return new RegExp(value, caseIgnoreFlag);
            }
            catch (e) {
                console.warn("bad regexp-value '" + serializedValue + "', parse error: " + e);
                return null;
            }
        };
        return ContextKeyExpr;
    }());
    exports.ContextKeyExpr = ContextKeyExpr;
    function cmp(a, b) {
        var aType = a.getType();
        var bType = b.getType();
        if (aType !== bType) {
            return aType - bType;
        }
        switch (aType) {
            case 1 /* Defined */:
                return a.cmp(b);
            case 2 /* Not */:
                return a.cmp(b);
            case 3 /* Equals */:
                return a.cmp(b);
            case 4 /* NotEquals */:
                return a.cmp(b);
            case 6 /* Regex */:
                return a.cmp(b);
            default:
                throw new Error('Unknown ContextKeyExpr!');
        }
    }
    var ContextKeyDefinedExpr = /** @class */ (function () {
        function ContextKeyDefinedExpr(key) {
            this.key = key;
        }
        ContextKeyDefinedExpr.prototype.getType = function () {
            return 1 /* Defined */;
        };
        ContextKeyDefinedExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyDefinedExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyDefinedExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyDefinedExpr.prototype.evaluate = function (context) {
            return (!!context.getValue(this.key));
        };
        ContextKeyDefinedExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyDefinedExpr.prototype.serialize = function () {
            return this.key;
        };
        ContextKeyDefinedExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyDefinedExpr;
    }());
    exports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;
    var ContextKeyEqualsExpr = /** @class */ (function () {
        function ContextKeyEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyEqualsExpr.prototype.getType = function () {
            return 3 /* Equals */;
        };
        ContextKeyEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context.getValue(this.key) == this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyDefinedExpr(this.key);
                }
                return new ContextKeyNotExpr(this.key);
            }
            return this;
        };
        ContextKeyEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        ContextKeyEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyEqualsExpr;
    }());
    exports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;
    var ContextKeyNotEqualsExpr = /** @class */ (function () {
        function ContextKeyNotEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyNotEqualsExpr.prototype.getType = function () {
            return 4 /* NotEquals */;
        };
        ContextKeyNotEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context.getValue(this.key) != this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyNotEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyNotExpr(this.key);
                }
                return new ContextKeyDefinedExpr(this.key);
            }
            return this;
        };
        ContextKeyNotEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        ContextKeyNotEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotEqualsExpr;
    }());
    exports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;
    var ContextKeyNotExpr = /** @class */ (function () {
        function ContextKeyNotExpr(key) {
            this.key = key;
        }
        ContextKeyNotExpr.prototype.getType = function () {
            return 2 /* Not */;
        };
        ContextKeyNotExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyNotExpr.prototype.evaluate = function (context) {
            return (!context.getValue(this.key));
        };
        ContextKeyNotExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyNotExpr.prototype.serialize = function () {
            return '!' + this.key;
        };
        ContextKeyNotExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotExpr;
    }());
    exports.ContextKeyNotExpr = ContextKeyNotExpr;
    var ContextKeyRegexExpr = /** @class */ (function () {
        function ContextKeyRegexExpr(key, regexp) {
            this.key = key;
            this.regexp = regexp;
            //
        }
        ContextKeyRegexExpr.prototype.getType = function () {
            return 6 /* Regex */;
        };
        ContextKeyRegexExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            var thisSource = this.regexp ? this.regexp.source : '';
            var otherSource = other.regexp ? other.regexp.source : '';
            if (thisSource < otherSource) {
                return -1;
            }
            if (thisSource > otherSource) {
                return 1;
            }
            return 0;
        };
        ContextKeyRegexExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyRegexExpr) {
                var thisSource = this.regexp ? this.regexp.source : '';
                var otherSource = other.regexp ? other.regexp.source : '';
                return (this.key === other.key && thisSource === otherSource);
            }
            return false;
        };
        ContextKeyRegexExpr.prototype.evaluate = function (context) {
            var value = context.getValue(this.key);
            return this.regexp ? this.regexp.test(value) : false;
        };
        ContextKeyRegexExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyRegexExpr.prototype.serialize = function () {
            var value = this.regexp
                ? "/" + this.regexp.source + "/" + (this.regexp.ignoreCase ? 'i' : '')
                : '/invalid/';
            return this.key + " =~ " + value;
        };
        ContextKeyRegexExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyRegexExpr;
    }());
    exports.ContextKeyRegexExpr = ContextKeyRegexExpr;
    var ContextKeyAndExpr = /** @class */ (function () {
        function ContextKeyAndExpr(expr) {
            this.expr = ContextKeyAndExpr._normalizeArr(expr);
        }
        ContextKeyAndExpr.prototype.getType = function () {
            return 5 /* And */;
        };
        ContextKeyAndExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyAndExpr) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (var i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        };
        ContextKeyAndExpr.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        ContextKeyAndExpr._normalizeArr = function (arr) {
            var expr = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var e = arr[i];
                    if (!e) {
                        continue;
                    }
                    e = e.normalize();
                    if (!e) {
                        continue;
                    }
                    if (e instanceof ContextKeyAndExpr) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                expr.sort(cmp);
            }
            return expr;
        };
        ContextKeyAndExpr.prototype.normalize = function () {
            if (this.expr.length === 0) {
                return null;
            }
            if (this.expr.length === 1) {
                return this.expr[0];
            }
            return this;
        };
        ContextKeyAndExpr.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                var normalized = this.normalize();
                if (!normalized) {
                    return '';
                }
                return normalized.serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        ContextKeyAndExpr.prototype.keys = function () {
            var result = [];
            for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {
                var expr = _a[_i];
                result.push.apply(result, expr.keys());
            }
            return result;
        };
        return ContextKeyAndExpr;
    }());
    exports.ContextKeyAndExpr = ContextKeyAndExpr;
    var RawContextKey = /** @class */ (function (_super) {
        __extends(RawContextKey, _super);
        function RawContextKey(key, defaultValue) {
            var _this = _super.call(this, key) || this;
            _this._defaultValue = defaultValue;
            return _this;
        }
        RawContextKey.prototype.bindTo = function (target) {
            return target.createKey(this.key, this._defaultValue);
        };
        RawContextKey.prototype.getValue = function (target) {
            return target.getContextKeyValue(this.key);
        };
        RawContextKey.prototype.toNegated = function () {
            return ContextKeyExpr.not(this.key);
        };
        RawContextKey.prototype.isEqualTo = function (value) {
            return ContextKeyExpr.equals(this.key, value);
        };
        RawContextKey.prototype.notEqualsTo = function (value) {
            return ContextKeyExpr.notEquals(this.key, value);
        };
        return RawContextKey;
    }(ContextKeyDefinedExpr));
    exports.RawContextKey = RawContextKey;
    exports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[100/*vs/platform/extensionManagement/common/extensionManagement*/], __M([1/*require*/,0/*exports*/,78/*vs/nls!vs/platform/extensionManagement/common/extensionManagement*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, nls_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EXTENSION_IDENTIFIER_PATTERN = '^([a-z0-9A-Z][a-z0-9\-A-Z]*)\\.([a-z0-9A-Z][a-z0-9\-A-Z]*)$';
    exports.EXTENSION_IDENTIFIER_REGEX = new RegExp(exports.EXTENSION_IDENTIFIER_PATTERN);
    function isIExtensionIdentifier(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.id === 'string'
            && (!thing.uuid || typeof thing.uuid === 'string');
    }
    exports.isIExtensionIdentifier = isIExtensionIdentifier;
    var LocalExtensionType;
    (function (LocalExtensionType) {
        LocalExtensionType[LocalExtensionType["System"] = 0] = "System";
        LocalExtensionType[LocalExtensionType["User"] = 1] = "User";
    })(LocalExtensionType = exports.LocalExtensionType || (exports.LocalExtensionType = {}));
    exports.IExtensionManagementService = instantiation_1.createDecorator('extensionManagementService');
    exports.IExtensionGalleryService = instantiation_1.createDecorator('extensionGalleryService');
    var SortBy;
    (function (SortBy) {
        SortBy[SortBy["NoneOrRelevance"] = 0] = "NoneOrRelevance";
        SortBy[SortBy["LastUpdatedDate"] = 1] = "LastUpdatedDate";
        SortBy[SortBy["Title"] = 2] = "Title";
        SortBy[SortBy["PublisherName"] = 3] = "PublisherName";
        SortBy[SortBy["InstallCount"] = 4] = "InstallCount";
        SortBy[SortBy["PublishedDate"] = 5] = "PublishedDate";
        SortBy[SortBy["AverageRating"] = 6] = "AverageRating";
        SortBy[SortBy["WeightedRating"] = 12] = "WeightedRating";
    })(SortBy = exports.SortBy || (exports.SortBy = {}));
    var SortOrder;
    (function (SortOrder) {
        SortOrder[SortOrder["Default"] = 0] = "Default";
        SortOrder[SortOrder["Ascending"] = 1] = "Ascending";
        SortOrder[SortOrder["Descending"] = 2] = "Descending";
    })(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
    var StatisticType;
    (function (StatisticType) {
        StatisticType["Uninstall"] = "uninstall";
    })(StatisticType = exports.StatisticType || (exports.StatisticType = {}));
    var InstallOperation;
    (function (InstallOperation) {
        InstallOperation[InstallOperation["None"] = 0] = "None";
        InstallOperation[InstallOperation["Install"] = 1] = "Install";
        InstallOperation[InstallOperation["Update"] = 2] = "Update";
    })(InstallOperation = exports.InstallOperation || (exports.InstallOperation = {}));
    exports.INSTALL_ERROR_MALICIOUS = 'malicious';
    exports.INSTALL_ERROR_INCOMPATIBLE = 'incompatible';
    exports.IExtensionManagementServerService = instantiation_1.createDecorator('extensionManagementServerService');
    var EnablementState;
    (function (EnablementState) {
        EnablementState[EnablementState["Disabled"] = 0] = "Disabled";
        EnablementState[EnablementState["WorkspaceDisabled"] = 1] = "WorkspaceDisabled";
        EnablementState[EnablementState["Enabled"] = 2] = "Enabled";
        EnablementState[EnablementState["WorkspaceEnabled"] = 3] = "WorkspaceEnabled";
    })(EnablementState = exports.EnablementState || (exports.EnablementState = {}));
    exports.IExtensionEnablementService = instantiation_1.createDecorator('extensionEnablementService');
    exports.IExtensionTipsService = instantiation_1.createDecorator('extensionTipsService');
    var ExtensionRecommendationReason;
    (function (ExtensionRecommendationReason) {
        ExtensionRecommendationReason[ExtensionRecommendationReason["Workspace"] = 0] = "Workspace";
        ExtensionRecommendationReason[ExtensionRecommendationReason["File"] = 1] = "File";
        ExtensionRecommendationReason[ExtensionRecommendationReason["Executable"] = 2] = "Executable";
        ExtensionRecommendationReason[ExtensionRecommendationReason["DynamicWorkspace"] = 3] = "DynamicWorkspace";
        ExtensionRecommendationReason[ExtensionRecommendationReason["Experimental"] = 4] = "Experimental";
    })(ExtensionRecommendationReason = exports.ExtensionRecommendationReason || (exports.ExtensionRecommendationReason = {}));
    exports.ExtensionsLabel = nls_1.localize(0, null);
    exports.ExtensionsChannelId = 'extensions';
    exports.PreferencesLabel = nls_1.localize(1, null);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[101/*vs/platform/files/common/files*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,19/*vs/platform/instantiation/common/instantiation*/,5/*vs/base/common/strings*/,24/*vs/base/common/resources*/,18/*vs/base/common/types*/]), function (require, exports, paths, platform_1, instantiation_1, strings_1, resources_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IFileService = instantiation_1.createDecorator('fileService');
    var FileType;
    (function (FileType) {
        FileType[FileType["Unknown"] = 0] = "Unknown";
        FileType[FileType["File"] = 1] = "File";
        FileType[FileType["Directory"] = 2] = "Directory";
        FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType = exports.FileType || (exports.FileType = {}));
    var FileSystemProviderCapabilities;
    (function (FileSystemProviderCapabilities) {
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadWrite"] = 2] = "FileReadWrite";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileFolderCopy"] = 8] = "FileFolderCopy";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["Readonly"] = 2048] = "Readonly";
    })(FileSystemProviderCapabilities = exports.FileSystemProviderCapabilities || (exports.FileSystemProviderCapabilities = {}));
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
    })(FileOperation = exports.FileOperation || (exports.FileOperation = {}));
    var FileOperationEvent = /** @class */ (function () {
        function FileOperationEvent(_resource, _operation, _target) {
            this._resource = _resource;
            this._operation = _operation;
            this._target = _target;
        }
        Object.defineProperty(FileOperationEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "operation", {
            get: function () {
                return this._operation;
            },
            enumerable: true,
            configurable: true
        });
        return FileOperationEvent;
    }());
    exports.FileOperationEvent = FileOperationEvent;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangesEvent = /** @class */ (function () {
        function FileChangesEvent(changes) {
            this._changes = changes;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type (if provided). In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            var checkForChangeType = !types_1.isUndefinedOrNull(type);
            return this._changes.some(function (change) {
                if (checkForChangeType && change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (change.type === 2 /* DELETED */) {
                    return resources_1.isEqualOrParent(resource, change.resource, !platform_1.isLinux /* ignorecase */);
                }
                return resources_1.isEqual(resource, change.resource, !platform_1.isLinux /* ignorecase */);
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(1 /* ADDED */);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(1 /* ADDED */);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(2 /* DELETED */);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(2 /* DELETED */);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(0 /* UPDATED */);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(0 /* UPDATED */);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }());
    exports.FileChangesEvent = FileChangesEvent;
    function isParent(path, candidate, ignoreCase) {
        if (!path || !candidate || path === candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (candidate.charAt(candidate.length - 1) !== paths.nativeSep) {
            candidate += paths.nativeSep;
        }
        if (ignoreCase) {
            return strings_1.startsWithIgnoreCase(path, candidate);
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isParent = isParent;
    var StringSnapshot = /** @class */ (function () {
        function StringSnapshot(value) {
            this._value = value;
        }
        StringSnapshot.prototype.read = function () {
            var ret = this._value;
            this._value = null;
            return ret;
        };
        return StringSnapshot;
    }());
    exports.StringSnapshot = StringSnapshot;
    /**
     * Helper method to convert a snapshot into its full string form.
     */
    function snapshotToString(snapshot) {
        var chunks = [];
        var chunk;
        while (typeof (chunk = snapshot.read()) === 'string') {
            chunks.push(chunk);
        }
        return chunks.join('');
    }
    exports.snapshotToString = snapshotToString;
    var FileOperationError = /** @class */ (function (_super) {
        __extends(FileOperationError, _super);
        function FileOperationError(message, fileOperationResult, options) {
            var _this = _super.call(this, message) || this;
            _this.fileOperationResult = fileOperationResult;
            _this.options = options;
            return _this;
        }
        FileOperationError.isFileOperationError = function (obj) {
            return obj instanceof Error && !types_1.isUndefinedOrNull(obj.fileOperationResult);
        };
        return FileOperationError;
    }(Error));
    exports.FileOperationError = FileOperationError;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_PERMISSION_DENIED"] = 7] = "FILE_PERMISSION_DENIED";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 8] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 9] = "FILE_INVALID_PATH";
        FileOperationResult[FileOperationResult["FILE_EXCEED_MEMORY_LIMIT"] = 10] = "FILE_EXCEED_MEMORY_LIMIT";
    })(FileOperationResult = exports.FileOperationResult || (exports.FileOperationResult = {}));
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.HotExitConfiguration = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;
    exports.FILES_ASSOCIATIONS_CONFIG = 'files.associations';
    exports.FILES_EXCLUDE_CONFIG = 'files.exclude';
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        cp852: {
            labelLong: 'Central European (CP 852)',
            labelShort: 'CP 852',
            order: 18
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 19
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 20
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 21
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 22
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 23
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 24
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 25
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 26
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 27
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 28
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 29
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 30
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 31
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 32
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 33
        },
        gbk: {
            labelLong: 'Simplified Chinese (GBK)',
            labelShort: 'GBK',
            order: 34
        },
        gb18030: {
            labelLong: 'Simplified Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 35
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 36
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 37
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 38
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 39
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 40
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 41
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 42
        },
        koi8ru: {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 43
        },
        koi8t: {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 44
        },
        gb2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 45
        },
        cp865: {
            labelLong: 'Nordic DOS (CP 865)',
            labelShort: 'CP 865',
            order: 46
        },
        cp850: {
            labelLong: 'Western European DOS (CP 850)',
            labelShort: 'CP 850',
            order: 47
        }
    };
    var FileKind;
    (function (FileKind) {
        FileKind[FileKind["FILE"] = 0] = "FILE";
        FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
        FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind = exports.FileKind || (exports.FileKind = {}));
    exports.MIN_MAX_MEMORY_SIZE_MB = 2048;
    exports.FALLBACK_MAX_MEMORY_SIZE_MB = 4096;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[33/*vs/platform/log/common/log*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/,8/*vs/base/common/lifecycle*/,6/*vs/base/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, instantiation_1, lifecycle_1, platform_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILogService = instantiation_1.createDecorator('logService');
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        LogLevel[LogLevel["Info"] = 2] = "Info";
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        LogLevel[LogLevel["Error"] = 4] = "Error";
        LogLevel[LogLevel["Critical"] = 5] = "Critical";
        LogLevel[LogLevel["Off"] = 6] = "Off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    exports.DEFAULT_LOG_LEVEL = LogLevel.Info;
    var AbstractLogService = /** @class */ (function (_super) {
        __extends(AbstractLogService, _super);
        function AbstractLogService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.level = exports.DEFAULT_LOG_LEVEL;
            _this._onDidChangeLogLevel = _this._register(new event_1.Emitter());
            _this.onDidChangeLogLevel = _this._onDidChangeLogLevel.event;
            return _this;
        }
        AbstractLogService.prototype.setLevel = function (level) {
            if (this.level !== level) {
                this.level = level;
                this._onDidChangeLogLevel.fire(this.level);
            }
        };
        AbstractLogService.prototype.getLevel = function () {
            return this.level;
        };
        return AbstractLogService;
    }(lifecycle_1.Disposable));
    exports.AbstractLogService = AbstractLogService;
    var ConsoleLogMainService = /** @class */ (function (_super) {
        __extends(ConsoleLogMainService, _super);
        function ConsoleLogMainService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            _this.useColors = !platform_1.isWindows;
            return _this;
        }
        ConsoleLogMainService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                if (this.useColors) {
                    console.warn.apply(console, ["\u001B[93m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.warn.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[91m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.dispose = function () {
            // noop
        };
        return ConsoleLogMainService;
    }(AbstractLogService));
    exports.ConsoleLogMainService = ConsoleLogMainService;
    var ConsoleLogService = /** @class */ (function (_super) {
        __extends(ConsoleLogService, _super);
        function ConsoleLogService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            return _this;
        }
        ConsoleLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                console.log.apply(console, ['%cTRACE', 'color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                console.log.apply(console, ['%cDEBUG', 'background: #eee; color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                console.log.apply(console, ['%c INFO', 'color: #33f', message].concat(args));
            }
        };
        ConsoleLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                console.log.apply(console, ['%c WARN', 'color: #993', message].concat(args));
            }
        };
        ConsoleLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                console.log.apply(console, ['%c  ERR', 'color: #f33', message].concat(args));
            }
        };
        ConsoleLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                console.log.apply(console, ['%cCRITI', 'background: #f33; color: white', message].concat(args));
            }
        };
        ConsoleLogService.prototype.dispose = function () { };
        return ConsoleLogService;
    }(AbstractLogService));
    exports.ConsoleLogService = ConsoleLogService;
    var MultiplexLogService = /** @class */ (function (_super) {
        __extends(MultiplexLogService, _super);
        function MultiplexLogService(logServices) {
            var _this = _super.call(this) || this;
            _this.logServices = logServices;
            if (logServices.length) {
                _this.setLevel(logServices[0].getLevel());
            }
            return _this;
        }
        MultiplexLogService.prototype.setLevel = function (level) {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.setLevel(level);
            }
            _super.prototype.setLevel.call(this, level);
        };
        MultiplexLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.trace.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.debug.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.info.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.warn.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.error.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.critical.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.dispose = function () {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.dispose();
            }
        };
        return MultiplexLogService;
    }(AbstractLogService));
    exports.MultiplexLogService = MultiplexLogService;
    var DelegatedLogService = /** @class */ (function (_super) {
        __extends(DelegatedLogService, _super);
        function DelegatedLogService(logService) {
            var _this = _super.call(this) || this;
            _this.logService = logService;
            _this._register(logService);
            return _this;
        }
        Object.defineProperty(DelegatedLogService.prototype, "onDidChangeLogLevel", {
            get: function () {
                return this.logService.onDidChangeLogLevel;
            },
            enumerable: true,
            configurable: true
        });
        DelegatedLogService.prototype.setLevel = function (level) {
            this.logService.setLevel(level);
        };
        DelegatedLogService.prototype.getLevel = function () {
            return this.logService.getLevel();
        };
        DelegatedLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).trace.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).debug.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).info.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).warn.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).error.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).critical.apply(_a, [message].concat(args));
        };
        return DelegatedLogService;
    }(lifecycle_1.Disposable));
    exports.DelegatedLogService = DelegatedLogService;
    var NullLogService = /** @class */ (function () {
        function NullLogService() {
            this.onDidChangeLogLevel = new event_1.Emitter().event;
        }
        NullLogService.prototype.setLevel = function (level) { };
        NullLogService.prototype.getLevel = function () { return LogLevel.Info; };
        NullLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.dispose = function () { };
        return NullLogService;
    }());
    exports.NullLogService = NullLogService;
    function getLogLevel(environmentService) {
        if (environmentService.verbose) {
            return LogLevel.Trace;
        }
        if (typeof environmentService.args.log === 'string') {
            var logLevel = environmentService.args.log.toLowerCase();
            switch (logLevel) {
                case 'trace':
                    return LogLevel.Trace;
                case 'debug':
                    return LogLevel.Debug;
                case 'info':
                    return LogLevel.Info;
                case 'warn':
                    return LogLevel.Warning;
                case 'error':
                    return LogLevel.Error;
                case 'critical':
                    return LogLevel.Critical;
                case 'off':
                    return LogLevel.Off;
            }
        }
        return exports.DEFAULT_LOG_LEVEL;
    }
    exports.getLogLevel = getLogLevel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[61/*vs/platform/log/node/spdlogService*/], __M([1/*require*/,0/*exports*/,10/*path*/,33/*vs/platform/log/common/log*/]), function (require, exports, path, log_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createSpdLogService(processName, logLevel, logsFolder) {
        // Do not crash if spdlog cannot be loaded
        try {
            var _spdlog = require.__$__nodeRequire('spdlog');
            _spdlog.setAsyncMode(8192, 500);
            var logfilePath = path.join(logsFolder, processName + ".log");
            var logger = new _spdlog.RotatingLogger(processName, logfilePath, 1024 * 1024 * 5, 6);
            logger.setLevel(0);
            return new SpdLogService(logger, logLevel);
        }
        catch (e) {
            console.error(e);
        }
        return new log_1.NullLogService();
    }
    exports.createSpdLogService = createSpdLogService;
    function createRotatingLogger(name, filename, filesize, filecount) {
        var _spdlog = require.__$__nodeRequire('spdlog');
        return new _spdlog.RotatingLogger(name, filename, filesize, filecount);
    }
    exports.createRotatingLogger = createRotatingLogger;
    var SpdLogService = /** @class */ (function (_super) {
        __extends(SpdLogService, _super);
        function SpdLogService(logger, level) {
            if (level === void 0) { level = log_1.LogLevel.Error; }
            var _this = _super.call(this) || this;
            _this.logger = logger;
            _this.setLevel(level);
            return _this;
        }
        SpdLogService.prototype.trace = function () {
            if (this.getLevel() <= log_1.LogLevel.Trace) {
                this.logger.trace(this.format(arguments));
            }
        };
        SpdLogService.prototype.debug = function () {
            if (this.getLevel() <= log_1.LogLevel.Debug) {
                this.logger.debug(this.format(arguments));
            }
        };
        SpdLogService.prototype.info = function () {
            if (this.getLevel() <= log_1.LogLevel.Info) {
                this.logger.info(this.format(arguments));
            }
        };
        SpdLogService.prototype.warn = function () {
            if (this.getLevel() <= log_1.LogLevel.Warning) {
                this.logger.warn(this.format(arguments));
            }
        };
        SpdLogService.prototype.error = function () {
            if (this.getLevel() <= log_1.LogLevel.Error) {
                var arg = arguments[0];
                if (arg instanceof Error) {
                    var array = Array.prototype.slice.call(arguments);
                    array[0] = arg.stack;
                    this.logger.error(this.format(array));
                }
                else {
                    this.logger.error(this.format(arguments));
                }
            }
        };
        SpdLogService.prototype.critical = function () {
            if (this.getLevel() <= log_1.LogLevel.Critical) {
                this.logger.critical(this.format(arguments));
            }
        };
        SpdLogService.prototype.dispose = function () {
            this.logger.drop();
        };
        SpdLogService.prototype.format = function (args) {
            var result = '';
            for (var i = 0; i < args.length; i++) {
                var a = args[i];
                if (typeof a === 'object') {
                    try {
                        a = JSON.stringify(a);
                    }
                    catch (e) { }
                }
                result += (i > 0 ? ' ' : '') + a;
            }
            return result;
        };
        return SpdLogService;
    }(log_1.AbstractLogService));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[62/*vs/platform/markers/common/markers*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/,79/*vs/nls!vs/platform/markers/common/markers*/,29/*vs/base/common/severity*/]), function (require, exports, instantiation_1, nls_1, severity_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MarkerTag;
    (function (MarkerTag) {
        MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    })(MarkerTag = exports.MarkerTag || (exports.MarkerTag = {}));
    var MarkerSeverity;
    (function (MarkerSeverity) {
        MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
        MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
        MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
        MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
    })(MarkerSeverity = exports.MarkerSeverity || (exports.MarkerSeverity = {}));
    (function (MarkerSeverity) {
        function compare(a, b) {
            return b - a;
        }
        MarkerSeverity.compare = compare;
        var _displayStrings = Object.create(null);
        _displayStrings[MarkerSeverity.Error] = nls_1.localize(0, null);
        _displayStrings[MarkerSeverity.Warning] = nls_1.localize(1, null);
        _displayStrings[MarkerSeverity.Info] = nls_1.localize(2, null);
        function toString(a) {
            return _displayStrings[a] || '';
        }
        MarkerSeverity.toString = toString;
        function fromSeverity(severity) {
            switch (severity) {
                case severity_1.default.Error: return MarkerSeverity.Error;
                case severity_1.default.Warning: return MarkerSeverity.Warning;
                case severity_1.default.Info: return MarkerSeverity.Info;
                case severity_1.default.Ignore: return MarkerSeverity.Hint;
            }
        }
        MarkerSeverity.fromSeverity = fromSeverity;
    })(MarkerSeverity = exports.MarkerSeverity || (exports.MarkerSeverity = {}));
    var IMarkerData;
    (function (IMarkerData) {
        var emptyString = '';
        function makeKey(markerData) {
            var result = [emptyString];
            if (markerData.source) {
                result.push(markerData.source.replace('', '\'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.code) {
                result.push(markerData.code.replace('', '\'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.severity !== void 0 && markerData.severity !== null) {
                result.push(MarkerSeverity.toString(markerData.severity));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.message) {
                result.push(markerData.message.replace('', '\'));
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startLineNumber !== void 0 && markerData.startLineNumber !== null) {
                result.push(markerData.startLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.startColumn !== void 0 && markerData.startColumn !== null) {
                result.push(markerData.startColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endLineNumber !== void 0 && markerData.endLineNumber !== null) {
                result.push(markerData.endLineNumber.toString());
            }
            else {
                result.push(emptyString);
            }
            if (markerData.endColumn !== void 0 && markerData.endColumn !== null) {
                result.push(markerData.endColumn.toString());
            }
            else {
                result.push(emptyString);
            }
            result.push(emptyString);
            return result.join('');
        }
        IMarkerData.makeKey = makeKey;
    })(IMarkerData = exports.IMarkerData || (exports.IMarkerData = {}));
    exports.IMarkerService = instantiation_1.createDecorator('markerService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[63/*vs/platform/node/package*/], __M([1/*require*/,0/*exports*/,10/*path*/,28/*vs/base/common/amd*/]), function (require, exports, path, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(amd_1.getPathFromAmdModule(require, ''));
    var packageJsonPath = path.join(rootPath, 'package.json');
    exports.default = require.__$__nodeRequire(packageJsonPath);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[50/*vs/platform/node/product*/], __M([1/*require*/,0/*exports*/,10/*path*/,28/*vs/base/common/amd*/]), function (require, exports, path, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(amd_1.getPathFromAmdModule(require, ''));
    var productJsonPath = path.join(rootPath, 'product.json');
    var product = require.__$__nodeRequire(productJsonPath);
    if (process.env['VSCODE_DEV']) {
        product.nameShort += ' Dev';
        product.nameLong += ' Dev';
        product.dataFolderName += '-dev';
    }
    exports.default = product;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[107/*vs/platform/notification/common/notification*/], __M([1/*require*/,0/*exports*/,29/*vs/base/common/severity*/,19/*vs/platform/instantiation/common/instantiation*/,3/*vs/base/common/event*/]), function (require, exports, severity_1, instantiation_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Severity = severity_1.default;
    exports.INotificationService = instantiation_1.createDecorator('notificationService');
    var NoOpNotification = /** @class */ (function () {
        function NoOpNotification() {
            this.progress = new NoOpProgress();
            this._onDidClose = new event_1.Emitter();
        }
        Object.defineProperty(NoOpNotification.prototype, "onDidClose", {
            get: function () {
                return this._onDidClose.event;
            },
            enumerable: true,
            configurable: true
        });
        NoOpNotification.prototype.updateSeverity = function (severity) { };
        NoOpNotification.prototype.updateMessage = function (message) { };
        NoOpNotification.prototype.updateActions = function (actions) { };
        NoOpNotification.prototype.close = function () {
            this._onDidClose.dispose();
        };
        return NoOpNotification;
    }());
    exports.NoOpNotification = NoOpNotification;
    var NoOpProgress = /** @class */ (function () {
        function NoOpProgress() {
        }
        NoOpProgress.prototype.infinite = function () { };
        NoOpProgress.prototype.done = function () { };
        NoOpProgress.prototype.total = function (value) { };
        NoOpProgress.prototype.worked = function (value) { };
        return NoOpProgress;
    }());
    exports.NoOpProgress = NoOpProgress;
});

define(__m[108/*vs/platform/output/node/outputAppender*/], __M([1/*require*/,0/*exports*/,61/*vs/platform/log/node/spdlogService*/]), function (require, exports, spdlogService_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var OutputAppender = /** @class */ (function () {
        function OutputAppender(name, file) {
            this.appender = spdlogService_1.createRotatingLogger(name, file, 1024 * 1024 * 30, 1);
            this.appender.clearFormatters();
        }
        OutputAppender.prototype.append = function (content) {
            this.appender.critical(content);
        };
        OutputAppender.prototype.flush = function () {
            this.appender.flush();
        };
        return OutputAppender;
    }());
    exports.OutputAppender = OutputAppender;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[109/*vs/platform/progress/common/progress*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/,17/*vs/base/common/cancellation*/,8/*vs/base/common/lifecycle*/]), function (require, exports, instantiation_1, cancellation_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IProgressService = instantiation_1.createDecorator('progressService');
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["Explorer"] = 1] = "Explorer";
        ProgressLocation[ProgressLocation["Scm"] = 3] = "Scm";
        ProgressLocation[ProgressLocation["Extensions"] = 5] = "Extensions";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    exports.IProgressService2 = instantiation_1.createDecorator('progressService2');
    exports.emptyProgressRunner = Object.freeze({
        total: function () { },
        worked: function () { },
        done: function () { }
    });
    exports.emptyProgress = Object.freeze({ report: function () { } });
    var Progress = /** @class */ (function () {
        function Progress(callback) {
            this._callback = callback;
        }
        Object.defineProperty(Progress.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Progress.prototype.report = function (item) {
            this._value = item;
            this._callback(this._value);
        };
        return Progress;
    }());
    exports.Progress = Progress;
    var LongRunningOperation = /** @class */ (function () {
        function LongRunningOperation(progressService) {
            this.progressService = progressService;
            this.currentOperationId = 0;
            this.currentOperationDisposables = [];
        }
        LongRunningOperation.prototype.start = function (progressDelay) {
            var _this = this;
            // Stop any previous operation
            this.stop();
            // Start new
            var newOperationId = ++this.currentOperationId;
            var newOperationToken = new cancellation_1.CancellationTokenSource();
            this.currentProgressTimeout = setTimeout(function () {
                if (newOperationId === _this.currentOperationId) {
                    _this.currentProgressRunner = _this.progressService.show(true);
                }
            }, progressDelay);
            this.currentOperationDisposables.push(lifecycle_1.toDisposable(function () { return clearTimeout(_this.currentProgressTimeout); }), lifecycle_1.toDisposable(function () { return newOperationToken.cancel(); }), lifecycle_1.toDisposable(function () { return _this.currentProgressRunner ? _this.currentProgressRunner.done() : void 0; }));
            return {
                id: newOperationId,
                token: newOperationToken.token,
                stop: function () { return _this.doStop(newOperationId); },
                isCurrent: function () { return _this.currentOperationId === newOperationId; }
            };
        };
        LongRunningOperation.prototype.stop = function () {
            this.doStop(this.currentOperationId);
        };
        LongRunningOperation.prototype.doStop = function (operationId) {
            if (this.currentOperationId === operationId) {
                this.currentOperationDisposables = lifecycle_1.dispose(this.currentOperationDisposables);
            }
        };
        LongRunningOperation.prototype.dispose = function () {
            this.currentOperationDisposables = lifecycle_1.dispose(this.currentOperationDisposables);
        };
        return LongRunningOperation;
    }());
    exports.LongRunningOperation = LongRunningOperation;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[37/*vs/platform/registry/common/platform*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/types*/,48/*vs/base/common/assert*/]), function (require, exports, Types, Assert) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RegistryImpl = /** @class */ (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[111/*vs/platform/jsonschemas/common/jsonContributionRegistry*/], __M([1/*require*/,0/*exports*/,37/*vs/platform/registry/common/platform*/,3/*vs/base/common/event*/]), function (require, exports, platform, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = /** @class */ (function () {
        function JSONContributionRegistry() {
            this._onDidChangeSchema = new event_1.Emitter();
            this.onDidChangeSchema = this._onDidChangeSchema.event;
            this.schemasById = {};
        }
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.notifySchemaChanged = function (uri) {
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[34/*vs/platform/configuration/common/configurationRegistry*/], __M([1/*require*/,0/*exports*/,188/*vs/nls!vs/platform/configuration/common/configurationRegistry*/,3/*vs/base/common/event*/,37/*vs/platform/registry/common/platform*/,18/*vs/base/common/types*/,5/*vs/base/common/strings*/,111/*vs/platform/jsonschemas/common/jsonContributionRegistry*/]), function (require, exports, nls, event_1, platform_1, types, strings, jsonContributionRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        Configuration: 'base.contributions.configuration'
    };
    var ConfigurationScope;
    (function (ConfigurationScope) {
        ConfigurationScope[ConfigurationScope["APPLICATION"] = 1] = "APPLICATION";
        ConfigurationScope[ConfigurationScope["WINDOW"] = 2] = "WINDOW";
        ConfigurationScope[ConfigurationScope["RESOURCE"] = 3] = "RESOURCE";
    })(ConfigurationScope = exports.ConfigurationScope || (exports.ConfigurationScope = {}));
    exports.allSettings = { properties: {}, patternProperties: {} };
    exports.applicationSettings = { properties: {}, patternProperties: {} };
    exports.windowSettings = { properties: {}, patternProperties: {} };
    exports.resourceSettings = { properties: {}, patternProperties: {} };
    exports.editorConfigurationSchemaId = 'vscode://schemas/settings/editor';
    var contributionRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ConfigurationRegistry = /** @class */ (function () {
        function ConfigurationRegistry() {
            this.overrideIdentifiers = [];
            this._onDidSchemaChange = new event_1.Emitter();
            this.onDidSchemaChange = this._onDidSchemaChange.event;
            this._onDidRegisterConfiguration = new event_1.Emitter();
            this.onDidRegisterConfiguration = this._onDidRegisterConfiguration.event;
            this.configurationContributors = [];
            this.editorConfigurationSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting' };
            this.configurationProperties = {};
            this.excludedConfigurationProperties = {};
            this.computeOverridePropertyPattern();
            contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
        }
        ConfigurationRegistry.prototype.registerConfiguration = function (configuration, validate) {
            if (validate === void 0) { validate = true; }
            this.registerConfigurations([configuration], [], validate);
        };
        ConfigurationRegistry.prototype.registerConfigurations = function (configurations, defaultConfigurations, validate) {
            var _this = this;
            if (validate === void 0) { validate = true; }
            var configurationNode = this.toConfiguration(defaultConfigurations);
            if (configurationNode) {
                configurations.push(configurationNode);
            }
            var properties = [];
            configurations.forEach(function (configuration) {
                properties.push.apply(properties, _this.validateAndRegisterProperties(configuration, validate)); // fills in defaults
                _this.configurationContributors.push(configuration);
                _this.registerJSONConfiguration(configuration);
                _this.updateSchemaForOverrideSettingsConfiguration(configuration);
            });
            this._onDidRegisterConfiguration.fire(properties);
        };
        ConfigurationRegistry.prototype.notifyConfigurationSchemaUpdated = function (configuration) {
            contributionRegistry.notifySchemaChanged(exports.editorConfigurationSchemaId);
        };
        ConfigurationRegistry.prototype.registerOverrideIdentifiers = function (overrideIdentifiers) {
            var _a;
            (_a = this.overrideIdentifiers).push.apply(_a, overrideIdentifiers);
            this.updateOverridePropertyPatternKey();
        };
        ConfigurationRegistry.prototype.toConfiguration = function (defaultConfigurations) {
            var configurationNode = {
                id: 'defaultOverrides',
                title: nls.localize(0, null),
                properties: {}
            };
            for (var _i = 0, defaultConfigurations_1 = defaultConfigurations; _i < defaultConfigurations_1.length; _i++) {
                var defaultConfiguration = defaultConfigurations_1[_i];
                for (var key in defaultConfiguration.defaults) {
                    var defaultValue = defaultConfiguration.defaults[key];
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key) && typeof defaultValue === 'object') {
                        configurationNode.properties[key] = {
                            type: 'object',
                            default: defaultValue,
                            description: nls.localize(1, null, key),
                            $ref: exports.editorConfigurationSchemaId
                        };
                    }
                }
            }
            return Object.keys(configurationNode.properties).length ? configurationNode : null;
        };
        ConfigurationRegistry.prototype.validateAndRegisterProperties = function (configuration, validate, scope, overridable) {
            if (validate === void 0) { validate = true; }
            if (scope === void 0) { scope = 2 /* WINDOW */; }
            if (overridable === void 0) { overridable = false; }
            scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
            overridable = configuration.overridable || overridable;
            var propertyKeys = [];
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    var message = void 0;
                    if (validate && (message = validateProperty(key))) {
                        console.warn(message);
                        delete properties[key];
                        continue;
                    }
                    // fill in default values
                    var property = properties[key];
                    var defaultValue = property.default;
                    if (types.isUndefined(defaultValue)) {
                        property.default = getDefaultValue(property.type);
                    }
                    // Inherit overridable property from parent
                    if (overridable) {
                        property.overridable = true;
                    }
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                        property.scope = void 0; // No scope for overridable properties `[${identifier}]`
                    }
                    else {
                        property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;
                    }
                    // Add to properties maps
                    // Property is included by default if 'included' is unspecified
                    if (properties[key].hasOwnProperty('included') && !properties[key].included) {
                        this.excludedConfigurationProperties[key] = properties[key];
                        delete properties[key];
                        continue;
                    }
                    else {
                        this.configurationProperties[key] = properties[key];
                    }
                    propertyKeys.push(key);
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                for (var _i = 0, subNodes_1 = subNodes; _i < subNodes_1.length; _i++) {
                    var node = subNodes_1[_i];
                    propertyKeys.push.apply(propertyKeys, this.validateAndRegisterProperties(node, validate, scope, overridable));
                }
            }
            return propertyKeys;
        };
        ConfigurationRegistry.prototype.getConfigurations = function () {
            return this.configurationContributors;
        };
        ConfigurationRegistry.prototype.getConfigurationProperties = function () {
            return this.configurationProperties;
        };
        ConfigurationRegistry.prototype.getExcludedConfigurationProperties = function () {
            return this.excludedConfigurationProperties;
        };
        ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
            function register(configuration) {
                var properties = configuration.properties;
                if (properties) {
                    for (var key in properties) {
                        exports.allSettings.properties[key] = properties[key];
                        switch (properties[key].scope) {
                            case 1 /* APPLICATION */:
                                exports.applicationSettings.properties[key] = properties[key];
                                break;
                            case 2 /* WINDOW */:
                                exports.windowSettings.properties[key] = properties[key];
                                break;
                            case 3 /* RESOURCE */:
                                exports.resourceSettings.properties[key] = properties[key];
                                break;
                        }
                    }
                }
                var subNodes = configuration.allOf;
                if (subNodes) {
                    subNodes.forEach(register);
                }
            }
            register(configuration);
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.updateSchemaForOverrideSettingsConfiguration = function (configuration) {
            if (configuration.id !== SETTINGS_OVERRRIDE_NODE_ID) {
                this.update(configuration);
                contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
            }
        };
        ConfigurationRegistry.prototype.updateOverridePropertyPatternKey = function () {
            var patternProperties = exports.allSettings.patternProperties[this.overridePropertyPattern];
            if (!patternProperties) {
                patternProperties = {
                    type: 'object',
                    description: nls.localize(2, null),
                    errorMessage: 'Unknown Identifier. Use language identifiers',
                    $ref: exports.editorConfigurationSchemaId
                };
            }
            delete exports.allSettings.patternProperties[this.overridePropertyPattern];
            delete exports.applicationSettings.patternProperties[this.overridePropertyPattern];
            delete exports.windowSettings.patternProperties[this.overridePropertyPattern];
            delete exports.resourceSettings.patternProperties[this.overridePropertyPattern];
            this.computeOverridePropertyPattern();
            exports.allSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.applicationSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.windowSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.resourceSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.update = function (configuration) {
            var _this = this;
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    if (properties[key].overridable) {
                        this.editorConfigurationSchema.properties[key] = this.getConfigurationProperties()[key];
                    }
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                subNodes.forEach(function (subNode) { return _this.update(subNode); });
            }
        };
        ConfigurationRegistry.prototype.computeOverridePropertyPattern = function () {
            this.overridePropertyPattern = this.overrideIdentifiers.length ? OVERRIDE_PATTERN_WITH_SUBSTITUTION.replace('${0}', this.overrideIdentifiers.map(function (identifier) { return strings.createRegExp(identifier, false).source; }).join('|')) : OVERRIDE_PROPERTY;
        };
        return ConfigurationRegistry;
    }());
    var SETTINGS_OVERRRIDE_NODE_ID = 'override';
    var OVERRIDE_PROPERTY = '\\[.*\\]$';
    var OVERRIDE_PATTERN_WITH_SUBSTITUTION = '\\[(${0})\\]$';
    exports.OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);
    function getDefaultValue(type) {
        var t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
            case 'number':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
    var configurationRegistry = new ConfigurationRegistry();
    platform_1.Registry.add(exports.Extensions.Configuration, configurationRegistry);
    function validateProperty(property) {
        if (exports.OVERRIDE_PROPERTY_PATTERN.test(property)) {
            return nls.localize(3, null, property);
        }
        if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
            return nls.localize(4, null, property);
        }
        return null;
    }
    exports.validateProperty = validateProperty;
    function getScopes() {
        var scopes = {};
        var configurationProperties = configurationRegistry.getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(configurationProperties); _i < _a.length; _i++) {
            var key = _a[_i];
            scopes[key] = configurationProperties[key].scope;
        }
        scopes['launch'] = 3 /* RESOURCE */;
        scopes['task'] = 3 /* RESOURCE */;
        return scopes;
    }
    exports.getScopes = getScopes;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[65/*vs/platform/configuration/common/configuration*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/objects*/,18/*vs/base/common/types*/,2/*vs/base/common/uri*/,37/*vs/platform/registry/common/platform*/,19/*vs/platform/instantiation/common/instantiation*/,34/*vs/platform/configuration/common/configurationRegistry*/]), function (require, exports, objects, types, uri_1, platform_1, instantiation_1, configurationRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    function isConfigurationOverrides(thing) {
        return thing
            && typeof thing === 'object'
            && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
            && (!thing.resource || thing.resource instanceof uri_1.URI);
    }
    exports.isConfigurationOverrides = isConfigurationOverrides;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["USER"] = 1] = "USER";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 2] = "WORKSPACE";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE_FOLDER"] = 3] = "WORKSPACE_FOLDER";
        ConfigurationTarget[ConfigurationTarget["DEFAULT"] = 4] = "DEFAULT";
        ConfigurationTarget[ConfigurationTarget["MEMORY"] = 5] = "MEMORY";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    function ConfigurationTargetToString(configurationTarget) {
        switch (configurationTarget) {
            case 1 /* USER */: return 'USER';
            case 2 /* WORKSPACE */: return 'WORKSPACE';
            case 3 /* WORKSPACE_FOLDER */: return 'WORKSPACE_FOLDER';
            case 4 /* DEFAULT */: return 'DEFAULT';
            case 5 /* MEMORY */: return 'MEMORY';
        }
    }
    exports.ConfigurationTargetToString = ConfigurationTargetToString;
    function compare(from, to) {
        var added = to.keys.filter(function (key) { return from.keys.indexOf(key) === -1; });
        var removed = from.keys.filter(function (key) { return to.keys.indexOf(key) === -1; });
        var updated = [];
        for (var _i = 0, _a = from.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            var value1 = getConfigurationValue(from.contents, key);
            var value2 = getConfigurationValue(to.contents, key);
            if (!objects.equals(value1, value2)) {
                updated.push(key);
            }
        }
        return { added: added, removed: removed, updated: updated };
    }
    exports.compare = compare;
    function toOverrides(raw, conflictReporter) {
        var overrides = [];
        var configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(raw); _i < _a.length; _i++) {
            var key = _a[_i];
            if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                var overrideRaw = {};
                for (var keyInOverrideRaw in raw[key]) {
                    if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {
                        overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                    }
                }
                overrides.push({
                    identifiers: [overrideIdentifierFromKey(key).trim()],
                    contents: toValuesTree(overrideRaw, conflictReporter)
                });
            }
        }
        return overrides;
    }
    exports.toOverrides = toOverrides;
    function toValuesTree(properties, conflictReporter) {
        var root = Object.create(null);
        for (var key in properties) {
            addToValueTree(root, key, properties[key], conflictReporter);
        }
        return root;
    }
    exports.toValuesTree = toValuesTree;
    function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
        var segments = key.split('.');
        var last = segments.pop();
        var curr = settingsTreeRoot;
        for (var i = 0; i < segments.length; i++) {
            var s = segments[i];
            var obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    break;
                default:
                    conflictReporter("Ignoring " + key + " as " + segments.slice(0, i + 1).join('.') + " is " + JSON.stringify(obj));
                    return;
            }
            curr = obj;
        }
        if (typeof curr === 'object') {
            curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
        }
        else {
            conflictReporter("Ignoring " + key + " as " + segments.join('.') + " is " + JSON.stringify(curr));
        }
    }
    exports.addToValueTree = addToValueTree;
    function removeFromValueTree(valueTree, key) {
        var segments = key.split('.');
        doRemoveFromValueTree(valueTree, segments);
    }
    exports.removeFromValueTree = removeFromValueTree;
    function doRemoveFromValueTree(valueTree, segments) {
        var first = segments.shift();
        if (segments.length === 0) {
            // Reached last segment
            delete valueTree[first];
            return;
        }
        if (Object.keys(valueTree).indexOf(first) !== -1) {
            var value = valueTree[first];
            if (typeof value === 'object' && !Array.isArray(value)) {
                doRemoveFromValueTree(value, segments);
                if (Object.keys(value).length === 0) {
                    delete valueTree[first];
                }
            }
        }
    }
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                current = current[path[i]];
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    function getConfigurationKeys() {
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        return Object.keys(properties);
    }
    exports.getConfigurationKeys = getConfigurationKeys;
    function getDefaultValues() {
        var valueTreeRoot = Object.create(null);
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var key in properties) {
            var value = properties[key].default;
            addToValueTree(valueTreeRoot, key, value, function (message) { return console.error("Conflict in default settings: " + message); });
        }
        return valueTreeRoot;
    }
    exports.getDefaultValues = getDefaultValues;
    function overrideIdentifierFromKey(key) {
        return key.substring(1, key.length - 1);
    }
    exports.overrideIdentifierFromKey = overrideIdentifierFromKey;
    function keyFromOverrideIdentifier(overrideIdentifier) {
        return "[" + overrideIdentifier + "]";
    }
    exports.keyFromOverrideIdentifier = keyFromOverrideIdentifier;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[66/*vs/platform/configuration/common/configurationModels*/], __M([1/*require*/,0/*exports*/,139/*vs/base/common/json*/,22/*vs/base/common/map*/,9/*vs/base/common/arrays*/,18/*vs/base/common/types*/,13/*vs/base/common/objects*/,34/*vs/platform/configuration/common/configurationRegistry*/,65/*vs/platform/configuration/common/configuration*/]), function (require, exports, json, map_1, arrays, types, objects, configurationRegistry_1, configuration_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConfigurationModel = /** @class */ (function () {
        function ConfigurationModel(_contents, _keys, _overrides) {
            if (_contents === void 0) { _contents = {}; }
            if (_keys === void 0) { _keys = []; }
            if (_overrides === void 0) { _overrides = []; }
            this._contents = _contents;
            this._keys = _keys;
            this._overrides = _overrides;
            this.isFrozen = false;
        }
        Object.defineProperty(ConfigurationModel.prototype, "contents", {
            get: function () {
                return this.checkAndFreeze(this._contents);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "overrides", {
            get: function () {
                return this.checkAndFreeze(this._overrides);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "keys", {
            get: function () {
                return this.checkAndFreeze(this._keys);
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModel.prototype.getValue = function (section) {
            return section ? configuration_1.getConfigurationValue(this.contents, section) : this.contents;
        };
        ConfigurationModel.prototype.override = function (identifier) {
            var overrideContents = this.getContentsForOverrideIdentifer(identifier);
            if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
                // If there are no valid overrides, return self
                return this;
            }
            var contents = {};
            for (var _i = 0, _a = arrays.distinct(Object.keys(this.contents).concat(Object.keys(overrideContents))); _i < _a.length; _i++) {
                var key = _a[_i];
                var contentsForKey = this.contents[key];
                var overrideContentsForKey = overrideContents[key];
                // If there are override contents for the key, clone and merge otherwise use base contents
                if (overrideContentsForKey) {
                    // Clone and merge only if base contents and override contents are of type object otherwise just override
                    if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                        contentsForKey = objects.deepClone(contentsForKey);
                        this.mergeContents(contentsForKey, overrideContentsForKey);
                    }
                    else {
                        contentsForKey = overrideContentsForKey;
                    }
                }
                contents[key] = contentsForKey;
            }
            return new ConfigurationModel(contents);
        };
        ConfigurationModel.prototype.merge = function () {
            var others = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                others[_i] = arguments[_i];
            }
            var contents = objects.deepClone(this.contents);
            var overrides = objects.deepClone(this.overrides);
            var keys = this.keys.slice();
            for (var _a = 0, others_1 = others; _a < others_1.length; _a++) {
                var other = others_1[_a];
                this.mergeContents(contents, other.contents);
                var _loop_1 = function (otherOverride) {
                    var override = overrides.filter(function (o) { return arrays.equals(o.identifiers, otherOverride.identifiers); })[0];
                    if (override) {
                        this_1.mergeContents(override.contents, otherOverride.contents);
                    }
                    else {
                        overrides.push(objects.deepClone(otherOverride));
                    }
                };
                var this_1 = this;
                for (var _b = 0, _c = other.overrides; _b < _c.length; _b++) {
                    var otherOverride = _c[_b];
                    _loop_1(otherOverride);
                }
                for (var _d = 0, _e = other.keys; _d < _e.length; _d++) {
                    var key = _e[_d];
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                    }
                }
            }
            return new ConfigurationModel(contents, keys, overrides);
        };
        ConfigurationModel.prototype.freeze = function () {
            this.isFrozen = true;
            return this;
        };
        ConfigurationModel.prototype.mergeContents = function (source, target) {
            for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
                var key = _a[_i];
                if (key in source) {
                    if (types.isObject(source[key]) && types.isObject(target[key])) {
                        this.mergeContents(source[key], target[key]);
                        continue;
                    }
                }
                source[key] = objects.deepClone(target[key]);
            }
        };
        ConfigurationModel.prototype.checkAndFreeze = function (data) {
            if (this.isFrozen && !Object.isFrozen(data)) {
                return objects.deepFreeze(data);
            }
            return data;
        };
        ConfigurationModel.prototype.getContentsForOverrideIdentifer = function (identifier) {
            for (var _i = 0, _a = this.overrides; _i < _a.length; _i++) {
                var override = _a[_i];
                if (override.identifiers.indexOf(identifier) !== -1) {
                    return override.contents;
                }
            }
            return null;
        };
        ConfigurationModel.prototype.toJSON = function () {
            return {
                contents: this.contents,
                overrides: this.overrides,
                keys: this.keys
            };
        };
        // Update methods
        ConfigurationModel.prototype.setValue = function (key, value) {
            this.addKey(key);
            configuration_1.addToValueTree(this.contents, key, value, function (e) { throw new Error(e); });
        };
        ConfigurationModel.prototype.removeValue = function (key) {
            if (this.removeKey(key)) {
                configuration_1.removeFromValueTree(this.contents, key);
            }
        };
        ConfigurationModel.prototype.addKey = function (key) {
            var index = this.keys.length;
            for (var i = 0; i < index; i++) {
                if (key.indexOf(this.keys[i]) === 0) {
                    index = i;
                }
            }
            this.keys.splice(index, 1, key);
        };
        ConfigurationModel.prototype.removeKey = function (key) {
            var index = this.keys.indexOf(key);
            if (index !== -1) {
                this.keys.splice(index, 1);
                return true;
            }
            return false;
        };
        return ConfigurationModel;
    }());
    exports.ConfigurationModel = ConfigurationModel;
    var DefaultConfigurationModel = /** @class */ (function (_super) {
        __extends(DefaultConfigurationModel, _super);
        function DefaultConfigurationModel() {
            var _this = this;
            var contents = configuration_1.getDefaultValues();
            var keys = configuration_1.getConfigurationKeys();
            var overrides = [];
            for (var _i = 0, _a = Object.keys(contents); _i < _a.length; _i++) {
                var key = _a[_i];
                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                    overrides.push({
                        identifiers: [configuration_1.overrideIdentifierFromKey(key).trim()],
                        contents: configuration_1.toValuesTree(contents[key], function (message) { return console.error("Conflict in default settings file: " + message); })
                    });
                }
            }
            _this = _super.call(this, contents, keys, overrides) || this;
            return _this;
        }
        return DefaultConfigurationModel;
    }(ConfigurationModel));
    exports.DefaultConfigurationModel = DefaultConfigurationModel;
    var ConfigurationModelParser = /** @class */ (function () {
        function ConfigurationModelParser(_name) {
            this._name = _name;
            this._configurationModel = null;
            this._parseErrors = [];
        }
        Object.defineProperty(ConfigurationModelParser.prototype, "configurationModel", {
            get: function () {
                return this._configurationModel || new ConfigurationModel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModelParser.prototype, "errors", {
            get: function () {
                return this._parseErrors;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModelParser.prototype.parse = function (content) {
            var raw = this.parseContent(content);
            var configurationModel = this.parseRaw(raw);
            this._configurationModel = new ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
        };
        ConfigurationModelParser.prototype.parseContent = function (content) {
            var raw = {};
            var currentProperty = null;
            var currentParent = [];
            var previousParents = [];
            var parseErrors = [];
            function onValue(value) {
                if (Array.isArray(currentParent)) {
                    currentParent.push(value);
                }
                else if (currentProperty) {
                    currentParent[currentProperty] = value;
                }
            }
            var visitor = {
                onObjectBegin: function () {
                    var object = {};
                    onValue(object);
                    previousParents.push(currentParent);
                    currentParent = object;
                    currentProperty = null;
                },
                onObjectProperty: function (name) {
                    currentProperty = name;
                },
                onObjectEnd: function () {
                    currentParent = previousParents.pop();
                },
                onArrayBegin: function () {
                    var array = [];
                    onValue(array);
                    previousParents.push(currentParent);
                    currentParent = array;
                    currentProperty = null;
                },
                onArrayEnd: function () {
                    currentParent = previousParents.pop();
                },
                onLiteralValue: onValue,
                onError: function (error, offset, length) {
                    parseErrors.push({ error: error, offset: offset, length: length });
                }
            };
            if (content) {
                try {
                    json.visit(content, visitor);
                    raw = currentParent[0] || {};
                }
                catch (e) {
                    console.error("Error while parsing settings file " + this._name + ": " + e);
                    this._parseErrors = [e];
                }
            }
            return raw;
        };
        ConfigurationModelParser.prototype.parseRaw = function (raw) {
            var _this = this;
            var contents = configuration_1.toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            var keys = Object.keys(raw);
            var overrides = configuration_1.toOverrides(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            return { contents: contents, keys: keys, overrides: overrides };
        };
        return ConfigurationModelParser;
    }());
    exports.ConfigurationModelParser = ConfigurationModelParser;
    var Configuration = /** @class */ (function () {
        function Configuration(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, _freeze) {
            if (_workspaceConfiguration === void 0) { _workspaceConfiguration = new ConfigurationModel(); }
            if (_folderConfigurations === void 0) { _folderConfigurations = new map_1.ResourceMap(); }
            if (_memoryConfiguration === void 0) { _memoryConfiguration = new ConfigurationModel(); }
            if (_memoryConfigurationByResource === void 0) { _memoryConfigurationByResource = new map_1.ResourceMap(); }
            if (_freeze === void 0) { _freeze = true; }
            this._defaultConfiguration = _defaultConfiguration;
            this._userConfiguration = _userConfiguration;
            this._workspaceConfiguration = _workspaceConfiguration;
            this._folderConfigurations = _folderConfigurations;
            this._memoryConfiguration = _memoryConfiguration;
            this._memoryConfigurationByResource = _memoryConfigurationByResource;
            this._freeze = _freeze;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations = new map_1.ResourceMap();
        }
        Configuration.prototype.getValue = function (section, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            return consolidateConfigurationModel.getValue(section);
        };
        Configuration.prototype.updateValue = function (key, value, overrides) {
            if (overrides === void 0) { overrides = {}; }
            var memoryConfiguration;
            if (overrides.resource) {
                memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
                if (!memoryConfiguration) {
                    memoryConfiguration = new ConfigurationModel();
                    this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
                }
            }
            else {
                memoryConfiguration = this._memoryConfiguration;
            }
            if (value === void 0) {
                memoryConfiguration.removeValue(key);
            }
            else {
                memoryConfiguration.setValue(key, value);
            }
            if (!overrides.resource) {
                this._workspaceConsolidatedConfiguration = null;
            }
        };
        Configuration.prototype.inspect = function (key, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
            var memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
            return {
                default: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key),
                user: overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key),
                workspace: workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key) : void 0,
                workspaceFolder: folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0,
                memory: overrides.overrideIdentifier ? memoryConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.freeze().getValue(key),
                value: consolidateConfigurationModel.getValue(key)
            };
        };
        Configuration.prototype.keys = function (workspace) {
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(undefined, workspace);
            return {
                default: this._defaultConfiguration.freeze().keys,
                user: this._userConfiguration.freeze().keys,
                workspace: this._workspaceConfiguration.freeze().keys,
                workspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []
            };
        };
        Configuration.prototype.updateDefaultConfiguration = function (defaultConfiguration) {
            this._defaultConfiguration = defaultConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateUserConfiguration = function (userConfiguration) {
            this._userConfiguration = userConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateWorkspaceConfiguration = function (workspaceConfiguration) {
            this._workspaceConfiguration = workspaceConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateFolderConfiguration = function (resource, configuration) {
            this._folderConfigurations.set(resource, configuration);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Configuration.prototype.deleteFolderConfiguration = function (resource) {
            this.folders.delete(resource);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Object.defineProperty(Configuration.prototype, "defaults", {
            get: function () {
                return this._defaultConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "user", {
            get: function () {
                return this._userConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "workspace", {
            get: function () {
                return this._workspaceConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "folders", {
            get: function () {
                return this._folderConfigurations;
            },
            enumerable: true,
            configurable: true
        });
        Configuration.prototype.getConsolidateConfigurationModel = function (overrides, workspace) {
            var configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
            return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
        };
        Configuration.prototype.getConsolidatedConfigurationModelForResource = function (_a, workspace) {
            var resource = _a.resource;
            var consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
                }
                var memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
                if (memoryConfigurationForResource) {
                    consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
                }
            }
            return consolidateConfiguration;
        };
        Configuration.prototype.getWorkspaceConsolidatedConfiguration = function () {
            if (!this._workspaceConsolidatedConfiguration) {
                this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
                if (this._freeze) {
                    this._workspaceConfiguration = this._workspaceConfiguration.freeze();
                }
            }
            return this._workspaceConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConsolidatedConfiguration = function (folder) {
            var folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
            if (!folderConsolidatedConfiguration) {
                var workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
                var folderConfiguration = this._folderConfigurations.get(folder);
                if (folderConfiguration) {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
                    if (this._freeze) {
                        folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
                    }
                    this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
                }
                else {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
                }
            }
            return folderConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConfigurationModelForResource = function (resource, workspace) {
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    return this._folderConfigurations.get(root.uri);
                }
            }
            return null;
        };
        Configuration.prototype.toData = function () {
            var _this = this;
            return {
                defaults: {
                    contents: this._defaultConfiguration.contents,
                    overrides: this._defaultConfiguration.overrides,
                    keys: this._defaultConfiguration.keys
                },
                user: {
                    contents: this._userConfiguration.contents,
                    overrides: this._userConfiguration.overrides,
                    keys: this._userConfiguration.keys
                },
                workspace: {
                    contents: this._workspaceConfiguration.contents,
                    overrides: this._workspaceConfiguration.overrides,
                    keys: this._workspaceConfiguration.keys
                },
                folders: this._folderConfigurations.keys().reduce(function (result, folder) {
                    var _a = _this._folderConfigurations.get(folder), contents = _a.contents, overrides = _a.overrides, keys = _a.keys;
                    result[folder.toString()] = { contents: contents, overrides: overrides, keys: keys };
                    return result;
                }, Object.create({})),
                isComplete: true
            };
        };
        Configuration.prototype.allKeys = function (workspace) {
            var keys = this.keys(workspace);
            var all = keys.default.slice();
            var addKeys = function (keys) {
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    if (all.indexOf(key) === -1) {
                        all.push(key);
                    }
                }
            };
            addKeys(keys.user);
            addKeys(keys.workspace);
            for (var _i = 0, _a = this.folders.keys(); _i < _a.length; _i++) {
                var resource = _a[_i];
                addKeys(this.folders.get(resource).keys);
            }
            return all;
        };
        return Configuration;
    }());
    exports.Configuration = Configuration;
    var AbstractConfigurationChangeEvent = /** @class */ (function () {
        function AbstractConfigurationChangeEvent() {
        }
        AbstractConfigurationChangeEvent.prototype.doesConfigurationContains = function (configuration, config) {
            var _a;
            var changedKeysTree = configuration.contents;
            var requestedTree = configuration_1.toValuesTree((_a = {}, _a[config] = true, _a), function () { });
            var key;
            while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property
                changedKeysTree = changedKeysTree[key];
                if (!changedKeysTree) {
                    return false; // Requested tree is not found
                }
                requestedTree = requestedTree[key];
            }
            return true;
        };
        AbstractConfigurationChangeEvent.prototype.updateKeys = function (configuration, keys, resource) {
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                configuration.setValue(key, {});
            }
        };
        return AbstractConfigurationChangeEvent;
    }());
    exports.AbstractConfigurationChangeEvent = AbstractConfigurationChangeEvent;
    var ConfigurationChangeEvent = /** @class */ (function (_super) {
        __extends(ConfigurationChangeEvent, _super);
        function ConfigurationChangeEvent(_changedConfiguration, _changedConfigurationByResource) {
            if (_changedConfiguration === void 0) { _changedConfiguration = new ConfigurationModel(); }
            if (_changedConfigurationByResource === void 0) { _changedConfigurationByResource = new map_1.ResourceMap(); }
            var _this = _super.call(this) || this;
            _this._changedConfiguration = _changedConfiguration;
            _this._changedConfigurationByResource = _changedConfigurationByResource;
            return _this;
        }
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                return this._changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return this._changedConfigurationByResource;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.change = function (arg1, arg2) {
            if (arg1 instanceof ConfigurationChangeEvent) {
                this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);
                for (var _i = 0, _a = arg1._changedConfigurationByResource.keys(); _i < _a.length; _i++) {
                    var resource = _a[_i];
                    var changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);
                    changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));
                    this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
                }
            }
            else {
                this.changeWithKeys(arg1, arg2);
            }
            return this;
        };
        ConfigurationChangeEvent.prototype.telemetryData = function (source, sourceConfig) {
            this._source = source;
            this._sourceConfig = sourceConfig;
            return this;
        };
        Object.defineProperty(ConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                var keys = this._changedConfiguration.keys.slice();
                this._changedConfigurationByResource.forEach(function (model) { return keys.push.apply(keys, model.keys); });
                return arrays.distinct(keys);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "source", {
            get: function () {
                return this._source;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "sourceConfig", {
            get: function () {
                return this._sourceConfig;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            var configurationModelsToSearch = [this._changedConfiguration];
            if (resource) {
                var model = this._changedConfigurationByResource.get(resource);
                if (model) {
                    configurationModelsToSearch.push(model);
                }
            }
            else {
                configurationModelsToSearch.push.apply(configurationModelsToSearch, this._changedConfigurationByResource.values());
            }
            for (var _i = 0, configurationModelsToSearch_1 = configurationModelsToSearch; _i < configurationModelsToSearch_1.length; _i++) {
                var configuration = configurationModelsToSearch_1[_i];
                if (this.doesConfigurationContains(configuration, config)) {
                    return true;
                }
            }
            return false;
        };
        ConfigurationChangeEvent.prototype.changeWithKeys = function (keys, resource) {
            var changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;
            this.updateKeys(changedConfiguration, keys);
        };
        ConfigurationChangeEvent.prototype.getOrSetChangedConfigurationForResource = function (resource) {
            var changedConfigurationByResource = this._changedConfigurationByResource.get(resource);
            if (!changedConfigurationByResource) {
                changedConfigurationByResource = new ConfigurationModel();
                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
            }
            return changedConfigurationByResource;
        };
        return ConfigurationChangeEvent;
    }(AbstractConfigurationChangeEvent));
    exports.ConfigurationChangeEvent = ConfigurationChangeEvent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[41/*vs/platform/search/common/search*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/arrays*/,23/*vs/base/common/glob*/,13/*vs/base/common/objects*/,12/*vs/base/common/paths*/,5/*vs/base/common/strings*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, arrays_1, glob, objects, paths, strings_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VIEW_ID = 'workbench.view.search';
    exports.ISearchHistoryService = instantiation_1.createDecorator('searchHistoryService');
    exports.ISearchService = instantiation_1.createDecorator('searchService');
    /**
     * TODO@roblou - split text from file search entirely, or share code in a more natural way.
     */
    var SearchProviderType;
    (function (SearchProviderType) {
        SearchProviderType[SearchProviderType["file"] = 0] = "file";
        SearchProviderType[SearchProviderType["fileIndex"] = 1] = "fileIndex";
        SearchProviderType[SearchProviderType["text"] = 2] = "text";
    })(SearchProviderType = exports.SearchProviderType || (exports.SearchProviderType = {}));
    var QueryType;
    (function (QueryType) {
        QueryType[QueryType["File"] = 1] = "File";
        QueryType[QueryType["Text"] = 2] = "Text";
    })(QueryType = exports.QueryType || (exports.QueryType = {}));
    function resultIsMatch(result) {
        return !!result.preview;
    }
    exports.resultIsMatch = resultIsMatch;
    var FileMatch = /** @class */ (function () {
        function FileMatch(resource) {
            this.resource = resource;
            this.results = [];
            // empty
        }
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    var TextSearchMatch = /** @class */ (function () {
        function TextSearchMatch(text, range, previewOptions) {
            this.ranges = range;
            if (previewOptions && previewOptions.matchLines === 1 && !Array.isArray(range)) {
                // 1 line preview requested
                text = strings_1.getNLines(text, previewOptions.matchLines);
                var leadingChars = Math.floor(previewOptions.charsPerLine / 5);
                var previewStart = Math.max(range.startColumn - leadingChars, 0);
                var previewText = text.substring(previewStart, previewOptions.charsPerLine + previewStart);
                var endColInPreview = (range.endLineNumber - range.startLineNumber + 1) <= previewOptions.matchLines ?
                    Math.min(previewText.length, range.endColumn - previewStart) : // if number of match lines will not be trimmed by previewOptions
                    previewText.length; // if number of lines is trimmed
                this.preview = {
                    text: previewText,
                    matches: new OneLineRange(0, range.startColumn - previewStart, endColInPreview)
                };
            }
            else {
                var firstMatchLine_1 = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;
                // n line, no preview requested, or multiple matches in the preview
                this.preview = {
                    text: text,
                    matches: arrays_1.mapArrayOrNot(range, function (r) { return new SearchRange(r.startLineNumber - firstMatchLine_1, r.startColumn, r.endLineNumber - firstMatchLine_1, r.endColumn); })
                };
            }
        }
        return TextSearchMatch;
    }());
    exports.TextSearchMatch = TextSearchMatch;
    var SearchRange = /** @class */ (function () {
        function SearchRange(startLineNumber, startColumn, endLineNumber, endColumn) {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
        return SearchRange;
    }());
    exports.SearchRange = SearchRange;
    var OneLineRange = /** @class */ (function (_super) {
        __extends(OneLineRange, _super);
        function OneLineRange(lineNumber, startColumn, endColumn) {
            return _super.call(this, lineNumber, startColumn, lineNumber, endColumn) || this;
        }
        return OneLineRange;
    }(SearchRange));
    exports.OneLineRange = OneLineRange;
    function getExcludes(configuration) {
        var fileExcludes = configuration && configuration.files && configuration.files.exclude;
        var searchExcludes = configuration && configuration.search && configuration.search.exclude;
        if (!fileExcludes && !searchExcludes) {
            return undefined;
        }
        if (!fileExcludes || !searchExcludes) {
            return fileExcludes || searchExcludes;
        }
        var allExcludes = Object.create(null);
        // clone the config as it could be frozen
        allExcludes = objects.mixin(allExcludes, objects.deepClone(fileExcludes));
        allExcludes = objects.mixin(allExcludes, objects.deepClone(searchExcludes), true);
        return allExcludes;
    }
    exports.getExcludes = getExcludes;
    function pathIncludedInQuery(queryProps, fsPath) {
        if (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {
            return false;
        }
        if (queryProps.includePattern && !glob.match(queryProps.includePattern, fsPath)) {
            return false;
        }
        // If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present
        if (queryProps.usingSearchPaths) {
            return !!queryProps.folderQueries && queryProps.folderQueries.every(function (fq) {
                var searchPath = fq.folder.fsPath;
                if (paths.isEqualOrParent(fsPath, searchPath)) {
                    return !fq.includePattern || !!glob.match(fq.includePattern, fsPath);
                }
                else {
                    return false;
                }
            });
        }
        return true;
    }
    exports.pathIncludedInQuery = pathIncludedInQuery;
    var SearchErrorCode;
    (function (SearchErrorCode) {
        SearchErrorCode[SearchErrorCode["unknownEncoding"] = 1] = "unknownEncoding";
        SearchErrorCode[SearchErrorCode["regexParseError"] = 2] = "regexParseError";
        SearchErrorCode[SearchErrorCode["globParseError"] = 3] = "globParseError";
        SearchErrorCode[SearchErrorCode["invalidLiteral"] = 4] = "invalidLiteral";
        SearchErrorCode[SearchErrorCode["rgProcessError"] = 5] = "rgProcessError";
        SearchErrorCode[SearchErrorCode["other"] = 6] = "other";
    })(SearchErrorCode = exports.SearchErrorCode || (exports.SearchErrorCode = {}));
    var SearchError = /** @class */ (function (_super) {
        __extends(SearchError, _super);
        function SearchError(message, code) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            return _this;
        }
        return SearchError;
    }(Error));
    exports.SearchError = SearchError;
    function deserializeSearchError(errorMsg) {
        try {
            var details = JSON.parse(errorMsg);
            return new SearchError(details.message, details.code);
        }
        catch (e) {
            return new SearchError(errorMsg, SearchErrorCode.other);
        }
    }
    exports.deserializeSearchError = deserializeSearchError;
    function serializeSearchError(searchError) {
        var details = { message: searchError.message, code: searchError.code };
        return new Error(JSON.stringify(details));
    }
    exports.serializeSearchError = serializeSearchError;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[116/*vs/platform/workspaces/common/workspaces*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/,80/*vs/nls!vs/platform/workspaces/common/workspaces*/,2/*vs/base/common/uri*/]), function (require, exports, instantiation_1, nls_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspacesMainService = instantiation_1.createDecorator('workspacesMainService');
    exports.IWorkspacesService = instantiation_1.createDecorator('workspacesService');
    exports.WORKSPACE_EXTENSION = 'code-workspace';
    exports.WORKSPACE_FILTER = [{ name: nls_1.localize(0, null), extensions: [exports.WORKSPACE_EXTENSION] }];
    exports.UNTITLED_WORKSPACE_NAME = 'workspace.json';
    function isStoredWorkspaceFolder(thing) {
        return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);
    }
    exports.isStoredWorkspaceFolder = isStoredWorkspaceFolder;
    function isRawFileWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.path === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawFileWorkspaceFolder = isRawFileWorkspaceFolder;
    function isRawUriWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.uri === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawUriWorkspaceFolder = isRawUriWorkspaceFolder;
    function isSingleFolderWorkspaceIdentifier(obj) {
        return obj instanceof uri_1.URI;
    }
    exports.isSingleFolderWorkspaceIdentifier = isSingleFolderWorkspaceIdentifier;
    function isWorkspaceIdentifier(obj) {
        var workspaceIdentifier = obj;
        return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && typeof workspaceIdentifier.configPath === 'string';
    }
    exports.isWorkspaceIdentifier = isWorkspaceIdentifier;
    function toWorkspaceIdentifier(workspace) {
        if (workspace.configuration) {
            return {
                configPath: workspace.configuration.fsPath,
                id: workspace.id
            };
        }
        if (workspace.folders.length === 1) {
            return workspace.folders[0].uri;
        }
        // Empty workspace
        return undefined;
    }
    exports.toWorkspaceIdentifier = toWorkspaceIdentifier;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[117/*vs/platform/workspace/common/workspace*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,12/*vs/base/common/paths*/,24/*vs/base/common/resources*/,19/*vs/platform/instantiation/common/instantiation*/,22/*vs/base/common/map*/,116/*vs/platform/workspaces/common/workspaces*/,9/*vs/base/common/arrays*/,6/*vs/base/common/platform*/]), function (require, exports, uri_1, paths, resources, instantiation_1, map_1, workspaces_1, arrays_1, platform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var WorkbenchState;
    (function (WorkbenchState) {
        WorkbenchState[WorkbenchState["EMPTY"] = 1] = "EMPTY";
        WorkbenchState[WorkbenchState["FOLDER"] = 2] = "FOLDER";
        WorkbenchState[WorkbenchState["WORKSPACE"] = 3] = "WORKSPACE";
    })(WorkbenchState = exports.WorkbenchState || (exports.WorkbenchState = {}));
    var IWorkspace;
    (function (IWorkspace) {
        function isIWorkspace(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.id === 'string'
                && Array.isArray(thing.folders);
        }
        IWorkspace.isIWorkspace = isIWorkspace;
    })(IWorkspace = exports.IWorkspace || (exports.IWorkspace = {}));
    var IWorkspaceFolder;
    (function (IWorkspaceFolder) {
        function isIWorkspaceFolder(thing) {
            return thing && typeof thing === 'object'
                && uri_1.URI.isUri(thing.uri)
                && typeof thing.name === 'string'
                && typeof thing.toResource === 'function';
        }
        IWorkspaceFolder.isIWorkspaceFolder = isIWorkspaceFolder;
    })(IWorkspaceFolder = exports.IWorkspaceFolder || (exports.IWorkspaceFolder = {}));
    var Workspace = /** @class */ (function () {
        function Workspace(_id, folders, _configuration) {
            if (folders === void 0) { folders = []; }
            if (_configuration === void 0) { _configuration = null; }
            this._id = _id;
            this._configuration = _configuration;
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            this.folders = folders;
        }
        Workspace.prototype.update = function (workspace) {
            this._id = workspace.id;
            this._configuration = workspace.configuration;
            this.folders = workspace.folders;
        };
        Object.defineProperty(Workspace.prototype, "folders", {
            get: function () {
                return this._folders;
            },
            set: function (folders) {
                this._folders = folders;
                this.updateFoldersMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "configuration", {
            get: function () {
                return this._configuration;
            },
            set: function (configuration) {
                this._configuration = configuration;
            },
            enumerable: true,
            configurable: true
        });
        Workspace.prototype.getFolder = function (resource) {
            if (!resource) {
                return null;
            }
            return this._foldersMap.findSubstr(resource.toString());
        };
        Workspace.prototype.updateFoldersMap = function () {
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            for (var _i = 0, _a = this.folders; _i < _a.length; _i++) {
                var folder = _a[_i];
                this._foldersMap.set(folder.uri.toString(), folder);
            }
        };
        Workspace.prototype.toJSON = function () {
            return { id: this.id, folders: this.folders, configuration: this.configuration };
        };
        return Workspace;
    }());
    exports.Workspace = Workspace;
    var WorkspaceFolder = /** @class */ (function () {
        function WorkspaceFolder(data, raw) {
            this.raw = raw;
            this.uri = data.uri;
            this.index = data.index;
            this.name = data.name;
        }
        WorkspaceFolder.prototype.toResource = function (relativePath) {
            return resources.joinPath(this.uri, relativePath);
        };
        WorkspaceFolder.prototype.toJSON = function () {
            return { uri: this.uri, name: this.name, index: this.index };
        };
        return WorkspaceFolder;
    }());
    exports.WorkspaceFolder = WorkspaceFolder;
    function toWorkspaceFolders(configuredFolders, relativeTo) {
        var workspaceFolders = parseWorkspaceFolders(configuredFolders, relativeTo);
        return ensureUnique(arrays_1.coalesce(workspaceFolders))
            .map(function (_a, index) {
            var uri = _a.uri, raw = _a.raw, name = _a.name;
            return new WorkspaceFolder({ uri: uri, name: name || resources.basenameOrAuthority(uri), index: index }, raw);
        });
    }
    exports.toWorkspaceFolders = toWorkspaceFolders;
    function parseWorkspaceFolders(configuredFolders, relativeTo) {
        return configuredFolders.map(function (configuredFolder, index) {
            var uri = null;
            if (workspaces_1.isRawFileWorkspaceFolder(configuredFolder)) {
                uri = toUri(configuredFolder.path, relativeTo);
            }
            else if (workspaces_1.isRawUriWorkspaceFolder(configuredFolder)) {
                try {
                    uri = uri_1.URI.parse(configuredFolder.uri);
                    // this makes sure all workspace folder are absolute
                    if (uri.path[0] !== '/') {
                        uri = uri.with({ path: '/' + uri.path });
                    }
                }
                catch (e) {
                    console.warn(e);
                    // ignore
                }
            }
            if (!uri) {
                return void 0;
            }
            return new WorkspaceFolder({ uri: uri, name: configuredFolder.name /*is ensured in caller*/, index: index }, configuredFolder);
        });
    }
    function toUri(path, relativeTo) {
        if (path) {
            if (paths.isAbsolute(path)) {
                return uri_1.URI.file(path);
            }
            if (relativeTo) {
                return resources.joinPath(relativeTo, path);
            }
        }
        return null;
    }
    function ensureUnique(folders) {
        return arrays_1.distinct(folders, function (folder) { return platform_1.isLinux ? folder.uri.toString() : folder.uri.toString().toLowerCase(); });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[43/*vs/workbench/api/node/extHostExtensionActivator*/], __M([1/*require*/,0/*exports*/,84/*vs/nls!vs/workbench/api/node/extHostExtensionActivator*/,29/*vs/base/common/severity*/]), function (require, exports, nls, severity_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var NO_OP_VOID_PROMISE = Promise.resolve(void 0);
    var ExtensionActivationTimes = /** @class */ (function () {
        function ExtensionActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
        }
        ExtensionActivationTimes.NONE = new ExtensionActivationTimes(false, -1, -1, -1);
        return ExtensionActivationTimes;
    }());
    exports.ExtensionActivationTimes = ExtensionActivationTimes;
    var ExtensionActivationTimesBuilder = /** @class */ (function () {
        function ExtensionActivationTimesBuilder(startup) {
            this._startup = startup;
            this._codeLoadingStart = -1;
            this._codeLoadingStop = -1;
            this._activateCallStart = -1;
            this._activateCallStop = -1;
            this._activateResolveStart = -1;
            this._activateResolveStop = -1;
        }
        ExtensionActivationTimesBuilder.prototype._delta = function (start, stop) {
            if (start === -1 || stop === -1) {
                return -1;
            }
            return stop - start;
        };
        ExtensionActivationTimesBuilder.prototype.build = function () {
            return new ExtensionActivationTimes(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop));
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStart = function () {
            this._codeLoadingStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.codeLoadingStop = function () {
            this._codeLoadingStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStart = function () {
            this._activateCallStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateCallStop = function () {
            this._activateCallStop = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStart = function () {
            this._activateResolveStart = Date.now();
        };
        ExtensionActivationTimesBuilder.prototype.activateResolveStop = function () {
            this._activateResolveStop = Date.now();
        };
        return ExtensionActivationTimesBuilder;
    }());
    exports.ExtensionActivationTimesBuilder = ExtensionActivationTimesBuilder;
    var ActivatedExtension = /** @class */ (function () {
        function ActivatedExtension(activationFailed, activationFailedError, activationTimes, module, exports, subscriptions) {
            this.activationFailed = activationFailed;
            this.activationFailedError = activationFailedError;
            this.activationTimes = activationTimes;
            this.module = module;
            this.exports = exports;
            this.subscriptions = subscriptions;
        }
        return ActivatedExtension;
    }());
    exports.ActivatedExtension = ActivatedExtension;
    var EmptyExtension = /** @class */ (function (_super) {
        __extends(EmptyExtension, _super);
        function EmptyExtension(activationTimes) {
            return _super.call(this, false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return EmptyExtension;
    }(ActivatedExtension));
    exports.EmptyExtension = EmptyExtension;
    var FailedExtension = /** @class */ (function (_super) {
        __extends(FailedExtension, _super);
        function FailedExtension(activationError) {
            return _super.call(this, true, activationError, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []) || this;
        }
        return FailedExtension;
    }(ActivatedExtension));
    exports.FailedExtension = FailedExtension;
    var ExtensionActivatedByEvent = /** @class */ (function () {
        function ExtensionActivatedByEvent(startup, activationEvent) {
            this.startup = startup;
            this.activationEvent = activationEvent;
        }
        return ExtensionActivatedByEvent;
    }());
    exports.ExtensionActivatedByEvent = ExtensionActivatedByEvent;
    var ExtensionActivatedByAPI = /** @class */ (function () {
        function ExtensionActivatedByAPI(startup) {
            this.startup = startup;
        }
        return ExtensionActivatedByAPI;
    }());
    exports.ExtensionActivatedByAPI = ExtensionActivatedByAPI;
    var ExtensionsActivator = /** @class */ (function () {
        function ExtensionsActivator(registry, host) {
            this._registry = registry;
            this._host = host;
            this._activatingExtensions = {};
            this._activatedExtensions = {};
            this._alreadyActivatedEvents = Object.create(null);
        }
        ExtensionsActivator.prototype.isActivated = function (extensionId) {
            return hasOwnProperty.call(this._activatedExtensions, extensionId);
        };
        ExtensionsActivator.prototype.getActivatedExtension = function (extensionId) {
            if (!hasOwnProperty.call(this._activatedExtensions, extensionId)) {
                throw new Error('Extension `' + extensionId + '` is not known or not activated');
            }
            return this._activatedExtensions[extensionId];
        };
        ExtensionsActivator.prototype.activateByEvent = function (activationEvent, reason) {
            var _this = this;
            if (this._alreadyActivatedEvents[activationEvent]) {
                return NO_OP_VOID_PROMISE;
            }
            var activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
            return this._activateExtensions(activateExtensions, reason, 0).then(function () {
                _this._alreadyActivatedEvents[activationEvent] = true;
            });
        };
        ExtensionsActivator.prototype.activateById = function (extensionId, reason) {
            var desc = this._registry.getExtensionDescription(extensionId);
            if (!desc) {
                throw new Error('Extension `' + extensionId + '` is not known');
            }
            return this._activateExtensions([desc], reason, 0);
        };
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * semantics: `redExtensions` must wait for `greenExtensions`.
         */
        ExtensionsActivator.prototype._handleActivateRequest = function (currentExtension, greenExtensions, redExtensions) {
            var depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            var currentExtensionGetsGreenLight = true;
            for (var j = 0, lenJ = depIds.length; j < lenJ; j++) {
                var depId = depIds[j];
                var depDesc = this._registry.getExtensionDescription(depId);
                if (!depDesc) {
                    // Error condition 1: unknown dependency
                    this._host.showMessage(severity_1.default.Error, nls.localize(0, null, currentExtension.displayName || currentExtension.id, depId));
                    var error = new Error("Unknown dependency '" + depId + "'");
                    this._activatedExtensions[currentExtension.id] = new FailedExtension(error);
                    return;
                }
                if (hasOwnProperty.call(this._activatedExtensions, depId)) {
                    var dep = this._activatedExtensions[depId];
                    if (dep.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        this._host.showMessage(severity_1.default.Error, nls.localize(1, null, currentExtension.displayName || currentExtension.id, depId));
                        var error = new Error("Dependency " + depId + " failed to activate");
                        error.detail = dep.activationFailedError;
                        this._activatedExtensions[currentExtension.id] = new FailedExtension(error);
                        return;
                    }
                }
                else {
                    // must first wait for the dependency to activate
                    currentExtensionGetsGreenLight = false;
                    greenExtensions[depId] = depDesc;
                }
            }
            if (currentExtensionGetsGreenLight) {
                greenExtensions[currentExtension.id] = currentExtension;
            }
            else {
                redExtensions.push(currentExtension);
            }
        };
        ExtensionsActivator.prototype._activateExtensions = function (extensionDescriptions, reason, recursionLevel) {
            var _this = this;
            // console.log(recursionLevel, '_activateExtensions: ', extensionDescriptions.map(p => p.id));
            if (extensionDescriptions.length === 0) {
                return Promise.resolve(void 0);
            }
            extensionDescriptions = extensionDescriptions.filter(function (p) { return !hasOwnProperty.call(_this._activatedExtensions, p.id); });
            if (extensionDescriptions.length === 0) {
                return Promise.resolve(void 0);
            }
            if (recursionLevel > 10) {
                // More than 10 dependencies deep => most likely a dependency loop
                for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                    // Error condition 3: dependency loop
                    this._host.showMessage(severity_1.default.Error, nls.localize(2, null, extensionDescriptions[i].id));
                    var error = new Error('More than 10 levels of dependencies (most likely a dependency loop)');
                    this._activatedExtensions[extensionDescriptions[i].id] = new FailedExtension(error);
                }
                return Promise.resolve(void 0);
            }
            var greenMap = Object.create(null), red = [];
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                this._handleActivateRequest(extensionDescriptions[i], greenMap, red);
            }
            // Make sure no red is also green
            for (var i = 0, len = red.length; i < len; i++) {
                if (greenMap[red[i].id]) {
                    delete greenMap[red[i].id];
                }
            }
            var green = Object.keys(greenMap).map(function (id) { return greenMap[id]; });
            // console.log('greenExtensions: ', green.map(p => p.id));
            // console.log('redExtensions: ', red.map(p => p.id));
            if (red.length === 0) {
                // Finally reached only leafs!
                return Promise.all(green.map(function (p) { return _this._activateExtension(p, reason); })).then(function (_) { return void 0; });
            }
            return this._activateExtensions(green, reason, recursionLevel + 1).then(function (_) {
                return _this._activateExtensions(red, reason, recursionLevel + 1);
            });
        };
        ExtensionsActivator.prototype._activateExtension = function (extensionDescription, reason) {
            var _this = this;
            if (hasOwnProperty.call(this._activatedExtensions, extensionDescription.id)) {
                return Promise.resolve(void 0);
            }
            if (hasOwnProperty.call(this._activatingExtensions, extensionDescription.id)) {
                return this._activatingExtensions[extensionDescription.id];
            }
            this._activatingExtensions[extensionDescription.id] = this._host.actualActivateExtension(extensionDescription, reason).then(null, function (err) {
                _this._host.showMessage(severity_1.default.Error, nls.localize(3, null, extensionDescription.id, err.message));
                console.error('Activating extension `' + extensionDescription.id + '` failed: ', err.message);
                console.log('Here is the error stack: ', err.stack);
                // Treat the extension as being empty
                return new FailedExtension(err);
            }).then(function (x) {
                _this._activatedExtensions[extensionDescription.id] = x;
                delete _this._activatingExtensions[extensionDescription.id];
            });
            return this._activatingExtensions[extensionDescription.id];
        };
        return ExtensionsActivator;
    }());
    exports.ExtensionsActivator = ExtensionsActivator;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[119/*vs/workbench/api/node/extHostHeapService*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostHeapService = /** @class */ (function () {
        function ExtHostHeapService() {
            this._data = new Map();
        }
        ExtHostHeapService.prototype.keep = function (obj) {
            var id = ExtHostHeapService._idPool++;
            this._data.set(id, obj);
            return id;
        };
        ExtHostHeapService.prototype.delete = function (id) {
            return this._data.delete(id);
        };
        ExtHostHeapService.prototype.get = function (id) {
            return this._data.get(id);
        };
        ExtHostHeapService.prototype.$onGarbageCollection = function (ids) {
            for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                var id = ids_1[_i];
                this.delete(id);
            }
        };
        ExtHostHeapService._idPool = 0;
        return ExtHostHeapService;
    }());
    exports.ExtHostHeapService = ExtHostHeapService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[7/*vs/workbench/api/node/extHostTypes*/], __M([1/*require*/,0/*exports*/,202/*crypto*/,2/*vs/base/common/uri*/,14/*vs/base/common/errors*/,60/*vs/base/common/htmlContent*/,10/*path*/,5/*vs/base/common/strings*/,22/*vs/base/common/map*/,9/*vs/base/common/arrays*/]), function (require, exports, crypto, uri_1, errors_1, htmlContent_1, path_1, strings_1, map_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Disposable = /** @class */ (function () {
        function Disposable(callOnDispose) {
            this._callOnDispose = callOnDispose;
        }
        Disposable.from = function () {
            var inDisposables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                inDisposables[_i] = arguments[_i];
            }
            var disposables = inDisposables;
            return new Disposable(function () {
                if (disposables) {
                    for (var _i = 0, disposables_1 = disposables; _i < disposables_1.length; _i++) {
                        var disposable = disposables_1[_i];
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            });
        };
        Disposable.prototype.dispose = function () {
            if (typeof this._callOnDispose === 'function') {
                this._callOnDispose();
                this._callOnDispose = undefined;
            }
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Position = /** @class */ (function () {
        function Position(line, character) {
            if (line < 0) {
                throw errors_1.illegalArgument('line must be non-negative');
            }
            if (character < 0) {
                throw errors_1.illegalArgument('character must be non-negative');
            }
            this._line = line;
            this._character = character;
        }
        Position.Min = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_1 = positions; _a < positions_1.length; _a++) {
                var p = positions_1[_a];
                if (p.isBefore(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.Max = function () {
            var positions = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                positions[_i] = arguments[_i];
            }
            var result = positions.pop();
            for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {
                var p = positions_2[_a];
                if (p.isAfter(result)) {
                    result = p;
                }
            }
            return result;
        };
        Position.isPosition = function (other) {
            if (!other) {
                return false;
            }
            if (other instanceof Position) {
                return true;
            }
            var _a = other, line = _a.line, character = _a.character;
            if (typeof line === 'number' && typeof character === 'number') {
                return true;
            }
            return false;
        };
        Object.defineProperty(Position.prototype, "line", {
            get: function () {
                return this._line;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Position.prototype, "character", {
            get: function () {
                return this._character;
            },
            enumerable: true,
            configurable: true
        });
        Position.prototype.isBefore = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character < other._character;
        };
        Position.prototype.isBeforeOrEqual = function (other) {
            if (this._line < other._line) {
                return true;
            }
            if (other._line < this._line) {
                return false;
            }
            return this._character <= other._character;
        };
        Position.prototype.isAfter = function (other) {
            return !this.isBeforeOrEqual(other);
        };
        Position.prototype.isAfterOrEqual = function (other) {
            return !this.isBefore(other);
        };
        Position.prototype.isEqual = function (other) {
            return this._line === other._line && this._character === other._character;
        };
        Position.prototype.compareTo = function (other) {
            if (this._line < other._line) {
                return -1;
            }
            else if (this._line > other.line) {
                return 1;
            }
            else {
                // equal line
                if (this._character < other._character) {
                    return -1;
                }
                else if (this._character > other._character) {
                    return 1;
                }
                else {
                    // equal line and character
                    return 0;
                }
            }
        };
        Position.prototype.translate = function (lineDeltaOrChange, characterDelta) {
            if (characterDelta === void 0) { characterDelta = 0; }
            if (lineDeltaOrChange === null || characterDelta === null) {
                throw errors_1.illegalArgument();
            }
            var lineDelta;
            if (typeof lineDeltaOrChange === 'undefined') {
                lineDelta = 0;
            }
            else if (typeof lineDeltaOrChange === 'number') {
                lineDelta = lineDeltaOrChange;
            }
            else {
                lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
                characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
            }
            if (lineDelta === 0 && characterDelta === 0) {
                return this;
            }
            return new Position(this.line + lineDelta, this.character + characterDelta);
        };
        Position.prototype.with = function (lineOrChange, character) {
            if (character === void 0) { character = this.character; }
            if (lineOrChange === null || character === null) {
                throw errors_1.illegalArgument();
            }
            var line;
            if (typeof lineOrChange === 'undefined') {
                line = this.line;
            }
            else if (typeof lineOrChange === 'number') {
                line = lineOrChange;
            }
            else {
                line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
                character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
            }
            if (line === this.line && character === this.character) {
                return this;
            }
            return new Position(line, character);
        };
        Position.prototype.toJSON = function () {
            return { line: this.line, character: this.character };
        };
        return Position;
    }());
    exports.Position = Position;
    var Range = /** @class */ (function () {
        function Range(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
            var start;
            var end;
            if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
                start = new Position(startLineOrStart, startColumnOrEnd);
                end = new Position(endLine, endColumn);
            }
            else if (startLineOrStart instanceof Position && startColumnOrEnd instanceof Position) {
                start = startLineOrStart;
                end = startColumnOrEnd;
            }
            if (!start || !end) {
                throw new Error('Invalid arguments');
            }
            if (start.isBefore(end)) {
                this._start = start;
                this._end = end;
            }
            else {
                this._start = end;
                this._end = start;
            }
        }
        Range.isRange = function (thing) {
            if (thing instanceof Range) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Position.isPosition(thing.start)
                && Position.isPosition(thing.end);
        };
        Object.defineProperty(Range.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.contains = function (positionOrRange) {
            if (positionOrRange instanceof Range) {
                return this.contains(positionOrRange._start)
                    && this.contains(positionOrRange._end);
            }
            else if (positionOrRange instanceof Position) {
                if (positionOrRange.isBefore(this._start)) {
                    return false;
                }
                if (this._end.isBefore(positionOrRange)) {
                    return false;
                }
                return true;
            }
            return false;
        };
        Range.prototype.isEqual = function (other) {
            return this._start.isEqual(other._start) && this._end.isEqual(other._end);
        };
        Range.prototype.intersection = function (other) {
            var start = Position.Max(other.start, this._start);
            var end = Position.Min(other.end, this._end);
            if (start.isAfter(end)) {
                // this happens when there is no overlap:
                // |-----|
                //          |----|
                return undefined;
            }
            return new Range(start, end);
        };
        Range.prototype.union = function (other) {
            if (this.contains(other)) {
                return this;
            }
            else if (other.contains(this)) {
                return other;
            }
            var start = Position.Min(other.start, this._start);
            var end = Position.Max(other.end, this.end);
            return new Range(start, end);
        };
        Object.defineProperty(Range.prototype, "isEmpty", {
            get: function () {
                return this._start.isEqual(this._end);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Range.prototype, "isSingleLine", {
            get: function () {
                return this._start.line === this._end.line;
            },
            enumerable: true,
            configurable: true
        });
        Range.prototype.with = function (startOrChange, end) {
            if (end === void 0) { end = this.end; }
            if (startOrChange === null || end === null) {
                throw errors_1.illegalArgument();
            }
            var start;
            if (!startOrChange) {
                start = this.start;
            }
            else if (Position.isPosition(startOrChange)) {
                start = startOrChange;
            }
            else {
                start = startOrChange.start || this.start;
                end = startOrChange.end || this.end;
            }
            if (start.isEqual(this._start) && end.isEqual(this.end)) {
                return this;
            }
            return new Range(start, end);
        };
        Range.prototype.toJSON = function () {
            return [this.start, this.end];
        };
        return Range;
    }());
    exports.Range = Range;
    var Selection = /** @class */ (function (_super) {
        __extends(Selection, _super);
        function Selection(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
            var _this = this;
            var anchor;
            var active;
            if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
                anchor = new Position(anchorLineOrAnchor, anchorColumnOrActive);
                active = new Position(activeLine, activeColumn);
            }
            else if (anchorLineOrAnchor instanceof Position && anchorColumnOrActive instanceof Position) {
                anchor = anchorLineOrAnchor;
                active = anchorColumnOrActive;
            }
            if (!anchor || !active) {
                throw new Error('Invalid arguments');
            }
            _this = _super.call(this, anchor, active) || this;
            _this._anchor = anchor;
            _this._active = active;
            return _this;
        }
        Selection.isSelection = function (thing) {
            if (thing instanceof Selection) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && Position.isPosition(thing.anchor)
                && Position.isPosition(thing.active)
                && typeof thing.isReversed === 'boolean';
        };
        Object.defineProperty(Selection.prototype, "anchor", {
            get: function () {
                return this._anchor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "active", {
            get: function () {
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "isReversed", {
            get: function () {
                return this._anchor === this._end;
            },
            enumerable: true,
            configurable: true
        });
        Selection.prototype.toJSON = function () {
            return {
                start: this.start,
                end: this.end,
                active: this.active,
                anchor: this.anchor
            };
        };
        return Selection;
    }(Range));
    exports.Selection = Selection;
    var EndOfLine;
    (function (EndOfLine) {
        EndOfLine[EndOfLine["LF"] = 1] = "LF";
        EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var TextEdit = /** @class */ (function () {
        function TextEdit(range, newText) {
            this.range = range;
            this.newText = newText;
        }
        TextEdit.isTextEdit = function (thing) {
            if (thing instanceof TextEdit) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing)
                && typeof thing.newText === 'string';
        };
        TextEdit.replace = function (range, newText) {
            return new TextEdit(range, newText);
        };
        TextEdit.insert = function (position, newText) {
            return TextEdit.replace(new Range(position, position), newText);
        };
        TextEdit.delete = function (range) {
            return TextEdit.replace(range, '');
        };
        TextEdit.setEndOfLine = function (eol) {
            var ret = new TextEdit(undefined, undefined);
            ret.newEol = eol;
            return ret;
        };
        Object.defineProperty(TextEdit.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                if (value && !Range.isRange(value)) {
                    throw errors_1.illegalArgument('range');
                }
                this._range = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newText", {
            get: function () {
                return this._newText || '';
            },
            set: function (value) {
                if (value && typeof value !== 'string') {
                    throw errors_1.illegalArgument('newText');
                }
                this._newText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextEdit.prototype, "newEol", {
            get: function () {
                return this._newEol;
            },
            set: function (value) {
                if (value && typeof value !== 'number') {
                    throw errors_1.illegalArgument('newEol');
                }
                this._newEol = value;
            },
            enumerable: true,
            configurable: true
        });
        TextEdit.prototype.toJSON = function () {
            return {
                range: this.range,
                newText: this.newText,
                newEol: this._newEol
            };
        };
        return TextEdit;
    }());
    exports.TextEdit = TextEdit;
    var WorkspaceEdit = /** @class */ (function () {
        function WorkspaceEdit() {
            this._edits = new Array();
        }
        WorkspaceEdit.prototype.renameFile = function (from, to, options) {
            this._edits.push({ _type: 1, from: from, to: to, options: options });
        };
        WorkspaceEdit.prototype.createFile = function (uri, options) {
            this._edits.push({ _type: 1, from: undefined, to: uri, options: options });
        };
        WorkspaceEdit.prototype.deleteFile = function (uri, options) {
            this._edits.push({ _type: 1, from: uri, to: undefined, options: options });
        };
        WorkspaceEdit.prototype.replace = function (uri, range, newText) {
            this._edits.push({ _type: 2, uri: uri, edit: new TextEdit(range, newText) });
        };
        WorkspaceEdit.prototype.insert = function (resource, position, newText) {
            this.replace(resource, new Range(position, position), newText);
        };
        WorkspaceEdit.prototype.delete = function (resource, range) {
            this.replace(resource, range, '');
        };
        WorkspaceEdit.prototype.has = function (uri) {
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (edit._type === 2 && edit.uri.toString() === uri.toString()) {
                    return true;
                }
            }
            return false;
        };
        WorkspaceEdit.prototype.set = function (uri, edits) {
            if (!edits) {
                // remove all text edits for `uri`
                for (var i = 0; i < this._edits.length; i++) {
                    var element = this._edits[i];
                    if (element._type === 2 && element.uri.toString() === uri.toString()) {
                        this._edits[i] = undefined;
                    }
                }
                this._edits = arrays_1.coalesce(this._edits);
            }
            else {
                // append edit to the end
                for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                    var edit = edits_1[_i];
                    if (edit) {
                        this._edits.push({ _type: 2, uri: uri, edit: edit });
                    }
                }
            }
        };
        WorkspaceEdit.prototype.get = function (uri) {
            var res = [];
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var candidate = _a[_i];
                if (candidate._type === 2 && candidate.uri.toString() === uri.toString()) {
                    res.push(candidate.edit);
                }
            }
            if (res.length === 0) {
                return undefined;
            }
            return res;
        };
        WorkspaceEdit.prototype.entries = function () {
            var textEdits = new Map();
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var candidate = _a[_i];
                if (candidate._type === 2) {
                    var textEdit = textEdits.get(candidate.uri.toString());
                    if (!textEdit) {
                        textEdit = [candidate.uri, []];
                        textEdits.set(candidate.uri.toString(), textEdit);
                    }
                    textEdit[1].push(candidate.edit);
                }
            }
            return map_1.values(textEdits);
        };
        WorkspaceEdit.prototype._allEntries = function () {
            var res = [];
            for (var _i = 0, _a = this._edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (edit._type === 1) {
                    res.push([edit.from, edit.to, edit.options]);
                }
                else {
                    res.push([edit.uri, [edit.edit]]);
                }
            }
            return res;
        };
        Object.defineProperty(WorkspaceEdit.prototype, "size", {
            get: function () {
                return this.entries().length;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceEdit.prototype.toJSON = function () {
            return this.entries();
        };
        return WorkspaceEdit;
    }());
    exports.WorkspaceEdit = WorkspaceEdit;
    var SnippetString = /** @class */ (function () {
        function SnippetString(value) {
            this._tabstop = 1;
            this.value = value || '';
        }
        SnippetString.isSnippetString = function (thing) {
            if (thing instanceof SnippetString) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.value === 'string';
        };
        SnippetString._escape = function (value) {
            return value.replace(/\$|}|\\/g, '\\$&');
        };
        SnippetString.prototype.appendText = function (string) {
            this.value += SnippetString._escape(string);
            return this;
        };
        SnippetString.prototype.appendTabstop = function (number) {
            if (number === void 0) { number = this._tabstop++; }
            this.value += '$';
            this.value += number;
            return this;
        };
        SnippetString.prototype.appendPlaceholder = function (value, number) {
            if (number === void 0) { number = this._tabstop++; }
            if (typeof value === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                value(nested);
                this._tabstop = nested._tabstop;
                value = nested.value;
            }
            else {
                value = SnippetString._escape(value);
            }
            this.value += '${';
            this.value += number;
            this.value += ':';
            this.value += value;
            this.value += '}';
            return this;
        };
        SnippetString.prototype.appendVariable = function (name, defaultValue) {
            if (typeof defaultValue === 'function') {
                var nested = new SnippetString();
                nested._tabstop = this._tabstop;
                defaultValue(nested);
                this._tabstop = nested._tabstop;
                defaultValue = nested.value;
            }
            else if (typeof defaultValue === 'string') {
                defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
            }
            this.value += '${';
            this.value += name;
            if (defaultValue) {
                this.value += ':';
                this.value += defaultValue;
            }
            this.value += '}';
            return this;
        };
        return SnippetString;
    }());
    exports.SnippetString = SnippetString;
    var DiagnosticTag;
    (function (DiagnosticTag) {
        DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    })(DiagnosticTag = exports.DiagnosticTag || (exports.DiagnosticTag = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
        DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
        DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
        DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var Location = /** @class */ (function () {
        function Location(uri, rangeOrPosition) {
            this.uri = uri;
            if (!rangeOrPosition) {
                //that's OK
            }
            else if (rangeOrPosition instanceof Range) {
                this.range = rangeOrPosition;
            }
            else if (rangeOrPosition instanceof Position) {
                this.range = new Range(rangeOrPosition, rangeOrPosition);
            }
            else {
                throw new Error('Illegal argument');
            }
        }
        Location.isLocation = function (thing) {
            if (thing instanceof Location) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return Range.isRange(thing.range)
                && uri_1.URI.isUri(thing.uri);
        };
        Location.prototype.toJSON = function () {
            return {
                uri: this.uri,
                range: this.range
            };
        };
        return Location;
    }());
    exports.Location = Location;
    var DiagnosticRelatedInformation = /** @class */ (function () {
        function DiagnosticRelatedInformation(location, message) {
            this.location = location;
            this.message = message;
        }
        DiagnosticRelatedInformation.is = function (thing) {
            if (!thing) {
                return false;
            }
            return typeof thing.message === 'string'
                && thing.location
                && Range.isRange(thing.location.range)
                && uri_1.URI.isUri(thing.location.uri);
        };
        DiagnosticRelatedInformation.isEqual = function (a, b) {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.message === b.message
                && a.location.range.isEqual(b.location.range)
                && a.location.uri.toString() === b.location.uri.toString();
        };
        return DiagnosticRelatedInformation;
    }());
    exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation;
    var Diagnostic = /** @class */ (function () {
        function Diagnostic(range, message, severity) {
            if (severity === void 0) { severity = DiagnosticSeverity.Error; }
            this.range = range;
            this.message = message;
            this.severity = severity;
        }
        Diagnostic.prototype.toJSON = function () {
            return {
                severity: DiagnosticSeverity[this.severity],
                message: this.message,
                range: this.range,
                source: this.source,
                code: this.code,
            };
        };
        Diagnostic.isEqual = function (a, b) {
            if (a === b) {
                return true;
            }
            if (!a || !b) {
                return false;
            }
            return a.message === b.message
                && a.severity === b.severity
                && a.code === b.code
                && a.severity === b.severity
                && a.source === b.source
                && a.range.isEqual(b.range)
                && arrays_1.equals(a.tags, b.tags)
                && arrays_1.equals(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);
        };
        return Diagnostic;
    }());
    exports.Diagnostic = Diagnostic;
    var Hover = /** @class */ (function () {
        function Hover(contents, range) {
            if (!contents) {
                throw new Error('Illegal argument, contents must be defined');
            }
            if (Array.isArray(contents)) {
                this.contents = contents;
            }
            else if (htmlContent_1.isMarkdownString(contents)) {
                this.contents = [contents];
            }
            else {
                this.contents = [contents];
            }
            this.range = range;
        }
        return Hover;
    }());
    exports.Hover = Hover;
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    var DocumentHighlight = /** @class */ (function () {
        function DocumentHighlight(range, kind) {
            if (kind === void 0) { kind = DocumentHighlightKind.Text; }
            this.range = range;
            this.kind = kind;
        }
        DocumentHighlight.prototype.toJSON = function () {
            return {
                range: this.range,
                kind: DocumentHighlightKind[this.kind]
            };
        };
        return DocumentHighlight;
    }());
    exports.DocumentHighlight = DocumentHighlight;
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
        SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
        SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
        SymbolKind[SymbolKind["Event"] = 23] = "Event";
        SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
        SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolInformation = /** @class */ (function () {
        function SymbolInformation(name, kind, rangeOrContainer, locationOrUri, containerName) {
            this.name = name;
            this.kind = kind;
            this.containerName = containerName;
            if (typeof rangeOrContainer === 'string') {
                this.containerName = rangeOrContainer;
            }
            if (locationOrUri instanceof Location) {
                this.location = locationOrUri;
            }
            else if (rangeOrContainer instanceof Range) {
                this.location = new Location(locationOrUri, rangeOrContainer);
            }
            SymbolInformation.validate(this);
        }
        SymbolInformation.validate = function (candidate) {
            if (!candidate.name) {
                throw new Error('name must not be falsy');
            }
        };
        SymbolInformation.prototype.toJSON = function () {
            return {
                name: this.name,
                kind: SymbolKind[this.kind],
                location: this.location,
                containerName: this.containerName
            };
        };
        return SymbolInformation;
    }());
    exports.SymbolInformation = SymbolInformation;
    var DocumentSymbol = /** @class */ (function () {
        function DocumentSymbol(name, detail, kind, range, selectionRange) {
            this.name = name;
            this.detail = detail;
            this.kind = kind;
            this.range = range;
            this.selectionRange = selectionRange;
            this.children = [];
            DocumentSymbol.validate(this);
        }
        DocumentSymbol.validate = function (candidate) {
            if (!candidate.name) {
                throw new Error('name must not be falsy');
            }
            if (!candidate.range.contains(candidate.selectionRange)) {
                throw new Error('selectionRange must be contained in fullRange');
            }
            if (candidate.children) {
                candidate.children.forEach(DocumentSymbol.validate);
            }
        };
        return DocumentSymbol;
    }());
    exports.DocumentSymbol = DocumentSymbol;
    var CodeActionTrigger;
    (function (CodeActionTrigger) {
        CodeActionTrigger[CodeActionTrigger["Automatic"] = 1] = "Automatic";
        CodeActionTrigger[CodeActionTrigger["Manual"] = 2] = "Manual";
    })(CodeActionTrigger = exports.CodeActionTrigger || (exports.CodeActionTrigger = {}));
    var CodeAction = /** @class */ (function () {
        function CodeAction(title, kind) {
            this.title = title;
            this.kind = kind;
        }
        return CodeAction;
    }());
    exports.CodeAction = CodeAction;
    var CodeActionKind = /** @class */ (function () {
        function CodeActionKind(value) {
            this.value = value;
        }
        CodeActionKind.prototype.append = function (parts) {
            return new CodeActionKind(this.value ? this.value + CodeActionKind.sep + parts : parts);
        };
        CodeActionKind.prototype.contains = function (other) {
            return this.value === other.value || strings_1.startsWith(other.value, this.value + CodeActionKind.sep);
        };
        CodeActionKind.sep = '.';
        CodeActionKind.Empty = new CodeActionKind('');
        CodeActionKind.QuickFix = CodeActionKind.Empty.append('quickfix');
        CodeActionKind.Refactor = CodeActionKind.Empty.append('refactor');
        CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append('extract');
        CodeActionKind.RefactorInline = CodeActionKind.Refactor.append('inline');
        CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append('rewrite');
        CodeActionKind.Source = CodeActionKind.Empty.append('source');
        CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append('organizeImports');
        return CodeActionKind;
    }());
    exports.CodeActionKind = CodeActionKind;
    var CodeLens = /** @class */ (function () {
        function CodeLens(range, command) {
            this.range = range;
            this.command = command;
        }
        Object.defineProperty(CodeLens.prototype, "isResolved", {
            get: function () {
                return !!this.command;
            },
            enumerable: true,
            configurable: true
        });
        return CodeLens;
    }());
    exports.CodeLens = CodeLens;
    var MarkdownString = /** @class */ (function () {
        function MarkdownString(value) {
            this.value = value || '';
        }
        MarkdownString.prototype.appendText = function (value) {
            // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
            this.value += value.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&');
            return this;
        };
        MarkdownString.prototype.appendMarkdown = function (value) {
            this.value += value;
            return this;
        };
        MarkdownString.prototype.appendCodeblock = function (code, language) {
            if (language === void 0) { language = ''; }
            this.value += '\n```';
            this.value += language;
            this.value += '\n';
            this.value += code;
            this.value += '\n```\n';
            return this;
        };
        return MarkdownString;
    }());
    exports.MarkdownString = MarkdownString;
    var ParameterInformation = /** @class */ (function () {
        function ParameterInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
        }
        return ParameterInformation;
    }());
    exports.ParameterInformation = ParameterInformation;
    var SignatureInformation = /** @class */ (function () {
        function SignatureInformation(label, documentation) {
            this.label = label;
            this.documentation = documentation;
            this.parameters = [];
        }
        return SignatureInformation;
    }());
    exports.SignatureInformation = SignatureInformation;
    var SignatureHelp = /** @class */ (function () {
        function SignatureHelp() {
            this.signatures = [];
        }
        return SignatureHelp;
    }());
    exports.SignatureHelp = SignatureHelp;
    var SignatureHelpTriggerReason;
    (function (SignatureHelpTriggerReason) {
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["Invoke"] = 1] = "Invoke";
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["TriggerCharacter"] = 2] = "TriggerCharacter";
        SignatureHelpTriggerReason[SignatureHelpTriggerReason["ContentChange"] = 3] = "ContentChange";
    })(SignatureHelpTriggerReason = exports.SignatureHelpTriggerReason || (exports.SignatureHelpTriggerReason = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
        CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
        CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
        CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
        CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
        CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
        CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
        CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
        CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
        CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItemInsertTextRule;
    (function (CompletionItemInsertTextRule) {
        CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    })(CompletionItemInsertTextRule = exports.CompletionItemInsertTextRule || (exports.CompletionItemInsertTextRule = {}));
    var CompletionItem = /** @class */ (function () {
        function CompletionItem(label, kind) {
            this.label = label;
            this.kind = kind;
        }
        CompletionItem.prototype.toJSON = function () {
            return {
                label: this.label,
                kind: CompletionItemKind[this.kind],
                detail: this.detail,
                documentation: this.documentation,
                sortText: this.sortText,
                filterText: this.filterText,
                preselect: this.preselect,
                insertText: this.insertText,
                textEdit: this.textEdit
            };
        };
        return CompletionItem;
    }());
    exports.CompletionItem = CompletionItem;
    var CompletionList = /** @class */ (function () {
        function CompletionList(items, isIncomplete) {
            if (items === void 0) { items = []; }
            if (isIncomplete === void 0) { isIncomplete = false; }
            this.items = items;
            this.isIncomplete = isIncomplete;
        }
        return CompletionList;
    }());
    exports.CompletionList = CompletionList;
    var ViewColumn;
    (function (ViewColumn) {
        ViewColumn[ViewColumn["Active"] = -1] = "Active";
        ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
        ViewColumn[ViewColumn["One"] = 1] = "One";
        ViewColumn[ViewColumn["Two"] = 2] = "Two";
        ViewColumn[ViewColumn["Three"] = 3] = "Three";
        ViewColumn[ViewColumn["Four"] = 4] = "Four";
        ViewColumn[ViewColumn["Five"] = 5] = "Five";
        ViewColumn[ViewColumn["Six"] = 6] = "Six";
        ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
        ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
        ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
    var StatusBarAlignment;
    (function (StatusBarAlignment) {
        StatusBarAlignment[StatusBarAlignment["Left"] = 1] = "Left";
        StatusBarAlignment[StatusBarAlignment["Right"] = 2] = "Right";
    })(StatusBarAlignment = exports.StatusBarAlignment || (exports.StatusBarAlignment = {}));
    var TextEditorLineNumbersStyle;
    (function (TextEditorLineNumbersStyle) {
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
        TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
    })(TextEditorLineNumbersStyle = exports.TextEditorLineNumbersStyle || (exports.TextEditorLineNumbersStyle = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
        TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
        TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var TextEditorSelectionChangeKind;
    (function (TextEditorSelectionChangeKind) {
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
        TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    /**
     * These values match very carefully the values of `TrackedRangeStickiness`
     */
    var DecorationRangeBehavior;
    (function (DecorationRangeBehavior) {
        /**
         * TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
        /**
         * TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
         */
        DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
        /**
         * TrackedRangeStickiness.GrowsOnlyWhenTypingAfter
         */
        DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
    })(DecorationRangeBehavior = exports.DecorationRangeBehavior || (exports.DecorationRangeBehavior = {}));
    (function (TextEditorSelectionChangeKind) {
        function fromValue(s) {
            switch (s) {
                case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
                case 'mouse': return TextEditorSelectionChangeKind.Mouse;
                case 'api': return TextEditorSelectionChangeKind.Command;
            }
            return undefined;
        }
        TextEditorSelectionChangeKind.fromValue = fromValue;
    })(TextEditorSelectionChangeKind = exports.TextEditorSelectionChangeKind || (exports.TextEditorSelectionChangeKind = {}));
    var DocumentLink = /** @class */ (function () {
        function DocumentLink(range, target) {
            if (target && !(target instanceof uri_1.URI)) {
                throw errors_1.illegalArgument('target');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.target = target;
        }
        return DocumentLink;
    }());
    exports.DocumentLink = DocumentLink;
    var Color = /** @class */ (function () {
        function Color(red, green, blue, alpha) {
            this.red = red;
            this.green = green;
            this.blue = blue;
            this.alpha = alpha;
        }
        return Color;
    }());
    exports.Color = Color;
    var ColorInformation = /** @class */ (function () {
        function ColorInformation(range, color) {
            if (color && !(color instanceof Color)) {
                throw errors_1.illegalArgument('color');
            }
            if (!Range.isRange(range) || range.isEmpty) {
                throw errors_1.illegalArgument('range');
            }
            this.range = range;
            this.color = color;
        }
        return ColorInformation;
    }());
    exports.ColorInformation = ColorInformation;
    var ColorPresentation = /** @class */ (function () {
        function ColorPresentation(label) {
            if (!label || typeof label !== 'string') {
                throw errors_1.illegalArgument('label');
            }
            this.label = label;
        }
        return ColorPresentation;
    }());
    exports.ColorPresentation = ColorPresentation;
    var ColorFormat;
    (function (ColorFormat) {
        ColorFormat[ColorFormat["RGB"] = 0] = "RGB";
        ColorFormat[ColorFormat["HEX"] = 1] = "HEX";
        ColorFormat[ColorFormat["HSL"] = 2] = "HSL";
    })(ColorFormat = exports.ColorFormat || (exports.ColorFormat = {}));
    var SourceControlInputBoxValidationType;
    (function (SourceControlInputBoxValidationType) {
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Error"] = 0] = "Error";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Warning"] = 1] = "Warning";
        SourceControlInputBoxValidationType[SourceControlInputBoxValidationType["Information"] = 2] = "Information";
    })(SourceControlInputBoxValidationType = exports.SourceControlInputBoxValidationType || (exports.SourceControlInputBoxValidationType = {}));
    var TaskRevealKind;
    (function (TaskRevealKind) {
        TaskRevealKind[TaskRevealKind["Always"] = 1] = "Always";
        TaskRevealKind[TaskRevealKind["Silent"] = 2] = "Silent";
        TaskRevealKind[TaskRevealKind["Never"] = 3] = "Never";
    })(TaskRevealKind = exports.TaskRevealKind || (exports.TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        TaskPanelKind[TaskPanelKind["Shared"] = 1] = "Shared";
        TaskPanelKind[TaskPanelKind["Dedicated"] = 2] = "Dedicated";
        TaskPanelKind[TaskPanelKind["New"] = 3] = "New";
    })(TaskPanelKind = exports.TaskPanelKind || (exports.TaskPanelKind = {}));
    var TaskGroup = /** @class */ (function () {
        function TaskGroup(id, _label) {
            if (typeof id !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            if (typeof _label !== 'string') {
                throw errors_1.illegalArgument('name');
            }
            this._id = id;
        }
        TaskGroup.from = function (value) {
            switch (value) {
                case 'clean':
                    return TaskGroup.Clean;
                case 'build':
                    return TaskGroup.Build;
                case 'rebuild':
                    return TaskGroup.Rebuild;
                case 'test':
                    return TaskGroup.Test;
                default:
                    return undefined;
            }
        };
        Object.defineProperty(TaskGroup.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        TaskGroup.Clean = new TaskGroup('clean', 'Clean');
        TaskGroup.Build = new TaskGroup('build', 'Build');
        TaskGroup.Rebuild = new TaskGroup('rebuild', 'Rebuild');
        TaskGroup.Test = new TaskGroup('test', 'Test');
        return TaskGroup;
    }());
    exports.TaskGroup = TaskGroup;
    var ProcessExecution = /** @class */ (function () {
        function ProcessExecution(process, varg1, varg2) {
            if (typeof process !== 'string') {
                throw errors_1.illegalArgument('process');
            }
            this._process = process;
            if (varg1 !== void 0) {
                if (Array.isArray(varg1)) {
                    this._args = varg1;
                    this._options = varg2;
                }
                else {
                    this._options = varg1;
                }
            }
            if (this._args === void 0) {
                this._args = [];
            }
        }
        Object.defineProperty(ProcessExecution.prototype, "process", {
            get: function () {
                return this._process;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('process');
                }
                this._process = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "args", {
            get: function () {
                return this._args;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    value = [];
                }
                this._args = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ProcessExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        ProcessExecution.prototype.computeId = function () {
            var hash = crypto.createHash('md5');
            hash.update('process');
            if (this._process !== void 0) {
                hash.update(this._process);
            }
            if (this._args && this._args.length > 0) {
                for (var _i = 0, _a = this._args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    hash.update(arg);
                }
            }
            return hash.digest('hex');
        };
        return ProcessExecution;
    }());
    exports.ProcessExecution = ProcessExecution;
    var ShellExecution = /** @class */ (function () {
        function ShellExecution(arg0, arg1, arg2) {
            if (Array.isArray(arg1)) {
                if (!arg0) {
                    throw errors_1.illegalArgument('command can\'t be undefined or null');
                }
                if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                    throw errors_1.illegalArgument('command');
                }
                this._command = arg0;
                this._args = arg1;
                this._options = arg2;
            }
            else {
                if (typeof arg0 !== 'string') {
                    throw errors_1.illegalArgument('commandLine');
                }
                this._commandLine = arg0;
                this._options = arg1;
            }
        }
        Object.defineProperty(ShellExecution.prototype, "commandLine", {
            get: function () {
                return this._commandLine;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('commandLine');
                }
                this._commandLine = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (value) {
                if (typeof value !== 'string' && typeof value.value !== 'string') {
                    throw errors_1.illegalArgument('command');
                }
                this._command = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "args", {
            get: function () {
                return this._args;
            },
            set: function (value) {
                this._args = value || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShellExecution.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        ShellExecution.prototype.computeId = function () {
            var hash = crypto.createHash('md5');
            hash.update('shell');
            if (this._commandLine !== void 0) {
                hash.update(this._commandLine);
            }
            if (this._command !== void 0) {
                hash.update(typeof this._command === 'string' ? this._command : this._command.value);
            }
            if (this._args && this._args.length > 0) {
                for (var _i = 0, _a = this._args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    hash.update(typeof arg === 'string' ? arg : arg.value);
                }
            }
            return hash.digest('hex');
        };
        return ShellExecution;
    }());
    exports.ShellExecution = ShellExecution;
    var ShellQuoting;
    (function (ShellQuoting) {
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
    })(TaskScope = exports.TaskScope || (exports.TaskScope = {}));
    var Task = /** @class */ (function () {
        function Task(definition, arg2, arg3, arg4, arg5, arg6) {
            this.definition = definition;
            var problemMatchers;
            if (typeof arg2 === 'string') {
                this.name = arg2;
                this.source = arg3;
                this.execution = arg4;
                problemMatchers = arg5;
            }
            else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
                this.target = arg2;
                this.name = arg3;
                this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            else {
                this.target = arg2;
                this.name = arg3;
                this.source = arg4;
                this.execution = arg5;
                problemMatchers = arg6;
            }
            if (typeof problemMatchers === 'string') {
                this._problemMatchers = [problemMatchers];
                this._hasDefinedMatchers = true;
            }
            else if (Array.isArray(problemMatchers)) {
                this._problemMatchers = problemMatchers;
                this._hasDefinedMatchers = true;
            }
            else {
                this._problemMatchers = [];
                this._hasDefinedMatchers = false;
            }
            this._isBackground = false;
        }
        Object.defineProperty(Task.prototype, "_id", {
            get: function () {
                return this.__id;
            },
            set: function (value) {
                this.__id = value;
            },
            enumerable: true,
            configurable: true
        });
        Task.prototype.clear = function () {
            if (this.__id === void 0) {
                return;
            }
            this.__id = undefined;
            this._scope = undefined;
            this._definition = undefined;
            if (this._execution instanceof ProcessExecution) {
                this._definition = {
                    type: 'process',
                    id: this._execution.computeId()
                };
            }
            else if (this._execution instanceof ShellExecution) {
                this._definition = {
                    type: 'shell',
                    id: this._execution.computeId()
                };
            }
        };
        Object.defineProperty(Task.prototype, "definition", {
            get: function () {
                return this._definition;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    throw errors_1.illegalArgument('Kind can\'t be undefined or null');
                }
                this.clear();
                this._definition = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "scope", {
            get: function () {
                return this._scope;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "target", {
            set: function (value) {
                this.clear();
                this._scope = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                if (typeof value !== 'string') {
                    throw errors_1.illegalArgument('name');
                }
                this.clear();
                this._name = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "execution", {
            get: function () {
                return this._execution;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this.clear();
                this._execution = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "problemMatchers", {
            get: function () {
                return this._problemMatchers;
            },
            set: function (value) {
                if (!Array.isArray(value)) {
                    this._problemMatchers = [];
                    this._hasDefinedMatchers = false;
                    return;
                }
                this.clear();
                this._problemMatchers = value;
                this._hasDefinedMatchers = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "hasDefinedMatchers", {
            get: function () {
                return this._hasDefinedMatchers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "isBackground", {
            get: function () {
                return this._isBackground;
            },
            set: function (value) {
                if (value !== true && value !== false) {
                    value = false;
                }
                this.clear();
                this._isBackground = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (value) {
                if (typeof value !== 'string' || value.length === 0) {
                    throw errors_1.illegalArgument('source must be a string of length > 0');
                }
                this.clear();
                this._source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "group", {
            get: function () {
                return this._group;
            },
            set: function (value) {
                if (value === void 0 || value === null) {
                    this._group = undefined;
                    return;
                }
                this.clear();
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Task.prototype, "presentationOptions", {
            get: function () {
                return this._presentationOptions;
            },
            set: function (value) {
                if (value === null) {
                    value = undefined;
                }
                this.clear();
                this._presentationOptions = value;
            },
            enumerable: true,
            configurable: true
        });
        return Task;
    }());
    exports.Task = Task;
    var ProgressLocation;
    (function (ProgressLocation) {
        ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
        ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
        ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    var TreeItem = /** @class */ (function () {
        function TreeItem(arg1, collapsibleState) {
            if (collapsibleState === void 0) { collapsibleState = TreeItemCollapsibleState.None; }
            this.collapsibleState = collapsibleState;
            if (arg1 instanceof uri_1.URI) {
                this.resourceUri = arg1;
            }
            else {
                this.label = arg1;
            }
        }
        return TreeItem;
    }());
    exports.TreeItem = TreeItem;
    var TreeItemCollapsibleState;
    (function (TreeItemCollapsibleState) {
        TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
        TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
    })(TreeItemCollapsibleState = exports.TreeItemCollapsibleState || (exports.TreeItemCollapsibleState = {}));
    var ThemeIcon = /** @class */ (function () {
        function ThemeIcon(id) {
            this.id = id;
        }
        ThemeIcon.File = new ThemeIcon('file');
        ThemeIcon.Folder = new ThemeIcon('folder');
        return ThemeIcon;
    }());
    exports.ThemeIcon = ThemeIcon;
    var ThemeColor = /** @class */ (function () {
        function ThemeColor(id) {
            this.id = id;
        }
        return ThemeColor;
    }());
    exports.ThemeColor = ThemeColor;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
        ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
        ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    var RelativePattern = /** @class */ (function () {
        function RelativePattern(base, pattern) {
            if (typeof base !== 'string') {
                if (!base || !uri_1.URI.isUri(base.uri)) {
                    throw errors_1.illegalArgument('base');
                }
            }
            if (typeof pattern !== 'string') {
                throw errors_1.illegalArgument('pattern');
            }
            if (typeof base === 'string') {
                this.base = base;
            }
            else {
                this.baseFolder = base.uri;
                this.base = base.uri.fsPath;
            }
            this.pattern = pattern;
        }
        RelativePattern.prototype.pathToRelative = function (from, to) {
            return path_1.relative(from, to);
        };
        return RelativePattern;
    }());
    exports.RelativePattern = RelativePattern;
    var Breakpoint = /** @class */ (function () {
        function Breakpoint(enabled, condition, hitCondition, logMessage) {
            this.enabled = typeof enabled === 'boolean' ? enabled : true;
            if (typeof condition === 'string') {
                this.condition = condition;
            }
            if (typeof hitCondition === 'string') {
                this.hitCondition = hitCondition;
            }
            if (typeof logMessage === 'string') {
                this.logMessage = logMessage;
            }
        }
        return Breakpoint;
    }());
    exports.Breakpoint = Breakpoint;
    var SourceBreakpoint = /** @class */ (function (_super) {
        __extends(SourceBreakpoint, _super);
        function SourceBreakpoint(location, enabled, condition, hitCondition, logMessage) {
            var _this = _super.call(this, enabled, condition, hitCondition, logMessage) || this;
            if (location === null) {
                throw errors_1.illegalArgument('location');
            }
            _this.location = location;
            return _this;
        }
        return SourceBreakpoint;
    }(Breakpoint));
    exports.SourceBreakpoint = SourceBreakpoint;
    var FunctionBreakpoint = /** @class */ (function (_super) {
        __extends(FunctionBreakpoint, _super);
        function FunctionBreakpoint(functionName, enabled, condition, hitCondition, logMessage) {
            var _this = _super.call(this, enabled, condition, hitCondition, logMessage) || this;
            if (!functionName) {
                throw errors_1.illegalArgument('functionName');
            }
            _this.functionName = functionName;
            return _this;
        }
        return FunctionBreakpoint;
    }(Breakpoint));
    exports.FunctionBreakpoint = FunctionBreakpoint;
    var DebugAdapterExecutable = /** @class */ (function () {
        function DebugAdapterExecutable(command, args, env, cwd) {
            this.type = 'executable';
            this.command = command;
            this.args = args;
            this.env = env;
            this.cwd = cwd;
        }
        return DebugAdapterExecutable;
    }());
    exports.DebugAdapterExecutable = DebugAdapterExecutable;
    var DebugAdapterServer = /** @class */ (function () {
        function DebugAdapterServer(port, host) {
            this.type = 'server';
            this.port = port;
            this.host = host;
        }
        return DebugAdapterServer;
    }());
    exports.DebugAdapterServer = DebugAdapterServer;
    var DebugAdapterImplementation = /** @class */ (function () {
        function DebugAdapterImplementation(transport) {
            this.type = 'implementation';
            this.implementation = transport;
        }
        return DebugAdapterImplementation;
    }());
    exports.DebugAdapterImplementation = DebugAdapterImplementation;
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 1] = "Trace";
        LogLevel[LogLevel["Debug"] = 2] = "Debug";
        LogLevel[LogLevel["Info"] = 3] = "Info";
        LogLevel[LogLevel["Warning"] = 4] = "Warning";
        LogLevel[LogLevel["Error"] = 5] = "Error";
        LogLevel[LogLevel["Critical"] = 6] = "Critical";
        LogLevel[LogLevel["Off"] = 7] = "Off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    //#region file api
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
        FileChangeType[FileChangeType["Created"] = 2] = "Created";
        FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileSystemError = /** @class */ (function (_super) {
        __extends(FileSystemError, _super);
        function FileSystemError(uriOrMessage, code, terminator) {
            var _this = _super.call(this, uri_1.URI.isUri(uriOrMessage) ? uriOrMessage.toString(true) : uriOrMessage) || this;
            _this.name = code ? code + " (FileSystemError)" : "FileSystemError";
            // workaround when extending builtin objects and when compiling to ES5, see:
            // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
            if (typeof Object.setPrototypeOf === 'function') {
                Object.setPrototypeOf(_this, FileSystemError.prototype);
            }
            if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
                // nice stack traces
                Error.captureStackTrace(_this, terminator);
            }
            return _this;
        }
        FileSystemError.FileExists = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryExists', FileSystemError.FileExists);
        };
        FileSystemError.FileNotFound = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryNotFound', FileSystemError.FileNotFound);
        };
        FileSystemError.FileNotADirectory = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryNotADirectory', FileSystemError.FileNotADirectory);
        };
        FileSystemError.FileIsADirectory = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'EntryIsADirectory', FileSystemError.FileIsADirectory);
        };
        FileSystemError.NoPermissions = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'NoPermissions', FileSystemError.NoPermissions);
        };
        FileSystemError.Unavailable = function (messageOrUri) {
            return new FileSystemError(messageOrUri, 'Unavailable', FileSystemError.Unavailable);
        };
        return FileSystemError;
    }(Error));
    exports.FileSystemError = FileSystemError;
    //#endregion
    //#region folding api
    var FoldingRange = /** @class */ (function () {
        function FoldingRange(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
        }
        return FoldingRange;
    }());
    exports.FoldingRange = FoldingRange;
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
        FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
        FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    //#endregion
    var CommentThreadCollapsibleState;
    (function (CommentThreadCollapsibleState) {
        /**
         * Determines an item is collapsed
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
        /**
         * Determines an item is expanded
         */
        CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
    })(CommentThreadCollapsibleState = exports.CommentThreadCollapsibleState || (exports.CommentThreadCollapsibleState = {}));
    var QuickInputButtons = /** @class */ (function () {
        function QuickInputButtons() {
        }
        QuickInputButtons.Back = { iconPath: 'back.svg' };
        return QuickInputButtons;
    }());
    exports.QuickInputButtons = QuickInputButtons;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[68/*vs/workbench/api/node/extHostDocumentData*/], __M([1/*require*/,0/*exports*/,48/*vs/base/common/assert*/,26/*vs/base/common/network*/,5/*vs/base/common/strings*/,113/*vs/editor/common/model/mirrorTextModel*/,54/*vs/editor/common/model/wordHelper*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, assert_1, network_1, strings_1, mirrorTextModel_1, wordHelper_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _modeId2WordDefinition = new Map();
    function setWordDefinitionFor(modeId, wordDefinition) {
        _modeId2WordDefinition.set(modeId, wordDefinition);
    }
    exports.setWordDefinitionFor = setWordDefinitionFor;
    function getWordDefinitionFor(modeId) {
        return _modeId2WordDefinition.get(modeId);
    }
    exports.getWordDefinitionFor = getWordDefinitionFor;
    var ExtHostDocumentData = /** @class */ (function (_super) {
        __extends(ExtHostDocumentData, _super);
        function ExtHostDocumentData(proxy, uri, lines, eol, languageId, versionId, isDirty) {
            var _this = _super.call(this, uri, lines, eol, versionId) || this;
            _this._textLines = [];
            _this._isDisposed = false;
            _this._proxy = proxy;
            _this._languageId = languageId;
            _this._isDirty = isDirty;
            return _this;
        }
        ExtHostDocumentData.prototype.dispose = function () {
            // we don't really dispose documents but let
            // extensions still read from them. some
            // operations, live saving, will now error tho
            assert_1.ok(!this._isDisposed);
            this._isDisposed = true;
            this._isDirty = false;
        };
        ExtHostDocumentData.prototype.equalLines = function (lines) {
            var len = lines.length;
            if (len !== this._lines.length) {
                return false;
            }
            for (var i = 0; i < len; i++) {
                if (lines[i] !== this._lines[i]) {
                    return false;
                }
            }
            return true;
        };
        Object.defineProperty(ExtHostDocumentData.prototype, "document", {
            get: function () {
                if (!this._document) {
                    var data_1 = this;
                    this._document = {
                        get uri() { return data_1._uri; },
                        get fileName() { return data_1._uri.fsPath; },
                        get isUntitled() { return data_1._uri.scheme === network_1.Schemas.untitled; },
                        get languageId() { return data_1._languageId; },
                        get version() { return data_1._versionId; },
                        get isClosed() { return data_1._isDisposed; },
                        get isDirty() { return data_1._isDirty; },
                        save: function () { return data_1._save(); },
                        getText: function (range) { return range ? data_1._getTextInRange(range) : data_1.getText(); },
                        get eol() { return data_1._eol === '\n' ? extHostTypes_1.EndOfLine.LF : extHostTypes_1.EndOfLine.CRLF; },
                        get lineCount() { return data_1._lines.length; },
                        lineAt: function (lineOrPos) { return data_1._lineAt(lineOrPos); },
                        offsetAt: function (pos) { return data_1._offsetAt(pos); },
                        positionAt: function (offset) { return data_1._positionAt(offset); },
                        validateRange: function (ran) { return data_1._validateRange(ran); },
                        validatePosition: function (pos) { return data_1._validatePosition(pos); },
                        getWordRangeAtPosition: function (pos, regexp) { return data_1._getWordRangeAtPosition(pos, regexp); }
                    };
                }
                return Object.freeze(this._document);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDocumentData.prototype._acceptLanguageId = function (newLanguageId) {
            assert_1.ok(!this._isDisposed);
            this._languageId = newLanguageId;
        };
        ExtHostDocumentData.prototype._acceptIsDirty = function (isDirty) {
            assert_1.ok(!this._isDisposed);
            this._isDirty = isDirty;
        };
        ExtHostDocumentData.prototype._save = function () {
            if (this._isDisposed) {
                return Promise.reject(new Error('Document has been closed'));
            }
            return this._proxy.$trySaveDocument(this._uri);
        };
        ExtHostDocumentData.prototype._getTextInRange = function (_range) {
            var range = this._validateRange(_range);
            if (range.isEmpty) {
                return '';
            }
            if (range.isSingleLine) {
                return this._lines[range.start.line].substring(range.start.character, range.end.character);
            }
            var lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.start.character));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
            return resultLines.join(lineEnding);
        };
        ExtHostDocumentData.prototype._lineAt = function (lineOrPosition) {
            var line;
            if (lineOrPosition instanceof extHostTypes_1.Position) {
                line = lineOrPosition.line;
            }
            else if (typeof lineOrPosition === 'number') {
                line = lineOrPosition;
            }
            if (line < 0 || line >= this._lines.length) {
                throw new Error('Illegal value for `line`');
            }
            var result = this._textLines[line];
            if (!result || result.lineNumber !== line || result.text !== this._lines[line]) {
                var text = this._lines[line];
                var firstNonWhitespaceCharacterIndex = /^(\s*)/.exec(text)[1].length;
                var range = new extHostTypes_1.Range(line, 0, line, text.length);
                var rangeIncludingLineBreak = line < this._lines.length - 1
                    ? new extHostTypes_1.Range(line, 0, line + 1, 0)
                    : range;
                result = Object.freeze({
                    lineNumber: line,
                    range: range,
                    rangeIncludingLineBreak: rangeIncludingLineBreak,
                    text: text,
                    firstNonWhitespaceCharacterIndex: firstNonWhitespaceCharacterIndex,
                    isEmptyOrWhitespace: firstNonWhitespaceCharacterIndex === text.length
                });
                this._textLines[line] = result;
            }
            return result;
        };
        ExtHostDocumentData.prototype._offsetAt = function (position) {
            position = this._validatePosition(position);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.line - 1) + position.character;
        };
        ExtHostDocumentData.prototype._positionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].length;
            // Ensure we return a valid position
            return new extHostTypes_1.Position(out.index, Math.min(out.remainder, lineLength));
        };
        // ---- range math
        ExtHostDocumentData.prototype._validateRange = function (range) {
            if (!(range instanceof extHostTypes_1.Range)) {
                throw new Error('Invalid argument');
            }
            var start = this._validatePosition(range.start);
            var end = this._validatePosition(range.end);
            if (start === range.start && end === range.end) {
                return range;
            }
            return new extHostTypes_1.Range(start.line, start.character, end.line, end.character);
        };
        ExtHostDocumentData.prototype._validatePosition = function (position) {
            if (!(position instanceof extHostTypes_1.Position)) {
                throw new Error('Invalid argument');
            }
            var line = position.line, character = position.character;
            var hasChanged = false;
            if (line < 0) {
                line = 0;
                character = 0;
                hasChanged = true;
            }
            else if (line >= this._lines.length) {
                line = this._lines.length - 1;
                character = this._lines[line].length;
                hasChanged = true;
            }
            else {
                var maxCharacter = this._lines[line].length;
                if (character < 0) {
                    character = 0;
                    hasChanged = true;
                }
                else if (character > maxCharacter) {
                    character = maxCharacter;
                    hasChanged = true;
                }
            }
            if (!hasChanged) {
                return position;
            }
            return new extHostTypes_1.Position(line, character);
        };
        ExtHostDocumentData.prototype._getWordRangeAtPosition = function (_position, regexp) {
            var position = this._validatePosition(_position);
            if (!regexp) {
                // use default when custom-regexp isn't provided
                regexp = getWordDefinitionFor(this._languageId);
            }
            else if (strings_1.regExpLeadsToEndlessLoop(regexp)) {
                // use default when custom-regexp is bad
                console.warn("[getWordRangeAtPosition]: ignoring custom regexp '" + regexp.source + "' because it matches the empty string.");
                regexp = getWordDefinitionFor(this._languageId);
            }
            var wordAtText = wordHelper_1.getWordAtText(position.character + 1, wordHelper_1.ensureValidWordDefinition(regexp), this._lines[position.line], 0);
            if (wordAtText) {
                return new extHostTypes_1.Range(position.line, wordAtText.startColumn - 1, position.line, wordAtText.endColumn - 1);
            }
            return undefined;
        };
        return ExtHostDocumentData;
    }(mirrorTextModel_1.MirrorTextModel));
    exports.ExtHostDocumentData = ExtHostDocumentData;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[122/*vs/workbench/common/extensionHostProtocol*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["Initialized"] = 0] = "Initialized";
        MessageType[MessageType["Ready"] = 1] = "Ready";
        MessageType[MessageType["Terminate"] = 2] = "Terminate";
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    function createMessageOfType(type) {
        var result = Buffer.allocUnsafe(1);
        switch (type) {
            case 0 /* Initialized */:
                result.writeUInt8(1, 0);
                break;
            case 1 /* Ready */:
                result.writeUInt8(2, 0);
                break;
            case 2 /* Terminate */:
                result.writeUInt8(3, 0);
                break;
        }
        return result;
    }
    exports.createMessageOfType = createMessageOfType;
    function isMessageOfType(message, type) {
        if (message.length !== 1) {
            return false;
        }
        switch (message.readUInt8(0)) {
            case 1: return type === 0 /* Initialized */;
            case 2: return type === 1 /* Ready */;
            case 3: return type === 2 /* Terminate */;
            default: return false;
        }
    }
    exports.isMessageOfType = isMessageOfType;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[77/*vs/workbench/parts/debug/common/debugUtils*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/strings*/,2/*vs/base/common/uri*/,12/*vs/base/common/paths*/]), function (require, exports, strings_1, uri_1, paths_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _formatPIIRegexp = /{([^}]+)}/g;
    function formatPII(value, excludePII, args) {
        return value.replace(_formatPIIRegexp, function (match, group) {
            if (excludePII && group.length > 0 && group[0] !== '_') {
                return match;
            }
            return args && args.hasOwnProperty(group) ?
                args[group] :
                match;
        });
    }
    exports.formatPII = formatPII;
    function isExtensionHostDebugging(config) {
        return config.type && strings_1.equalsIgnoreCase(config.type === 'vslsShare' ? config.adapterProxy.configuration.type : config.type, 'extensionhost');
    }
    exports.isExtensionHostDebugging = isExtensionHostDebugging;
    function getExactExpressionStartAndEnd(lineContent, looseStart, looseEnd) {
        var matchingExpression = undefined;
        var startOffset = 0;
        // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar
        // Match any character except a set of characters which often break interesting sub-expressions
        var expression = /([^()\[\]{}<>\s+\-/%~#^;=|,`!]|\->)+/g;
        var result = undefined;
        // First find the full expression under the cursor
        while (result = expression.exec(lineContent)) {
            var start = result.index + 1;
            var end = start + result[0].length;
            if (start <= looseStart && end >= looseEnd) {
                matchingExpression = result[0];
                startOffset = start;
                break;
            }
        }
        // If there are non-word characters after the cursor, we want to truncate the expression then.
        // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.
        if (matchingExpression) {
            var subExpression = /\w+/g;
            var subExpressionResult = undefined;
            while (subExpressionResult = subExpression.exec(matchingExpression)) {
                var subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;
                if (subEnd >= looseEnd) {
                    break;
                }
            }
            if (subExpressionResult) {
                matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);
            }
        }
        return matchingExpression ?
            { start: startOffset, end: startOffset + matchingExpression.length - 1 } :
            { start: 0, end: 0 };
    }
    exports.getExactExpressionStartAndEnd = getExactExpressionStartAndEnd;
    // RFC 2396, Appendix A: https://www.ietf.org/rfc/rfc2396.txt
    var _schemePattern = /^[a-zA-Z][a-zA-Z0-9\+\-\.]+:/;
    function isUri(s) {
        // heuristics: a valid uri starts with a scheme and
        // the scheme has at least 2 characters so that it doesn't look like a drive letter.
        return s && s.match(_schemePattern);
    }
    exports.isUri = isUri;
    function stringToUri(source) {
        if (typeof source.path === 'string') {
            if (isUri(source.path)) {
                source.path = uri_1.URI.parse(source.path);
            }
            else {
                // assume path
                if (paths_1.isAbsolute_posix(source.path) || paths_1.isAbsolute_win32(source.path)) {
                    source.path = uri_1.URI.file(source.path);
                }
                else {
                    // leave relative path as is
                }
            }
        }
    }
    exports.stringToUri = stringToUri;
    function uriToString(source) {
        if (typeof source.path === 'object') {
            var u = uri_1.URI.revive(source.path);
            if (u.scheme === 'file') {
                source.path = u.fsPath;
            }
            else {
                source.path = u.toString();
            }
        }
    }
    exports.uriToString = uriToString;
    // path hooks helpers
    function convertToDAPaths(msg, fixSourcePaths) {
        convertPaths(msg, function (toDA, source) {
            if (toDA && source) {
                fixSourcePaths(source);
            }
        });
    }
    exports.convertToDAPaths = convertToDAPaths;
    function convertToVSCPaths(msg, fixSourcePaths) {
        convertPaths(msg, function (toDA, source) {
            if (!toDA && source) {
                fixSourcePaths(source);
            }
        });
    }
    exports.convertToVSCPaths = convertToVSCPaths;
    function convertPaths(msg, fixSourcePaths) {
        switch (msg.type) {
            case 'event':
                var event_1 = msg;
                switch (event_1.event) {
                    case 'output':
                        fixSourcePaths(false, event_1.body.source);
                        break;
                    case 'loadedSource':
                        fixSourcePaths(false, event_1.body.source);
                        break;
                    case 'breakpoint':
                        fixSourcePaths(false, event_1.body.breakpoint.source);
                        break;
                    default:
                        break;
                }
                break;
            case 'request':
                var request = msg;
                switch (request.command) {
                    case 'setBreakpoints':
                        fixSourcePaths(true, request.arguments.source);
                        break;
                    case 'source':
                        fixSourcePaths(true, request.arguments.source);
                        break;
                    case 'gotoTargets':
                        fixSourcePaths(true, request.arguments.source);
                        break;
                    default:
                        break;
                }
                break;
            case 'response':
                var response = msg;
                if (response.success) {
                    switch (response.command) {
                        case 'stackTrace':
                            var r1 = response;
                            r1.body.stackFrames.forEach(function (frame) { return fixSourcePaths(false, frame.source); });
                            break;
                        case 'loadedSources':
                            var r2 = response;
                            r2.body.sources.forEach(function (source) { return fixSourcePaths(false, source); });
                            break;
                        case 'scopes':
                            var r3 = response;
                            r3.body.scopes.forEach(function (scope) { return fixSourcePaths(false, scope.source); });
                            break;
                        case 'setFunctionBreakpoints':
                            var r4 = response;
                            r4.body.breakpoints.forEach(function (bp) { return fixSourcePaths(false, bp.source); });
                            break;
                        case 'setBreakpoints':
                            var r5 = response;
                            r5.body.breakpoints.forEach(function (bp) { return fixSourcePaths(false, bp.source); });
                            break;
                        default:
                            break;
                    }
                }
                break;
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[124/*vs/workbench/parts/debug/node/debugAdapter*/], __M([1/*require*/,0/*exports*/,27/*fs*/,25/*child_process*/,90/*vs/nls!vs/workbench/parts/debug/node/debugAdapter*/,64/*net*/,12/*vs/base/common/paths*/,5/*vs/base/common/strings*/,13/*vs/base/common/objects*/,6/*vs/base/common/platform*/,3/*vs/base/common/event*/,100/*vs/platform/extensionManagement/common/extensionManagement*/]), function (require, exports, fs, cp, nls, net, paths, strings, objects, platform, event_1, extensionManagement_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Abstract implementation of the low level API for a debug adapter.
     * Missing is how this API communicates with the debug adapter.
     */
    var AbstractDebugAdapter = /** @class */ (function () {
        function AbstractDebugAdapter() {
            this.sequence = 1;
            this.pendingRequests = new Map();
            this._onError = new event_1.Emitter();
            this._onExit = new event_1.Emitter();
        }
        AbstractDebugAdapter.prototype.dispose = function () {
        };
        Object.defineProperty(AbstractDebugAdapter.prototype, "onError", {
            get: function () {
                return this._onError.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractDebugAdapter.prototype, "onExit", {
            get: function () {
                return this._onExit.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractDebugAdapter.prototype.onMessage = function (callback) {
            if (this.eventCallback) {
                this._onError.fire(new Error("attempt to set more than one 'Message' callback"));
            }
            this.messageCallback = callback;
        };
        AbstractDebugAdapter.prototype.onEvent = function (callback) {
            if (this.eventCallback) {
                this._onError.fire(new Error("attempt to set more than one 'Event' callback"));
            }
            this.eventCallback = callback;
        };
        AbstractDebugAdapter.prototype.onRequest = function (callback) {
            if (this.requestCallback) {
                this._onError.fire(new Error("attempt to set more than one 'Request' callback"));
            }
            this.requestCallback = callback;
        };
        AbstractDebugAdapter.prototype.sendResponse = function (response) {
            if (response.seq > 0) {
                this._onError.fire(new Error("attempt to send more than one response for command " + response.command));
            }
            else {
                this.internalSend('response', response);
            }
        };
        AbstractDebugAdapter.prototype.sendRequest = function (command, args, clb, timeout) {
            var _this = this;
            var request = {
                command: command
            };
            if (args && Object.keys(args).length > 0) {
                request.arguments = args;
            }
            this.internalSend('request', request);
            if (typeof timeout === 'number') {
                var timer_1 = setTimeout(function () {
                    clearTimeout(timer_1);
                    var clb = _this.pendingRequests.get(request.seq);
                    if (clb) {
                        _this.pendingRequests.delete(request.seq);
                        var err = {
                            type: 'response',
                            seq: 0,
                            request_seq: request.seq,
                            success: false,
                            command: command,
                            message: "timeout after " + timeout + " ms"
                        };
                        clb(err);
                    }
                }, timeout);
            }
            if (clb) {
                // store callback for this request
                this.pendingRequests.set(request.seq, clb);
            }
        };
        AbstractDebugAdapter.prototype.acceptMessage = function (message) {
            if (this.messageCallback) {
                this.messageCallback(message);
            }
            else {
                switch (message.type) {
                    case 'event':
                        if (this.eventCallback) {
                            this.eventCallback(message);
                        }
                        break;
                    case 'request':
                        if (this.requestCallback) {
                            this.requestCallback(message);
                        }
                        break;
                    case 'response':
                        var response = message;
                        var clb = this.pendingRequests.get(response.request_seq);
                        if (clb) {
                            this.pendingRequests.delete(response.request_seq);
                            clb(response);
                        }
                        break;
                }
            }
        };
        AbstractDebugAdapter.prototype.internalSend = function (typ, message) {
            message.type = typ;
            message.seq = this.sequence++;
            this.sendMessage(message);
        };
        AbstractDebugAdapter.prototype.cancelPending = function () {
            var pending = this.pendingRequests;
            this.pendingRequests = new Map();
            setTimeout(function (_) {
                pending.forEach(function (callback, request_seq) {
                    var err = {
                        type: 'response',
                        seq: 0,
                        request_seq: request_seq,
                        success: false,
                        command: 'canceled',
                        message: 'canceled'
                    };
                    callback(err);
                });
            }, 1000);
        };
        return AbstractDebugAdapter;
    }());
    exports.AbstractDebugAdapter = AbstractDebugAdapter;
    /**
     * An implementation that communicates via two streams with the debug adapter.
     */
    var StreamDebugAdapter = /** @class */ (function (_super) {
        __extends(StreamDebugAdapter, _super);
        function StreamDebugAdapter() {
            return _super.call(this) || this;
        }
        StreamDebugAdapter.prototype.connect = function (readable, writable) {
            var _this = this;
            this.outputStream = writable;
            this.rawData = Buffer.allocUnsafe(0);
            this.contentLength = -1;
            readable.on('data', function (data) { return _this.handleData(data); });
        };
        StreamDebugAdapter.prototype.sendMessage = function (message) {
            if (this.outputStream) {
                var json = JSON.stringify(message);
                this.outputStream.write("Content-Length: " + Buffer.byteLength(json, 'utf8') + StreamDebugAdapter.TWO_CRLF + json, 'utf8');
            }
        };
        StreamDebugAdapter.prototype.handleData = function (data) {
            this.rawData = Buffer.concat([this.rawData, data]);
            while (true) {
                if (this.contentLength >= 0) {
                    if (this.rawData.length >= this.contentLength) {
                        var message = this.rawData.toString('utf8', 0, this.contentLength);
                        this.rawData = this.rawData.slice(this.contentLength);
                        this.contentLength = -1;
                        if (message.length > 0) {
                            try {
                                this.acceptMessage(JSON.parse(message));
                            }
                            catch (e) {
                                this._onError.fire(new Error((e.message || e) + '\n' + message));
                            }
                        }
                        continue; // there may be more complete messages to process
                    }
                }
                else {
                    var idx = this.rawData.indexOf(StreamDebugAdapter.TWO_CRLF);
                    if (idx !== -1) {
                        var header = this.rawData.toString('utf8', 0, idx);
                        var lines = header.split(StreamDebugAdapter.HEADER_LINESEPARATOR);
                        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                            var h = lines_1[_i];
                            var kvPair = h.split(StreamDebugAdapter.HEADER_FIELDSEPARATOR);
                            if (kvPair[0] === 'Content-Length') {
                                this.contentLength = Number(kvPair[1]);
                            }
                        }
                        this.rawData = this.rawData.slice(idx + StreamDebugAdapter.TWO_CRLF.length);
                        continue;
                    }
                }
                break;
            }
        };
        StreamDebugAdapter.TWO_CRLF = '\r\n\r\n';
        StreamDebugAdapter.HEADER_LINESEPARATOR = /\r?\n/; // allow for non-RFC 2822 conforming line separators
        StreamDebugAdapter.HEADER_FIELDSEPARATOR = /: */;
        return StreamDebugAdapter;
    }(AbstractDebugAdapter));
    exports.StreamDebugAdapter = StreamDebugAdapter;
    /**
     * An implementation that connects to a debug adapter via a socket.
    */
    var SocketDebugAdapter = /** @class */ (function (_super) {
        __extends(SocketDebugAdapter, _super);
        function SocketDebugAdapter(adapterServer) {
            var _this = _super.call(this) || this;
            _this.adapterServer = adapterServer;
            return _this;
        }
        SocketDebugAdapter.prototype.startSession = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var connected = false;
                _this.socket = net.createConnection(_this.adapterServer.port, _this.adapterServer.host || '127.0.0.1', function () {
                    _this.connect(_this.socket, _this.socket);
                    resolve(null);
                    connected = true;
                });
                _this.socket.on('close', function () {
                    if (connected) {
                        _this._onError.fire(new Error('connection closed'));
                    }
                    else {
                        reject(new Error('connection closed'));
                    }
                });
                _this.socket.on('error', function (error) {
                    if (connected) {
                        _this._onError.fire(error);
                    }
                    else {
                        reject(error);
                    }
                });
            });
        };
        SocketDebugAdapter.prototype.stopSession = function () {
            // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.
            this.cancelPending();
            if (this.socket) {
                this.socket.end();
                this.socket = undefined;
            }
            return Promise.resolve(undefined);
        };
        return SocketDebugAdapter;
    }(StreamDebugAdapter));
    exports.SocketDebugAdapter = SocketDebugAdapter;
    /**
     * An implementation that launches the debug adapter as a separate process and communicates via stdin/stdout.
    */
    var ExecutableDebugAdapter = /** @class */ (function (_super) {
        __extends(ExecutableDebugAdapter, _super);
        function ExecutableDebugAdapter(adapterExecutable, debugType, outputService) {
            var _this = _super.call(this) || this;
            _this.adapterExecutable = adapterExecutable;
            _this.debugType = debugType;
            _this.outputService = outputService;
            return _this;
        }
        ExecutableDebugAdapter.prototype.startSession = function () {
            var _this = this;
            return new Promise(function (resolve, reject) {
                // verify executables
                if (_this.adapterExecutable.command) {
                    if (paths.isAbsolute(_this.adapterExecutable.command)) {
                        if (!fs.existsSync(_this.adapterExecutable.command)) {
                            reject(new Error(nls.localize(0, null, _this.adapterExecutable.command)));
                        }
                    }
                    else {
                        // relative path
                        if (_this.adapterExecutable.command.indexOf('/') < 0 && _this.adapterExecutable.command.indexOf('\\') < 0) {
                            // no separators: command looks like a runtime name like 'node' or 'mono'
                            // TODO: check that the runtime is available on PATH
                        }
                    }
                }
                else {
                    reject(new Error(nls.localize(1, null, _this.debugType)));
                }
                if (_this.adapterExecutable.command === 'node') {
                    if (Array.isArray(_this.adapterExecutable.args) && _this.adapterExecutable.args.length > 0) {
                        var isElectron = !!process.env['ELECTRON_RUN_AS_NODE'] || !!process.versions['electron'];
                        var options = {
                            env: _this.adapterExecutable.env
                                ? objects.mixin(objects.mixin({}, process.env), _this.adapterExecutable.env)
                                : process.env,
                            execArgv: isElectron ? ['-e', 'delete process.env.ELECTRON_RUN_AS_NODE;require(process.argv[1])'] : [],
                            silent: true
                        };
                        if (_this.adapterExecutable.cwd) {
                            options.cwd = _this.adapterExecutable.cwd;
                        }
                        var child = cp.fork(_this.adapterExecutable.args[0], _this.adapterExecutable.args.slice(1), options);
                        if (!child.pid) {
                            reject(new Error(nls.localize(2, null, _this.adapterExecutable.args[0])));
                        }
                        _this.serverProcess = child;
                        resolve(null);
                    }
                    else {
                        reject(new Error(nls.localize(3, null)));
                    }
                }
                else {
                    var options = {
                        env: _this.adapterExecutable.env
                            ? objects.mixin(objects.mixin({}, process.env), _this.adapterExecutable.env)
                            : process.env
                    };
                    if (_this.adapterExecutable.cwd) {
                        options.cwd = _this.adapterExecutable.cwd;
                    }
                    _this.serverProcess = cp.spawn(_this.adapterExecutable.command, _this.adapterExecutable.args, options);
                    resolve(null);
                }
            }).then(function (_) {
                _this.serverProcess.on('error', function (err) {
                    _this._onError.fire(err);
                });
                _this.serverProcess.on('exit', function (code, signal) {
                    _this._onExit.fire(code);
                });
                _this.serverProcess.stdout.on('close', function () {
                    _this._onError.fire(new Error('read error'));
                });
                _this.serverProcess.stdout.on('error', function (error) {
                    _this._onError.fire(error);
                });
                _this.serverProcess.stdin.on('error', function (error) {
                    _this._onError.fire(error);
                });
                if (_this.outputService) {
                    var sanitize_1 = function (s) { return s.toString().replace(/\r?\n$/mg, ''); };
                    // this.serverProcess.stdout.on('data', (data: string) => {
                    // 	console.log('%c' + sanitize(data), 'background: #ddd; font-style: italic;');
                    // });
                    _this.serverProcess.stderr.on('data', function (data) {
                        _this.outputService.getChannel(extensionManagement_1.ExtensionsChannelId).append(sanitize_1(data));
                    });
                }
                _this.connect(_this.serverProcess.stdout, _this.serverProcess.stdin);
            }, function (err) {
                _this._onError.fire(err);
            });
        };
        ExecutableDebugAdapter.prototype.stopSession = function () {
            var _this = this;
            // Cancel all sent promises on disconnect so debug trees are not left in a broken state #3666.
            this.cancelPending();
            if (!this.serverProcess) {
                return Promise.resolve(null);
            }
            // when killing a process in windows its child
            // processes are *not* killed but become root
            // processes. Therefore we use TASKKILL.EXE
            if (platform.isWindows) {
                return new Promise(function (c, e) {
                    var killer = cp.exec("taskkill /F /T /PID " + _this.serverProcess.pid, function (err, stdout, stderr) {
                        if (err) {
                            return e(err);
                        }
                    });
                    killer.on('exit', c);
                    killer.on('error', e);
                });
            }
            else {
                this.serverProcess.kill('SIGTERM');
                return Promise.resolve(null);
            }
        };
        ExecutableDebugAdapter.extract = function (contribution, extensionFolderPath) {
            if (!contribution) {
                return undefined;
            }
            var result = Object.create(null);
            if (contribution.runtime) {
                if (contribution.runtime.indexOf('./') === 0) { // TODO
                    result.runtime = paths.join(extensionFolderPath, contribution.runtime);
                }
                else {
                    result.runtime = contribution.runtime;
                }
            }
            if (contribution.runtimeArgs) {
                result.runtimeArgs = contribution.runtimeArgs;
            }
            if (contribution.program) {
                if (!paths.isAbsolute(contribution.program)) {
                    result.program = paths.join(extensionFolderPath, contribution.program);
                }
                else {
                    result.program = contribution.program;
                }
            }
            if (contribution.args) {
                result.args = contribution.args;
            }
            if (contribution.win) {
                result.win = ExecutableDebugAdapter.extract(contribution.win, extensionFolderPath);
            }
            if (contribution.winx86) {
                result.winx86 = ExecutableDebugAdapter.extract(contribution.winx86, extensionFolderPath);
            }
            if (contribution.windows) {
                result.windows = ExecutableDebugAdapter.extract(contribution.windows, extensionFolderPath);
            }
            if (contribution.osx) {
                result.osx = ExecutableDebugAdapter.extract(contribution.osx, extensionFolderPath);
            }
            if (contribution.linux) {
                result.linux = ExecutableDebugAdapter.extract(contribution.linux, extensionFolderPath);
            }
            return result;
        };
        ExecutableDebugAdapter.platformAdapterExecutable = function (extensionDescriptions, debugType) {
            var result = Object.create(null);
            debugType = debugType.toLowerCase();
            var _loop_1 = function (ed) {
                if (ed.contributes) {
                    var debuggers = ed.contributes['debuggers'];
                    if (debuggers && debuggers.length > 0) {
                        debuggers.filter(function (dbg) { return strings.equalsIgnoreCase(dbg.type, debugType); }).forEach(function (dbg) {
                            // extract relevant attributes and make then absolute where needed
                            var extractedDbg = ExecutableDebugAdapter.extract(dbg, ed.extensionLocation.fsPath);
                            // merge
                            objects.mixin(result, extractedDbg, ed.isBuiltin);
                        });
                    }
                }
            };
            // merge all contributions into one
            for (var _i = 0, extensionDescriptions_1 = extensionDescriptions; _i < extensionDescriptions_1.length; _i++) {
                var ed = extensionDescriptions_1[_i];
                _loop_1(ed);
            }
            // select the right platform
            var platformInfo;
            if (platform.isWindows && !process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {
                platformInfo = result.winx86 || result.win || result.windows;
            }
            else if (platform.isWindows) {
                platformInfo = result.win || result.windows;
            }
            else if (platform.isMacintosh) {
                platformInfo = result.osx;
            }
            else if (platform.isLinux) {
                platformInfo = result.linux;
            }
            platformInfo = platformInfo || result;
            // these are the relevant attributes
            var program = platformInfo.program || result.program;
            var args = platformInfo.args || result.args;
            var runtime = platformInfo.runtime || result.runtime;
            var runtimeArgs = platformInfo.runtimeArgs || result.runtimeArgs;
            if (runtime) {
                return {
                    type: 'executable',
                    command: runtime,
                    args: (runtimeArgs || []).concat([program]).concat(args || [])
                };
            }
            else {
                return {
                    type: 'executable',
                    command: program,
                    args: args || []
                };
            }
        };
        return ExecutableDebugAdapter;
    }(StreamDebugAdapter));
    exports.ExecutableDebugAdapter = ExecutableDebugAdapter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[125/*vs/workbench/parts/debug/node/terminals*/], __M([1/*require*/,0/*exports*/,25/*child_process*/,91/*vs/nls!vs/workbench/parts/debug/node/terminals*/,6/*vs/base/common/platform*/,47/*vs/base/node/pfs*/,13/*vs/base/common/objects*/,20/*vs/base/common/winjs.base*/,28/*vs/base/common/amd*/]), function (require, exports, cp, nls, env, pfs, objects_1, winjs_base_1, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TERMINAL_TITLE = nls.localize(0, null);
    var terminalLauncher = undefined;
    function getTerminalLauncher() {
        if (!terminalLauncher) {
            if (env.isWindows) {
                terminalLauncher = new WinTerminalService();
            }
            else if (env.isMacintosh) {
                terminalLauncher = new MacTerminalService();
            }
            else if (env.isLinux) {
                terminalLauncher = new LinuxTerminalService();
            }
        }
        return terminalLauncher;
    }
    exports.getTerminalLauncher = getTerminalLauncher;
    var _DEFAULT_TERMINAL_LINUX_READY = null;
    function getDefaultTerminalLinuxReady() {
        if (!_DEFAULT_TERMINAL_LINUX_READY) {
            _DEFAULT_TERMINAL_LINUX_READY = new Promise(function (c) {
                if (env.isLinux) {
                    winjs_base_1.TPromise.join([pfs.exists('/etc/debian_version'), process.lazyEnv]).then(function (_a) {
                        var isDebian = _a[0];
                        if (isDebian) {
                            c('x-terminal-emulator');
                        }
                        else if (process.env.DESKTOP_SESSION === 'gnome' || process.env.DESKTOP_SESSION === 'gnome-classic') {
                            c('gnome-terminal');
                        }
                        else if (process.env.DESKTOP_SESSION === 'kde-plasma') {
                            c('konsole');
                        }
                        else if (process.env.COLORTERM) {
                            c(process.env.COLORTERM);
                        }
                        else if (process.env.TERM) {
                            c(process.env.TERM);
                        }
                        else {
                            c('xterm');
                        }
                    });
                    return;
                }
                c('xterm');
            });
        }
        return _DEFAULT_TERMINAL_LINUX_READY;
    }
    exports.getDefaultTerminalLinuxReady = getDefaultTerminalLinuxReady;
    var _DEFAULT_TERMINAL_WINDOWS = null;
    function getDefaultTerminalWindows() {
        if (!_DEFAULT_TERMINAL_WINDOWS) {
            var isWoW64 = !!process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432');
            _DEFAULT_TERMINAL_WINDOWS = (process.env.windir ? process.env.windir : 'C:\\Windows') + "\\" + (isWoW64 ? 'Sysnative' : 'System32') + "\\cmd.exe";
        }
        return _DEFAULT_TERMINAL_WINDOWS;
    }
    exports.getDefaultTerminalWindows = getDefaultTerminalWindows;
    var TerminalLauncher = /** @class */ (function () {
        function TerminalLauncher() {
        }
        TerminalLauncher.prototype.runInTerminal = function (args, config) {
            return this.runInTerminal0(args.title, args.cwd, args.args, args.env || {}, config);
        };
        TerminalLauncher.prototype.runInTerminal0 = function (title, dir, args, envVars, config) {
            return void 0;
        };
        return TerminalLauncher;
    }());
    var WinTerminalService = /** @class */ (function (_super) {
        __extends(WinTerminalService, _super);
        function WinTerminalService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WinTerminalService.prototype.runInTerminal0 = function (title, dir, args, envVars, configuration) {
            var exec = configuration.external.windowsExec || getDefaultTerminalWindows();
            return new Promise(function (c, e) {
                var title = "\"" + dir + " - " + TERMINAL_TITLE + "\"";
                var command = "\"\"" + args.join('" "') + "\" & pause\""; // use '|' to only pause on non-zero exit code
                var cmdArgs = [
                    '/c', 'start', title, '/wait', exec, '/c', command
                ];
                // merge environment variables into a copy of the process.env
                var env = objects_1.assign({}, process.env, envVars);
                // delete environment variables that have a null value
                Object.keys(env).filter(function (v) { return env[v] === null; }).forEach(function (key) { return delete env[key]; });
                var options = {
                    cwd: dir,
                    env: env,
                    windowsVerbatimArguments: true
                };
                var cmd = cp.spawn(WinTerminalService.CMD, cmdArgs, options);
                cmd.on('error', e);
                c(null);
            });
        };
        WinTerminalService.CMD = 'cmd.exe';
        return WinTerminalService;
    }(TerminalLauncher));
    var MacTerminalService = /** @class */ (function (_super) {
        __extends(MacTerminalService, _super);
        function MacTerminalService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MacTerminalService.prototype.runInTerminal0 = function (title, dir, args, envVars, configuration) {
            var terminalApp = configuration.external.osxExec || MacTerminalService.DEFAULT_TERMINAL_OSX;
            return new Promise(function (c, e) {
                if (terminalApp === MacTerminalService.DEFAULT_TERMINAL_OSX || terminalApp === 'iTerm.app') {
                    // On OS X we launch an AppleScript that creates (or reuses) a Terminal window
                    // and then launches the program inside that window.
                    var script_1 = terminalApp === MacTerminalService.DEFAULT_TERMINAL_OSX ? 'TerminalHelper' : 'iTermHelper';
                    var scriptpath = amd_1.getPathFromAmdModule(require, "vs/workbench/parts/execution/electron-browser/" + script_1 + ".scpt");
                    var osaArgs = [
                        scriptpath,
                        '-t', title || TERMINAL_TITLE,
                        '-w', dir,
                    ];
                    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
                        var a = args_1[_i];
                        osaArgs.push('-a');
                        osaArgs.push(a);
                    }
                    if (envVars) {
                        for (var key in envVars) {
                            var value = envVars[key];
                            if (value === null) {
                                osaArgs.push('-u');
                                osaArgs.push(key);
                            }
                            else {
                                osaArgs.push('-e');
                                osaArgs.push(key + "=" + value);
                            }
                        }
                    }
                    var stderr_1 = '';
                    var osa = cp.spawn(MacTerminalService.OSASCRIPT, osaArgs);
                    osa.on('error', e);
                    osa.stderr.on('data', function (data) {
                        stderr_1 += data.toString();
                    });
                    osa.on('exit', function (code) {
                        if (code === 0) { // OK
                            c(null);
                        }
                        else {
                            if (stderr_1) {
                                var lines = stderr_1.split('\n', 1);
                                e(new Error(lines[0]));
                            }
                            else {
                                e(new Error(nls.localize(1, null, script_1, code)));
                            }
                        }
                    });
                }
                else {
                    e(new Error(nls.localize(2, null, terminalApp)));
                }
            });
        };
        MacTerminalService.DEFAULT_TERMINAL_OSX = 'Terminal.app';
        MacTerminalService.OSASCRIPT = '/usr/bin/osascript'; // osascript is the AppleScript interpreter on OS X
        return MacTerminalService;
    }(TerminalLauncher));
    var LinuxTerminalService = /** @class */ (function (_super) {
        __extends(LinuxTerminalService, _super);
        function LinuxTerminalService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LinuxTerminalService.prototype.runInTerminal0 = function (title, dir, args, envVars, configuration) {
            var terminalConfig = configuration.external;
            var execThenable = terminalConfig.linuxExec ? Promise.resolve(terminalConfig.linuxExec) : getDefaultTerminalLinuxReady();
            return new Promise(function (c, e) {
                var termArgs = [];
                //termArgs.push('--title');
                //termArgs.push(`"${TERMINAL_TITLE}"`);
                execThenable.then(function (exec) {
                    if (exec.indexOf('gnome-terminal') >= 0) {
                        termArgs.push('-x');
                    }
                    else {
                        termArgs.push('-e');
                    }
                    termArgs.push('bash');
                    termArgs.push('-c');
                    var bashCommand = quote(args) + "; echo; read -p \"" + LinuxTerminalService.WAIT_MESSAGE + "\" -n1;";
                    termArgs.push("''" + bashCommand + "''"); // wrapping argument in two sets of ' because node is so "friendly" that it removes one set...
                    // merge environment variables into a copy of the process.env
                    var env = objects_1.assign({}, process.env, envVars);
                    // delete environment variables that have a null value
                    Object.keys(env).filter(function (v) { return env[v] === null; }).forEach(function (key) { return delete env[key]; });
                    var options = {
                        cwd: dir,
                        env: env
                    };
                    var stderr = '';
                    var cmd = cp.spawn(exec, termArgs, options);
                    cmd.on('error', e);
                    cmd.stderr.on('data', function (data) {
                        stderr += data.toString();
                    });
                    cmd.on('exit', function (code) {
                        if (code === 0) { // OK
                            c(null);
                        }
                        else {
                            if (stderr) {
                                var lines = stderr.split('\n', 1);
                                e(new Error(lines[0]));
                            }
                            else {
                                e(new Error(nls.localize(4, null, exec, code)));
                            }
                        }
                    });
                });
            });
        };
        LinuxTerminalService.WAIT_MESSAGE = nls.localize(3, null);
        return LinuxTerminalService;
    }(TerminalLauncher));
    /**
     * Quote args if necessary and combine into a space separated string.
     */
    function quote(args) {
        var r = '';
        for (var _i = 0, args_2 = args; _i < args_2.length; _i++) {
            var a = args_2[_i];
            if (a.indexOf(' ') >= 0) {
                r += '"' + a + '"';
            }
            else {
                r += a;
            }
            r += ' ';
        }
        return r;
    }
    function hasChildprocesses(processId) {
        if (processId) {
            try {
                // if shell has at least one child process, assume that shell is busy
                if (env.isWindows) {
                    var result = cp.spawnSync('wmic', ['process', 'get', 'ParentProcessId']);
                    if (result.stdout) {
                        var pids = result.stdout.toString().split('\r\n');
                        if (!pids.some(function (p) { return parseInt(p) === processId; })) {
                            return false;
                        }
                    }
                }
                else {
                    var result = cp.spawnSync('/usr/bin/pgrep', ['-lP', String(processId)]);
                    if (result.stdout) {
                        var r = result.stdout.toString().trim();
                        if (r.length === 0 || r.indexOf(' tmux') >= 0) { // ignore 'tmux'; see #43683
                            return false;
                        }
                    }
                }
            }
            catch (e) {
                // silently ignore
            }
        }
        // fall back to safe side
        return true;
    }
    exports.hasChildprocesses = hasChildprocesses;
    var ShellType;
    (function (ShellType) {
        ShellType[ShellType["cmd"] = 0] = "cmd";
        ShellType[ShellType["powershell"] = 1] = "powershell";
        ShellType[ShellType["bash"] = 2] = "bash";
    })(ShellType || (ShellType = {}));
    function prepareCommand(args, config) {
        var shellType;
        // get the shell configuration for the current platform
        var shell;
        var shell_config = config.integrated.shell;
        if (env.isWindows) {
            shell = shell_config.windows;
            shellType = 0 /* cmd */;
        }
        else if (env.isLinux) {
            shell = shell_config.linux;
            shellType = 2 /* bash */;
        }
        else if (env.isMacintosh) {
            shell = shell_config.osx;
            shellType = 2 /* bash */;
        }
        // try to determine the shell type
        shell = shell.trim().toLowerCase();
        if (shell.indexOf('powershell') >= 0 || shell.indexOf('pwsh') >= 0) {
            shellType = 1 /* powershell */;
        }
        else if (shell.indexOf('cmd.exe') >= 0) {
            shellType = 0 /* cmd */;
        }
        else if (shell.indexOf('bash') >= 0) {
            shellType = 2 /* bash */;
        }
        else if (shell.indexOf('git\\bin\\bash.exe') >= 0) {
            shellType = 2 /* bash */;
        }
        var quote;
        var command = '';
        switch (shellType) {
            case 1 /* powershell */:
                quote = function (s) {
                    s = s.replace(/\'/g, '\'\'');
                    return "'" + s + "'";
                    //return s.indexOf(' ') >= 0 || s.indexOf('\'') >= 0 || s.indexOf('"') >= 0 ? `'${s}'` : s;
                };
                if (args.cwd) {
                    command += "cd '" + args.cwd + "'; ";
                }
                if (args.env) {
                    for (var key in args.env) {
                        var value = args.env[key];
                        if (value === null) {
                            command += "Remove-Item env:" + key + "; ";
                        }
                        else {
                            command += "${env:" + key + "}='" + value + "'; ";
                        }
                    }
                }
                if (args.args && args.args.length > 0) {
                    var cmd = quote(args.args.shift());
                    command += (cmd[0] === '\'') ? "& " + cmd + " " : cmd + " ";
                    for (var _i = 0, _a = args.args; _i < _a.length; _i++) {
                        var a = _a[_i];
                        command += quote(a) + " ";
                    }
                }
                break;
            case 0 /* cmd */:
                quote = function (s) {
                    s = s.replace(/\"/g, '""');
                    return (s.indexOf(' ') >= 0 || s.indexOf('"') >= 0) ? "\"" + s + "\"" : s;
                };
                if (args.cwd) {
                    command += "cd " + quote(args.cwd) + " && ";
                }
                if (args.env) {
                    command += 'cmd /C "';
                    for (var key in args.env) {
                        var value = args.env[key];
                        if (value === null) {
                            command += "set \"" + key + "=\" && ";
                        }
                        else {
                            value = value.replace(/[\^\&]/g, function (s) { return "^" + s; });
                            command += "set \"" + key + "=" + value + "\" && ";
                        }
                    }
                }
                for (var _b = 0, _c = args.args; _b < _c.length; _b++) {
                    var a = _c[_b];
                    command += quote(a) + " ";
                }
                if (args.env) {
                    command += '"';
                }
                break;
            case 2 /* bash */:
                quote = function (s) {
                    s = s.replace(/\"/g, '\\"');
                    return (s.indexOf(' ') >= 0 || s.indexOf('\\') >= 0) ? "\"" + s + "\"" : s;
                };
                if (args.cwd) {
                    command += "cd " + quote(args.cwd) + " ; ";
                }
                if (args.env) {
                    command += 'env';
                    for (var key in args.env) {
                        var value = args.env[key];
                        if (value === null) {
                            command += " -u \"" + key + "\"";
                        }
                        else {
                            command += " \"" + key + "=" + value + "\"";
                        }
                    }
                    command += ' ';
                }
                for (var _d = 0, _e = args.args; _d < _e.length; _d++) {
                    var a = _e[_d];
                    command += quote(a) + " ";
                }
                break;
        }
        return command;
    }
    exports.prepareCommand = prepareCommand;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[121/*vs/workbench/parts/tasks/common/tasks*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/types*/,13/*vs/base/common/objects*/,59/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, Types, Objects, contextkey_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TASK_RUNNING_STATE = new contextkey_1.RawContextKey('taskRunning', false);
    var ShellQuoting;
    (function (ShellQuoting) {
        /**
         * Use character escaping.
         */
        ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
        /**
         * Use strong quoting
         */
        ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
        /**
         * Use weak quoting.
         */
        ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    (function (ShellQuoting) {
        function from(value) {
            if (!value) {
                return ShellQuoting.Strong;
            }
            switch (value.toLowerCase()) {
                case 'escape':
                    return ShellQuoting.Escape;
                case 'strong':
                    return ShellQuoting.Strong;
                case 'weak':
                    return ShellQuoting.Weak;
                default:
                    return ShellQuoting.Strong;
            }
        }
        ShellQuoting.from = from;
    })(ShellQuoting = exports.ShellQuoting || (exports.ShellQuoting = {}));
    var RevealKind;
    (function (RevealKind) {
        /**
         * Always brings the terminal to front if the task is executed.
         */
        RevealKind[RevealKind["Always"] = 1] = "Always";
        /**
         * Only brings the terminal to front if a problem is detected executing the task
         * (e.g. the task couldn't be started because).
         */
        RevealKind[RevealKind["Silent"] = 2] = "Silent";
        /**
         * The terminal never comes to front when the task is executed.
         */
        RevealKind[RevealKind["Never"] = 3] = "Never";
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    (function (RevealKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'always':
                    return RevealKind.Always;
                case 'silent':
                    return RevealKind.Silent;
                case 'never':
                    return RevealKind.Never;
                default:
                    return RevealKind.Always;
            }
        }
        RevealKind.fromString = fromString;
    })(RevealKind = exports.RevealKind || (exports.RevealKind = {}));
    var PanelKind;
    (function (PanelKind) {
        /**
         * Shares a panel with other tasks. This is the default.
         */
        PanelKind[PanelKind["Shared"] = 1] = "Shared";
        /**
         * Uses a dedicated panel for this tasks. The panel is not
         * shared with other tasks.
         */
        PanelKind[PanelKind["Dedicated"] = 2] = "Dedicated";
        /**
         * Creates a new panel whenever this task is executed.
         */
        PanelKind[PanelKind["New"] = 3] = "New";
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    (function (PanelKind) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shared':
                    return PanelKind.Shared;
                case 'dedicated':
                    return PanelKind.Dedicated;
                case 'new':
                    return PanelKind.New;
                default:
                    return PanelKind.Shared;
            }
        }
        PanelKind.fromString = fromString;
    })(PanelKind = exports.PanelKind || (exports.PanelKind = {}));
    var RuntimeType;
    (function (RuntimeType) {
        RuntimeType[RuntimeType["Shell"] = 1] = "Shell";
        RuntimeType[RuntimeType["Process"] = 2] = "Process";
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    (function (RuntimeType) {
        function fromString(value) {
            switch (value.toLowerCase()) {
                case 'shell':
                    return RuntimeType.Shell;
                case 'process':
                    return RuntimeType.Process;
                default:
                    return RuntimeType.Process;
            }
        }
        RuntimeType.fromString = fromString;
    })(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
    var CommandString;
    (function (CommandString) {
        function value(value) {
            if (Types.isString(value)) {
                return value;
            }
            else {
                return value.value;
            }
        }
        CommandString.value = value;
    })(CommandString = exports.CommandString || (exports.CommandString = {}));
    var TaskGroup;
    (function (TaskGroup) {
        TaskGroup.Clean = 'clean';
        TaskGroup.Build = 'build';
        TaskGroup.Rebuild = 'rebuild';
        TaskGroup.Test = 'test';
        function is(value) {
            return value === TaskGroup.Clean || value === TaskGroup.Build || value === TaskGroup.Rebuild || value === TaskGroup.Test;
        }
        TaskGroup.is = is;
    })(TaskGroup = exports.TaskGroup || (exports.TaskGroup = {}));
    var TaskScope;
    (function (TaskScope) {
        TaskScope[TaskScope["Global"] = 1] = "Global";
        TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
        TaskScope[TaskScope["Folder"] = 3] = "Folder";
    })(TaskScope = exports.TaskScope || (exports.TaskScope = {}));
    var TaskSourceKind;
    (function (TaskSourceKind) {
        TaskSourceKind.Workspace = 'workspace';
        TaskSourceKind.Extension = 'extension';
        TaskSourceKind.InMemory = 'inMemory';
    })(TaskSourceKind = exports.TaskSourceKind || (exports.TaskSourceKind = {}));
    var GroupType;
    (function (GroupType) {
        GroupType["default"] = "default";
        GroupType["user"] = "user";
    })(GroupType = exports.GroupType || (exports.GroupType = {}));
    var CustomTask;
    (function (CustomTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.type === 'custom';
        }
        CustomTask.is = is;
        function getDefinition(task) {
            var type;
            if (task.command !== void 0) {
                type = task.command.runtime === RuntimeType.Shell ? 'shell' : 'process';
            }
            else {
                type = '$composite';
            }
            var result = {
                type: type,
                _key: task._id,
                id: task._id
            };
            return result;
        }
        CustomTask.getDefinition = getDefinition;
        function customizes(task) {
            if (task._source && task._source.customizes) {
                return task._source.customizes;
            }
            return undefined;
        }
        CustomTask.customizes = customizes;
    })(CustomTask = exports.CustomTask || (exports.CustomTask = {}));
    var ConfiguringTask;
    (function (ConfiguringTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.configures && Types.isString(candidate.configures.type) && value.command === void 0;
        }
        ConfiguringTask.is = is;
    })(ConfiguringTask = exports.ConfiguringTask || (exports.ConfiguringTask = {}));
    var ContributedTask;
    (function (ContributedTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate.defines && Types.isString(candidate.defines.type) && candidate.command !== void 0;
        }
        ContributedTask.is = is;
    })(ContributedTask = exports.ContributedTask || (exports.ContributedTask = {}));
    var InMemoryTask;
    (function (InMemoryTask) {
        function is(value) {
            var candidate = value;
            return candidate && candidate._source && candidate._source.kind === TaskSourceKind.InMemory;
        }
        InMemoryTask.is = is;
    })(InMemoryTask = exports.InMemoryTask || (exports.InMemoryTask = {}));
    var Task;
    (function (Task) {
        function getRecentlyUsedKey(task) {
            if (InMemoryTask.is(task)) {
                return undefined;
            }
            if (CustomTask.is(task)) {
                var workspaceFolder = task._source.config.workspaceFolder;
                if (!workspaceFolder) {
                    return undefined;
                }
                var key = { type: 'custom', folder: workspaceFolder.uri.toString(), id: task.identifier };
                return JSON.stringify(key);
            }
            if (ContributedTask.is(task)) {
                var key = { type: 'contributed', scope: task._source.scope, id: task._id };
                if (task._source.scope === 3 /* Folder */ && task._source.workspaceFolder) {
                    key.folder = task._source.workspaceFolder.uri.toString();
                }
                return JSON.stringify(key);
            }
            return undefined;
        }
        Task.getRecentlyUsedKey = getRecentlyUsedKey;
        function getMapKey(task) {
            if (CustomTask.is(task)) {
                var workspaceFolder = task._source.config.workspaceFolder;
                return workspaceFolder ? workspaceFolder.uri.toString() + "|" + task._id : task._id;
            }
            else if (ContributedTask.is(task)) {
                var workspaceFolder = task._source.workspaceFolder;
                return workspaceFolder
                    ? task._source.scope.toString() + "|" + workspaceFolder.uri.toString() + "|" + task._id
                    : task._source.scope.toString() + "|" + task._id;
            }
            else {
                return task._id;
            }
        }
        Task.getMapKey = getMapKey;
        function getWorkspaceFolder(task) {
            if (CustomTask.is(task)) {
                return task._source.config.workspaceFolder;
            }
            else if (ContributedTask.is(task)) {
                return task._source.workspaceFolder;
            }
            else {
                return undefined;
            }
        }
        Task.getWorkspaceFolder = getWorkspaceFolder;
        function clone(task) {
            return Objects.assign({}, task);
        }
        Task.clone = clone;
        function getTelemetryKind(task) {
            if (ContributedTask.is(task)) {
                return 'extension';
            }
            else if (CustomTask.is(task)) {
                if (task._source.customizes) {
                    return 'workspace>extension';
                }
                else {
                    return 'workspace';
                }
            }
            else if (InMemoryTask.is(task)) {
                return 'composite';
            }
            else {
                return 'unknown';
            }
        }
        Task.getTelemetryKind = getTelemetryKind;
        function matches(task, key, compareId) {
            if (compareId === void 0) { compareId = false; }
            if (key === void 0) {
                return false;
            }
            if (Types.isString(key)) {
                return key === task._label || key === task.identifier || (compareId && key === task._id);
            }
            var identifier = Task.getTaskDefinition(task, true);
            return identifier !== void 0 && identifier._key === key._key;
        }
        Task.matches = matches;
        function getQualifiedLabel(task) {
            var workspaceFolder = getWorkspaceFolder(task);
            if (workspaceFolder) {
                return task._label + " (" + workspaceFolder.name + ")";
            }
            else {
                return task._label;
            }
        }
        Task.getQualifiedLabel = getQualifiedLabel;
        function getTaskDefinition(task, useSource) {
            if (useSource === void 0) { useSource = false; }
            if (ContributedTask.is(task)) {
                return task.defines;
            }
            else if (CustomTask.is(task)) {
                if (useSource && task._source.customizes !== void 0) {
                    return task._source.customizes;
                }
                else {
                    return CustomTask.getDefinition(task);
                }
            }
            else {
                return undefined;
            }
        }
        Task.getTaskDefinition = getTaskDefinition;
        function getTaskExecution(task) {
            var result = {
                id: task._id,
                task: task
            };
            return result;
        }
        Task.getTaskExecution = getTaskExecution;
    })(Task = exports.Task || (exports.Task = {}));
    var ExecutionEngine;
    (function (ExecutionEngine) {
        ExecutionEngine[ExecutionEngine["Process"] = 1] = "Process";
        ExecutionEngine[ExecutionEngine["Terminal"] = 2] = "Terminal";
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    (function (ExecutionEngine) {
        ExecutionEngine._default = ExecutionEngine.Terminal;
    })(ExecutionEngine = exports.ExecutionEngine || (exports.ExecutionEngine = {}));
    var JsonSchemaVersion;
    (function (JsonSchemaVersion) {
        JsonSchemaVersion[JsonSchemaVersion["V0_1_0"] = 1] = "V0_1_0";
        JsonSchemaVersion[JsonSchemaVersion["V2_0_0"] = 2] = "V2_0_0";
    })(JsonSchemaVersion = exports.JsonSchemaVersion || (exports.JsonSchemaVersion = {}));
    var TaskSorter = /** @class */ (function () {
        function TaskSorter(workspaceFolders) {
            this._order = new Map();
            for (var i = 0; i < workspaceFolders.length; i++) {
                this._order.set(workspaceFolders[i].uri.toString(), i);
            }
        }
        TaskSorter.prototype.compare = function (a, b) {
            var aw = Task.getWorkspaceFolder(a);
            var bw = Task.getWorkspaceFolder(b);
            if (aw && bw) {
                var ai = this._order.get(aw.uri.toString());
                ai = ai === void 0 ? 0 : ai + 1;
                var bi = this._order.get(bw.uri.toString());
                bi = bi === void 0 ? 0 : bi + 1;
                if (ai === bi) {
                    return a._label.localeCompare(b._label);
                }
                else {
                    return ai - bi;
                }
            }
            else if (!aw && bw) {
                return -1;
            }
            else if (aw && !bw) {
                return +1;
            }
            else {
                return 0;
            }
        };
        return TaskSorter;
    }());
    exports.TaskSorter = TaskSorter;
    var TaskEventKind;
    (function (TaskEventKind) {
        TaskEventKind["Start"] = "start";
        TaskEventKind["ProcessStarted"] = "processStarted";
        TaskEventKind["Active"] = "active";
        TaskEventKind["Inactive"] = "inactive";
        TaskEventKind["Changed"] = "changed";
        TaskEventKind["Terminated"] = "terminated";
        TaskEventKind["ProcessEnded"] = "processEnded";
        TaskEventKind["End"] = "end";
    })(TaskEventKind = exports.TaskEventKind || (exports.TaskEventKind = {}));
    var TaskRunType;
    (function (TaskRunType) {
        TaskRunType["SingleRun"] = "singleRun";
        TaskRunType["Background"] = "background";
    })(TaskRunType = exports.TaskRunType || (exports.TaskRunType = {}));
    var TaskEvent;
    (function (TaskEvent) {
        function create(kind, task, processIdOrExitCode) {
            if (task) {
                var result = {
                    kind: kind,
                    taskId: task._id,
                    taskName: task.name,
                    runType: task.isBackground ? "background" /* Background */ : "singleRun" /* SingleRun */,
                    group: task.group,
                    processId: undefined,
                    exitCode: undefined,
                    __task: task,
                };
                if (kind === "processStarted" /* ProcessStarted */) {
                    result.processId = processIdOrExitCode;
                }
                else if (kind === "processEnded" /* ProcessEnded */) {
                    result.exitCode = processIdOrExitCode;
                }
                return Object.freeze(result);
            }
            else {
                return Object.freeze({ kind: "changed" /* Changed */ });
            }
        }
        TaskEvent.create = create;
    })(TaskEvent = exports.TaskEvent || (exports.TaskEvent = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[126/*vs/workbench/parts/terminal/common/terminal*/], __M([1/*require*/,0/*exports*/,59/*vs/platform/contextkey/common/contextkey*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, contextkey_1, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TERMINAL_PANEL_ID = 'workbench.panel.terminal';
    exports.TERMINAL_SERVICE_ID = 'terminalService';
    /** A context key that is set when there is at least one opened integrated terminal. */
    exports.KEYBINDING_CONTEXT_TERMINAL_IS_OPEN = new contextkey_1.RawContextKey('terminalIsOpen', false);
    /** A context key that is set when the integrated terminal has focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS = new contextkey_1.RawContextKey('terminalFocus', false);
    /** A context key that is set when the integrated terminal does not have focus. */
    exports.KEYBINDING_CONTEXT_TERMINAL_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FOCUS.toNegated();
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED = new contextkey_1.RawContextKey('terminalTextSelected', false);
    /** A keybinding context key that is set when the integrated terminal does not have text selected. */
    exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_NOT_SELECTED = exports.KEYBINDING_CONTEXT_TERMINAL_TEXT_SELECTED.toNegated();
    /**  A context key that is set when the find widget in integrated terminal is visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('terminalFindWidgetVisible', false);
    /**  A context key that is set when the find widget in integrated terminal is not visible. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_NOT_VISIBLE = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_VISIBLE.toNegated();
    /**  A context key that is set when the find widget find input in integrated terminal is focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetInputFocused', false);
    /**  A context key that is set when the find widget in integrated terminal is focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_FOCUSED = new contextkey_1.RawContextKey('terminalFindWidgetFocused', false);
    /**  A context key that is set when the find widget find input in integrated terminal is not focused. */
    exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_NOT_FOCUSED = exports.KEYBINDING_CONTEXT_TERMINAL_FIND_WIDGET_INPUT_FOCUSED.toNegated();
    exports.IS_WORKSPACE_SHELL_ALLOWED_STORAGE_KEY = 'terminal.integrated.isWorkspaceShellAllowed';
    exports.NEVER_SUGGEST_SELECT_WINDOWS_SHELL_STORAGE_KEY = 'terminal.integrated.neverSuggestSelectWindowsShell';
    exports.NEVER_MEASURE_RENDER_TIME_STORAGE_KEY = 'terminal.integrated.neverMeasureRenderTime';
    // The creation of extension host terminals is delayed by this value (milliseconds). The purpose of
    // this delay is to allow the terminal instance to initialize correctly and have its ID set before
    // trying to create the corressponding object on the ext host.
    exports.EXT_HOST_CREATION_DELAY = 100;
    exports.ITerminalService = instantiation_1.createDecorator(exports.TERMINAL_SERVICE_ID);
    exports.TerminalCursorStyle = {
        BLOCK: 'block',
        LINE: 'line',
        UNDERLINE: 'underline'
    };
    exports.TERMINAL_CONFIG_SECTION = 'terminal.integrated';
    exports.DEFAULT_LETTER_SPACING = 0;
    exports.MINIMUM_LETTER_SPACING = -5;
    exports.DEFAULT_LINE_HEIGHT = 1.0;
    var Direction;
    (function (Direction) {
        Direction[Direction["Left"] = 0] = "Left";
        Direction[Direction["Right"] = 1] = "Right";
        Direction[Direction["Up"] = 2] = "Up";
        Direction[Direction["Down"] = 3] = "Down";
    })(Direction = exports.Direction || (exports.Direction = {}));
    var ProcessState;
    (function (ProcessState) {
        // The process has not been initialized yet.
        ProcessState[ProcessState["UNINITIALIZED"] = 0] = "UNINITIALIZED";
        // The process is currently launching, the process is marked as launching
        // for a short duration after being created and is helpful to indicate
        // whether the process died as a result of bad shell and args.
        ProcessState[ProcessState["LAUNCHING"] = 1] = "LAUNCHING";
        // The process is running normally.
        ProcessState[ProcessState["RUNNING"] = 2] = "RUNNING";
        // The process was killed during launch, likely as a result of bad shell and
        // args.
        ProcessState[ProcessState["KILLED_DURING_LAUNCH"] = 3] = "KILLED_DURING_LAUNCH";
        // The process was killed by the user (the event originated from VS Code).
        ProcessState[ProcessState["KILLED_BY_USER"] = 4] = "KILLED_BY_USER";
        // The process was killed by itself, for example the shell crashed or `exit`
        // was run.
        ProcessState[ProcessState["KILLED_BY_PROCESS"] = 5] = "KILLED_BY_PROCESS";
    })(ProcessState = exports.ProcessState || (exports.ProcessState = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[127/*vs/workbench/parts/terminal/node/terminalEnvironment*/], __M([1/*require*/,0/*exports*/,30/*os*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,63/*vs/platform/node/package*/]), function (require, exports, os, paths, platform, package_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This module contains utility functions related to the environment, cwd and paths.
     */
    function mergeEnvironments(parent, other) {
        if (!other) {
            return;
        }
        // On Windows apply the new values ignoring case, while still retaining
        // the case of the original key.
        if (platform.isWindows) {
            for (var configKey in other) {
                var actualKey = configKey;
                for (var envKey in parent) {
                    if (configKey.toLowerCase() === envKey.toLowerCase()) {
                        actualKey = envKey;
                        break;
                    }
                }
                var value = other[configKey];
                _mergeEnvironmentValue(parent, actualKey, value);
            }
        }
        else {
            Object.keys(other).forEach(function (key) {
                var value = other[key];
                _mergeEnvironmentValue(parent, key, value);
            });
        }
    }
    exports.mergeEnvironments = mergeEnvironments;
    function _mergeEnvironmentValue(env, key, value) {
        if (typeof value === 'string') {
            env[key] = value;
        }
        else {
            delete env[key];
        }
    }
    function sanitizeEnvironment(env) {
        // Remove keys based on strings
        var keysToRemove = [
            'ELECTRON_ENABLE_STACK_DUMPING',
            'ELECTRON_ENABLE_LOGGING',
            'ELECTRON_NO_ASAR',
            'ELECTRON_NO_ATTACH_CONSOLE',
            'ELECTRON_RUN_AS_NODE',
            'GOOGLE_API_KEY',
            'VSCODE_CLI',
            'VSCODE_DEV',
            'VSCODE_IPC_HOOK',
            'VSCODE_LOGS',
            'VSCODE_NLS_CONFIG',
            'VSCODE_PORTABLE',
            'VSCODE_PID',
            'VSCODE_NODE_CACHED_DATA_DIR'
        ];
        keysToRemove.forEach(function (key) {
            if (env[key]) {
                delete env[key];
            }
        });
    }
    exports.sanitizeEnvironment = sanitizeEnvironment;
    function addTerminalEnvironmentKeys(env, locale) {
        env['TERM_PROGRAM'] = 'vscode';
        env['TERM_PROGRAM_VERSION'] = package_1.default.version;
        env['LANG'] = _getLangEnvVariable(locale);
    }
    exports.addTerminalEnvironmentKeys = addTerminalEnvironmentKeys;
    function resolveConfigurationVariables(configurationResolverService, env, lastActiveWorkspaceRoot) {
        Object.keys(env).forEach(function (key) {
            if (typeof env[key] === 'string') {
                env[key] = configurationResolverService.resolve(lastActiveWorkspaceRoot, env[key]);
            }
        });
        return env;
    }
    exports.resolveConfigurationVariables = resolveConfigurationVariables;
    function _getLangEnvVariable(locale) {
        var parts = locale ? locale.split('-') : [];
        var n = parts.length;
        if (n === 0) {
            // Fallback to en_US to prevent possible encoding issues.
            return 'en_US.UTF-8';
        }
        if (n === 1) {
            // app.getLocale can return just a language without a variant, fill in the variant for
            // supported languages as many shells expect a 2-part locale.
            var languageVariants = {
                de: 'DE',
                en: 'US',
                es: 'ES',
                fi: 'FI',
                fr: 'FR',
                it: 'IT',
                ja: 'JP',
                ko: 'KR',
                pl: 'PL',
                ru: 'RU',
                zh: 'CN'
            };
            if (parts[0] in languageVariants) {
                parts.push(languageVariants[parts[0]]);
            }
        }
        else {
            // Ensure the variant is uppercase
            parts[1] = parts[1].toUpperCase();
        }
        return parts.join('_') + '.UTF-8';
    }
    function getCwd(shell, root, configHelper) {
        if (shell.cwd) {
            return shell.cwd;
        }
        var cwd;
        // TODO: Handle non-existent customCwd
        if (!shell.ignoreConfigurationCwd) {
            // Evaluate custom cwd first
            var customCwd = configHelper.config.cwd;
            if (customCwd) {
                if (paths.isAbsolute(customCwd)) {
                    cwd = customCwd;
                }
                else if (root) {
                    cwd = paths.normalize(paths.join(root.fsPath, customCwd));
                }
            }
        }
        // If there was no custom cwd or it was relative with no workspace
        if (!cwd) {
            cwd = root ? root.fsPath : os.homedir();
        }
        return _sanitizeCwd(cwd);
    }
    exports.getCwd = getCwd;
    function _sanitizeCwd(cwd) {
        // Make the drive letter uppercase on Windows (see #9448)
        if (platform.platform === 3 /* Windows */ && cwd && cwd[1] === ':') {
            return cwd[0].toUpperCase() + cwd.substr(1);
        }
        return cwd;
    }
    /**
     * Adds quotes to a path if it contains whitespaces
     */
    function preparePathForTerminal(path) {
        if (platform.isWindows) {
            if (/\s+/.test(path)) {
                return "\"" + path + "\"";
            }
            return path;
        }
        path = path.replace(/(%5C|\\)/g, '\\\\');
        var charsToEscape = [
            ' ', '\'', '"', '?', ':', ';', '!', '*', '(', ')', '{', '}', '[', ']'
        ];
        for (var i = 0; i < path.length; i++) {
            var indexOfChar = charsToEscape.indexOf(path.charAt(i));
            if (indexOfChar >= 0) {
                path = path.substring(0, i) + "\\" + path.charAt(i) + path.substring(i + 1);
                i++; // Skip char due to escape char being added
            }
        }
        return path;
    }
    exports.preparePathForTerminal = preparePathForTerminal;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[128/*vs/workbench/parts/terminal/node/terminalProcess*/], __M([1/*require*/,0/*exports*/,30/*os*/,10/*path*/,201/*node-pty*/,3/*vs/base/common/event*/]), function (require, exports, os, path, pty, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TerminalProcess = /** @class */ (function () {
        function TerminalProcess(shellLaunchConfig, cwd, cols, rows, env) {
            var _this = this;
            this._currentTitle = '';
            this._onProcessData = new event_1.Emitter();
            this._onProcessExit = new event_1.Emitter();
            this._onProcessIdReady = new event_1.Emitter();
            this._onProcessTitleChanged = new event_1.Emitter();
            var shellName;
            if (os.platform() === 'win32') {
                shellName = path.basename(shellLaunchConfig.executable);
            }
            else {
                // Using 'xterm-256color' here helps ensure that the majority of Linux distributions will use a
                // color prompt as defined in the default ~/.bashrc file.
                shellName = 'xterm-256color';
            }
            var options = {
                name: shellName,
                cwd: cwd,
                env: env,
                cols: cols,
                rows: rows
            };
            try {
                this._ptyProcess = pty.spawn(shellLaunchConfig.executable, shellLaunchConfig.args, options);
                this._processStartupComplete = new Promise(function (c) {
                    _this.onProcessIdReady(function (pid) {
                        c();
                    });
                });
            }
            catch (error) {
                // The only time this is expected to happen is when the file specified to launch with does not exist.
                this._exitCode = 2;
                this._queueProcessExit();
                this._processStartupComplete = Promise.resolve(void 0);
                return;
            }
            this._ptyProcess.on('data', function (data) {
                _this._onProcessData.fire(data);
                if (_this._closeTimeout) {
                    clearTimeout(_this._closeTimeout);
                    _this._queueProcessExit();
                }
            });
            this._ptyProcess.on('exit', function (code) {
                _this._exitCode = code;
                _this._queueProcessExit();
            });
            // TODO: We should no longer need to delay this since pty.spawn is sync
            setTimeout(function () {
                _this._sendProcessId();
            }, 500);
            this._setupTitlePolling();
        }
        Object.defineProperty(TerminalProcess.prototype, "onProcessData", {
            get: function () { return this._onProcessData.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessExit", {
            get: function () { return this._onProcessExit.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessIdReady", {
            get: function () { return this._onProcessIdReady.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerminalProcess.prototype, "onProcessTitleChanged", {
            get: function () { return this._onProcessTitleChanged.event; },
            enumerable: true,
            configurable: true
        });
        TerminalProcess.prototype.dispose = function () {
            this._onProcessData.dispose();
            this._onProcessExit.dispose();
            this._onProcessIdReady.dispose();
            this._onProcessTitleChanged.dispose();
        };
        TerminalProcess.prototype._setupTitlePolling = function () {
            var _this = this;
            // Send initial timeout async to give event listeners a chance to init
            setTimeout(function () {
                _this._sendProcessTitle();
            }, 0);
            // Setup polling
            setInterval(function () {
                if (_this._currentTitle !== _this._ptyProcess.process) {
                    _this._sendProcessTitle();
                }
            }, 200);
        };
        // Allow any trailing data events to be sent before the exit event is sent.
        // See https://github.com/Tyriar/node-pty/issues/72
        TerminalProcess.prototype._queueProcessExit = function () {
            var _this = this;
            if (this._closeTimeout) {
                clearTimeout(this._closeTimeout);
            }
            this._closeTimeout = setTimeout(function () { return _this._kill(); }, 250);
        };
        TerminalProcess.prototype._kill = function () {
            var _this = this;
            // Wait to kill to process until the start up code has run. This prevents us from firing a process exit before a
            // process start.
            this._processStartupComplete.then(function () {
                // Attempt to kill the pty, it may have already been killed at this
                // point but we want to make sure
                try {
                    _this._ptyProcess.kill();
                }
                catch (ex) {
                    // Swallow, the pty has already been killed
                }
                _this._onProcessExit.fire(_this._exitCode);
                _this.dispose();
            });
        };
        TerminalProcess.prototype._sendProcessId = function () {
            this._onProcessIdReady.fire(this._ptyProcess.pid);
        };
        TerminalProcess.prototype._sendProcessTitle = function () {
            this._currentTitle = this._ptyProcess.process;
            this._onProcessTitleChanged.fire(this._currentTitle);
        };
        TerminalProcess.prototype.shutdown = function (immediate) {
            if (immediate) {
                this._kill();
            }
            else {
                this._queueProcessExit();
            }
        };
        TerminalProcess.prototype.input = function (data) {
            this._ptyProcess.write(data);
        };
        TerminalProcess.prototype.resize = function (cols, rows) {
            // Ensure that cols and rows are always >= 1, this prevents a native
            // exception in winpty.
            this._ptyProcess.resize(Math.max(cols, 1), Math.max(rows, 1));
        };
        return TerminalProcess;
    }());
    exports.TerminalProcess = TerminalProcess;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[129/*vs/workbench/services/configuration/common/configurationModels*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/objects*/,65/*vs/platform/configuration/common/configuration*/,66/*vs/platform/configuration/common/configurationModels*/,37/*vs/platform/registry/common/platform*/,34/*vs/platform/configuration/common/configurationRegistry*/,22/*vs/base/common/map*/]), function (require, exports, objects_1, configuration_1, configurationModels_1, platform_1, configurationRegistry_1, map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkspaceConfigurationModelParser = /** @class */ (function (_super) {
        __extends(WorkspaceConfigurationModelParser, _super);
        function WorkspaceConfigurationModelParser(name) {
            var _this = _super.call(this, name) || this;
            _this._folders = [];
            _this._settingsModelParser = new FolderSettingsModelParser(name, [2 /* WINDOW */, 3 /* RESOURCE */]);
            _this._launchModel = new configurationModels_1.ConfigurationModel();
            return _this;
        }
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "folders", {
            get: function () {
                return this._folders;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "settingsModel", {
            get: function () {
                return this._settingsModelParser.configurationModel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationModelParser.prototype, "launchModel", {
            get: function () {
                return this._launchModel;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceConfigurationModelParser.prototype.reprocessWorkspaceSettings = function () {
            this._settingsModelParser.reprocess();
        };
        WorkspaceConfigurationModelParser.prototype.parseRaw = function (raw) {
            this._folders = (raw['folders'] || []);
            this._settingsModelParser.parse(raw['settings']);
            this._launchModel = this.createConfigurationModelFrom(raw, 'launch');
            return _super.prototype.parseRaw.call(this, raw);
        };
        WorkspaceConfigurationModelParser.prototype.createConfigurationModelFrom = function (raw, key) {
            var _this = this;
            var data = raw[key];
            if (data) {
                var contents = configuration_1.toValuesTree(data, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
                var scopedContents = Object.create(null);
                scopedContents[key] = contents;
                var keys = Object.keys(data).map(function (k) { return key + "." + k; });
                return new configurationModels_1.ConfigurationModel(scopedContents, keys, []);
            }
            return new configurationModels_1.ConfigurationModel();
        };
        return WorkspaceConfigurationModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.WorkspaceConfigurationModelParser = WorkspaceConfigurationModelParser;
    var StandaloneConfigurationModelParser = /** @class */ (function (_super) {
        __extends(StandaloneConfigurationModelParser, _super);
        function StandaloneConfigurationModelParser(name, scope) {
            var _this = _super.call(this, name) || this;
            _this.scope = scope;
            return _this;
        }
        StandaloneConfigurationModelParser.prototype.parseRaw = function (raw) {
            var _this = this;
            var contents = configuration_1.toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            var scopedContents = Object.create(null);
            scopedContents[this.scope] = contents;
            var keys = Object.keys(raw).map(function (key) { return _this.scope + "." + key; });
            return { contents: scopedContents, keys: keys, overrides: [] };
        };
        return StandaloneConfigurationModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.StandaloneConfigurationModelParser = StandaloneConfigurationModelParser;
    var FolderSettingsModelParser = /** @class */ (function (_super) {
        __extends(FolderSettingsModelParser, _super);
        function FolderSettingsModelParser(name, scopes) {
            var _this = _super.call(this, name) || this;
            _this.scopes = scopes;
            return _this;
        }
        FolderSettingsModelParser.prototype.parse = function (content) {
            this._raw = typeof content === 'string' ? this.parseContent(content) : content;
            this.parseWorkspaceSettings(this._raw);
        };
        Object.defineProperty(FolderSettingsModelParser.prototype, "configurationModel", {
            get: function () {
                return this._settingsModel || new configurationModels_1.ConfigurationModel();
            },
            enumerable: true,
            configurable: true
        });
        FolderSettingsModelParser.prototype.reprocess = function () {
            this.parse(this._raw);
        };
        FolderSettingsModelParser.prototype.parseWorkspaceSettings = function (rawSettings) {
            var configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
            var rawWorkspaceSettings = this.filterByScope(rawSettings, configurationProperties, true);
            var configurationModel = this.parseRaw(rawWorkspaceSettings);
            this._settingsModel = new configurationModels_1.ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
        };
        FolderSettingsModelParser.prototype.filterByScope = function (properties, configurationProperties, filterOverriddenProperties) {
            var result = {};
            for (var key in properties) {
                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) && filterOverriddenProperties) {
                    result[key] = this.filterByScope(properties[key], configurationProperties, false);
                }
                else {
                    var scope = this.getScope(key, configurationProperties);
                    if (this.scopes.indexOf(scope) !== -1) {
                        result[key] = properties[key];
                    }
                }
            }
            return result;
        };
        FolderSettingsModelParser.prototype.getScope = function (key, configurationProperties) {
            var propertySchema = configurationProperties[key];
            return propertySchema && typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : 2 /* WINDOW */;
        };
        return FolderSettingsModelParser;
    }(configurationModels_1.ConfigurationModelParser));
    exports.FolderSettingsModelParser = FolderSettingsModelParser;
    var Configuration = /** @class */ (function (_super) {
        __extends(Configuration, _super);
        function Configuration(defaults, user, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource, _workspace) {
            var _this = _super.call(this, defaults, user, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource) || this;
            _this._workspace = _workspace;
            return _this;
        }
        Configuration.prototype.getValue = function (key, overrides) {
            if (overrides === void 0) { overrides = {}; }
            return _super.prototype.getValue.call(this, key, overrides, this._workspace);
        };
        Configuration.prototype.inspect = function (key, overrides) {
            if (overrides === void 0) { overrides = {}; }
            return _super.prototype.inspect.call(this, key, overrides, this._workspace);
        };
        Configuration.prototype.keys = function () {
            return _super.prototype.keys.call(this, this._workspace);
        };
        Configuration.prototype.compareAndUpdateUserConfiguration = function (user) {
            var _a = configuration_1.compare(this.user, user), added = _a.added, updated = _a.updated, removed = _a.removed;
            var changedKeys = added.concat(updated, removed);
            if (changedKeys.length) {
                _super.prototype.updateUserConfiguration.call(this, user);
            }
            return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys);
        };
        Configuration.prototype.compareAndUpdateWorkspaceConfiguration = function (workspaceConfiguration) {
            var _a = configuration_1.compare(this.workspace, workspaceConfiguration), added = _a.added, updated = _a.updated, removed = _a.removed;
            var changedKeys = added.concat(updated, removed);
            if (changedKeys.length) {
                _super.prototype.updateWorkspaceConfiguration.call(this, workspaceConfiguration);
            }
            return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys);
        };
        Configuration.prototype.compareAndUpdateFolderConfiguration = function (resource, folderConfiguration) {
            var currentFolderConfiguration = this.folders.get(resource);
            if (currentFolderConfiguration) {
                var _a = configuration_1.compare(currentFolderConfiguration, folderConfiguration), added = _a.added, updated = _a.updated, removed = _a.removed;
                var changedKeys = added.concat(updated, removed);
                if (changedKeys.length) {
                    _super.prototype.updateFolderConfiguration.call(this, resource, folderConfiguration);
                }
                return new configurationModels_1.ConfigurationChangeEvent().change(changedKeys, resource);
            }
            else {
                _super.prototype.updateFolderConfiguration.call(this, resource, folderConfiguration);
                return new configurationModels_1.ConfigurationChangeEvent().change(folderConfiguration.keys, resource);
            }
        };
        Configuration.prototype.compareAndDeleteFolderConfiguration = function (folder) {
            if (this._workspace && this._workspace.folders.length > 0 && this._workspace.folders[0].uri.toString() === folder.toString()) {
                // Do not remove workspace configuration
                return new configurationModels_1.ConfigurationChangeEvent();
            }
            var keys = this.folders.get(folder).keys;
            _super.prototype.deleteFolderConfiguration.call(this, folder);
            return new configurationModels_1.ConfigurationChangeEvent().change(keys, folder);
        };
        Configuration.prototype.compare = function (other) {
            var _this = this;
            var result = [];
            var _loop_1 = function (key) {
                if (!objects_1.equals(this_1.getValue(key), other.getValue(key))
                    || (this_1._workspace && this_1._workspace.folders.some(function (folder) { return !objects_1.equals(_this.getValue(key, { resource: folder.uri }), other.getValue(key, { resource: folder.uri })); }))) {
                    result.push(key);
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = this.allKeys(); _i < _a.length; _i++) {
                var key = _a[_i];
                _loop_1(key);
            }
            return result;
        };
        Configuration.prototype.allKeys = function () {
            return _super.prototype.allKeys.call(this, this._workspace);
        };
        return Configuration;
    }(configurationModels_1.Configuration));
    exports.Configuration = Configuration;
    var AllKeysConfigurationChangeEvent = /** @class */ (function (_super) {
        __extends(AllKeysConfigurationChangeEvent, _super);
        function AllKeysConfigurationChangeEvent(_configuration, source, sourceConfig) {
            var _this = _super.call(this) || this;
            _this._configuration = _configuration;
            _this.source = source;
            _this.sourceConfig = sourceConfig;
            _this._changedConfiguration = null;
            return _this;
        }
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                if (!this._changedConfiguration) {
                    this._changedConfiguration = new configurationModels_1.ConfigurationModel();
                    this.updateKeys(this._changedConfiguration, this.affectedKeys);
                }
                return this._changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return new map_1.ResourceMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AllKeysConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                return this._configuration.allKeys();
            },
            enumerable: true,
            configurable: true
        });
        AllKeysConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            return this.doesConfigurationContains(this.changedConfiguration, config);
        };
        return AllKeysConfigurationChangeEvent;
    }(configurationModels_1.AbstractConfigurationChangeEvent));
    exports.AllKeysConfigurationChangeEvent = AllKeysConfigurationChangeEvent;
    var WorkspaceConfigurationChangeEvent = /** @class */ (function () {
        function WorkspaceConfigurationChangeEvent(configurationChangeEvent, workspace) {
            this.configurationChangeEvent = configurationChangeEvent;
            this.workspace = workspace;
        }
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                return this.configurationChangeEvent.changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return this.configurationChangeEvent.changedConfigurationByResource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                return this.configurationChangeEvent.affectedKeys;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "source", {
            get: function () {
                return this.configurationChangeEvent.source;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspaceConfigurationChangeEvent.prototype, "sourceConfig", {
            get: function () {
                return this.configurationChangeEvent.sourceConfig;
            },
            enumerable: true,
            configurable: true
        });
        WorkspaceConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            if (this.configurationChangeEvent.affectsConfiguration(config, resource)) {
                return true;
            }
            if (resource && this.workspace) {
                var workspaceFolder = this.workspace.getFolder(resource);
                if (workspaceFolder) {
                    return this.configurationChangeEvent.affectsConfiguration(config, workspaceFolder.uri);
                }
            }
            return false;
        };
        return WorkspaceConfigurationChangeEvent;
    }());
    exports.WorkspaceConfigurationChangeEvent = WorkspaceConfigurationChangeEvent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[130/*vs/workbench/api/node/extHostConfiguration*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/objects*/,2/*vs/base/common/uri*/,3/*vs/base/common/event*/,7/*vs/workbench/api/node/extHostTypes*/,66/*vs/platform/configuration/common/configurationModels*/,129/*vs/workbench/services/configuration/common/configurationModels*/,22/*vs/base/common/map*/,34/*vs/platform/configuration/common/configurationRegistry*/,18/*vs/base/common/types*/]), function (require, exports, objects_1, uri_1, event_1, extHostTypes_1, configurationModels_1, configurationModels_2, map_1, configurationRegistry_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lookUp(tree, key) {
        if (key) {
            var parts = key.split('.');
            var node = tree;
            for (var i = 0; node && i < parts.length; i++) {
                node = node[parts[i]];
            }
            return node;
        }
    }
    var ExtHostConfiguration = /** @class */ (function () {
        function ExtHostConfiguration(proxy, extHostWorkspace, data) {
            this._onDidChangeConfiguration = new event_1.Emitter();
            this._proxy = proxy;
            this._extHostWorkspace = extHostWorkspace;
            this._configuration = ExtHostConfiguration.parse(data);
            this._configurationScopes = data.configurationScopes;
        }
        Object.defineProperty(ExtHostConfiguration.prototype, "onDidChangeConfiguration", {
            get: function () {
                return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostConfiguration.prototype.$acceptConfigurationChanged = function (data, eventData) {
            this._configuration = ExtHostConfiguration.parse(data);
            this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(eventData));
        };
        ExtHostConfiguration.prototype.getConfiguration = function (section, resource, extensionId) {
            var _this = this;
            var config = this._toReadonlyValue(section
                ? lookUp(this._configuration.getValue(null, { resource: resource }, this._extHostWorkspace.workspace), section)
                : this._configuration.getValue(null, { resource: resource }, this._extHostWorkspace.workspace));
            if (section) {
                this._validateConfigurationAccess(section, resource, extensionId);
            }
            function parseConfigurationTarget(arg) {
                if (arg === void 0 || arg === null) {
                    return null;
                }
                if (typeof arg === 'boolean') {
                    return arg ? 1 /* USER */ : 2 /* WORKSPACE */;
                }
                switch (arg) {
                    case extHostTypes_1.ConfigurationTarget.Global: return 1 /* USER */;
                    case extHostTypes_1.ConfigurationTarget.Workspace: return 2 /* WORKSPACE */;
                    case extHostTypes_1.ConfigurationTarget.WorkspaceFolder: return 3 /* WORKSPACE_FOLDER */;
                }
            }
            var result = {
                has: function (key) {
                    return typeof lookUp(config, key) !== 'undefined';
                },
                get: function (key, defaultValue) {
                    _this._validateConfigurationAccess(section ? section + "." + key : key, resource, extensionId);
                    var result = lookUp(config, key);
                    if (typeof result === 'undefined') {
                        result = defaultValue;
                    }
                    else {
                        var clonedConfig_1 = void 0;
                        var cloneOnWriteProxy_1 = function (target, accessor) {
                            var clonedTarget = void 0;
                            var cloneTarget = function () {
                                clonedConfig_1 = clonedConfig_1 ? clonedConfig_1 : objects_1.deepClone(config);
                                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig_1, accessor);
                            };
                            return types_1.isObject(target) ?
                                new Proxy(target, {
                                    get: function (target, property) {
                                        if (typeof property === 'string' && property.toLowerCase() === 'tojson') {
                                            cloneTarget();
                                            return function () { return clonedTarget; };
                                        }
                                        if (clonedConfig_1) {
                                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig_1, accessor);
                                            return clonedTarget[property];
                                        }
                                        var result = target[property];
                                        if (typeof property === 'string') {
                                            return cloneOnWriteProxy_1(result, accessor + "." + property);
                                        }
                                        return result;
                                    },
                                    set: function (_target, property, value) {
                                        cloneTarget();
                                        clonedTarget[property] = value;
                                        return true;
                                    },
                                    deleteProperty: function (_target, property) {
                                        cloneTarget();
                                        delete clonedTarget[property];
                                        return true;
                                    },
                                    defineProperty: function (_target, property, descriptor) {
                                        cloneTarget();
                                        Object.defineProperty(clonedTarget, property, descriptor);
                                        return true;
                                    }
                                }) : target;
                        };
                        result = cloneOnWriteProxy_1(result, key);
                    }
                    return result;
                },
                update: function (key, value, arg) {
                    key = section ? section + "." + key : key;
                    var target = parseConfigurationTarget(arg);
                    if (value !== void 0) {
                        return _this._proxy.$updateConfigurationOption(target, key, value, resource);
                    }
                    else {
                        return _this._proxy.$removeConfigurationOption(target, key, resource);
                    }
                },
                inspect: function (key) {
                    key = section ? section + "." + key : key;
                    var config = objects_1.deepClone(_this._configuration.inspect(key, { resource: resource }, _this._extHostWorkspace.workspace));
                    if (config) {
                        return {
                            key: key,
                            defaultValue: config.default,
                            globalValue: config.user,
                            workspaceValue: config.workspace,
                            workspaceFolderValue: config.workspaceFolder
                        };
                    }
                    return undefined;
                }
            };
            if (typeof config === 'object') {
                objects_1.mixin(result, config, false);
            }
            return Object.freeze(result);
        };
        ExtHostConfiguration.prototype._toReadonlyValue = function (result) {
            var readonlyProxy = function (target) {
                return types_1.isObject(target) ?
                    new Proxy(target, {
                        get: function (target, property) { return readonlyProxy(target[property]); },
                        set: function (_target, property, _value) { throw new Error("TypeError: Cannot assign to read only property '" + property + "' of object"); },
                        deleteProperty: function (_target, property) { throw new Error("TypeError: Cannot delete read only property '" + property + "' of object"); },
                        defineProperty: function (_target, property) { throw new Error("TypeError: Cannot define property '" + property + "' for a readonly object"); },
                        setPrototypeOf: function (_target) { throw new Error("TypeError: Cannot set prototype for a readonly object"); },
                        isExtensible: function () { return false; },
                        preventExtensions: function () { return true; }
                    }) : target;
            };
            return readonlyProxy(result);
        };
        ExtHostConfiguration.prototype._validateConfigurationAccess = function (key, resource, extensionId) {
            var scope = configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) ? 3 /* RESOURCE */ : this._configurationScopes[key];
            var extensionIdText = extensionId ? "[" + extensionId + "] " : '';
            if (3 /* RESOURCE */ === scope) {
                if (resource === void 0) {
                    console.warn(extensionIdText + "Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '" + key + "', provide the URI of a resource or 'null' for any resource.");
                }
                return;
            }
            if (2 /* WINDOW */ === scope) {
                if (resource) {
                    console.warn(extensionIdText + "Accessing a window scoped configuration for a resource is not expected. To associate '" + key + "' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.");
                }
                return;
            }
        };
        ExtHostConfiguration.prototype._toConfigurationChangeEvent = function (data) {
            var changedConfiguration = new configurationModels_1.ConfigurationModel(data.changedConfiguration.contents, data.changedConfiguration.keys, data.changedConfiguration.overrides);
            var changedConfigurationByResource = new map_1.ResourceMap();
            for (var _i = 0, _a = Object.keys(data.changedConfigurationByResource); _i < _a.length; _i++) {
                var key = _a[_i];
                var resource = uri_1.URI.parse(key);
                var model = data.changedConfigurationByResource[key];
                changedConfigurationByResource.set(resource, new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides));
            }
            var event = new configurationModels_2.WorkspaceConfigurationChangeEvent(new configurationModels_1.ConfigurationChangeEvent(changedConfiguration, changedConfigurationByResource), this._extHostWorkspace.workspace);
            return Object.freeze({
                affectsConfiguration: function (section, resource) { return event.affectsConfiguration(section, resource); }
            });
        };
        ExtHostConfiguration.parse = function (data) {
            var defaultConfiguration = ExtHostConfiguration.parseConfigurationModel(data.defaults);
            var userConfiguration = ExtHostConfiguration.parseConfigurationModel(data.user);
            var workspaceConfiguration = ExtHostConfiguration.parseConfigurationModel(data.workspace);
            var folders = Object.keys(data.folders).reduce(function (result, key) {
                result.set(uri_1.URI.parse(key), ExtHostConfiguration.parseConfigurationModel(data.folders[key]));
                return result;
            }, new map_1.ResourceMap());
            return new configurationModels_1.Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, folders, new configurationModels_1.ConfigurationModel(), new map_1.ResourceMap(), false);
        };
        ExtHostConfiguration.parseConfigurationModel = function (model) {
            return new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides).freeze();
        };
        return ExtHostConfiguration;
    }());
    exports.ExtHostConfiguration = ExtHostConfiguration;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[131/*vs/workbench/services/configurationResolver/node/variableResolver*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/paths*/,18/*vs/base/common/types*/,13/*vs/base/common/objects*/,10/*path*/,6/*vs/base/common/platform*/,110/*vs/base/common/labels*/,92/*vs/nls!vs/workbench/services/configurationResolver/node/variableResolver*/]), function (require, exports, paths, types, objects, path_1, platform_1, labels_1, nls_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractVariableResolverService = /** @class */ (function () {
        function AbstractVariableResolverService(_context, _envVariables) {
            if (_envVariables === void 0) { _envVariables = process.env; }
            var _this = this;
            this._context = _context;
            this._envVariables = _envVariables;
            if (platform_1.isWindows) {
                this._envVariables = Object.create(null);
                Object.keys(_envVariables).forEach(function (key) {
                    _this._envVariables[key.toLowerCase()] = _envVariables[key];
                });
            }
        }
        AbstractVariableResolverService.prototype.resolve = function (root, value) {
            return this.recursiveResolve(root ? root.uri : undefined, value);
        };
        AbstractVariableResolverService.prototype.resolveAny = function (workspaceFolder, config, commandValueMapping) {
            var result = objects.deepClone(config);
            // hoist platform specific attributes to top level
            if (platform_1.isWindows && result.windows) {
                Object.keys(result.windows).forEach(function (key) { return result[key] = result.windows[key]; });
            }
            else if (platform_1.isMacintosh && result.osx) {
                Object.keys(result.osx).forEach(function (key) { return result[key] = result.osx[key]; });
            }
            else if (platform_1.isLinux && result.linux) {
                Object.keys(result.linux).forEach(function (key) { return result[key] = result.linux[key]; });
            }
            // delete all platform specific sections
            delete result.windows;
            delete result.osx;
            delete result.linux;
            // substitute all variables recursively in string values
            return this.recursiveResolve(workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping);
        };
        AbstractVariableResolverService.prototype.resolveWithCommands = function (folder, config) {
            throw new Error('resolveWithCommands not implemented.');
        };
        AbstractVariableResolverService.prototype.recursiveResolve = function (folderUri, value, commandValueMapping) {
            var _this = this;
            if (types.isString(value)) {
                return this.resolveString(folderUri, value, commandValueMapping);
            }
            else if (types.isArray(value)) {
                return value.map(function (s) { return _this.recursiveResolve(folderUri, s, commandValueMapping); });
            }
            else if (types.isObject(value)) {
                var result_1 = Object.create(null);
                Object.keys(value).forEach(function (key) {
                    var resolvedKey = _this.resolveString(folderUri, key, commandValueMapping);
                    result_1[resolvedKey] = _this.recursiveResolve(folderUri, value[key], commandValueMapping);
                });
                return result_1;
            }
            return value;
        };
        AbstractVariableResolverService.prototype.resolveString = function (folderUri, value, commandValueMapping) {
            var _this = this;
            var filePath = this._context.getFilePath();
            return value.replace(AbstractVariableResolverService.VARIABLE_REGEXP, function (match, variable) {
                var argument;
                var parts = variable.split(':');
                if (parts && parts.length > 1) {
                    variable = parts[0];
                    argument = parts[1];
                }
                switch (variable) {
                    case 'env':
                        if (argument) {
                            if (platform_1.isWindows) {
                                argument = argument.toLowerCase();
                            }
                            var env = _this._envVariables[argument];
                            if (types.isString(env)) {
                                return env;
                            }
                            // For `env` we should do the same as a normal shell does - evaluates missing envs to an empty string #46436
                            return '';
                        }
                        throw new Error(nls_1.localize(0, null, match));
                    case 'config':
                        if (argument) {
                            var config = _this._context.getConfigurationValue(folderUri, argument);
                            if (types.isUndefinedOrNull(config)) {
                                throw new Error(nls_1.localize(1, null, match, argument));
                            }
                            if (types.isObject(config)) {
                                throw new Error(nls_1.localize(2, null, match, argument));
                            }
                            return config;
                        }
                        throw new Error(nls_1.localize(3, null, match));
                    case 'command':
                        if (argument && commandValueMapping) {
                            var v = commandValueMapping[argument];
                            if (typeof v === 'string') {
                                return v;
                            }
                            throw new Error(nls_1.localize(4, null, match));
                        }
                        return match;
                    default: {
                        // common error handling for all variables that require an open folder and accept a folder name argument
                        switch (variable) {
                            case 'workspaceRoot':
                            case 'workspaceFolder':
                            case 'workspaceRootFolderName':
                            case 'workspaceFolderBasename':
                            case 'relativeFile':
                                if (argument) {
                                    var folder = _this._context.getFolderUri(argument);
                                    if (folder) {
                                        folderUri = folder;
                                    }
                                    else {
                                        throw new Error(nls_1.localize(5, null, match, argument));
                                    }
                                }
                                if (!folderUri) {
                                    if (_this._context.getWorkspaceFolderCount() > 1) {
                                        throw new Error(nls_1.localize(6, null, match));
                                    }
                                    throw new Error(nls_1.localize(7, null, match));
                                }
                                break;
                            default:
                                break;
                        }
                        // common error handling for all variables that require an open file
                        switch (variable) {
                            case 'file':
                            case 'relativeFile':
                            case 'fileDirname':
                            case 'fileExtname':
                            case 'fileBasename':
                            case 'fileBasenameNoExtension':
                                if (!filePath) {
                                    throw new Error(nls_1.localize(8, null, match));
                                }
                                break;
                            default:
                                break;
                        }
                        switch (variable) {
                            case 'workspaceRoot':
                            case 'workspaceFolder':
                                return labels_1.normalizeDriveLetter(folderUri.fsPath);
                            case 'cwd':
                                return folderUri ? labels_1.normalizeDriveLetter(folderUri.fsPath) : process.cwd();
                            case 'workspaceRootFolderName':
                            case 'workspaceFolderBasename':
                                return paths.basename(folderUri.fsPath);
                            case 'lineNumber':
                                var lineNumber = _this._context.getLineNumber();
                                if (lineNumber) {
                                    return lineNumber;
                                }
                                throw new Error(nls_1.localize(9, null, match));
                            case 'selectedText':
                                var selectedText = _this._context.getSelectedText();
                                if (selectedText) {
                                    return selectedText;
                                }
                                throw new Error(nls_1.localize(10, null, match));
                            case 'file':
                                return filePath;
                            case 'relativeFile':
                                if (folderUri) {
                                    return paths.normalize(path_1.relative(folderUri.fsPath, filePath));
                                }
                                return filePath;
                            case 'fileDirname':
                                return paths.dirname(filePath);
                            case 'fileExtname':
                                return paths.extname(filePath);
                            case 'fileBasename':
                                return paths.basename(filePath);
                            case 'fileBasenameNoExtension':
                                var basename = paths.basename(filePath);
                                return basename.slice(0, basename.length - paths.extname(basename).length);
                            case 'execPath':
                                var ep = _this._context.getExecPath();
                                if (ep) {
                                    return ep;
                                }
                                return match;
                            default:
                                return match;
                        }
                    }
                }
            });
        };
        AbstractVariableResolverService.VARIABLE_REGEXP = /\$\{(.*?)\}/g;
        return AbstractVariableResolverService;
    }());
    exports.AbstractVariableResolverService = AbstractVariableResolverService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[132/*vs/workbench/services/editor/common/editorService*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    exports.ACTIVE_GROUP = -1;
    exports.SIDE_GROUP = -2;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[21/*vs/workbench/api/node/extHostTypeConverters*/], __M([1/*require*/,0/*exports*/,97/*vs/editor/common/modes*/,7/*vs/workbench/api/node/extHostTypes*/,2/*vs/base/common/uri*/,60/*vs/base/common/htmlContent*/,62/*vs/platform/markers/common/markers*/,132/*vs/workbench/services/editor/common/editorService*/,18/*vs/base/common/types*/]), function (require, exports, modes, types, uri_1, htmlContent, markers_1, editorService_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Selection;
    (function (Selection) {
        function to(selection) {
            var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
            var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
            var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
            return new types.Selection(start, end);
        }
        Selection.to = to;
        function from(selection) {
            var anchor = selection.anchor, active = selection.active;
            return {
                selectionStartLineNumber: anchor.line + 1,
                selectionStartColumn: anchor.character + 1,
                positionLineNumber: active.line + 1,
                positionColumn: active.character + 1
            };
        }
        Selection.from = from;
    })(Selection = exports.Selection || (exports.Selection = {}));
    var Range;
    (function (Range) {
        function from(range) {
            if (!range) {
                return undefined;
            }
            var start = range.start, end = range.end;
            return {
                startLineNumber: start.line + 1,
                startColumn: start.character + 1,
                endLineNumber: end.line + 1,
                endColumn: end.character + 1
            };
        }
        Range.from = from;
        function to(range) {
            if (!range) {
                return undefined;
            }
            var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
            return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
        }
        Range.to = to;
    })(Range = exports.Range || (exports.Range = {}));
    var Position;
    (function (Position) {
        function to(position) {
            return new types.Position(position.lineNumber - 1, position.column - 1);
        }
        Position.to = to;
        function from(position) {
            return { lineNumber: position.line + 1, column: position.character + 1 };
        }
        Position.from = from;
    })(Position = exports.Position || (exports.Position = {}));
    var DiagnosticTag;
    (function (DiagnosticTag) {
        function from(value) {
            switch (value) {
                case types.DiagnosticTag.Unnecessary:
                    return 1 /* Unnecessary */;
            }
            return undefined;
        }
        DiagnosticTag.from = from;
    })(DiagnosticTag = exports.DiagnosticTag || (exports.DiagnosticTag = {}));
    var Diagnostic;
    (function (Diagnostic) {
        function from(value) {
            return __assign({}, Range.from(value.range), { message: value.message, source: value.source, code: types_1.isString(value.code) || types_1.isNumber(value.code) ? String(value.code) : void 0, severity: DiagnosticSeverity.from(value.severity), relatedInformation: value.relatedInformation && value.relatedInformation.map(DiagnosticRelatedInformation.from), tags: Array.isArray(value.tags) ? value.tags.map(DiagnosticTag.from) : undefined });
        }
        Diagnostic.from = from;
    })(Diagnostic = exports.Diagnostic || (exports.Diagnostic = {}));
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        function from(value) {
            return __assign({}, Range.from(value.location.range), { message: value.message, resource: value.location.uri });
        }
        DiagnosticRelatedInformation.from = from;
        function to(value) {
            return new types.DiagnosticRelatedInformation(new types.Location(value.resource, Range.to(value)), value.message);
        }
        DiagnosticRelatedInformation.to = to;
    })(DiagnosticRelatedInformation = exports.DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = {}));
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        function from(value) {
            switch (value) {
                case types.DiagnosticSeverity.Error:
                    return markers_1.MarkerSeverity.Error;
                case types.DiagnosticSeverity.Warning:
                    return markers_1.MarkerSeverity.Warning;
                case types.DiagnosticSeverity.Information:
                    return markers_1.MarkerSeverity.Info;
                case types.DiagnosticSeverity.Hint:
                    return markers_1.MarkerSeverity.Hint;
            }
            return markers_1.MarkerSeverity.Error;
        }
        DiagnosticSeverity.from = from;
        function to(value) {
            switch (value) {
                case markers_1.MarkerSeverity.Info:
                    return types.DiagnosticSeverity.Information;
                case markers_1.MarkerSeverity.Warning:
                    return types.DiagnosticSeverity.Warning;
                case markers_1.MarkerSeverity.Error:
                    return types.DiagnosticSeverity.Error;
                case markers_1.MarkerSeverity.Hint:
                    return types.DiagnosticSeverity.Hint;
            }
            return types.DiagnosticSeverity.Error;
        }
        DiagnosticSeverity.to = to;
    })(DiagnosticSeverity = exports.DiagnosticSeverity || (exports.DiagnosticSeverity = {}));
    var ViewColumn;
    (function (ViewColumn) {
        function from(column) {
            if (typeof column === 'number' && column >= types.ViewColumn.One) {
                return column - 1; // adjust zero index (ViewColumn.ONE => 0)
            }
            if (column === types.ViewColumn.Beside) {
                return editorService_1.SIDE_GROUP;
            }
            return editorService_1.ACTIVE_GROUP; // default is always the active group
        }
        ViewColumn.from = from;
        function to(position) {
            if (typeof position === 'number' && position >= 0) {
                return position + 1; // adjust to index (ViewColumn.ONE => 1)
            }
            return undefined;
        }
        ViewColumn.to = to;
    })(ViewColumn = exports.ViewColumn || (exports.ViewColumn = {}));
    function isDecorationOptions(something) {
        return (typeof something.range !== 'undefined');
    }
    function isDecorationOptionsArr(something) {
        if (something.length === 0) {
            return true;
        }
        return isDecorationOptions(something[0]) ? true : false;
    }
    exports.isDecorationOptionsArr = isDecorationOptionsArr;
    var MarkdownString;
    (function (MarkdownString) {
        function fromMany(markup) {
            return markup.map(MarkdownString.from);
        }
        MarkdownString.fromMany = fromMany;
        function isCodeblock(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.language === 'string'
                && typeof thing.value === 'string';
        }
        function from(markup) {
            if (isCodeblock(markup)) {
                var language = markup.language, value = markup.value;
                return { value: '```' + language + '\n' + value + '\n```\n' };
            }
            else if (htmlContent.isMarkdownString(markup)) {
                return markup;
            }
            else if (typeof markup === 'string') {
                return { value: markup };
            }
            else {
                return { value: '' };
            }
        }
        MarkdownString.from = from;
        function to(value) {
            var ret = new htmlContent.MarkdownString(value.value);
            ret.isTrusted = value.isTrusted;
            return ret;
        }
        MarkdownString.to = to;
        function fromStrict(value) {
            if (!value) {
                return undefined;
            }
            return typeof value === 'string' ? value : MarkdownString.from(value);
        }
        MarkdownString.fromStrict = fromStrict;
    })(MarkdownString = exports.MarkdownString || (exports.MarkdownString = {}));
    function fromRangeOrRangeWithMessage(ranges) {
        if (isDecorationOptionsArr(ranges)) {
            return ranges.map(function (r) {
                return {
                    range: Range.from(r.range),
                    hoverMessage: Array.isArray(r.hoverMessage) ? MarkdownString.fromMany(r.hoverMessage) : r.hoverMessage && MarkdownString.from(r.hoverMessage),
                    renderOptions: r.renderOptions
                };
            });
        }
        else {
            return ranges.map(function (r) {
                return {
                    range: Range.from(r)
                };
            });
        }
    }
    exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
    var TextEdit;
    (function (TextEdit) {
        function from(edit) {
            return {
                text: edit.newText,
                eol: EndOfLine.from(edit.newEol),
                range: Range.from(edit.range)
            };
        }
        TextEdit.from = from;
        function to(edit) {
            var result = new types.TextEdit(Range.to(edit.range), edit.text);
            result.newEol = EndOfLine.to(edit.eol);
            return result;
        }
        TextEdit.to = to;
    })(TextEdit = exports.TextEdit || (exports.TextEdit = {}));
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function from(value, documents) {
            var result = {
                edits: []
            };
            for (var _i = 0, _a = value._allEntries(); _i < _a.length; _i++) {
                var entry = _a[_i];
                var uri = entry[0], uriOrEdits = entry[1];
                if (Array.isArray(uriOrEdits)) {
                    // text edits
                    var doc = documents ? documents.getDocument(uri.toString()) : undefined;
                    result.edits.push({ resource: uri, modelVersionId: doc && doc.version, edits: uriOrEdits.map(TextEdit.from) });
                }
                else {
                    // resource edits
                    result.edits.push({ oldUri: uri, newUri: uriOrEdits, options: entry[2] });
                }
            }
            return result;
        }
        WorkspaceEdit.from = from;
        function to(value) {
            var result = new types.WorkspaceEdit();
            for (var _i = 0, _a = value.edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (Array.isArray(edit.edits)) {
                    result.set(uri_1.URI.revive(edit.resource), edit.edits.map(TextEdit.to));
                }
                else {
                    result.renameFile(uri_1.URI.revive(edit.oldUri), uri_1.URI.revive(edit.newUri), edit.options);
                }
            }
            return result;
        }
        WorkspaceEdit.to = to;
    })(WorkspaceEdit = exports.WorkspaceEdit || (exports.WorkspaceEdit = {}));
    var SymbolKind;
    (function (SymbolKind) {
        var _fromMapping = Object.create(null);
        _fromMapping[types.SymbolKind.File] = 0 /* File */;
        _fromMapping[types.SymbolKind.Module] = 1 /* Module */;
        _fromMapping[types.SymbolKind.Namespace] = 2 /* Namespace */;
        _fromMapping[types.SymbolKind.Package] = 3 /* Package */;
        _fromMapping[types.SymbolKind.Class] = 4 /* Class */;
        _fromMapping[types.SymbolKind.Method] = 5 /* Method */;
        _fromMapping[types.SymbolKind.Property] = 6 /* Property */;
        _fromMapping[types.SymbolKind.Field] = 7 /* Field */;
        _fromMapping[types.SymbolKind.Constructor] = 8 /* Constructor */;
        _fromMapping[types.SymbolKind.Enum] = 9 /* Enum */;
        _fromMapping[types.SymbolKind.Interface] = 10 /* Interface */;
        _fromMapping[types.SymbolKind.Function] = 11 /* Function */;
        _fromMapping[types.SymbolKind.Variable] = 12 /* Variable */;
        _fromMapping[types.SymbolKind.Constant] = 13 /* Constant */;
        _fromMapping[types.SymbolKind.String] = 14 /* String */;
        _fromMapping[types.SymbolKind.Number] = 15 /* Number */;
        _fromMapping[types.SymbolKind.Boolean] = 16 /* Boolean */;
        _fromMapping[types.SymbolKind.Array] = 17 /* Array */;
        _fromMapping[types.SymbolKind.Object] = 18 /* Object */;
        _fromMapping[types.SymbolKind.Key] = 19 /* Key */;
        _fromMapping[types.SymbolKind.Null] = 20 /* Null */;
        _fromMapping[types.SymbolKind.EnumMember] = 21 /* EnumMember */;
        _fromMapping[types.SymbolKind.Struct] = 22 /* Struct */;
        _fromMapping[types.SymbolKind.Event] = 23 /* Event */;
        _fromMapping[types.SymbolKind.Operator] = 24 /* Operator */;
        _fromMapping[types.SymbolKind.TypeParameter] = 25 /* TypeParameter */;
        function from(kind) {
            return _fromMapping[kind] || 6 /* Property */;
        }
        SymbolKind.from = from;
        function to(kind) {
            for (var k in _fromMapping) {
                if (_fromMapping[k] === kind) {
                    return Number(k);
                }
            }
            return types.SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    var WorkspaceSymbol;
    (function (WorkspaceSymbol) {
        function from(info) {
            return {
                name: info.name,
                kind: SymbolKind.from(info.kind),
                containerName: info.containerName,
                location: location.from(info.location)
            };
        }
        WorkspaceSymbol.from = from;
        function to(info) {
            return new types.SymbolInformation(info.name, SymbolKind.to(info.kind), info.containerName, location.to(info.location));
        }
        WorkspaceSymbol.to = to;
    })(WorkspaceSymbol = exports.WorkspaceSymbol || (exports.WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function (DocumentSymbol) {
        function from(info) {
            var result = {
                name: info.name,
                detail: info.detail,
                range: Range.from(info.range),
                selectionRange: Range.from(info.selectionRange),
                kind: SymbolKind.from(info.kind)
            };
            if (info.children) {
                result.children = info.children.map(from);
            }
            return result;
        }
        DocumentSymbol.from = from;
        function to(info) {
            var result = new types.DocumentSymbol(info.name, info.detail, SymbolKind.to(info.kind), Range.to(info.range), Range.to(info.selectionRange));
            if (info.children) {
                result.children = info.children.map(to);
            }
            return result;
        }
        DocumentSymbol.to = to;
    })(DocumentSymbol = exports.DocumentSymbol || (exports.DocumentSymbol = {}));
    var location;
    (function (location) {
        function from(value) {
            return {
                range: value.range && Range.from(value.range),
                uri: value.uri
            };
        }
        location.from = from;
        function to(value) {
            return new types.Location(value.uri, Range.to(value.range));
        }
        location.to = to;
    })(location = exports.location || (exports.location = {}));
    var DefinitionLink;
    (function (DefinitionLink) {
        function from(value) {
            var definitionLink = value;
            var location = value;
            return {
                origin: definitionLink.originSelectionRange
                    ? Range.from(definitionLink.originSelectionRange)
                    : undefined,
                uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
                range: Range.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
                selectionRange: definitionLink.targetSelectionRange
                    ? Range.from(definitionLink.targetSelectionRange)
                    : undefined,
            };
        }
        DefinitionLink.from = from;
    })(DefinitionLink = exports.DefinitionLink || (exports.DefinitionLink = {}));
    var Hover;
    (function (Hover) {
        function from(hover) {
            return {
                range: Range.from(hover.range),
                contents: MarkdownString.fromMany(hover.contents)
            };
        }
        Hover.from = from;
        function to(info) {
            return new types.Hover(info.contents.map(MarkdownString.to), Range.to(info.range));
        }
        Hover.to = to;
    })(Hover = exports.Hover || (exports.Hover = {}));
    var DocumentHighlight;
    (function (DocumentHighlight) {
        function from(documentHighlight) {
            return {
                range: Range.from(documentHighlight.range),
                kind: documentHighlight.kind
            };
        }
        DocumentHighlight.from = from;
        function to(occurrence) {
            return new types.DocumentHighlight(Range.to(occurrence.range), occurrence.kind);
        }
        DocumentHighlight.to = to;
    })(DocumentHighlight = exports.DocumentHighlight || (exports.DocumentHighlight = {}));
    var CompletionTriggerKind;
    (function (CompletionTriggerKind) {
        function to(kind) {
            switch (kind) {
                case 1 /* TriggerCharacter */:
                    return types.CompletionTriggerKind.TriggerCharacter;
                case 2 /* TriggerForIncompleteCompletions */:
                    return types.CompletionTriggerKind.TriggerForIncompleteCompletions;
                case 0 /* Invoke */:
                default:
                    return types.CompletionTriggerKind.Invoke;
            }
        }
        CompletionTriggerKind.to = to;
    })(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionContext;
    (function (CompletionContext) {
        function to(context) {
            return {
                triggerKind: CompletionTriggerKind.to(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            };
        }
        CompletionContext.to = to;
    })(CompletionContext = exports.CompletionContext || (exports.CompletionContext = {}));
    var CompletionItemKind;
    (function (CompletionItemKind) {
        function from(kind) {
            switch (kind) {
                case types.CompletionItemKind.Method: return 0 /* Method */;
                case types.CompletionItemKind.Function: return 1 /* Function */;
                case types.CompletionItemKind.Constructor: return 2 /* Constructor */;
                case types.CompletionItemKind.Field: return 3 /* Field */;
                case types.CompletionItemKind.Variable: return 4 /* Variable */;
                case types.CompletionItemKind.Class: return 5 /* Class */;
                case types.CompletionItemKind.Interface: return 7 /* Interface */;
                case types.CompletionItemKind.Struct: return 6 /* Struct */;
                case types.CompletionItemKind.Module: return 8 /* Module */;
                case types.CompletionItemKind.Property: return 9 /* Property */;
                case types.CompletionItemKind.Unit: return 12 /* Unit */;
                case types.CompletionItemKind.Value: return 13 /* Value */;
                case types.CompletionItemKind.Constant: return 14 /* Constant */;
                case types.CompletionItemKind.Enum: return 15 /* Enum */;
                case types.CompletionItemKind.EnumMember: return 16 /* EnumMember */;
                case types.CompletionItemKind.Keyword: return 17 /* Keyword */;
                case types.CompletionItemKind.Snippet: return 25 /* Snippet */;
                case types.CompletionItemKind.Text: return 18 /* Text */;
                case types.CompletionItemKind.Color: return 19 /* Color */;
                case types.CompletionItemKind.File: return 20 /* File */;
                case types.CompletionItemKind.Reference: return 21 /* Reference */;
                case types.CompletionItemKind.Folder: return 23 /* Folder */;
                case types.CompletionItemKind.Event: return 10 /* Event */;
                case types.CompletionItemKind.Operator: return 11 /* Operator */;
                case types.CompletionItemKind.TypeParameter: return 24 /* TypeParameter */;
            }
            return 9 /* Property */;
        }
        CompletionItemKind.from = from;
        function to(kind) {
            switch (kind) {
                case 0 /* Method */: return types.CompletionItemKind.Method;
                case 1 /* Function */: return types.CompletionItemKind.Function;
                case 2 /* Constructor */: return types.CompletionItemKind.Constructor;
                case 3 /* Field */: return types.CompletionItemKind.Field;
                case 4 /* Variable */: return types.CompletionItemKind.Variable;
                case 5 /* Class */: return types.CompletionItemKind.Class;
                case 7 /* Interface */: return types.CompletionItemKind.Interface;
                case 6 /* Struct */: return types.CompletionItemKind.Struct;
                case 8 /* Module */: return types.CompletionItemKind.Module;
                case 9 /* Property */: return types.CompletionItemKind.Property;
                case 12 /* Unit */: return types.CompletionItemKind.Unit;
                case 13 /* Value */: return types.CompletionItemKind.Value;
                case 14 /* Constant */: return types.CompletionItemKind.Constant;
                case 15 /* Enum */: return types.CompletionItemKind.Enum;
                case 16 /* EnumMember */: return types.CompletionItemKind.EnumMember;
                case 17 /* Keyword */: return types.CompletionItemKind.Keyword;
                case 25 /* Snippet */: return types.CompletionItemKind.Snippet;
                case 18 /* Text */: return types.CompletionItemKind.Text;
                case 19 /* Color */: return types.CompletionItemKind.Color;
                case 20 /* File */: return types.CompletionItemKind.File;
                case 21 /* Reference */: return types.CompletionItemKind.Reference;
                case 23 /* Folder */: return types.CompletionItemKind.Folder;
                case 10 /* Event */: return types.CompletionItemKind.Event;
                case 11 /* Operator */: return types.CompletionItemKind.Operator;
                case 24 /* TypeParameter */: return types.CompletionItemKind.TypeParameter;
            }
            return types.CompletionItemKind.Property;
        }
        CompletionItemKind.to = to;
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItemInsertTextRule;
    (function (CompletionItemInsertTextRule) {
        function from(rule) {
            var result = 0;
            if ((rule & types.CompletionItemInsertTextRule.KeepWhitespace)) {
                result += 1 /* KeepWhitespace */;
            }
            return result;
        }
        CompletionItemInsertTextRule.from = from;
        function to(rule) {
            var result = 0;
            if ((rule & 1 /* KeepWhitespace */)) {
                result += types.CompletionItemInsertTextRule.KeepWhitespace;
            }
            return result;
        }
        CompletionItemInsertTextRule.to = to;
    })(CompletionItemInsertTextRule = exports.CompletionItemInsertTextRule || (exports.CompletionItemInsertTextRule = {}));
    var CompletionItem;
    (function (CompletionItem) {
        function to(suggestion) {
            var result = new types.CompletionItem(suggestion.label);
            result.insertText = suggestion.insertText;
            result.kind = CompletionItemKind.to(suggestion.kind);
            result.detail = suggestion.detail;
            result.documentation = htmlContent.isMarkdownString(suggestion.documentation) ? MarkdownString.to(suggestion.documentation) : suggestion.documentation;
            result.sortText = suggestion.sortText;
            result.filterText = suggestion.filterText;
            result.preselect = suggestion.preselect;
            result.commitCharacters = suggestion.commitCharacters;
            result.range = Range.to(suggestion.range);
            result.insertTextRules = CompletionItemInsertTextRule.to(suggestion.insertTextRules);
            // 'inserText'-logic
            if (suggestion.insertTextRules & 4 /* InsertAsSnippet */) {
                result.insertText = new types.SnippetString(suggestion.insertText);
            }
            else {
                result.insertText = suggestion.insertText;
                result.textEdit = new types.TextEdit(result.range, result.insertText);
            }
            // TODO additionalEdits, command
            return result;
        }
        CompletionItem.to = to;
    })(CompletionItem = exports.CompletionItem || (exports.CompletionItem = {}));
    var ParameterInformation;
    (function (ParameterInformation) {
        function from(info) {
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation)
            };
        }
        ParameterInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation
            };
        }
        ParameterInformation.to = to;
    })(ParameterInformation = exports.ParameterInformation || (exports.ParameterInformation = {}));
    var SignatureInformation;
    (function (SignatureInformation) {
        function from(info) {
            return {
                label: info.label,
                documentation: MarkdownString.fromStrict(info.documentation),
                parameters: info.parameters && info.parameters.map(ParameterInformation.from)
            };
        }
        SignatureInformation.from = from;
        function to(info) {
            return {
                label: info.label,
                documentation: htmlContent.isMarkdownString(info.documentation) ? MarkdownString.to(info.documentation) : info.documentation,
                parameters: info.parameters && info.parameters.map(ParameterInformation.to)
            };
        }
        SignatureInformation.to = to;
    })(SignatureInformation = exports.SignatureInformation || (exports.SignatureInformation = {}));
    var SignatureHelp;
    (function (SignatureHelp) {
        function from(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: help.signatures && help.signatures.map(SignatureInformation.from)
            };
        }
        SignatureHelp.from = from;
        function to(help) {
            return {
                activeSignature: help.activeSignature,
                activeParameter: help.activeParameter,
                signatures: help.signatures && help.signatures.map(SignatureInformation.to)
            };
        }
        SignatureHelp.to = to;
    })(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
    var DocumentLink;
    (function (DocumentLink) {
        function from(link) {
            return {
                range: Range.from(link.range),
                url: link.target && link.target.toString()
            };
        }
        DocumentLink.from = from;
        function to(link) {
            return new types.DocumentLink(Range.to(link.range), link.url && uri_1.URI.parse(link.url));
        }
        DocumentLink.to = to;
    })(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
    var ColorPresentation;
    (function (ColorPresentation) {
        function to(colorPresentation) {
            var cp = new types.ColorPresentation(colorPresentation.label);
            if (colorPresentation.textEdit) {
                cp.textEdit = TextEdit.to(colorPresentation.textEdit);
            }
            if (colorPresentation.additionalTextEdits) {
                cp.additionalTextEdits = colorPresentation.additionalTextEdits.map(function (value) { return TextEdit.to(value); });
            }
            return cp;
        }
        ColorPresentation.to = to;
        function from(colorPresentation) {
            return {
                label: colorPresentation.label,
                textEdit: colorPresentation.textEdit ? TextEdit.from(colorPresentation.textEdit) : undefined,
                additionalTextEdits: colorPresentation.additionalTextEdits ? colorPresentation.additionalTextEdits.map(function (value) { return TextEdit.from(value); }) : undefined
            };
        }
        ColorPresentation.from = from;
    })(ColorPresentation = exports.ColorPresentation || (exports.ColorPresentation = {}));
    var Color;
    (function (Color) {
        function to(c) {
            return new types.Color(c[0], c[1], c[2], c[3]);
        }
        Color.to = to;
        function from(color) {
            return [color.red, color.green, color.blue, color.alpha];
        }
        Color.from = from;
    })(Color = exports.Color || (exports.Color = {}));
    var TextDocumentSaveReason;
    (function (TextDocumentSaveReason) {
        function to(reason) {
            switch (reason) {
                case 2 /* AUTO */:
                    return types.TextDocumentSaveReason.AfterDelay;
                case 1 /* EXPLICIT */:
                    return types.TextDocumentSaveReason.Manual;
                case 3 /* FOCUS_CHANGE */:
                case 4 /* WINDOW_CHANGE */:
                    return types.TextDocumentSaveReason.FocusOut;
            }
        }
        TextDocumentSaveReason.to = to;
    })(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var EndOfLine;
    (function (EndOfLine) {
        function from(eol) {
            if (eol === types.EndOfLine.CRLF) {
                return 1 /* CRLF */;
            }
            else if (eol === types.EndOfLine.LF) {
                return 0 /* LF */;
            }
            return undefined;
        }
        EndOfLine.from = from;
        function to(eol) {
            if (eol === 1 /* CRLF */) {
                return types.EndOfLine.CRLF;
            }
            else if (eol === 0 /* LF */) {
                return types.EndOfLine.LF;
            }
            return undefined;
        }
        EndOfLine.to = to;
    })(EndOfLine = exports.EndOfLine || (exports.EndOfLine = {}));
    var ProgressLocation;
    (function (ProgressLocation) {
        function from(loc) {
            switch (loc) {
                case types.ProgressLocation.SourceControl: return 3 /* Scm */;
                case types.ProgressLocation.Window: return 10 /* Window */;
                case types.ProgressLocation.Notification: return 15 /* Notification */;
            }
            return undefined;
        }
        ProgressLocation.from = from;
    })(ProgressLocation = exports.ProgressLocation || (exports.ProgressLocation = {}));
    var FoldingRange;
    (function (FoldingRange) {
        function from(r) {
            var range = { start: r.start + 1, end: r.end + 1 };
            if (r.kind) {
                range.kind = FoldingRangeKind.from(r.kind);
            }
            return range;
        }
        FoldingRange.from = from;
    })(FoldingRange = exports.FoldingRange || (exports.FoldingRange = {}));
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        function from(kind) {
            if (kind) {
                switch (kind) {
                    case types.FoldingRangeKind.Comment:
                        return modes.FoldingRangeKind.Comment;
                    case types.FoldingRangeKind.Imports:
                        return modes.FoldingRangeKind.Imports;
                    case types.FoldingRangeKind.Region:
                        return modes.FoldingRangeKind.Region;
                }
            }
            return void 0;
        }
        FoldingRangeKind.from = from;
    })(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
    var TextEditorOptions;
    (function (TextEditorOptions) {
        function from(options) {
            if (options) {
                return {
                    pinned: typeof options.preview === 'boolean' ? !options.preview : undefined,
                    preserveFocus: options.preserveFocus,
                    selection: typeof options.selection === 'object' ? Range.from(options.selection) : undefined
                };
            }
            return undefined;
        }
        TextEditorOptions.from = from;
    })(TextEditorOptions = exports.TextEditorOptions || (exports.TextEditorOptions = {}));
    var GlobPattern;
    (function (GlobPattern) {
        function from(pattern) {
            if (pattern instanceof types.RelativePattern) {
                return pattern;
            }
            if (typeof pattern === 'string') {
                return pattern;
            }
            if (isRelativePattern(pattern)) {
                return new types.RelativePattern(pattern.base, pattern.pattern);
            }
            return pattern; // preserve `undefined` and `null`
        }
        GlobPattern.from = from;
        function isRelativePattern(obj) {
            var rp = obj;
            return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';
        }
    })(GlobPattern = exports.GlobPattern || (exports.GlobPattern = {}));
    var LanguageSelector;
    (function (LanguageSelector) {
        function from(selector) {
            if (!selector) {
                return undefined;
            }
            else if (Array.isArray(selector)) {
                return selector.map(from);
            }
            else if (typeof selector === 'string') {
                return selector;
            }
            else {
                return {
                    language: selector.language,
                    scheme: selector.scheme,
                    pattern: GlobPattern.from(selector.pattern),
                    exclusive: selector.exclusive
                };
            }
        }
        LanguageSelector.from = from;
    })(LanguageSelector = exports.LanguageSelector || (exports.LanguageSelector = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[134/*vs/workbench/api/node/apiCommands*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/resources*/,21/*vs/workbench/api/node/extHostTypeConverters*/,98/*vs/platform/commands/common/commands*/]), function (require, exports, resources_1, typeConverters, commands_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function adjustHandler(handler) {
        return function (accessor) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return handler.apply(void 0, [accessor.get(commands_1.ICommandService)].concat(args));
        };
    }
    var PreviewHTMLAPICommand = /** @class */ (function () {
        function PreviewHTMLAPICommand() {
        }
        PreviewHTMLAPICommand.execute = function (executor, uri, position, label, options) {
            return executor.executeCommand('_workbench.previewHtml', uri, typeof position === 'number' && typeConverters.ViewColumn.from(position), label, options);
        };
        PreviewHTMLAPICommand.ID = 'vscode.previewHtml';
        return PreviewHTMLAPICommand;
    }());
    exports.PreviewHTMLAPICommand = PreviewHTMLAPICommand;
    commands_1.CommandsRegistry.registerCommand(PreviewHTMLAPICommand.ID, adjustHandler(PreviewHTMLAPICommand.execute));
    var OpenFolderAPICommand = /** @class */ (function () {
        function OpenFolderAPICommand() {
        }
        OpenFolderAPICommand.execute = function (executor, uri, forceNewWindow) {
            if (!uri) {
                return executor.executeCommand('_files.pickFolderAndOpen', forceNewWindow);
            }
            var correctedUri = resources_1.isMalformedFileUri(uri);
            if (correctedUri) {
                // workaround for #55916 and #55891, will be removed in 1.28
                console.warn("'vscode.openFolder' command invoked with an invalid URI (file:// scheme missing): '" + uri + "'. Converted to a 'file://' URI: " + correctedUri);
                uri = correctedUri;
            }
            return executor.executeCommand('_files.windowOpen', [uri], forceNewWindow);
        };
        OpenFolderAPICommand.ID = 'vscode.openFolder';
        return OpenFolderAPICommand;
    }());
    exports.OpenFolderAPICommand = OpenFolderAPICommand;
    commands_1.CommandsRegistry.registerCommand(OpenFolderAPICommand.ID, adjustHandler(OpenFolderAPICommand.execute));
    var DiffAPICommand = /** @class */ (function () {
        function DiffAPICommand() {
        }
        DiffAPICommand.execute = function (executor, left, right, label, options) {
            return executor.executeCommand('_workbench.diff', [
                left, right,
                label,
                undefined,
                typeConverters.TextEditorOptions.from(options),
                options ? typeConverters.ViewColumn.from(options.viewColumn) : undefined
            ]);
        };
        DiffAPICommand.ID = 'vscode.diff';
        return DiffAPICommand;
    }());
    exports.DiffAPICommand = DiffAPICommand;
    commands_1.CommandsRegistry.registerCommand(DiffAPICommand.ID, adjustHandler(DiffAPICommand.execute));
    var OpenAPICommand = /** @class */ (function () {
        function OpenAPICommand() {
        }
        OpenAPICommand.execute = function (executor, resource, columnOrOptions, label) {
            var options;
            var position;
            if (columnOrOptions) {
                if (typeof columnOrOptions === 'number') {
                    position = typeConverters.ViewColumn.from(columnOrOptions);
                }
                else {
                    options = typeConverters.TextEditorOptions.from(columnOrOptions);
                    position = typeConverters.ViewColumn.from(columnOrOptions.viewColumn);
                }
            }
            return executor.executeCommand('_workbench.open', [
                resource,
                options,
                position,
                label
            ]);
        };
        OpenAPICommand.ID = 'vscode.open';
        return OpenAPICommand;
    }());
    exports.OpenAPICommand = OpenAPICommand;
    commands_1.CommandsRegistry.registerCommand(OpenAPICommand.ID, adjustHandler(OpenAPICommand.execute));
    var RemoveFromRecentlyOpenedAPICommand = /** @class */ (function () {
        function RemoveFromRecentlyOpenedAPICommand() {
        }
        RemoveFromRecentlyOpenedAPICommand.execute = function (executor, path) {
            return executor.executeCommand('_workbench.removeFromRecentlyOpened', path);
        };
        RemoveFromRecentlyOpenedAPICommand.ID = 'vscode.removeFromRecentlyOpened';
        return RemoveFromRecentlyOpenedAPICommand;
    }());
    exports.RemoveFromRecentlyOpenedAPICommand = RemoveFromRecentlyOpenedAPICommand;
    commands_1.CommandsRegistry.registerCommand(RemoveFromRecentlyOpenedAPICommand.ID, adjustHandler(RemoveFromRecentlyOpenedAPICommand.execute));
    var SetEditorLayoutAPICommand = /** @class */ (function () {
        function SetEditorLayoutAPICommand() {
        }
        SetEditorLayoutAPICommand.execute = function (executor, layout) {
            return executor.executeCommand('layoutEditorGroups', layout);
        };
        SetEditorLayoutAPICommand.ID = 'vscode.setEditorLayout';
        return SetEditorLayoutAPICommand;
    }());
    exports.SetEditorLayoutAPICommand = SetEditorLayoutAPICommand;
    commands_1.CommandsRegistry.registerCommand(SetEditorLayoutAPICommand.ID, adjustHandler(SetEditorLayoutAPICommand.execute));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[135/*vs/workbench/api/node/extHostApiCommands*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/,134/*vs/workbench/api/node/apiCommands*/,9/*vs/base/common/arrays*/]), function (require, exports, uri_1, typeConverters, types, apiCommands_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostApiCommands = /** @class */ (function () {
        function ExtHostApiCommands(commands) {
            this._disposables = [];
            this._commands = commands;
        }
        ExtHostApiCommands.register = function (commands) {
            return new ExtHostApiCommands(commands).registerCommands();
        };
        ExtHostApiCommands.prototype.registerCommands = function () {
            var _this = this;
            this._register('vscode.executeWorkspaceSymbolProvider', this._executeWorkspaceSymbolProvider, {
                description: 'Execute all workspace symbol provider.',
                args: [{ name: 'query', description: 'Search string', constraint: String }],
                returns: 'A promise that resolves to an array of SymbolInformation-instances.'
            });
            this._register('vscode.executeDefinitionProvider', this._executeDefinitionProvider, {
                description: 'Execute all definition provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeTypeDefinitionProvider', this._executeTypeDefinitionProvider, {
                description: 'Execute all type definition providers.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeImplementationProvider', this._executeImplementationProvider, {
                description: 'Execute all implementation providers.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instance.'
            });
            this._register('vscode.executeHoverProvider', this._executeHoverProvider, {
                description: 'Execute all hover provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position of a symbol', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Hover-instances.'
            });
            this._register('vscode.executeDocumentHighlights', this._executeDocumentHighlights, {
                description: 'Execute document highlight provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of DocumentHighlight-instances.'
            });
            this._register('vscode.executeReferenceProvider', this._executeReferenceProvider, {
                description: 'Execute reference provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position }
                ],
                returns: 'A promise that resolves to an array of Location-instances.'
            });
            this._register('vscode.executeDocumentRenameProvider', this._executeDocumentRenameProvider, {
                description: 'Execute rename provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'newName', description: 'The new symbol name', constraint: String }
                ],
                returns: 'A promise that resolves to a WorkspaceEdit.'
            });
            this._register('vscode.executeSignatureHelpProvider', this._executeSignatureHelpProvider, {
                description: 'Execute signature help provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger signature help when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } }
                ],
                returns: 'A promise that resolves to SignatureHelp.'
            });
            this._register('vscode.executeDocumentSymbolProvider', this._executeDocumentSymbolProvider, {
                description: 'Execute document symbol provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI }
                ],
                returns: 'A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.'
            });
            this._register('vscode.executeCompletionItemProvider', this._executeCompletionItemProvider, {
                description: 'Execute completion item provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'triggerCharacter', description: '(optional) Trigger completion when the user types the character, like `,` or `(`', constraint: function (value) { return value === void 0 || typeof value === 'string'; } },
                    { name: 'itemResolveCount', description: '(optional) Number of completions to resolve (too large numbers slow down completions)', constraint: function (value) { return value === void 0 || typeof value === 'number'; } }
                ],
                returns: 'A promise that resolves to a CompletionList-instance.'
            });
            this._register('vscode.executeCodeActionProvider', this._executeCodeActionProvider, {
                description: 'Execute code action provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range }
                ],
                returns: 'A promise that resolves to an array of Command-instances.'
            });
            this._register('vscode.executeCodeLensProvider', this._executeCodeLensProvider, {
                description: 'Execute CodeLens provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'itemResolveCount', description: '(optional) Number of lenses that should be resolved and returned. Will only retrun resolved lenses, will impact performance)', constraint: function (value) { return value === void 0 || typeof value === 'number'; } }
                ],
                returns: 'A promise that resolves to an array of CodeLens-instances.'
            });
            this._register('vscode.executeFormatDocumentProvider', this._executeFormatDocumentProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatRangeProvider', this._executeFormatRangeProvider, {
                description: 'Execute range format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'range', description: 'Range in a text document', constraint: types.Range },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeFormatOnTypeProvider', this._executeFormatOnTypeProvider, {
                description: 'Execute document format provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                    { name: 'position', description: 'Position in a text document', constraint: types.Position },
                    { name: 'ch', description: 'Character that got typed', constraint: String },
                    { name: 'options', description: 'Formatting options' }
                ],
                returns: 'A promise that resolves to an array of TextEdits.'
            });
            this._register('vscode.executeLinkProvider', this._executeDocumentLinkProvider, {
                description: 'Execute document link provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI }
                ],
                returns: 'A promise that resolves to an array of DocumentLink-instances.'
            });
            this._register('vscode.executeDocumentColorProvider', this._executeDocumentColorProvider, {
                description: 'Execute document color provider.',
                args: [
                    { name: 'uri', description: 'Uri of a text document', constraint: uri_1.URI },
                ],
                returns: 'A promise that resolves to an array of ColorInformation objects.'
            });
            this._register('vscode.executeColorPresentationProvider', this._executeColorPresentationProvider, {
                description: 'Execute color presentation provider.',
                args: [
                    { name: 'color', description: 'The color to show and insert', constraint: types.Color },
                    { name: 'context', description: 'Context object with uri and range' }
                ],
                returns: 'A promise that resolves to an array of ColorPresentation objects.'
            });
            var adjustHandler = function (handler) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return handler.apply(void 0, [_this._commands].concat(args));
                };
            };
            this._register(apiCommands_1.PreviewHTMLAPICommand.ID, adjustHandler(apiCommands_1.PreviewHTMLAPICommand.execute), {
                description: "\n\t\t\t\t\tRender the HTML of the resource in an editor view.\n\n\t\t\t\t\tSee [working with the HTML preview](https://code.visualstudio.com/docs/extensionAPI/vscode-api-commands#working-with-the-html-preview) for more information about the HTML preview's integration with the editor and for best practices for extension authors.\n\t\t\t\t",
                args: [
                    { name: 'uri', description: 'Uri of the resource to preview.', constraint: function (value) { return value instanceof uri_1.URI || typeof value === 'string'; } },
                    { name: 'column', description: '(optional) Column in which to preview.', constraint: function (value) { return typeof value === 'undefined' || (typeof value === 'number' && typeof types.ViewColumn[value] === 'string'); } },
                    { name: 'label', description: '(optional) An human readable string that is used as title for the preview.', constraint: function (v) { return typeof v === 'string' || typeof v === 'undefined'; } },
                    { name: 'options', description: '(optional) Options for controlling webview environment.', constraint: function (v) { return typeof v === 'object' || typeof v === 'undefined'; } }
                ]
            });
            this._register(apiCommands_1.OpenFolderAPICommand.ID, adjustHandler(apiCommands_1.OpenFolderAPICommand.execute), {
                description: 'Open a folder or workspace in the current window or new window depending on the newWindow argument. Note that opening in the same window will shutdown the current extension host process and start a new one on the given folder/workspace unless the newWindow parameter is set to true.',
                args: [
                    { name: 'uri', description: '(optional) Uri of the folder or workspace file to open. If not provided, a native dialog will ask the user for the folder', constraint: function (value) { return value === void 0 || value instanceof uri_1.URI; } },
                    { name: 'newWindow', description: '(optional) Whether to open the folder/workspace in a new window or the same. Defaults to opening in the same window.', constraint: function (value) { return value === void 0 || typeof value === 'boolean'; } }
                ]
            });
            this._register(apiCommands_1.DiffAPICommand.ID, adjustHandler(apiCommands_1.DiffAPICommand.execute), {
                description: 'Opens the provided resources in the diff editor to compare their contents.',
                args: [
                    { name: 'left', description: 'Left-hand side resource of the diff editor', constraint: uri_1.URI },
                    { name: 'right', description: 'Right-hand side resource of the diff editor', constraint: uri_1.URI },
                    { name: 'title', description: '(optional) Human readable title for the diff editor', constraint: function (v) { return v === void 0 || typeof v === 'string'; } },
                    { name: 'options', description: '(optional) Editor options, see vscode.TextDocumentShowOptions' }
                ]
            });
            this._register(apiCommands_1.OpenAPICommand.ID, adjustHandler(apiCommands_1.OpenAPICommand.execute), {
                description: 'Opens the provided resource in the editor. Can be a text or binary file, or a http(s) url. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.',
                args: [
                    { name: 'resource', description: 'Resource to open', constraint: uri_1.URI },
                    { name: 'columnOrOptions', description: '(optional) Either the column in which to open or editor options, see vscode.TextDocumentShowOptions', constraint: function (v) { return v === void 0 || typeof v === 'number' || typeof v === 'object'; } }
                ]
            });
            this._register(apiCommands_1.RemoveFromRecentlyOpenedAPICommand.ID, adjustHandler(apiCommands_1.RemoveFromRecentlyOpenedAPICommand.execute), {
                description: 'Removes an entry with the given path from the recently opened list.',
                args: [
                    { name: 'path', description: 'Path to remove from recently opened.', constraint: function (value) { return typeof value === 'string'; } }
                ]
            });
            this._register(apiCommands_1.SetEditorLayoutAPICommand.ID, adjustHandler(apiCommands_1.SetEditorLayoutAPICommand.execute), {
                description: 'Sets the editor layout. The layout is described as object with an initial (optional) orientation (0 = horizontal, 1 = vertical) and an array of editor groups within. Each editor group can have a size and another array of editor groups that will be laid out orthogonal to the orientation. If editor group sizes are provided, their sum must be 1 to be applied per row or column. Example for a 2x2 grid: `{ orientation: 0, groups: [{ groups: [{}, {}], size: 0.5 }, { groups: [{}, {}], size: 0.5 }] }`',
                args: [
                    { name: 'layout', description: 'The editor layout to set.', constraint: function (value) { return typeof value === 'object' && Array.isArray(value.groups); } }
                ]
            });
        };
        // --- command impl
        ExtHostApiCommands.prototype._register = function (id, handler, description) {
            var disposable = this._commands.registerCommand(false, id, handler, this, description);
            this._disposables.push(disposable);
        };
        /**
         * Execute workspace symbol provider.
         *
         * @param query Search string to match query symbol names
         * @return A promise that resolves to an array of symbol information.
         */
        ExtHostApiCommands.prototype._executeWorkspaceSymbolProvider = function (query) {
            return this._commands.executeCommand('_executeWorkspaceSymbolProvider', { query: query }).then(function (value) {
                var result = [];
                if (Array.isArray(value)) {
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var tuple = value_1[_i];
                        result.push.apply(result, tuple[1].map(typeConverters.WorkspaceSymbol.to));
                    }
                }
                return result;
            });
        };
        ExtHostApiCommands.prototype._executeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeDefinitionProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeTypeDefinitionProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeTypeDefinitionProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeImplementationProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeImplementationProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeHoverProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeHoverProvider', args)
                .then(tryMapWith(typeConverters.Hover.to));
        };
        ExtHostApiCommands.prototype._executeDocumentHighlights = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeDocumentHighlights', args)
                .then(tryMapWith(typeConverters.DocumentHighlight.to));
        };
        ExtHostApiCommands.prototype._executeReferenceProvider = function (resource, position) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position)
            };
            return this._commands.executeCommand('_executeReferenceProvider', args)
                .then(tryMapWith(typeConverters.location.to));
        };
        ExtHostApiCommands.prototype._executeDocumentRenameProvider = function (resource, position, newName) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                newName: newName
            };
            return this._commands.executeCommand('_executeDocumentRenameProvider', args).then(function (value) {
                if (!value) {
                    return undefined;
                }
                if (value.rejectReason) {
                    return Promise.reject(new Error(value.rejectReason));
                }
                return typeConverters.WorkspaceEdit.to(value);
            });
        };
        ExtHostApiCommands.prototype._executeSignatureHelpProvider = function (resource, position, triggerCharacter) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                triggerCharacter: triggerCharacter
            };
            return this._commands.executeCommand('_executeSignatureHelpProvider', args).then(function (value) {
                if (value) {
                    return typeConverters.SignatureHelp.to(value);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeCompletionItemProvider = function (resource, position, triggerCharacter, maxItemsToResolve) {
            var args = {
                resource: resource,
                position: position && typeConverters.Position.from(position),
                triggerCharacter: triggerCharacter,
                maxItemsToResolve: maxItemsToResolve
            };
            return this._commands.executeCommand('_executeCompletionItemProvider', args).then(function (result) {
                if (result) {
                    var items = result.suggestions.map(function (suggestion) { return typeConverters.CompletionItem.to(suggestion); });
                    return new types.CompletionList(items, result.incomplete);
                }
                return undefined;
            });
        };
        ExtHostApiCommands.prototype._executeDocumentColorProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentColorProvider', args).then(function (result) {
                if (result) {
                    return result.map(function (ci) { return ({ range: typeConverters.Range.to(ci.range), color: typeConverters.Color.to(ci.color) }); });
                }
                return [];
            });
        };
        ExtHostApiCommands.prototype._executeColorPresentationProvider = function (color, context) {
            var args = {
                resource: context.uri,
                color: typeConverters.Color.from(color),
                range: typeConverters.Range.from(context.range),
            };
            return this._commands.executeCommand('_executeColorPresentationProvider', args).then(function (result) {
                if (result) {
                    return result.map(typeConverters.ColorPresentation.to);
                }
                return [];
            });
        };
        ExtHostApiCommands.prototype._executeDocumentSymbolProvider = function (resource) {
            var args = {
                resource: resource
            };
            return this._commands.executeCommand('_executeDocumentSymbolProvider', args).then(function (value) {
                if (arrays_1.isFalsyOrEmpty(value)) {
                    return undefined;
                }
                var MergedInfo = /** @class */ (function (_super) {
                    __extends(MergedInfo, _super);
                    function MergedInfo() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    MergedInfo.to = function (symbol) {
                        var res = new MergedInfo(symbol.name, typeConverters.SymbolKind.to(symbol.kind), symbol.containerName, new types.Location(resource, typeConverters.Range.to(symbol.range)));
                        res.detail = symbol.detail;
                        res.range = res.location.range;
                        res.selectionRange = typeConverters.Range.to(symbol.selectionRange);
                        res.children = symbol.children && symbol.children.map(MergedInfo.to);
                        return res;
                    };
                    return MergedInfo;
                }(types.SymbolInformation));
                return value.map(MergedInfo.to);
            });
        };
        ExtHostApiCommands.prototype._executeCodeActionProvider = function (resource, range) {
            var _this = this;
            var args = {
                resource: resource,
                range: typeConverters.Range.from(range)
            };
            return this._commands.executeCommand('_executeCodeActionProvider', args)
                .then(tryMapWith(function (codeAction) {
                if (codeAction._isSynthetic) {
                    return _this._commands.converter.fromInternal(codeAction.command);
                }
                else {
                    var ret = new types.CodeAction(codeAction.title, codeAction.kind ? new types.CodeActionKind(codeAction.kind) : undefined);
                    if (codeAction.edit) {
                        ret.edit = typeConverters.WorkspaceEdit.to(codeAction.edit);
                    }
                    if (codeAction.command) {
                        ret.command = _this._commands.converter.fromInternal(codeAction.command);
                    }
                    return ret;
                }
            }));
        };
        ExtHostApiCommands.prototype._executeCodeLensProvider = function (resource, itemResolveCount) {
            var _this = this;
            var args = { resource: resource, itemResolveCount: itemResolveCount };
            return this._commands.executeCommand('_executeCodeLensProvider', args)
                .then(tryMapWith(function (item) {
                return new types.CodeLens(typeConverters.Range.to(item.range), _this._commands.converter.fromInternal(item.command));
            }));
        };
        ExtHostApiCommands.prototype._executeFormatDocumentProvider = function (resource, options) {
            var args = {
                resource: resource,
                options: options
            };
            return this._commands.executeCommand('_executeFormatDocumentProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeFormatRangeProvider = function (resource, range, options) {
            var args = {
                resource: resource,
                range: typeConverters.Range.from(range),
                options: options
            };
            return this._commands.executeCommand('_executeFormatRangeProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeFormatOnTypeProvider = function (resource, position, ch, options) {
            var args = {
                resource: resource,
                position: typeConverters.Position.from(position),
                ch: ch,
                options: options
            };
            return this._commands.executeCommand('_executeFormatOnTypeProvider', args)
                .then(tryMapWith(function (edit) { return new types.TextEdit(typeConverters.Range.to(edit.range), edit.text); }));
        };
        ExtHostApiCommands.prototype._executeDocumentLinkProvider = function (resource) {
            return this._commands.executeCommand('_executeLinkProvider', resource)
                .then(tryMapWith(typeConverters.DocumentLink.to));
        };
        return ExtHostApiCommands;
    }());
    exports.ExtHostApiCommands = ExtHostApiCommands;
    function tryMapWith(f) {
        return function (value) {
            if (Array.isArray(value)) {
                return value.map(f);
            }
            return undefined;
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[136/*vs/workbench/api/node/extHostDocumentSaveParticipant*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,11/*vs/base/common/async*/,14/*vs/base/common/errors*/,7/*vs/workbench/api/node/extHostTypes*/,21/*vs/workbench/api/node/extHostTypeConverters*/,38/*vs/base/common/linkedList*/]), function (require, exports, uri_1, async_1, errors_1, extHostTypes_1, extHostTypeConverters_1, linkedList_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentSaveParticipant = /** @class */ (function () {
        function ExtHostDocumentSaveParticipant(_logService, _documents, _mainThreadEditors, _thresholds) {
            if (_thresholds === void 0) { _thresholds = { timeout: 1500, errors: 3 }; }
            this._logService = _logService;
            this._documents = _documents;
            this._mainThreadEditors = _mainThreadEditors;
            this._thresholds = _thresholds;
            this._callbacks = new linkedList_1.LinkedList();
            this._badListeners = new WeakMap();
            //
        }
        ExtHostDocumentSaveParticipant.prototype.dispose = function () {
            this._callbacks.clear();
        };
        ExtHostDocumentSaveParticipant.prototype.getOnWillSaveTextDocumentEvent = function (extension) {
            var _this = this;
            return function (listener, thisArg, disposables) {
                var remove = _this._callbacks.push([listener, thisArg, extension]);
                var result = { dispose: remove };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        };
        ExtHostDocumentSaveParticipant.prototype.$participateInSave = function (data, reason) {
            var _this = this;
            var resource = uri_1.URI.revive(data);
            var entries = this._callbacks.toArray();
            var didTimeout = false;
            var didTimeoutHandle = setTimeout(function () { return didTimeout = true; }, this._thresholds.timeout);
            var promise = async_1.sequence(entries.map(function (listener) {
                return function () {
                    if (didTimeout) {
                        // timeout - no more listeners
                        return undefined;
                    }
                    var document = _this._documents.getDocumentData(resource).document;
                    return _this._deliverEventAsyncAndBlameBadListeners(listener, { document: document, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) });
                };
            }));
            return async_1.always(promise, function () { return clearTimeout(didTimeoutHandle); });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsyncAndBlameBadListeners = function (_a, stubEvent) {
            var _this = this;
            var listener = _a[0], thisArg = _a[1], extension = _a[2];
            var errors = this._badListeners.get(listener);
            if (errors > this._thresholds.errors) {
                // bad listener - ignore
                return Promise.resolve(false);
            }
            return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(function () {
                // don't send result across the wire
                return true;
            }, function (err) {
                _this._logService.error("onWillSaveTextDocument-listener from extension '" + extension.id + "' threw ERROR");
                _this._logService.error(err);
                if (!(err instanceof Error) || err.message !== 'concurrent_edits') {
                    var errors_2 = _this._badListeners.get(listener);
                    _this._badListeners.set(listener, !errors_2 ? 1 : errors_2 + 1);
                    if (errors_2 > _this._thresholds.errors) {
                        _this._logService.info("onWillSaveTextDocument-listener from extension '" + extension.id + "' will now be IGNORED because of timeouts and/or errors");
                    }
                }
                return false;
            });
        };
        ExtHostDocumentSaveParticipant.prototype._deliverEventAsync = function (extension, listener, thisArg, stubEvent) {
            var _this = this;
            var promises = [];
            var t1 = Date.now();
            var document = stubEvent.document, reason = stubEvent.reason;
            var version = document.version;
            var event = Object.freeze({
                document: document,
                reason: reason,
                waitUntil: function (p) {
                    if (Object.isFrozen(promises)) {
                        throw errors_1.illegalState('waitUntil can not be called async');
                    }
                    promises.push(Promise.resolve(p));
                }
            });
            try {
                // fire event
                listener.apply(thisArg, [event]);
            }
            catch (err) {
                return Promise.reject(err);
            }
            // freeze promises after event call
            Object.freeze(promises);
            return new Promise(function (resolve, reject) {
                // join on all listener promises, reject after timeout
                var handle = setTimeout(function () { return reject(new Error('timeout')); }, _this._thresholds.timeout);
                return Promise.all(promises).then(function (edits) {
                    _this._logService.debug("onWillSaveTextDocument-listener from extension '" + extension.id + "' finished after " + (Date.now() - t1) + "ms");
                    clearTimeout(handle);
                    resolve(edits);
                }).catch(function (err) {
                    clearTimeout(handle);
                    reject(err);
                });
            }).then(function (values) {
                var resourceEdit = {
                    resource: document.uri,
                    edits: []
                };
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    if (Array.isArray(value) && value.every(function (e) { return e instanceof extHostTypes_1.TextEdit; })) {
                        for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                            var _b = value_1[_a], newText = _b.newText, newEol = _b.newEol, range = _b.range;
                            resourceEdit.edits.push({
                                range: range && extHostTypeConverters_1.Range.from(range),
                                text: newText,
                                eol: extHostTypeConverters_1.EndOfLine.from(newEol)
                            });
                        }
                    }
                }
                // apply edits if any and if document
                // didn't change somehow in the meantime
                if (resourceEdit.edits.length === 0) {
                    return undefined;
                }
                if (version === document.version) {
                    return _this._mainThreadEditors.$tryApplyWorkspaceEdit({ edits: [resourceEdit] });
                }
                // TODO@joh bubble this to listener?
                return Promise.reject(new Error('concurrent_edits'));
            });
        };
        return ExtHostDocumentSaveParticipant;
    }());
    exports.ExtHostDocumentSaveParticipant = ExtHostDocumentSaveParticipant;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define(__m[137/*vs/workbench/api/node/extHostProgress*/], __M([1/*require*/,0/*exports*/,21/*vs/workbench/api/node/extHostTypeConverters*/,109/*vs/platform/progress/common/progress*/,85/*vs/nls!vs/workbench/api/node/extHostProgress*/,17/*vs/base/common/cancellation*/,75/*vs/base/common/decorators*/]), function (require, exports, extHostTypeConverters_1, progress_1, nls_1, cancellation_1, decorators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostProgress = /** @class */ (function () {
        function ExtHostProgress(proxy) {
            this._handles = 0;
            this._mapHandleToCancellationSource = new Map();
            this._proxy = proxy;
        }
        ExtHostProgress.prototype.withProgress = function (extension, options, task) {
            var handle = this._handles++;
            var title = options.title, location = options.location, cancellable = options.cancellable;
            var source = nls_1.localize(0, null, extension.displayName || extension.name);
            this._proxy.$startProgress(handle, { location: extHostTypeConverters_1.ProgressLocation.from(location), title: title, source: source, cancellable: cancellable });
            return this._withProgress(handle, task, cancellable);
        };
        ExtHostProgress.prototype._withProgress = function (handle, task, cancellable) {
            var _this = this;
            var source;
            if (cancellable) {
                source = new cancellation_1.CancellationTokenSource();
                this._mapHandleToCancellationSource.set(handle, source);
            }
            var progressEnd = function (handle) {
                _this._proxy.$progressEnd(handle);
                _this._mapHandleToCancellationSource.delete(handle);
                if (source) {
                    source.dispose();
                }
            };
            var p;
            try {
                p = task(new ProgressCallback(this._proxy, handle), cancellable ? source.token : cancellation_1.CancellationToken.None);
            }
            catch (err) {
                progressEnd(handle);
                throw err;
            }
            p.then(function (result) { return progressEnd(handle); }, function (err) { return progressEnd(handle); });
            return p;
        };
        ExtHostProgress.prototype.$acceptProgressCanceled = function (handle) {
            var source = this._mapHandleToCancellationSource.get(handle);
            if (source) {
                source.cancel();
                this._mapHandleToCancellationSource.delete(handle);
            }
        };
        return ExtHostProgress;
    }());
    exports.ExtHostProgress = ExtHostProgress;
    function mergeProgress(result, currentValue) {
        result.message = currentValue.message;
        if (typeof currentValue.increment === 'number') {
            if (typeof result.increment === 'number') {
                result.increment += currentValue.increment;
            }
            else {
                result.increment = currentValue.increment;
            }
        }
        return result;
    }
    var ProgressCallback = /** @class */ (function (_super) {
        __extends(ProgressCallback, _super);
        function ProgressCallback(_proxy, _handle) {
            var _this = _super.call(this, function (p) { return _this.throttledReport(p); }) || this;
            _this._proxy = _proxy;
            _this._handle = _handle;
            return _this;
        }
        ProgressCallback.prototype.throttledReport = function (p) {
            this._proxy.$progressReport(this._handle, p);
        };
        __decorate([
            decorators_1.debounce(100, function (result, currentValue) { return mergeProgress(result, currentValue); }, function () { return Object.create(null); })
        ], ProgressCallback.prototype, "throttledReport", null);
        return ProgressCallback;
    }(progress_1.Progress));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






define(__m[70/*vs/workbench/api/node/extHostTextEditor*/], __M([1/*require*/,0/*exports*/,48/*vs/base/common/assert*/,14/*vs/base/common/errors*/,177/*vs/base/common/idGenerator*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, assert_1, errors_1, idGenerator_1, TypeConverters, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorDecorationType = /** @class */ (function () {
        function TextEditorDecorationType(proxy, options) {
            this.key = TextEditorDecorationType._Keys.nextId();
            this._proxy = proxy;
            this._proxy.$registerTextEditorDecorationType(this.key, options);
        }
        TextEditorDecorationType.prototype.dispose = function () {
            this._proxy.$removeTextEditorDecorationType(this.key);
        };
        TextEditorDecorationType._Keys = new idGenerator_1.IdGenerator('TextEditorDecorationType');
        return TextEditorDecorationType;
    }());
    exports.TextEditorDecorationType = TextEditorDecorationType;
    var TextEditorEdit = /** @class */ (function () {
        function TextEditorEdit(document, options) {
            this._document = document;
            this._documentVersionId = document.version;
            this._collectedEdits = [];
            this._setEndOfLine = 0;
            this._undoStopBefore = options.undoStopBefore;
            this._undoStopAfter = options.undoStopAfter;
        }
        TextEditorEdit.prototype.finalize = function () {
            return {
                documentVersionId: this._documentVersionId,
                edits: this._collectedEdits,
                setEndOfLine: this._setEndOfLine,
                undoStopBefore: this._undoStopBefore,
                undoStopAfter: this._undoStopAfter
            };
        };
        TextEditorEdit.prototype.replace = function (location, value) {
            var range = null;
            if (location instanceof extHostTypes_1.Position) {
                range = new extHostTypes_1.Range(location, location);
            }
            else if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, value, false);
        };
        TextEditorEdit.prototype.insert = function (location, value) {
            this._pushEdit(new extHostTypes_1.Range(location, location), value, true);
        };
        TextEditorEdit.prototype.delete = function (location) {
            var range = null;
            if (location instanceof extHostTypes_1.Range) {
                range = location;
            }
            else {
                throw new Error('Unrecognized location');
            }
            this._pushEdit(range, null, true);
        };
        TextEditorEdit.prototype._pushEdit = function (range, text, forceMoveMarkers) {
            var validRange = this._document.validateRange(range);
            this._collectedEdits.push({
                range: validRange,
                text: text,
                forceMoveMarkers: forceMoveMarkers
            });
        };
        TextEditorEdit.prototype.setEndOfLine = function (endOfLine) {
            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {
                throw errors_1.illegalArgument('endOfLine');
            }
            this._setEndOfLine = endOfLine;
        };
        return TextEditorEdit;
    }());
    exports.TextEditorEdit = TextEditorEdit;
    function deprecated(name, message) {
        if (message === void 0) { message = 'Refer to the documentation for further details.'; }
        return function (target, key, descriptor) {
            var originalMethod = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                console.warn("[Deprecation Warning] method '" + name + "' is deprecated and should no longer be used. " + message);
                return originalMethod.apply(this, args);
            };
            return descriptor;
        };
    }
    var ExtHostTextEditorOptions = /** @class */ (function () {
        function ExtHostTextEditorOptions(proxy, id, source) {
            this._proxy = proxy;
            this._id = id;
            this._accept(source);
        }
        ExtHostTextEditorOptions.prototype._accept = function (source) {
            this._tabSize = source.tabSize;
            this._insertSpaces = source.insertSpaces;
            this._cursorStyle = source.cursorStyle;
            this._lineNumbers = source.lineNumbers;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "tabSize", {
            get: function () {
                return this._tabSize;
            },
            set: function (value) {
                var tabSize = this._validateTabSize(value);
                if (tabSize === null) {
                    // ignore invalid call
                    return;
                }
                if (typeof tabSize === 'number') {
                    if (this._tabSize === tabSize) {
                        // nothing to do
                        return;
                    }
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    tabSize: tabSize
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateTabSize = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            if (typeof value === 'number') {
                var r = Math.floor(value);
                return (r > 0 ? r : null);
            }
            if (typeof value === 'string') {
                var r = parseInt(value, 10);
                if (isNaN(r)) {
                    return null;
                }
                return (r > 0 ? r : null);
            }
            return null;
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "insertSpaces", {
            get: function () {
                return this._insertSpaces;
            },
            set: function (value) {
                var insertSpaces = this._validateInsertSpaces(value);
                if (typeof insertSpaces === 'boolean') {
                    if (this._insertSpaces === insertSpaces) {
                        // nothing to do
                        return;
                    }
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                }
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    insertSpaces: insertSpaces
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype._validateInsertSpaces = function (value) {
            if (value === 'auto') {
                return 'auto';
            }
            return (value === 'false' ? false : Boolean(value));
        };
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "cursorStyle", {
            get: function () {
                return this._cursorStyle;
            },
            set: function (value) {
                if (this._cursorStyle === value) {
                    // nothing to do
                    return;
                }
                this._cursorStyle = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    cursorStyle: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditorOptions.prototype, "lineNumbers", {
            get: function () {
                return this._lineNumbers;
            },
            set: function (value) {
                if (this._lineNumbers === value) {
                    // nothing to do
                    return;
                }
                this._lineNumbers = value;
                warnOnError(this._proxy.$trySetOptions(this._id, {
                    lineNumbers: value
                }));
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditorOptions.prototype.assign = function (newOptions) {
            var bulkConfigurationUpdate = {};
            var hasUpdate = false;
            if (typeof newOptions.tabSize !== 'undefined') {
                var tabSize = this._validateTabSize(newOptions.tabSize);
                if (tabSize === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
                else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {
                    // reflect the new tabSize value immediately
                    this._tabSize = tabSize;
                    hasUpdate = true;
                    bulkConfigurationUpdate.tabSize = tabSize;
                }
            }
            if (typeof newOptions.insertSpaces !== 'undefined') {
                var insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
                if (insertSpaces === 'auto') {
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
                else if (this._insertSpaces !== insertSpaces) {
                    // reflect the new insertSpaces value immediately
                    this._insertSpaces = insertSpaces;
                    hasUpdate = true;
                    bulkConfigurationUpdate.insertSpaces = insertSpaces;
                }
            }
            if (typeof newOptions.cursorStyle !== 'undefined') {
                if (this._cursorStyle !== newOptions.cursorStyle) {
                    this._cursorStyle = newOptions.cursorStyle;
                    hasUpdate = true;
                    bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
                }
            }
            if (typeof newOptions.lineNumbers !== 'undefined') {
                if (this._lineNumbers !== newOptions.lineNumbers) {
                    this._lineNumbers = newOptions.lineNumbers;
                    hasUpdate = true;
                    bulkConfigurationUpdate.lineNumbers = newOptions.lineNumbers;
                }
            }
            if (hasUpdate) {
                warnOnError(this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
            }
        };
        return ExtHostTextEditorOptions;
    }());
    exports.ExtHostTextEditorOptions = ExtHostTextEditorOptions;
    var ExtHostTextEditor = /** @class */ (function () {
        function ExtHostTextEditor(proxy, id, document, selections, options, visibleRanges, viewColumn) {
            this._disposed = false;
            this._proxy = proxy;
            this._id = id;
            this._documentData = document;
            this._selections = selections;
            this._options = new ExtHostTextEditorOptions(this._proxy, this._id, options);
            this._visibleRanges = visibleRanges;
            this._viewColumn = viewColumn;
            this._hasDecorationsForKey = Object.create(null);
        }
        Object.defineProperty(ExtHostTextEditor.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.dispose = function () {
            assert_1.ok(!this._disposed);
            this._disposed = true;
        };
        ExtHostTextEditor.prototype.show = function (column) {
            this._proxy.$tryShowEditor(this._id, TypeConverters.ViewColumn.from(column));
        };
        ExtHostTextEditor.prototype.hide = function () {
            this._proxy.$tryHideEditor(this._id);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "document", {
            // ---- the document
            get: function () {
                return this._documentData.document;
            },
            set: function (value) {
                throw errors_1.readonly('document');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "options", {
            // ---- options
            get: function () {
                return this._options;
            },
            set: function (value) {
                if (!this._disposed) {
                    this._options.assign(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptOptions = function (options) {
            assert_1.ok(!this._disposed);
            this._options._accept(options);
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "visibleRanges", {
            // ---- visible ranges
            get: function () {
                return this._visibleRanges;
            },
            set: function (value) {
                throw errors_1.readonly('visibleRanges');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptVisibleRanges = function (value) {
            assert_1.ok(!this._disposed);
            this._visibleRanges = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "viewColumn", {
            // ---- view column
            get: function () {
                return this._viewColumn;
            },
            set: function (value) {
                throw errors_1.readonly('viewColumn');
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype._acceptViewColumn = function (value) {
            assert_1.ok(!this._disposed);
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostTextEditor.prototype, "selection", {
            // ---- selections
            get: function () {
                return this._selections && this._selections[0];
            },
            set: function (value) {
                if (!(value instanceof extHostTypes_1.Selection)) {
                    throw errors_1.illegalArgument('selection');
                }
                this._selections = [value];
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTextEditor.prototype, "selections", {
            get: function () {
                return this._selections;
            },
            set: function (value) {
                if (!Array.isArray(value) || value.some(function (a) { return !(a instanceof extHostTypes_1.Selection); })) {
                    throw errors_1.illegalArgument('selections');
                }
                this._selections = value;
                this._trySetSelection();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTextEditor.prototype.setDecorations = function (decorationType, ranges) {
            var _this = this;
            var willBeEmpty = (ranges.length === 0);
            if (willBeEmpty && !this._hasDecorationsForKey[decorationType.key]) {
                // avoid no-op call to the renderer
                return;
            }
            if (willBeEmpty) {
                delete this._hasDecorationsForKey[decorationType.key];
            }
            else {
                this._hasDecorationsForKey[decorationType.key] = true;
            }
            this._runOnProxy(function () {
                if (TypeConverters.isDecorationOptionsArr(ranges)) {
                    return _this._proxy.$trySetDecorations(_this._id, decorationType.key, TypeConverters.fromRangeOrRangeWithMessage(ranges));
                }
                else {
                    var _ranges = new Array(4 * ranges.length);
                    for (var i = 0, len = ranges.length; i < len; i++) {
                        var range = ranges[i];
                        _ranges[4 * i] = range.start.line + 1;
                        _ranges[4 * i + 1] = range.start.character + 1;
                        _ranges[4 * i + 2] = range.end.line + 1;
                        _ranges[4 * i + 3] = range.end.character + 1;
                    }
                    return _this._proxy.$trySetDecorationsFast(_this._id, decorationType.key, _ranges);
                }
            });
        };
        ExtHostTextEditor.prototype.revealRange = function (range, revealType) {
            var _this = this;
            this._runOnProxy(function () { return _this._proxy.$tryRevealRange(_this._id, TypeConverters.Range.from(range), (revealType || extHostTypes_1.TextEditorRevealType.Default)); });
        };
        ExtHostTextEditor.prototype._trySetSelection = function () {
            var _this = this;
            var selection = this._selections.map(TypeConverters.Selection.from);
            return this._runOnProxy(function () { return _this._proxy.$trySetSelections(_this._id, selection); });
        };
        ExtHostTextEditor.prototype._acceptSelections = function (selections) {
            assert_1.ok(!this._disposed);
            this._selections = selections;
        };
        // ---- editing
        ExtHostTextEditor.prototype.edit = function (callback, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return Promise.reject(new Error('TextEditor#edit not possible on closed editors'));
            }
            var edit = new TextEditorEdit(this._documentData.document, options);
            callback(edit);
            return this._applyEdit(edit);
        };
        ExtHostTextEditor.prototype._applyEdit = function (editBuilder) {
            var editData = editBuilder.finalize();
            // return when there is nothing to do
            if (editData.edits.length === 0 && !editData.setEndOfLine) {
                return Promise.resolve(true);
            }
            // check that the edits are not overlapping (i.e. illegal)
            var editRanges = editData.edits.map(function (edit) { return edit.range; });
            // sort ascending (by end and then by start)
            editRanges.sort(function (a, b) {
                if (a.end.line === b.end.line) {
                    if (a.end.character === b.end.character) {
                        if (a.start.line === b.start.line) {
                            return a.start.character - b.start.character;
                        }
                        return a.start.line - b.start.line;
                    }
                    return a.end.character - b.end.character;
                }
                return a.end.line - b.end.line;
            });
            // check that no edits are overlapping
            for (var i = 0, count = editRanges.length - 1; i < count; i++) {
                var rangeEnd = editRanges[i].end;
                var nextRangeStart = editRanges[i + 1].start;
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    return Promise.reject(new Error('Overlapping ranges are not allowed!'));
                }
            }
            // prepare data for serialization
            var edits = editData.edits.map(function (edit) {
                return {
                    range: TypeConverters.Range.from(edit.range),
                    text: edit.text,
                    forceMoveMarkers: edit.forceMoveMarkers
                };
            });
            return this._proxy.$tryApplyEdits(this._id, editData.documentVersionId, edits, {
                setEndOfLine: editData.setEndOfLine,
                undoStopBefore: editData.undoStopBefore,
                undoStopAfter: editData.undoStopAfter
            });
        };
        ExtHostTextEditor.prototype.insertSnippet = function (snippet, where, options) {
            if (options === void 0) { options = { undoStopBefore: true, undoStopAfter: true }; }
            if (this._disposed) {
                return Promise.reject(new Error('TextEditor#insertSnippet not possible on closed editors'));
            }
            var ranges;
            if (!where || (Array.isArray(where) && where.length === 0)) {
                ranges = this._selections.map(TypeConverters.Range.from);
            }
            else if (where instanceof extHostTypes_1.Position) {
                var _a = TypeConverters.Position.from(where), lineNumber = _a.lineNumber, column = _a.column;
                ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
            }
            else if (where instanceof extHostTypes_1.Range) {
                ranges = [TypeConverters.Range.from(where)];
            }
            else {
                ranges = [];
                for (var _i = 0, where_1 = where; _i < where_1.length; _i++) {
                    var posOrRange = where_1[_i];
                    if (posOrRange instanceof extHostTypes_1.Range) {
                        ranges.push(TypeConverters.Range.from(posOrRange));
                    }
                    else {
                        var _b = TypeConverters.Position.from(posOrRange), lineNumber = _b.lineNumber, column = _b.column;
                        ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                    }
                }
            }
            return this._proxy.$tryInsertSnippet(this._id, snippet.value, ranges, options);
        };
        // ---- util
        ExtHostTextEditor.prototype._runOnProxy = function (callback) {
            var _this = this;
            if (this._disposed) {
                console.warn('TextEditor is closed/disposed');
                return Promise.resolve(undefined);
            }
            return callback().then(function () { return _this; }, function (err) {
                if (!(err instanceof Error && err.name === 'DISPOSED')) {
                    console.warn(err);
                }
                return null;
            });
        };
        __decorate([
            deprecated('TextEditor.show')
        ], ExtHostTextEditor.prototype, "show", null);
        __decorate([
            deprecated('TextEditor.hide')
        ], ExtHostTextEditor.prototype, "hide", null);
        return ExtHostTextEditor;
    }());
    exports.ExtHostTextEditor = ExtHostTextEditor;
    function warnOnError(promise) {
        promise.then(null, function (err) {
            console.warn(err);
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[46/*vs/workbench/services/extensions/common/extensions*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IExtensionService = instantiation_1.createDecorator('extensionService');
    var ActivationTimes = /** @class */ (function () {
        function ActivationTimes(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {
            this.startup = startup;
            this.codeLoadingTime = codeLoadingTime;
            this.activateCallTime = activateCallTime;
            this.activateResolvedTime = activateResolvedTime;
            this.activationEvent = activationEvent;
        }
        return ActivationTimes;
    }());
    exports.ActivationTimes = ActivationTimes;
    var ExtensionPointContribution = /** @class */ (function () {
        function ExtensionPointContribution(description, value) {
            this.description = description;
            this.value = value;
        }
        return ExtensionPointContribution;
    }());
    exports.ExtensionPointContribution = ExtensionPointContribution;
    exports.ExtensionHostLogFileName = 'exthost';
    function checkProposedApiEnabled(extension) {
        if (!extension.enableProposedApi) {
            throwProposedApiError(extension);
        }
    }
    exports.checkProposedApiEnabled = checkProposedApiEnabled;
    function throwProposedApiError(extension) {
        throw new Error("[" + extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + extension.id);
    }
    exports.throwProposedApiError = throwProposedApiError;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[140/*vs/workbench/api/node/extHostLogService*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/paths*/,33/*vs/platform/log/common/log*/,61/*vs/platform/log/node/spdlogService*/,46/*vs/workbench/services/extensions/common/extensions*/,2/*vs/base/common/uri*/]), function (require, exports, paths_1, log_1, spdlogService_1, extensions_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostLogService = /** @class */ (function (_super) {
        __extends(ExtHostLogService, _super);
        function ExtHostLogService(logLevel, logsPath) {
            var _this = _super.call(this, spdlogService_1.createSpdLogService(extensions_1.ExtensionHostLogFileName, logLevel, logsPath)) || this;
            _this._logsPath = logsPath;
            _this.logFile = uri_1.URI.file(paths_1.join(logsPath, extensions_1.ExtensionHostLogFileName + ".log"));
            return _this;
        }
        ExtHostLogService.prototype.$setLevel = function (level) {
            this.setLevel(level);
        };
        ExtHostLogService.prototype.getLogDirectory = function (extensionID) {
            return paths_1.join(this._logsPath, extensionID);
        };
        return ExtHostLogService;
    }(log_1.DelegatedLogService));
    exports.ExtHostLogService = ExtHostLogService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[141/*vs/workbench/api/node/extHostTreeViews*/], __M([1/*require*/,0/*exports*/,87/*vs/nls!vs/workbench/api/node/extHostTreeViews*/,12/*vs/base/common/paths*/,2/*vs/base/common/uri*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,11/*vs/base/common/async*/,7/*vs/workbench/api/node/extHostTypes*/,18/*vs/base/common/types*/,9/*vs/base/common/arrays*/,46/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, nls_1, paths_1, uri_1, event_1, lifecycle_1, async_1, extHostTypes_1, types_1, arrays_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function toTreeItemLabel(label, extension) {
        if (types_1.isString(label)) {
            return { label: label };
        }
        if (label
            && typeof label === 'object'
            && typeof label.label === 'string') {
            extensions_1.checkProposedApiEnabled(extension);
            var highlights = void 0;
            if (Array.isArray(label.highlights)) {
                highlights = label.highlights.filter((function (highlight) { return highlight.length === 2 && typeof highlight[0] === 'number' && typeof highlight[1] === 'number'; }));
                highlights = highlights.length ? highlights : void 0;
            }
            return { label: label.label, highlights: highlights };
        }
        return void 0;
    }
    var ExtHostTreeViews = /** @class */ (function () {
        function ExtHostTreeViews(_proxy, commands, logService) {
            var _this = this;
            this._proxy = _proxy;
            this.commands = commands;
            this.logService = logService;
            this.treeViews = new Map();
            commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$treeViewId && arg.$treeItemHandle) {
                        return _this.convertArgument(arg);
                    }
                    return arg;
                }
            });
        }
        ExtHostTreeViews.prototype.registerTreeDataProvider = function (id, treeDataProvider, extension) {
            var treeView = this.createTreeView(id, { treeDataProvider: treeDataProvider }, extension);
            return { dispose: function () { return treeView.dispose(); } };
        };
        ExtHostTreeViews.prototype.createTreeView = function (viewId, options, extension) {
            var _this = this;
            if (!options || !options.treeDataProvider) {
                throw new Error('Options with treeDataProvider is mandatory');
            }
            if (options.showCollapseAll) {
                extensions_1.checkProposedApiEnabled(extension);
            }
            var treeView = this.createExtHostTreeViewer(viewId, options, extension);
            return {
                get onDidCollapseElement() { return treeView.onDidCollapseElement; },
                get onDidExpandElement() { return treeView.onDidExpandElement; },
                get selection() { return treeView.selectedElements; },
                get onDidChangeSelection() { return treeView.onDidChangeSelection; },
                get visible() { return treeView.visible; },
                get onDidChangeVisibility() { return treeView.onDidChangeVisibility; },
                reveal: function (element, options) {
                    return treeView.reveal(element, options);
                },
                dispose: function () {
                    _this.treeViews.delete(viewId);
                    treeView.dispose();
                }
            };
        };
        ExtHostTreeViews.prototype.$getChildren = function (treeViewId, treeItemHandle) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                return Promise.reject(new Error(nls_1.localize(0, null, treeViewId)));
            }
            return treeView.getChildren(treeItemHandle);
        };
        ExtHostTreeViews.prototype.$setExpanded = function (treeViewId, treeItemHandle, expanded) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(1, null, treeViewId));
            }
            treeView.setExpanded(treeItemHandle, expanded);
        };
        ExtHostTreeViews.prototype.$setSelection = function (treeViewId, treeItemHandles) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(2, null, treeViewId));
            }
            treeView.setSelection(treeItemHandles);
        };
        ExtHostTreeViews.prototype.$setVisible = function (treeViewId, isVisible) {
            var treeView = this.treeViews.get(treeViewId);
            if (!treeView) {
                throw new Error(nls_1.localize(3, null, treeViewId));
            }
            treeView.setVisible(isVisible);
        };
        ExtHostTreeViews.prototype.createExtHostTreeViewer = function (id, options, extension) {
            var treeView = new ExtHostTreeView(id, options, this._proxy, this.commands.converter, this.logService, extension);
            this.treeViews.set(id, treeView);
            return treeView;
        };
        ExtHostTreeViews.prototype.convertArgument = function (arg) {
            var treeView = this.treeViews.get(arg.$treeViewId);
            return treeView ? treeView.getExtensionElement(arg.$treeItemHandle) : null;
        };
        return ExtHostTreeViews;
    }());
    exports.ExtHostTreeViews = ExtHostTreeViews;
    var ExtHostTreeView = /** @class */ (function (_super) {
        __extends(ExtHostTreeView, _super);
        function ExtHostTreeView(viewId, options, proxy, commands, logService, extension) {
            var _this = _super.call(this) || this;
            _this.viewId = viewId;
            _this.proxy = proxy;
            _this.commands = commands;
            _this.logService = logService;
            _this.extension = extension;
            _this.roots = null;
            _this.elements = new Map();
            _this.nodes = new Map();
            _this._visible = false;
            _this._selectedHandles = [];
            _this._onDidExpandElement = _this._register(new event_1.Emitter());
            _this.onDidExpandElement = _this._onDidExpandElement.event;
            _this._onDidCollapseElement = _this._register(new event_1.Emitter());
            _this.onDidCollapseElement = _this._onDidCollapseElement.event;
            _this._onDidChangeSelection = _this._register(new event_1.Emitter());
            _this.onDidChangeSelection = _this._onDidChangeSelection.event;
            _this._onDidChangeVisibility = _this._register(new event_1.Emitter());
            _this.onDidChangeVisibility = _this._onDidChangeVisibility.event;
            _this.refreshPromise = Promise.resolve(null);
            _this.dataProvider = options.treeDataProvider;
            _this.proxy.$registerTreeViewDataProvider(viewId, { showCollapseAll: !!options.showCollapseAll });
            if (_this.dataProvider.onDidChangeTreeData) {
                var refreshingPromise_1, promiseCallback_1;
                _this._register(event_1.debounceEvent(_this.dataProvider.onDidChangeTreeData, function (last, current) {
                    if (!refreshingPromise_1) {
                        // New refresh has started
                        refreshingPromise_1 = new Promise(function (c) { return promiseCallback_1 = c; });
                        _this.refreshPromise = _this.refreshPromise.then(function () { return refreshingPromise_1; });
                    }
                    return last ? last.concat([current]) : [current];
                }, 200)(function (elements) {
                    var _promiseCallback = promiseCallback_1;
                    refreshingPromise_1 = null;
                    _this.refresh(elements).then(function () { return _promiseCallback(); });
                }));
            }
            return _this;
        }
        Object.defineProperty(ExtHostTreeView.prototype, "visible", {
            get: function () { return this._visible; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTreeView.prototype, "selectedElements", {
            get: function () {
                var _this = this;
                return this._selectedHandles.map(function (handle) { return _this.getExtensionElement(handle); }).filter(function (element) { return !types_1.isUndefinedOrNull(element); });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTreeView.prototype.getChildren = function (parentHandle) {
            var parentElement = parentHandle ? this.getExtensionElement(parentHandle) : void 0;
            if (parentHandle && !parentElement) {
                console.error("No tree item with id '" + parentHandle + "' found.");
                return Promise.resolve([]);
            }
            var childrenNodes = this.getChildrenNodes(parentHandle); // Get it from cache
            return (childrenNodes ? Promise.resolve(childrenNodes) : this.fetchChildrenNodes(parentElement))
                .then(function (nodes) { return nodes.map(function (n) { return n.item; }); });
        };
        ExtHostTreeView.prototype.getExtensionElement = function (treeItemHandle) {
            return this.elements.get(treeItemHandle);
        };
        ExtHostTreeView.prototype.reveal = function (element, options) {
            var _this = this;
            options = options ? options : { select: true, focus: false };
            var select = types_1.isUndefinedOrNull(options.select) ? true : options.select;
            var focus = types_1.isUndefinedOrNull(options.focus) ? false : options.focus;
            var expand = types_1.isUndefinedOrNull(options.expand) ? false : options.expand;
            if (typeof this.dataProvider.getParent !== 'function') {
                return Promise.reject(new Error("Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method"));
            }
            return this.refreshPromise
                .then(function () { return _this.resolveUnknownParentChain(element); })
                .then(function (parentChain) { return _this.resolveTreeNode(element, parentChain[parentChain.length - 1])
                .then(function (treeNode) { return _this.proxy.$reveal(_this.viewId, treeNode.item, parentChain.map(function (p) { return p.item; }), { select: select, focus: focus, expand: expand }); }); }, function (error) { return _this.logService.error(error); });
        };
        ExtHostTreeView.prototype.setExpanded = function (treeItemHandle, expanded) {
            var element = this.getExtensionElement(treeItemHandle);
            if (element) {
                if (expanded) {
                    this._onDidExpandElement.fire(Object.freeze({ element: element }));
                }
                else {
                    this._onDidCollapseElement.fire(Object.freeze({ element: element }));
                }
            }
        };
        ExtHostTreeView.prototype.setSelection = function (treeItemHandles) {
            if (!arrays_1.equals(this._selectedHandles, treeItemHandles)) {
                this._selectedHandles = treeItemHandles;
                this._onDidChangeSelection.fire(Object.freeze({ selection: this.selectedElements }));
            }
        };
        ExtHostTreeView.prototype.setVisible = function (visible) {
            if (visible !== this._visible) {
                this._visible = visible;
                this._onDidChangeVisibility.fire(Object.freeze({ visible: this._visible }));
            }
        };
        ExtHostTreeView.prototype.resolveUnknownParentChain = function (element) {
            var _this = this;
            return this.resolveParent(element)
                .then(function (parent) {
                if (!parent) {
                    return Promise.resolve([]);
                }
                return _this.resolveUnknownParentChain(parent)
                    .then(function (result) { return _this.resolveTreeNode(parent, result[result.length - 1])
                    .then(function (parentNode) {
                    result.push(parentNode);
                    return result;
                }); });
            });
        };
        ExtHostTreeView.prototype.resolveParent = function (element) {
            var _this = this;
            var node = this.nodes.get(element);
            if (node) {
                return Promise.resolve(node.parent ? this.elements.get(node.parent.item.handle) : null);
            }
            return async_1.asThenable(function () { return _this.dataProvider.getParent(element); });
        };
        ExtHostTreeView.prototype.resolveTreeNode = function (element, parent) {
            var _this = this;
            var node = this.nodes.get(element);
            if (node) {
                return Promise.resolve(node);
            }
            return async_1.asThenable(function () { return _this.dataProvider.getTreeItem(element); })
                .then(function (extTreeItem) { return _this.createHandle(element, extTreeItem, parent, true); })
                .then(function (handle) { return _this.getChildren(parent ? parent.item.handle : null)
                .then(function () {
                var cachedElement = _this.getExtensionElement(handle);
                if (cachedElement) {
                    var node_1 = _this.nodes.get(cachedElement);
                    if (node_1) {
                        return Promise.resolve(node_1);
                    }
                }
                throw new Error("Cannot resolve tree item for element " + handle);
            }); });
        };
        ExtHostTreeView.prototype.getChildrenNodes = function (parentNodeOrHandle) {
            if (parentNodeOrHandle) {
                var parentNode = void 0;
                if (typeof parentNodeOrHandle === 'string') {
                    var parentElement = this.getExtensionElement(parentNodeOrHandle);
                    parentNode = parentElement ? this.nodes.get(parentElement) : null;
                }
                else {
                    parentNode = parentNodeOrHandle;
                }
                return parentNode ? parentNode.children : null;
            }
            return this.roots;
        };
        ExtHostTreeView.prototype.fetchChildrenNodes = function (parentElement) {
            var _this = this;
            // clear children cache
            this.clearChildren(parentElement);
            var parentNode = parentElement ? this.nodes.get(parentElement) : void 0;
            return async_1.asThenable(function () { return _this.dataProvider.getChildren(parentElement); })
                .then(function (elements) { return Promise.all((elements || [])
                .filter(function (element) { return !!element; })
                .map(function (element) { return async_1.asThenable(function () { return _this.dataProvider.getTreeItem(element); })
                .then(function (extTreeItem) { return extTreeItem ? _this.createAndRegisterTreeNode(element, extTreeItem, parentNode) : null; }); })); })
                .then(function (nodes) { return nodes.filter(function (n) { return !!n; }); });
        };
        ExtHostTreeView.prototype.refresh = function (elements) {
            var hasRoot = elements.some(function (element) { return !element; });
            if (hasRoot) {
                this.clearAll(); // clear cache
                return this.proxy.$refresh(this.viewId);
            }
            else {
                var handlesToRefresh = this.getHandlesToRefresh(elements);
                if (handlesToRefresh.length) {
                    return this.refreshHandles(handlesToRefresh);
                }
            }
            return Promise.resolve(null);
        };
        ExtHostTreeView.prototype.getHandlesToRefresh = function (elements) {
            var _this = this;
            var elementsToUpdate = new Set();
            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                var element = elements_1[_i];
                var elementNode = this.nodes.get(element);
                if (elementNode && !elementsToUpdate.has(elementNode.item.handle)) {
                    // check if an ancestor of extElement is already in the elements to update list
                    var currentNode = elementNode;
                    while (currentNode && currentNode.parent && !elementsToUpdate.has(currentNode.parent.item.handle)) {
                        var parentElement = this.elements.get(currentNode.parent.item.handle);
                        currentNode = this.nodes.get(parentElement);
                    }
                    if (!currentNode.parent) {
                        elementsToUpdate.add(elementNode.item.handle);
                    }
                }
            }
            var handlesToUpdate = [];
            // Take only top level elements
            elementsToUpdate.forEach(function (handle) {
                var element = _this.elements.get(handle);
                var node = _this.nodes.get(element);
                if (node && (!node.parent || !elementsToUpdate.has(node.parent.item.handle))) {
                    handlesToUpdate.push(handle);
                }
            });
            return handlesToUpdate;
        };
        ExtHostTreeView.prototype.refreshHandles = function (itemHandles) {
            var _this = this;
            var itemsToRefresh = {};
            return Promise.all(itemHandles.map(function (treeItemHandle) {
                return _this.refreshNode(treeItemHandle)
                    .then(function (node) {
                    if (node) {
                        itemsToRefresh[treeItemHandle] = node.item;
                    }
                });
            }))
                .then(function () { return Object.keys(itemsToRefresh).length ? _this.proxy.$refresh(_this.viewId, itemsToRefresh) : null; });
        };
        ExtHostTreeView.prototype.refreshNode = function (treeItemHandle) {
            var _this = this;
            var extElement = this.getExtensionElement(treeItemHandle);
            var existing = this.nodes.get(extElement);
            this.clearChildren(extElement); // clear children cache
            return async_1.asThenable(function () { return _this.dataProvider.getTreeItem(extElement); })
                .then(function (extTreeItem) {
                if (extTreeItem) {
                    var newNode = _this.createTreeNode(extElement, extTreeItem, existing.parent);
                    _this.updateNodeCache(extElement, newNode, existing, existing.parent);
                    return newNode;
                }
                return null;
            });
        };
        ExtHostTreeView.prototype.createAndRegisterTreeNode = function (element, extTreeItem, parentNode) {
            var node = this.createTreeNode(element, extTreeItem, parentNode);
            if (extTreeItem.id && this.elements.has(node.item.handle)) {
                throw new Error(nls_1.localize(4, null, extTreeItem.id));
            }
            this.addNodeToCache(element, node);
            this.addNodeToParentCache(node, parentNode);
            return node;
        };
        ExtHostTreeView.prototype.createTreeNode = function (element, extensionTreeItem, parent) {
            return {
                item: this.createTreeItem(element, extensionTreeItem, parent),
                parent: parent,
                children: void 0
            };
        };
        ExtHostTreeView.prototype.createTreeItem = function (element, extensionTreeItem, parent) {
            var handle = this.createHandle(element, extensionTreeItem, parent);
            var icon = this.getLightIconPath(extensionTreeItem);
            var item = {
                handle: handle,
                parentHandle: parent ? parent.item.handle : void 0,
                label: toTreeItemLabel(extensionTreeItem.label, this.extension),
                resourceUri: extensionTreeItem.resourceUri,
                tooltip: typeof extensionTreeItem.tooltip === 'string' ? extensionTreeItem.tooltip : void 0,
                command: extensionTreeItem.command ? this.commands.toInternal(extensionTreeItem.command) : void 0,
                contextValue: extensionTreeItem.contextValue,
                icon: icon,
                iconDark: this.getDarkIconPath(extensionTreeItem) || icon,
                themeIcon: extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon ? { id: extensionTreeItem.iconPath.id } : void 0,
                collapsibleState: types_1.isUndefinedOrNull(extensionTreeItem.collapsibleState) ? extHostTypes_1.TreeItemCollapsibleState.None : extensionTreeItem.collapsibleState
            };
            return item;
        };
        ExtHostTreeView.prototype.createHandle = function (element, _a, parent, returnFirst) {
            var id = _a.id, label = _a.label, resourceUri = _a.resourceUri;
            if (id) {
                return ExtHostTreeView.ID_HANDLE_PREFIX + "/" + id;
            }
            var treeItemLabel = toTreeItemLabel(label, this.extension);
            var prefix = parent ? parent.item.handle : ExtHostTreeView.LABEL_HANDLE_PREFIX;
            var elementId = treeItemLabel ? treeItemLabel.label : resourceUri ? paths_1.basename(resourceUri.path) : '';
            elementId = elementId.indexOf('/') !== -1 ? elementId.replace('/', '//') : elementId;
            var existingHandle = this.nodes.has(element) ? this.nodes.get(element).item.handle : void 0;
            var childrenNodes = (this.getChildrenNodes(parent) || []);
            var handle;
            var counter = 0;
            do {
                handle = prefix + "/" + counter + ":" + elementId;
                if (returnFirst || !this.elements.has(handle) || existingHandle === handle) {
                    // Return first if asked for or
                    // Return if handle does not exist or
                    // Return if handle is being reused
                    break;
                }
                counter++;
            } while (counter <= childrenNodes.length);
            return handle;
        };
        ExtHostTreeView.prototype.getLightIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon)) {
                if (typeof extensionTreeItem.iconPath === 'string'
                    || extensionTreeItem.iconPath instanceof uri_1.URI) {
                    return this.getIconPath(extensionTreeItem.iconPath);
                }
                return this.getIconPath(extensionTreeItem.iconPath['light']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getDarkIconPath = function (extensionTreeItem) {
            if (extensionTreeItem.iconPath && !(extensionTreeItem.iconPath instanceof extHostTypes_1.ThemeIcon) && extensionTreeItem.iconPath['dark']) {
                return this.getIconPath(extensionTreeItem.iconPath['dark']);
            }
            return void 0;
        };
        ExtHostTreeView.prototype.getIconPath = function (iconPath) {
            if (iconPath instanceof uri_1.URI) {
                return iconPath;
            }
            return uri_1.URI.file(iconPath);
        };
        ExtHostTreeView.prototype.addNodeToCache = function (element, node) {
            this.elements.set(node.item.handle, element);
            this.nodes.set(element, node);
        };
        ExtHostTreeView.prototype.updateNodeCache = function (element, newNode, existing, parentNode) {
            // Remove from the cache
            this.elements.delete(newNode.item.handle);
            this.nodes.delete(element);
            if (newNode.item.handle !== existing.item.handle) {
                this.elements.delete(existing.item.handle);
            }
            // Add the new node to the cache
            this.addNodeToCache(element, newNode);
            // Replace the node in parent's children nodes
            var childrenNodes = (this.getChildrenNodes(parentNode) || []);
            var childNode = childrenNodes.filter(function (c) { return c.item.handle === existing.item.handle; })[0];
            if (childNode) {
                childrenNodes.splice(childrenNodes.indexOf(childNode), 1, newNode);
            }
        };
        ExtHostTreeView.prototype.addNodeToParentCache = function (node, parentNode) {
            if (parentNode) {
                if (!parentNode.children) {
                    parentNode.children = [];
                }
                parentNode.children.push(node);
            }
            else {
                if (!this.roots) {
                    this.roots = [];
                }
                this.roots.push(node);
            }
        };
        ExtHostTreeView.prototype.clearChildren = function (parentElement) {
            if (parentElement) {
                var node = this.nodes.get(parentElement);
                if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        var childEleement = this.elements.get(child.item.handle);
                        if (childEleement) {
                            this.clear(childEleement);
                        }
                    }
                }
                node.children = void 0;
            }
            else {
                this.clearAll();
            }
        };
        ExtHostTreeView.prototype.clear = function (element) {
            var node = this.nodes.get(element);
            if (node.children) {
                for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    var childEleement = this.elements.get(child.item.handle);
                    if (childEleement) {
                        this.clear(childEleement);
                    }
                }
            }
            this.nodes.delete(element);
            this.elements.delete(node.item.handle);
        };
        ExtHostTreeView.prototype.clearAll = function () {
            this.roots = null;
            this.elements.clear();
            this.nodes.clear();
        };
        ExtHostTreeView.prototype.dispose = function () {
            this.clearAll();
        };
        ExtHostTreeView.LABEL_HANDLE_PREFIX = '0';
        ExtHostTreeView.ID_HANDLE_PREFIX = '1';
        return ExtHostTreeView;
    }(lifecycle_1.Disposable));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[142/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.hasOwnProperty;
    var ExtensionDescriptionRegistry = /** @class */ (function () {
        function ExtensionDescriptionRegistry(extensionDescriptions) {
            this._extensionsMap = {};
            this._extensionsArr = [];
            this._activationMap = {};
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                var extensionDescription = extensionDescriptions[i];
                if (hasOwnProperty.call(this._extensionsMap, extensionDescription.id)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.id + '` is already registered');
                    continue;
                }
                this._extensionsMap[extensionDescription.id] = extensionDescription;
                this._extensionsArr.push(extensionDescription);
                if (Array.isArray(extensionDescription.activationEvents)) {
                    for (var j = 0, lenJ = extensionDescription.activationEvents.length; j < lenJ; j++) {
                        var activationEvent = extensionDescription.activationEvents[j];
                        // TODO@joao: there's no easy way to contribute this
                        if (activationEvent === 'onUri') {
                            activationEvent = "onUri:" + extensionDescription.id;
                        }
                        this._activationMap[activationEvent] = this._activationMap[activationEvent] || [];
                        this._activationMap[activationEvent].push(extensionDescription);
                    }
                }
            }
        }
        ExtensionDescriptionRegistry.prototype.containsActivationEvent = function (activationEvent) {
            return hasOwnProperty.call(this._activationMap, activationEvent);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescriptionsForActivationEvent = function (activationEvent) {
            if (!hasOwnProperty.call(this._activationMap, activationEvent)) {
                return [];
            }
            return this._activationMap[activationEvent].slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getAllExtensionDescriptions = function () {
            return this._extensionsArr.slice(0);
        };
        ExtensionDescriptionRegistry.prototype.getExtensionDescription = function (extensionId) {
            if (!hasOwnProperty.call(this._extensionsMap, extensionId)) {
                return null;
            }
            return this._extensionsMap[extensionId];
        };
        return ExtensionDescriptionRegistry;
    }());
    exports.ExtensionDescriptionRegistry = ExtensionDescriptionRegistry;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[143/*vs/workbench/services/extensions/node/lazyPromise*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/errors*/,20/*vs/base/common/winjs.base*/]), function (require, exports, errors_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LazyPromise = /** @class */ (function () {
        function LazyPromise() {
            this._actual = null;
            this._actualOk = null;
            this._actualErr = null;
            this._hasValue = false;
            this._value = null;
            this._hasErr = false;
            this._err = null;
        }
        LazyPromise.prototype._ensureActual = function () {
            var _this = this;
            if (!this._actual) {
                this._actual = new winjs_base_1.TPromise(function (c, e) {
                    _this._actualOk = c;
                    _this._actualErr = e;
                    if (_this._hasValue) {
                        _this._actualOk(_this._value);
                    }
                    if (_this._hasErr) {
                        _this._actualErr(_this._err);
                    }
                });
            }
            return this._actual;
        };
        LazyPromise.prototype.resolveOk = function (value) {
            if (this._hasValue || this._hasErr) {
                return;
            }
            this._hasValue = true;
            this._value = value;
            if (this._actual) {
                this._actualOk(value);
            }
        };
        LazyPromise.prototype.resolveErr = function (err) {
            if (this._hasValue || this._hasErr) {
                return;
            }
            this._hasErr = true;
            this._err = err;
            if (this._actual) {
                this._actualErr(err);
            }
            else {
                // If nobody's listening at this point, it is safe to assume they never will,
                // since resolving this promise is always "async"
                errors_1.onUnexpectedError(err);
            }
        };
        LazyPromise.prototype.then = function (success, error) {
            return this._ensureActual().then(success, error);
        };
        return LazyPromise;
    }());
    exports.LazyPromise = LazyPromise;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[71/*vs/workbench/services/extensions/node/proxyIdentifier*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProxyIdentifier = /** @class */ (function () {
        function ProxyIdentifier(isMain, sid) {
            this.isMain = isMain;
            this.sid = sid;
            this.nid = (++ProxyIdentifier.count);
        }
        ProxyIdentifier.count = 0;
        return ProxyIdentifier;
    }());
    exports.ProxyIdentifier = ProxyIdentifier;
    var identifiers = [];
    function createMainContextProxyIdentifier(identifier) {
        var result = new ProxyIdentifier(true, identifier);
        identifiers[result.nid] = result;
        return result;
    }
    exports.createMainContextProxyIdentifier = createMainContextProxyIdentifier;
    function createExtHostContextProxyIdentifier(identifier) {
        var result = new ProxyIdentifier(false, identifier);
        identifiers[result.nid] = result;
        return result;
    }
    exports.createExtHostContextProxyIdentifier = createExtHostContextProxyIdentifier;
    function getStringIdentifierForProxy(nid) {
        return identifiers[nid].sid;
    }
    exports.getStringIdentifierForProxy = getStringIdentifierForProxy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[4/*vs/workbench/api/node/extHost.protocol*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,71/*vs/workbench/services/extensions/node/proxyIdentifier*/]), function (require, exports, uri_1, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextEditorRevealType;
    (function (TextEditorRevealType) {
        TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
        TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
        TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
        TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
    })(TextEditorRevealType = exports.TextEditorRevealType || (exports.TextEditorRevealType = {}));
    var ObjectIdentifier;
    (function (ObjectIdentifier) {
        ObjectIdentifier.name = '$ident';
        function mixin(obj, id) {
            Object.defineProperty(obj, ObjectIdentifier.name, { value: id, enumerable: true });
            return obj;
        }
        ObjectIdentifier.mixin = mixin;
        function of(obj) {
            return obj[ObjectIdentifier.name];
        }
        ObjectIdentifier.of = of;
    })(ObjectIdentifier = exports.ObjectIdentifier || (exports.ObjectIdentifier = {}));
    var IdObject = /** @class */ (function () {
        function IdObject() {
        }
        IdObject.mixin = function (object) {
            object._id = IdObject._n++;
            return object;
        };
        IdObject._n = 0;
        return IdObject;
    }());
    exports.IdObject = IdObject;
    function reviveWorkspaceEditDto(data) {
        if (data && data.edits) {
            for (var _i = 0, _a = data.edits; _i < _a.length; _i++) {
                var edit = _a[_i];
                if (typeof edit.resource === 'object') {
                    edit.resource = uri_1.URI.revive(edit.resource);
                }
                else {
                    edit.newUri = uri_1.URI.revive(edit.newUri);
                    edit.oldUri = uri_1.URI.revive(edit.oldUri);
                }
            }
        }
        return data;
    }
    exports.reviveWorkspaceEditDto = reviveWorkspaceEditDto;
    // --- proxy identifiers
    exports.MainContext = {
        MainThreadClipboard: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadClipboard'),
        MainThreadCommands: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadCommands'),
        MainThreadComments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadComments'),
        MainThreadConfiguration: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadConfiguration'),
        MainThreadDebugService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDebugService'),
        MainThreadDecorations: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDecorations'),
        MainThreadDiagnostics: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiagnostics'),
        MainThreadDialogs: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDiaglogs'),
        MainThreadDocuments: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocuments'),
        MainThreadDocumentContentProviders: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadDocumentContentProviders'),
        MainThreadTextEditors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTextEditors'),
        MainThreadErrors: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadErrors'),
        MainThreadTreeViews: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTreeViews'),
        MainThreadLanguageFeatures: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguageFeatures'),
        MainThreadLanguages: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadLanguages'),
        MainThreadMessageService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadMessageService'),
        MainThreadOutputService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadOutputService'),
        MainThreadProgress: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadProgress'),
        MainThreadQuickOpen: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadQuickOpen'),
        MainThreadStatusBar: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadStatusBar'),
        MainThreadStorage: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadStorage'),
        MainThreadTelemetry: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTelemetry'),
        MainThreadTerminalService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTerminalService'),
        MainThreadWebviews: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWebviews'),
        MainThreadUrls: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadUrls'),
        MainThreadWorkspace: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWorkspace'),
        MainThreadFileSystem: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadFileSystem'),
        MainThreadExtensionService: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadExtensionService'),
        MainThreadSCM: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadSCM'),
        MainThreadSearch: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadSearch'),
        MainThreadTask: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadTask'),
        MainThreadWindow: proxyIdentifier_1.createMainContextProxyIdentifier('MainThreadWindow'),
    };
    exports.ExtHostContext = {
        ExtHostCommands: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostCommands'),
        ExtHostConfiguration: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostConfiguration'),
        ExtHostDiagnostics: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDiagnostics'),
        ExtHostDebugService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDebugService'),
        ExtHostDecorations: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDecorations'),
        ExtHostDocumentsAndEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentsAndEditors'),
        ExtHostDocuments: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocuments'),
        ExtHostDocumentContentProviders: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentContentProviders'),
        ExtHostDocumentSaveParticipant: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostDocumentSaveParticipant'),
        ExtHostEditors: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostEditors'),
        ExtHostTreeViews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTreeViews'),
        ExtHostFileSystem: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystem'),
        ExtHostFileSystemEventService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostFileSystemEventService'),
        ExtHostHeapService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostHeapMonitor'),
        ExtHostLanguageFeatures: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLanguageFeatures'),
        ExtHostQuickOpen: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostQuickOpen'),
        ExtHostExtensionService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostExtensionService'),
        ExtHostLogService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostLogService'),
        ExtHostTerminalService: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTerminalService'),
        ExtHostSCM: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostSCM'),
        ExtHostSearch: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostSearch'),
        ExtHostTask: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostTask'),
        ExtHostWorkspace: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWorkspace'),
        ExtHostWindow: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWindow'),
        ExtHostWebviews: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostWebviews'),
        ExtHostProgress: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostProgress'),
        ExtHostComments: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostComments'),
        ExtHostStorage: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostStorage'),
        ExtHostUrls: proxyIdentifier_1.createExtHostContextProxyIdentifier('ExtHostUrls'),
        ExtHostOutputService: proxyIdentifier_1.createMainContextProxyIdentifier('ExtHostOutputService'),
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[146/*vs/workbench/api/node/extHostClipboard*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostClipboard = /** @class */ (function () {
        function ExtHostClipboard(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadClipboard);
        }
        ExtHostClipboard.prototype.readText = function () {
            return this._proxy.$readText();
        };
        ExtHostClipboard.prototype.writeText = function (value) {
            return this._proxy.$writeText(value);
        };
        return ExtHostClipboard;
    }());
    exports.ExtHostClipboard = ExtHostClipboard;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[147/*vs/workbench/api/node/extHostCommands*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/types*/,7/*vs/workbench/api/node/extHostTypes*/,21/*vs/workbench/api/node/extHostTypeConverters*/,13/*vs/base/common/objects*/,4/*vs/workbench/api/node/extHost.protocol*/,9/*vs/base/common/arrays*/,112/*vs/base/common/marshalling*/]), function (require, exports, types_1, extHostTypes, extHostTypeConverter, objects_1, extHost_protocol_1, arrays_1, marshalling_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostCommands = /** @class */ (function () {
        function ExtHostCommands(mainContext, heapService, logService) {
            this._commands = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadCommands);
            this._logService = logService;
            this._converter = new CommandsConverter(this, heapService);
            this._argumentProcessors = [{ processArgument: function (a) { return marshalling_1.revive(a, 0); } }];
        }
        Object.defineProperty(ExtHostCommands.prototype, "converter", {
            get: function () {
                return this._converter;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostCommands.prototype.registerArgumentProcessor = function (processor) {
            this._argumentProcessors.push(processor);
        };
        ExtHostCommands.prototype.registerCommand = function (global, id, callback, thisArg, description) {
            var _this = this;
            this._logService.trace('ExtHostCommands#registerCommand', id);
            if (!id.trim().length) {
                throw new Error('invalid id');
            }
            if (this._commands.has(id)) {
                throw new Error("command '" + id + "' already exists");
            }
            this._commands.set(id, { callback: callback, thisArg: thisArg, description: description });
            if (global) {
                this._proxy.$registerCommand(id);
            }
            return new extHostTypes.Disposable(function () {
                if (_this._commands.delete(id)) {
                    if (global) {
                        _this._proxy.$unregisterCommand(id);
                    }
                }
            });
        };
        ExtHostCommands.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this._logService.trace('ExtHostCommands#executeCommand', id);
            if (this._commands.has(id)) {
                // we stay inside the extension host and support
                // to pass any kind of parameters around
                return this._executeContributedCommand(id, args);
            }
            else {
                // automagically convert some argument types
                args = objects_1.cloneAndChange(args, function (value) {
                    if (value instanceof extHostTypes.Position) {
                        return extHostTypeConverter.Position.from(value);
                    }
                    if (value instanceof extHostTypes.Range) {
                        return extHostTypeConverter.Range.from(value);
                    }
                    if (value instanceof extHostTypes.Location) {
                        return extHostTypeConverter.location.from(value);
                    }
                    if (!Array.isArray(value)) {
                        return value;
                    }
                });
                return this._proxy.$executeCommand(id, args).then(function (result) { return marshalling_1.revive(result, 0); });
            }
        };
        ExtHostCommands.prototype._executeContributedCommand = function (id, args) {
            var _a = this._commands.get(id), callback = _a.callback, thisArg = _a.thisArg, description = _a.description;
            if (description) {
                for (var i = 0; i < description.args.length; i++) {
                    try {
                        types_1.validateConstraint(args[i], description.args[i].constraint);
                    }
                    catch (err) {
                        return Promise.reject(new Error("Running the contributed command:'" + id + "' failed. Illegal argument '" + description.args[i].name + "' - " + description.args[i].description));
                    }
                }
            }
            try {
                var result = callback.apply(thisArg, args);
                return Promise.resolve(result);
            }
            catch (err) {
                this._logService.error(err, id);
                return Promise.reject(new Error("Running the contributed command:'" + id + "' failed."));
            }
        };
        ExtHostCommands.prototype.$executeContributedCommand = function (id) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this._logService.trace('ExtHostCommands#$executeContributedCommand', id);
            if (!this._commands.has(id)) {
                return Promise.reject(new Error("Contributed command '" + id + "' does not exist."));
            }
            else {
                args = args.map(function (arg) { return _this._argumentProcessors.reduce(function (r, p) { return p.processArgument(r); }, arg); });
                return this._executeContributedCommand(id, args);
            }
        };
        ExtHostCommands.prototype.getCommands = function (filterUnderscoreCommands) {
            if (filterUnderscoreCommands === void 0) { filterUnderscoreCommands = false; }
            this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);
            return this._proxy.$getCommands().then(function (result) {
                if (filterUnderscoreCommands) {
                    result = result.filter(function (command) { return command[0] !== '_'; });
                }
                return result;
            });
        };
        ExtHostCommands.prototype.$getContributedCommandHandlerDescriptions = function () {
            var result = Object.create(null);
            this._commands.forEach(function (command, id) {
                var description = command.description;
                if (description) {
                    result[id] = description;
                }
            });
            return Promise.resolve(result);
        };
        return ExtHostCommands;
    }());
    exports.ExtHostCommands = ExtHostCommands;
    var CommandsConverter = /** @class */ (function () {
        // --- conversion between internal and api commands
        function CommandsConverter(commands, heap) {
            this._delegatingCommandId = "_internal_command_delegation_" + Date.now();
            this._commands = commands;
            this._heap = heap;
            this._commands.registerCommand(true, this._delegatingCommandId, this._executeConvertedCommand, this);
        }
        CommandsConverter.prototype.toInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var result = {
                id: command.command,
                title: command.title
            };
            if (command.command && !arrays_1.isFalsyOrEmpty(command.arguments)) {
                // we have a contributed command with arguments. that
                // means we don't want to send the arguments around
                var id = this._heap.keep(command);
                extHost_protocol_1.ObjectIdentifier.mixin(result, id);
                result.id = this._delegatingCommandId;
                result.arguments = [id];
            }
            if (command.tooltip) {
                result.tooltip = command.tooltip;
            }
            return result;
        };
        CommandsConverter.prototype.fromInternal = function (command) {
            if (!command) {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(command);
            if (typeof id === 'number') {
                return this._heap.get(id);
            }
            else {
                return {
                    command: command.id,
                    title: command.title,
                    arguments: command.arguments
                };
            }
        };
        CommandsConverter.prototype._executeConvertedCommand = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _a;
            var actualCmd = this._heap.get(args[0]);
            return (_a = this._commands).executeCommand.apply(_a, [actualCmd.command].concat(actualCmd.arguments));
        };
        return CommandsConverter;
    }());
    exports.CommandsConverter = CommandsConverter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[148/*vs/workbench/api/node/extHostComments*/], __M([1/*require*/,0/*exports*/,11/*vs/base/common/async*/,2/*vs/base/common/uri*/,21/*vs/workbench/api/node/extHostTypeConverters*/,4/*vs/workbench/api/node/extHost.protocol*/,17/*vs/base/common/cancellation*/]), function (require, exports, async_1, uri_1, extHostTypeConverter, extHost_protocol_1, cancellation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostComments = /** @class */ (function () {
        function ExtHostComments(mainContext, _commandsConverter, _documents) {
            this._commandsConverter = _commandsConverter;
            this._documents = _documents;
            this._documentProviders = new Map();
            this._workspaceProviders = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadComments);
        }
        ExtHostComments.prototype.registerWorkspaceCommentProvider = function (extensionId, provider) {
            var _this = this;
            var handle = ExtHostComments.handlePool++;
            this._workspaceProviders.set(handle, provider);
            this._proxy.$registerWorkspaceCommentProvider(handle, extensionId);
            this.registerListeners(handle, provider);
            return {
                dispose: function () {
                    _this._proxy.$unregisterWorkspaceCommentProvider(handle);
                    _this._workspaceProviders.delete(handle);
                }
            };
        };
        ExtHostComments.prototype.registerDocumentCommentProvider = function (provider) {
            var _this = this;
            var handle = ExtHostComments.handlePool++;
            this._documentProviders.set(handle, provider);
            this._proxy.$registerDocumentCommentProvider(handle);
            this.registerListeners(handle, provider);
            return {
                dispose: function () {
                    _this._proxy.$unregisterDocumentCommentProvider(handle);
                    _this._documentProviders.delete(handle);
                }
            };
        };
        ExtHostComments.prototype.$createNewCommentThread = function (handle, uri, range, text) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.URI.revive(uri));
            var ran = extHostTypeConverter.Range.to(range);
            if (!data || !data.document) {
                return Promise.resolve(null);
            }
            var provider = this._documentProviders.get(handle);
            return async_1.asThenable(function () {
                return provider.createNewCommentThread(data.document, ran, text, cancellation_1.CancellationToken.None);
            }).then(function (commentThread) { return commentThread ? convertToCommentThread(provider, commentThread, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$replyToCommentThread = function (handle, uri, range, thread, text) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.URI.revive(uri));
            var ran = extHostTypeConverter.Range.to(range);
            if (!data || !data.document) {
                return Promise.resolve(null);
            }
            var provider = this._documentProviders.get(handle);
            return async_1.asThenable(function () {
                return provider.replyToCommentThread(data.document, ran, convertFromCommentThread(thread), text, cancellation_1.CancellationToken.None);
            }).then(function (commentThread) { return commentThread ? convertToCommentThread(provider, commentThread, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$editComment = function (handle, uri, comment, text) {
            var data = this._documents.getDocumentData(uri_1.URI.revive(uri));
            if (!data || !data.document) {
                throw new Error('Unable to retrieve document from URI');
            }
            var provider = this._documentProviders.get(handle);
            return async_1.asThenable(function () {
                return provider.editComment(data.document, convertFromComment(comment), text, cancellation_1.CancellationToken.None);
            });
        };
        ExtHostComments.prototype.$deleteComment = function (handle, uri, comment) {
            var data = this._documents.getDocumentData(uri_1.URI.revive(uri));
            if (!data || !data.document) {
                throw new Error('Unable to retrieve document from URI');
            }
            var provider = this._documentProviders.get(handle);
            return async_1.asThenable(function () {
                return provider.deleteComment(data.document, convertFromComment(comment), cancellation_1.CancellationToken.None);
            });
        };
        ExtHostComments.prototype.$provideDocumentComments = function (handle, uri) {
            var _this = this;
            var data = this._documents.getDocumentData(uri_1.URI.revive(uri));
            if (!data || !data.document) {
                return Promise.resolve(null);
            }
            var provider = this._documentProviders.get(handle);
            return async_1.asThenable(function () {
                return provider.provideDocumentComments(data.document, cancellation_1.CancellationToken.None);
            }).then(function (commentInfo) { return commentInfo ? convertCommentInfo(handle, provider, commentInfo, _this._commandsConverter) : null; });
        };
        ExtHostComments.prototype.$provideWorkspaceComments = function (handle) {
            var _this = this;
            var provider = this._workspaceProviders.get(handle);
            if (!provider) {
                return Promise.resolve(null);
            }
            return async_1.asThenable(function () {
                return provider.provideWorkspaceComments(cancellation_1.CancellationToken.None);
            }).then(function (comments) {
                return comments.map(function (comment) { return convertToCommentThread(provider, comment, _this._commandsConverter); });
            });
        };
        ExtHostComments.prototype.registerListeners = function (handle, provider) {
            var _this = this;
            provider.onDidChangeCommentThreads(function (event) {
                _this._proxy.$onDidCommentThreadsChange(handle, {
                    owner: handle,
                    changed: event.changed.map(function (thread) { return convertToCommentThread(provider, thread, _this._commandsConverter); }),
                    added: event.added.map(function (thread) { return convertToCommentThread(provider, thread, _this._commandsConverter); }),
                    removed: event.removed.map(function (thread) { return convertToCommentThread(provider, thread, _this._commandsConverter); })
                });
            });
        };
        ExtHostComments.handlePool = 0;
        return ExtHostComments;
    }());
    exports.ExtHostComments = ExtHostComments;
    function convertCommentInfo(owner, provider, vscodeCommentInfo, commandsConverter) {
        return {
            owner: owner,
            threads: vscodeCommentInfo.threads.map(function (x) { return convertToCommentThread(provider, x, commandsConverter); }),
            commentingRanges: vscodeCommentInfo.commentingRanges ? vscodeCommentInfo.commentingRanges.map(function (range) { return extHostTypeConverter.Range.from(range); }) : []
        };
    }
    function convertToCommentThread(provider, vscodeCommentThread, commandsConverter) {
        return {
            threadId: vscodeCommentThread.threadId,
            resource: vscodeCommentThread.resource.toString(),
            range: extHostTypeConverter.Range.from(vscodeCommentThread.range),
            comments: vscodeCommentThread.comments.map(function (comment) { return convertToComment(provider, comment, commandsConverter); }),
            collapsibleState: vscodeCommentThread.collapsibleState
        };
    }
    function convertFromCommentThread(commentThread) {
        return {
            threadId: commentThread.threadId,
            resource: uri_1.URI.parse(commentThread.resource),
            range: extHostTypeConverter.Range.to(commentThread.range),
            comments: commentThread.comments.map(convertFromComment),
            collapsibleState: commentThread.collapsibleState
        };
    }
    function convertFromComment(comment) {
        var userIconPath;
        if (comment.userIconPath) {
            try {
                userIconPath = uri_1.URI.parse(comment.userIconPath);
            }
            catch (e) {
                // Ignore
            }
        }
        return {
            commentId: comment.commentId,
            body: extHostTypeConverter.MarkdownString.to(comment.body),
            userName: comment.userName,
            userIconPath: userIconPath,
            canEdit: comment.canEdit,
            canDelete: comment.canDelete
        };
    }
    function convertToComment(provider, vscodeComment, commandsConverter) {
        var canEdit = !!provider.editComment && vscodeComment.canEdit;
        var canDelete = !!provider.deleteComment && vscodeComment.canDelete;
        var iconPath = vscodeComment.userIconPath ? vscodeComment.userIconPath.toString() : vscodeComment.gravatar;
        return {
            commentId: vscodeComment.commentId,
            body: extHostTypeConverter.MarkdownString.from(vscodeComment.body),
            userName: vscodeComment.userName,
            userIconPath: iconPath,
            canEdit: canEdit,
            canDelete: canDelete,
            command: vscodeComment.command ? commandsConverter.toInternal(vscodeComment.command) : null
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[73/*vs/workbench/api/node/extHostDebugService*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/paths*/,26/*vs/base/common/network*/,2/*vs/base/common/uri*/,3/*vs/base/common/event*/,11/*vs/base/common/async*/,82/*vs/nls!vs/workbench/api/node/extHostDebugService*/,13/*vs/base/common/objects*/,4/*vs/workbench/api/node/extHost.protocol*/,7/*vs/workbench/api/node/extHostTypes*/,49/*vs/base/common/uuid*/,124/*vs/workbench/parts/debug/node/debugAdapter*/,125/*vs/workbench/parts/debug/node/terminals*/,131/*vs/workbench/services/configurationResolver/node/variableResolver*/,77/*vs/workbench/parts/debug/common/debugUtils*/,17/*vs/base/common/cancellation*/]), function (require, exports, paths, network_1, uri_1, event_1, async_1, nls, objects_1, extHost_protocol_1, extHostTypes_1, uuid_1, debugAdapter_1, terminals_1, variableResolver_1, debugUtils_1, cancellation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDebugService = /** @class */ (function () {
        function ExtHostDebugService(mainContext, _workspaceService, _extensionService, _editorsService, _configurationService, _terminalService, _commandService) {
            var _this = this;
            this._workspaceService = _workspaceService;
            this._extensionService = _extensionService;
            this._editorsService = _editorsService;
            this._configurationService = _configurationService;
            this._terminalService = _terminalService;
            this._commandService = _commandService;
            this._debugSessions = new Map();
            this._providerHandleCounter = 0;
            this._providerByHandle = new Map();
            this._providerByType = new Map();
            this._providers = [];
            this._aexCommands = new Map();
            this._debugAdapters = new Map();
            this._debugAdaptersTrackers = new Map();
            this._onDidStartDebugSession = new event_1.Emitter();
            this._onDidTerminateDebugSession = new event_1.Emitter();
            this._onDidChangeActiveDebugSession = new event_1.Emitter();
            this._onDidReceiveDebugSessionCustomEvent = new event_1.Emitter();
            this._debugServiceProxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDebugService);
            this._onDidChangeBreakpoints = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    _this.startBreakpoints();
                }
            });
            this._activeDebugConsole = new ExtHostDebugConsole(this._debugServiceProxy);
            this._breakpoints = new Map();
            this._breakpointEventsActive = false;
            // register all debug extensions
            var debugTypes = [];
            for (var _i = 0, _a = this._extensionService.getAllExtensionDescriptions(); _i < _a.length; _i++) {
                var ed = _a[_i];
                if (ed.contributes) {
                    var debuggers = ed.contributes['debuggers'];
                    if (debuggers && debuggers.length > 0) {
                        for (var _b = 0, debuggers_1 = debuggers; _b < debuggers_1.length; _b++) {
                            var dbg = debuggers_1[_b];
                            // only debugger contributions with a "label" are considered a "defining" debugger contribution
                            if (dbg.type && dbg.label) {
                                debugTypes.push(dbg.type);
                                if (dbg.adapterExecutableCommand) {
                                    this._aexCommands.set(dbg.type, dbg.adapterExecutableCommand);
                                }
                            }
                        }
                    }
                }
            }
            if (debugTypes.length > 0) {
                this._debugServiceProxy.$registerDebugTypes(debugTypes);
            }
        }
        Object.defineProperty(ExtHostDebugService.prototype, "onDidStartDebugSession", {
            get: function () { return this._onDidStartDebugSession.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "onDidTerminateDebugSession", {
            get: function () { return this._onDidTerminateDebugSession.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "onDidChangeActiveDebugSession", {
            get: function () { return this._onDidChangeActiveDebugSession.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "activeDebugSession", {
            get: function () { return this._activeDebugSession; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "onDidReceiveDebugSessionCustomEvent", {
            get: function () { return this._onDidReceiveDebugSessionCustomEvent.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "activeDebugConsole", {
            get: function () { return this._activeDebugConsole; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "onDidChangeBreakpoints", {
            // extension debug API
            get: function () {
                return this._onDidChangeBreakpoints.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugService.prototype, "breakpoints", {
            get: function () {
                this.startBreakpoints();
                var result = [];
                this._breakpoints.forEach(function (bp) { return result.push(bp); });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDebugService.prototype.addBreakpoints = function (breakpoints0) {
            this.startBreakpoints();
            // assign uuids for brand new breakpoints
            var breakpoints = [];
            for (var _i = 0, breakpoints0_1 = breakpoints0; _i < breakpoints0_1.length; _i++) {
                var bp = breakpoints0_1[_i];
                var id = bp['_id'];
                if (id) { // has already id
                    if (this._breakpoints.has(id)) {
                        // already there
                    }
                    else {
                        breakpoints.push(bp);
                    }
                }
                else {
                    id = uuid_1.generateUuid();
                    bp['_id'] = id;
                    this._breakpoints.set(id, bp);
                    breakpoints.push(bp);
                }
            }
            // send notification for added breakpoints
            this.fireBreakpointChanges(breakpoints, [], []);
            // convert added breakpoints to DTOs
            var dtos = [];
            var map = new Map();
            for (var _a = 0, breakpoints_1 = breakpoints; _a < breakpoints_1.length; _a++) {
                var bp = breakpoints_1[_a];
                if (bp instanceof extHostTypes_1.SourceBreakpoint) {
                    var dto = map.get(bp.location.uri.toString());
                    if (!dto) {
                        dto = {
                            type: 'sourceMulti',
                            uri: bp.location.uri,
                            lines: []
                        };
                        map.set(bp.location.uri.toString(), dto);
                        dtos.push(dto);
                    }
                    dto.lines.push({
                        id: bp['_id'],
                        enabled: bp.enabled,
                        condition: bp.condition,
                        hitCondition: bp.hitCondition,
                        logMessage: bp.logMessage,
                        line: bp.location.range.start.line,
                        character: bp.location.range.start.character
                    });
                }
                else if (bp instanceof extHostTypes_1.FunctionBreakpoint) {
                    dtos.push({
                        type: 'function',
                        id: bp['_id'],
                        enabled: bp.enabled,
                        hitCondition: bp.hitCondition,
                        logMessage: bp.logMessage,
                        condition: bp.condition,
                        functionName: bp.functionName
                    });
                }
            }
            // send DTOs to VS Code
            return this._debugServiceProxy.$registerBreakpoints(dtos);
        };
        ExtHostDebugService.prototype.removeBreakpoints = function (breakpoints0) {
            this.startBreakpoints();
            // remove from array
            var breakpoints = [];
            for (var _i = 0, breakpoints0_2 = breakpoints0; _i < breakpoints0_2.length; _i++) {
                var b = breakpoints0_2[_i];
                var id = b['_id'];
                if (id && this._breakpoints.delete(id)) {
                    breakpoints.push(b);
                }
            }
            // send notification
            this.fireBreakpointChanges([], breakpoints, []);
            // unregister with VS Code
            var ids = breakpoints.filter(function (bp) { return bp instanceof extHostTypes_1.SourceBreakpoint; }).map(function (bp) { return bp['_id']; });
            var fids = breakpoints.filter(function (bp) { return bp instanceof extHostTypes_1.FunctionBreakpoint; }).map(function (bp) { return bp['_id']; });
            return this._debugServiceProxy.$unregisterBreakpoints(ids, fids);
        };
        ExtHostDebugService.prototype.startDebugging = function (folder, nameOrConfig) {
            return this._debugServiceProxy.$startDebugging(folder ? folder.uri : undefined, nameOrConfig);
        };
        ExtHostDebugService.prototype.registerDebugConfigurationProvider = function (extension, type, provider) {
            var _this = this;
            if (!provider) {
                return new extHostTypes_1.Disposable(function () { });
            }
            // if a provider has a provideDebugAdapter method, we check the constraints specified in the API doc
            if (provider.provideDebugAdapter) {
                // a provider with this method can only be registered in the extension that contributes the debugger
                if (!this.definesDebugType(extension, type)) {
                    throw new Error("method 'provideDebugAdapter' must only be called from the extension that defines the '" + type + "' debugger.");
                }
                // make sure that only one provider for this type is registered
                if (this._providerByType.has(type)) {
                    throw new Error("a provider with method 'provideDebugAdapter' can only be registered once per a type.");
                }
                else {
                    this._providerByType.set(type, provider);
                }
            }
            var handle = this._providerHandleCounter++;
            this._providerByHandle.set(handle, provider);
            this._providers.push({ type: type, provider: provider });
            this._debugServiceProxy.$registerDebugConfigurationProvider(type, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.debugAdapterExecutable || !!provider.provideDebugAdapter, !!provider.provideDebugAdapterTracker, handle);
            return new extHostTypes_1.Disposable(function () {
                _this._providerByHandle.delete(handle);
                _this._providerByType.delete(type);
                _this._providers = _this._providers.filter(function (p) { return p.provider !== provider; }); // remove
                _this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);
            });
        };
        // RPC methods (ExtHostDebugServiceShape)
        ExtHostDebugService.prototype.$runInTerminal = function (args, config) {
            var _this = this;
            if (args.kind === 'integrated') {
                if (!this._terminalDisposedListener) {
                    // React on terminal disposed and check if that is the debug terminal #12956
                    this._terminalDisposedListener = this._terminalService.onDidCloseTerminal(function (terminal) {
                        if (_this._integratedTerminalInstance && _this._integratedTerminalInstance === terminal) {
                            _this._integratedTerminalInstance = null;
                        }
                    });
                }
                return new Promise(function (resolve) {
                    if (_this._integratedTerminalInstance) {
                        _this._integratedTerminalInstance.processId.then(function (pid) {
                            resolve(terminals_1.hasChildprocesses(pid));
                        }, function (err) {
                            resolve(true);
                        });
                    }
                    else {
                        resolve(true);
                    }
                }).then(function (needNewTerminal) {
                    if (needNewTerminal) {
                        _this._integratedTerminalInstance = _this._terminalService.createTerminal(args.title || nls.localize(0, null));
                    }
                    _this._integratedTerminalInstance.show();
                    return new Promise(function (resolve) {
                        setTimeout(function (_) {
                            var command = terminals_1.prepareCommand(args, config);
                            _this._integratedTerminalInstance.sendText(command, true);
                            resolve(void 0);
                        }, 500);
                    });
                });
            }
            else if (args.kind === 'external') {
                var terminalLauncher = terminals_1.getTerminalLauncher();
                if (terminalLauncher) {
                    return terminalLauncher.runInTerminal(args, config);
                }
            }
            return void 0;
        };
        ExtHostDebugService.prototype.$substituteVariables = function (folderUri, config) {
            if (!this._variableResolver) {
                this._variableResolver = new ExtHostVariableResolverService(this._workspaceService, this._editorsService, this._configurationService);
            }
            var ws;
            var folder = this.getFolder(folderUri);
            if (folder) {
                ws = {
                    uri: folder.uri,
                    name: folder.name,
                    index: folder.index,
                    toResource: function () {
                        throw new Error('Not implemented');
                    }
                };
            }
            return Promise.resolve(this._variableResolver.resolveAny(ws, config));
        };
        ExtHostDebugService.prototype.$startDASession = function (handle, sessionDto, folderUri, config) {
            var _this = this;
            var mythis = this;
            return this.getAdapterDescriptor(this._providerByType.get(config.type), sessionDto, folderUri, config).then(function (adapter) {
                var da = undefined;
                switch (adapter.type) {
                    case 'server':
                        da = new debugAdapter_1.SocketDebugAdapter(adapter);
                        break;
                    case 'executable':
                        da = new debugAdapter_1.ExecutableDebugAdapter(adapter, config.type);
                        break;
                    case 'implementation':
                        da = new DirectDebugAdapter(adapter.implementation);
                        break;
                    default:
                        break;
                }
                if (da) {
                    _this._debugAdapters.set(handle, da);
                    return _this.getDebugAdapterTrackers(sessionDto, folderUri, config).then(function (tracker) {
                        if (tracker) {
                            _this._debugAdaptersTrackers.set(handle, tracker);
                        }
                        da.onMessage(function (message) {
                            // since we modify Source.paths in the message in place, we need to make a copy of it (see #61129)
                            var msg = objects_1.deepClone(message);
                            if (tracker) {
                                tracker.fromDebugAdapter(msg);
                            }
                            // DA -> VS Code
                            debugUtils_1.convertToVSCPaths(msg, function (source) { return debugUtils_1.stringToUri(source); });
                            mythis._debugServiceProxy.$acceptDAMessage(handle, msg);
                        });
                        da.onError(function (err) {
                            if (tracker) {
                                tracker.debugAdapterError(err);
                            }
                            _this._debugServiceProxy.$acceptDAError(handle, err.name, err.message, err.stack);
                        });
                        da.onExit(function (code) {
                            if (tracker) {
                                tracker.debugAdapterExit(code, null);
                            }
                            _this._debugServiceProxy.$acceptDAExit(handle, code, null);
                        });
                        if (tracker) {
                            tracker.startDebugAdapter();
                        }
                        return da.startSession();
                    });
                }
                return undefined;
            });
        };
        ExtHostDebugService.prototype.$sendDAMessage = function (handle, message) {
            // VS Code -> DA
            debugUtils_1.convertToDAPaths(message, function (source) { return debugUtils_1.uriToString(source); });
            var tracker = this._debugAdaptersTrackers.get(handle);
            if (tracker) {
                tracker.toDebugAdapter(message);
            }
            var da = this._debugAdapters.get(handle);
            if (da) {
                da.sendMessage(message);
            }
            return void 0;
        };
        ExtHostDebugService.prototype.$stopDASession = function (handle) {
            var tracker = this._debugAdaptersTrackers.get(handle);
            this._debugAdaptersTrackers.delete(handle);
            if (tracker) {
                tracker.stopDebugAdapter();
            }
            var da = this._debugAdapters.get(handle);
            this._debugAdapters.delete(handle);
            if (da) {
                return da.stopSession();
            }
            else {
                return void 0;
            }
        };
        ExtHostDebugService.prototype.$acceptBreakpointsDelta = function (delta) {
            var a = [];
            var r = [];
            var c = [];
            if (delta.added) {
                for (var _i = 0, _a = delta.added; _i < _a.length; _i++) {
                    var bpd = _a[_i];
                    if (!this._breakpoints.has(bpd.id)) {
                        var bp = void 0;
                        if (bpd.type === 'function') {
                            bp = new extHostTypes_1.FunctionBreakpoint(bpd.functionName, bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage);
                        }
                        else {
                            var uri = uri_1.URI.revive(bpd.uri);
                            bp = new extHostTypes_1.SourceBreakpoint(new extHostTypes_1.Location(uri, new extHostTypes_1.Position(bpd.line, bpd.character)), bpd.enabled, bpd.condition, bpd.hitCondition, bpd.logMessage);
                        }
                        bp['_id'] = bpd.id;
                        this._breakpoints.set(bpd.id, bp);
                        a.push(bp);
                    }
                }
            }
            if (delta.removed) {
                for (var _b = 0, _c = delta.removed; _b < _c.length; _b++) {
                    var id = _c[_b];
                    var bp = this._breakpoints.get(id);
                    if (bp) {
                        this._breakpoints.delete(id);
                        r.push(bp);
                    }
                }
            }
            if (delta.changed) {
                for (var _d = 0, _e = delta.changed; _d < _e.length; _d++) {
                    var bpd = _e[_d];
                    var bp = this._breakpoints.get(bpd.id);
                    if (bp) {
                        if (bp instanceof extHostTypes_1.FunctionBreakpoint && bpd.type === 'function') {
                            var fbp = bp;
                            fbp.enabled = bpd.enabled;
                            fbp.condition = bpd.condition;
                            fbp.hitCondition = bpd.hitCondition;
                            fbp.logMessage = bpd.logMessage;
                            fbp.functionName = bpd.functionName;
                        }
                        else if (bp instanceof extHostTypes_1.SourceBreakpoint && bpd.type === 'source') {
                            var sbp = bp;
                            sbp.enabled = bpd.enabled;
                            sbp.condition = bpd.condition;
                            sbp.hitCondition = bpd.hitCondition;
                            sbp.logMessage = bpd.logMessage;
                            sbp.location = new extHostTypes_1.Location(uri_1.URI.revive(bpd.uri), new extHostTypes_1.Position(bpd.line, bpd.character));
                        }
                        c.push(bp);
                    }
                }
            }
            this.fireBreakpointChanges(a, r, c);
        };
        ExtHostDebugService.prototype.$provideDebugConfigurations = function (handle, folderUri) {
            var _this = this;
            var provider = this._providerByHandle.get(handle);
            if (!provider) {
                return Promise.reject(new Error('no handler found'));
            }
            if (!provider.provideDebugConfigurations) {
                return Promise.reject(new Error('handler has no method provideDebugConfigurations'));
            }
            return async_1.asThenable(function () { return provider.provideDebugConfigurations(_this.getFolder(folderUri), cancellation_1.CancellationToken.None); });
        };
        ExtHostDebugService.prototype.$resolveDebugConfiguration = function (handle, folderUri, debugConfiguration) {
            var _this = this;
            var provider = this._providerByHandle.get(handle);
            if (!provider) {
                return Promise.reject(new Error('no handler found'));
            }
            if (!provider.resolveDebugConfiguration) {
                return Promise.reject(new Error('handler has no method resolveDebugConfiguration'));
            }
            return async_1.asThenable(function () { return provider.resolveDebugConfiguration(_this.getFolder(folderUri), debugConfiguration, cancellation_1.CancellationToken.None); });
        };
        ExtHostDebugService.prototype.$provideDebugAdapter = function (handle, sessionDto, folderUri, config) {
            var provider = this._providerByHandle.get(handle);
            if (!provider) {
                return Promise.reject(new Error('no handler found'));
            }
            if (!provider.debugAdapterExecutable && !provider.provideDebugAdapter) {
                return Promise.reject(new Error('handler has no methods provideDebugAdapter or debugAdapterExecutable'));
            }
            return this.getAdapterDescriptor(provider, this.getSession(sessionDto), folderUri, config);
        };
        ExtHostDebugService.prototype.$acceptDebugSessionStarted = function (sessionDto) {
            this._onDidStartDebugSession.fire(this.getSession(sessionDto));
        };
        ExtHostDebugService.prototype.$acceptDebugSessionTerminated = function (sessionDto) {
            this._onDidTerminateDebugSession.fire(this.getSession(sessionDto));
            this._debugSessions.delete(sessionDto.id);
        };
        ExtHostDebugService.prototype.$acceptDebugSessionActiveChanged = function (sessionDto) {
            this._activeDebugSession = sessionDto ? this.getSession(sessionDto) : undefined;
            this._onDidChangeActiveDebugSession.fire(this._activeDebugSession);
        };
        ExtHostDebugService.prototype.$acceptDebugSessionCustomEvent = function (sessionDto, event) {
            var ee = {
                session: this.getSession(sessionDto),
                event: event.event,
                body: event.body
            };
            this._onDidReceiveDebugSessionCustomEvent.fire(ee);
        };
        // private & dto helpers
        ExtHostDebugService.prototype.definesDebugType = function (ed, type) {
            if (ed.contributes) {
                var debuggers = ed.contributes['debuggers'];
                if (debuggers && debuggers.length > 0) {
                    for (var _i = 0, debuggers_2 = debuggers; _i < debuggers_2.length; _i++) {
                        var dbg = debuggers_2[_i];
                        // only debugger contributions with a "label" are considered a "defining" debugger contribution
                        if (dbg.label && dbg.type) {
                            if (dbg.type === type) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        ExtHostDebugService.prototype.getDebugAdapterTrackers = function (sessionDto, folderUri, config) {
            var session = this.getSession(sessionDto);
            var folder = this.getFolder(folderUri);
            var type = config.type;
            var promises = this._providers
                .filter(function (pair) { return pair.provider.provideDebugAdapterTracker && (pair.type === type || pair.type === '*'); })
                .map(function (pair) { return async_1.asThenable(function () { return pair.provider.provideDebugAdapterTracker(session, folder, config, cancellation_1.CancellationToken.None); }).then(function (p) { return p; }).catch(function (err) { return null; }); });
            return Promise.race([
                Promise.all(promises).then(function (trackers) {
                    trackers = trackers.filter(function (t) { return t; }); // filter null
                    if (trackers.length > 0) {
                        return new MultiTracker(trackers);
                    }
                    return undefined;
                }),
                new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        clearTimeout(timeout);
                        reject(new Error('timeout'));
                    }, 1000);
                })
            ]).catch(function (err) {
                // ignore errors
                return undefined;
            });
        };
        ExtHostDebugService.prototype.getAdapterDescriptor = function (debugConfigProvider, sessionDto, folderUri, config) {
            var _this = this;
            // a "debugServer" attribute in the launch config takes precedence
            if (typeof config.debugServer === 'number') {
                return Promise.resolve(new extHostTypes_1.DebugAdapterServer(config.debugServer));
            }
            if (debugConfigProvider) {
                // try the proposed "provideDebugAdapter" API
                if (debugConfigProvider.provideDebugAdapter) {
                    var adapterExecutable_1 = debugAdapter_1.ExecutableDebugAdapter.platformAdapterExecutable(this._extensionService.getAllExtensionDescriptions(), config.type);
                    return async_1.asThenable(function () { return debugConfigProvider.provideDebugAdapter(_this.getSession(sessionDto), _this.getFolder(folderUri), adapterExecutable_1, config, cancellation_1.CancellationToken.None); });
                }
                // try the deprecated "debugAdapterExecutable" API
                if (debugConfigProvider.debugAdapterExecutable) {
                    return async_1.asThenable(function () { return debugConfigProvider.debugAdapterExecutable(_this.getFolder(folderUri), cancellation_1.CancellationToken.None); });
                }
            }
            // try deprecated command based extension API "adapterExecutableCommand" to determine the executable
            var aex = this._aexCommands.get(config.type);
            if (aex) {
                var rootFolder = folderUri ? uri_1.URI.revive(folderUri).toString() : undefined;
                return this._commandService.executeCommand(aex, rootFolder).then(function (ae) {
                    return new extHostTypes_1.DebugAdapterExecutable(ae.command, ae.args || []);
                });
            }
            // fallback: use executable information from package.json
            return Promise.resolve(debugAdapter_1.ExecutableDebugAdapter.platformAdapterExecutable(this._extensionService.getAllExtensionDescriptions(), config.type));
        };
        ExtHostDebugService.prototype.startBreakpoints = function () {
            if (!this._breakpointEventsActive) {
                this._breakpointEventsActive = true;
                this._debugServiceProxy.$startBreakpointEvents();
            }
        };
        ExtHostDebugService.prototype.fireBreakpointChanges = function (added, removed, changed) {
            if (added.length > 0 || removed.length > 0 || changed.length > 0) {
                this._onDidChangeBreakpoints.fire(Object.freeze({
                    added: added,
                    removed: removed,
                    changed: changed,
                }));
            }
        };
        ExtHostDebugService.prototype.getSession = function (dto) {
            if (dto) {
                var debugSession = this._debugSessions.get(dto.id);
                if (!debugSession) {
                    debugSession = new ExtHostDebugSession(this._debugServiceProxy, dto.id, dto.type, dto.name);
                    this._debugSessions.set(dto.id, debugSession);
                }
                return debugSession;
            }
            return undefined;
        };
        ExtHostDebugService.prototype.getFolder = function (_folderUri) {
            if (_folderUri) {
                var folderURI = uri_1.URI.revive(_folderUri);
                return this._workspaceService.resolveWorkspaceFolder(folderURI);
            }
            return undefined;
        };
        return ExtHostDebugService;
    }());
    exports.ExtHostDebugService = ExtHostDebugService;
    var ExtHostDebugSession = /** @class */ (function () {
        function ExtHostDebugSession(proxy, id, type, name) {
            this._debugServiceProxy = proxy;
            this._id = id;
            this._type = type;
            this._name = name;
        }
        Object.defineProperty(ExtHostDebugSession.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugSession.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostDebugSession.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostDebugSession.prototype.customRequest = function (command, args) {
            return this._debugServiceProxy.$customDebugAdapterRequest(this._id, command, args);
        };
        return ExtHostDebugSession;
    }());
    exports.ExtHostDebugSession = ExtHostDebugSession;
    var ExtHostDebugConsole = /** @class */ (function () {
        function ExtHostDebugConsole(proxy) {
            this._debugServiceProxy = proxy;
        }
        ExtHostDebugConsole.prototype.append = function (value) {
            this._debugServiceProxy.$appendDebugConsole(value);
        };
        ExtHostDebugConsole.prototype.appendLine = function (value) {
            this.append(value + '\n');
        };
        return ExtHostDebugConsole;
    }());
    exports.ExtHostDebugConsole = ExtHostDebugConsole;
    var ExtHostVariableResolverService = /** @class */ (function (_super) {
        __extends(ExtHostVariableResolverService, _super);
        function ExtHostVariableResolverService(workspaceService, editorService, configurationService) {
            return _super.call(this, {
                getFolderUri: function (folderName) {
                    var folders = workspaceService.getWorkspaceFolders();
                    var found = folders.filter(function (f) { return f.name === folderName; });
                    if (found && found.length > 0) {
                        return found[0].uri;
                    }
                    return undefined;
                },
                getWorkspaceFolderCount: function () {
                    return workspaceService.getWorkspaceFolders().length;
                },
                getConfigurationValue: function (folderUri, section) {
                    return configurationService.getConfiguration(undefined, folderUri).get(section);
                },
                getExecPath: function () {
                    return undefined; // does not exist in EH
                },
                getFilePath: function () {
                    var activeEditor = editorService.activeEditor();
                    if (activeEditor) {
                        var resource = activeEditor.document.uri;
                        if (resource.scheme === network_1.Schemas.file) {
                            return paths.normalize(resource.fsPath, true);
                        }
                    }
                    return undefined;
                },
                getSelectedText: function () {
                    var activeEditor = editorService.activeEditor();
                    if (activeEditor && !activeEditor.selection.isEmpty) {
                        return activeEditor.document.getText(activeEditor.selection);
                    }
                    return undefined;
                },
                getLineNumber: function () {
                    var activeEditor = editorService.activeEditor();
                    if (activeEditor) {
                        return String(activeEditor.selection.end.line + 1);
                    }
                    return undefined;
                }
            }) || this;
        }
        return ExtHostVariableResolverService;
    }(variableResolver_1.AbstractVariableResolverService));
    exports.ExtHostVariableResolverService = ExtHostVariableResolverService;
    var MultiTracker = /** @class */ (function () {
        function MultiTracker(trackers) {
            this.trackers = trackers;
        }
        MultiTracker.prototype.startDebugAdapter = function () {
            this.trackers.forEach(function (t) { return t.startDebugAdapter ? t.startDebugAdapter() : void 0; });
        };
        MultiTracker.prototype.toDebugAdapter = function (message) {
            this.trackers.forEach(function (t) { return t.toDebugAdapter ? t.toDebugAdapter(message) : void 0; });
        };
        MultiTracker.prototype.fromDebugAdapter = function (message) {
            this.trackers.forEach(function (t) { return t.fromDebugAdapter ? t.fromDebugAdapter(message) : void 0; });
        };
        MultiTracker.prototype.debugAdapterError = function (error) {
            this.trackers.forEach(function (t) { return t.debugAdapterError ? t.debugAdapterError(error) : void 0; });
        };
        MultiTracker.prototype.debugAdapterExit = function (code, signal) {
            this.trackers.forEach(function (t) { return t.debugAdapterExit ? t.debugAdapterExit(code, signal) : void 0; });
        };
        MultiTracker.prototype.stopDebugAdapter = function () {
            this.trackers.forEach(function (t) { return t.stopDebugAdapter ? t.stopDebugAdapter() : void 0; });
        };
        return MultiTracker;
    }());
    var DirectTransport = /** @class */ (function () {
        function DirectTransport(da) {
            this.da = da;
        }
        DirectTransport.prototype.start = function (cb, errorcb) {
            this._sendUp = cb;
        };
        DirectTransport.prototype.sendUp = function (message) {
            this._sendUp(message);
        };
        // DA -> VSCode
        DirectTransport.prototype.send = function (message) {
            this.da.acceptMessage(message);
        };
        DirectTransport.prototype.stop = function () {
            throw new Error('Method not implemented.');
        };
        return DirectTransport;
    }());
    var DirectDebugAdapter = /** @class */ (function (_super) {
        __extends(DirectDebugAdapter, _super);
        function DirectDebugAdapter(implementation) {
            var _this = _super.call(this) || this;
            if (implementation.__setTransport) {
                _this.transport = new DirectTransport(_this);
                implementation.__setTransport(_this.transport);
            }
            return _this;
        }
        DirectDebugAdapter.prototype.startSession = function () {
            return Promise.resolve(void 0);
        };
        // VSCode -> DA
        DirectDebugAdapter.prototype.sendMessage = function (message) {
            this.transport.sendUp(message);
        };
        DirectDebugAdapter.prototype.stopSession = function () {
            this.transport.stop();
            return Promise.resolve(void 0);
        };
        return DirectDebugAdapter;
    }(debugAdapter_1.AbstractDebugAdapter));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[150/*vs/workbench/api/node/extHostDecorations*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, uri_1, extHost_protocol_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDecorations = /** @class */ (function () {
        function ExtHostDecorations(mainContext) {
            this._provider = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDecorations);
        }
        ExtHostDecorations.prototype.registerDecorationProvider = function (provider, extensionId) {
            var _this = this;
            var handle = ExtHostDecorations._handlePool++;
            this._provider.set(handle, { provider: provider, extensionId: extensionId });
            this._proxy.$registerDecorationProvider(handle, extensionId);
            var listener = provider.onDidChangeDecorations(function (e) {
                _this._proxy.$onDidChange(handle, !e ? null : Array.isArray(e) ? e : [e]);
            });
            return new extHostTypes_1.Disposable(function () {
                listener.dispose();
                _this._proxy.$unregisterDecorationProvider(handle);
                _this._provider.delete(handle);
            });
        };
        ExtHostDecorations.prototype.$provideDecorations = function (requests, token) {
            var _this = this;
            var result = Object.create(null);
            return Promise.all(requests.map(function (request) {
                var handle = request.handle, uri = request.uri, id = request.id;
                if (!_this._provider.has(handle)) {
                    // might have been unregistered in the meantime
                    return void 0;
                }
                var _a = _this._provider.get(handle), provider = _a.provider, extensionId = _a.extensionId;
                return Promise.resolve(provider.provideDecoration(uri_1.URI.revive(uri), token)).then(function (data) {
                    if (data && data.letter && data.letter.length !== 1) {
                        console.warn("INVALID decoration from extension '" + extensionId + "'. The 'letter' must be set and be one character, not '" + data.letter + "'.");
                    }
                    result[id] = data && [data.priority, data.bubble, data.title, data.letter, data.color, data.source];
                }, function (err) {
                    console.error(err);
                });
            })).then(function () {
                return result;
            });
        };
        ExtHostDecorations._handlePool = 0;
        return ExtHostDecorations;
    }());
    exports.ExtHostDecorations = ExtHostDecorations;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[151/*vs/workbench/api/node/extHostDiagnostics*/], __M([1/*require*/,0/*exports*/,83/*vs/nls!vs/workbench/api/node/extHostDiagnostics*/,62/*vs/platform/markers/common/markers*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,7/*vs/workbench/api/node/extHostTypes*/,21/*vs/workbench/api/node/extHostTypeConverters*/,9/*vs/base/common/arrays*/,3/*vs/base/common/event*/,22/*vs/base/common/map*/]), function (require, exports, nls_1, markers_1, uri_1, extHost_protocol_1, extHostTypes_1, converter, arrays_1, event_1, map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DiagnosticCollection = /** @class */ (function () {
        function DiagnosticCollection(name, owner, maxDiagnosticsPerFile, proxy, onDidChangeDiagnostics) {
            this._isDisposed = false;
            this._data = new Map();
            this._name = name;
            this._owner = owner;
            this._maxDiagnosticsPerFile = maxDiagnosticsPerFile;
            this._proxy = proxy;
            this._onDidChangeDiagnostics = onDidChangeDiagnostics;
        }
        DiagnosticCollection.prototype.dispose = function () {
            if (!this._isDisposed) {
                this._onDidChangeDiagnostics.fire(map_1.keys(this._data));
                this._proxy.$clear(this._owner);
                this._data = undefined;
                this._isDisposed = true;
            }
        };
        Object.defineProperty(DiagnosticCollection.prototype, "name", {
            get: function () {
                this._checkDisposed();
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        DiagnosticCollection.prototype.set = function (first, diagnostics) {
            var _a;
            if (!first) {
                // this set-call is a clear-call
                this.clear();
                return;
            }
            // the actual implementation for #set
            this._checkDisposed();
            var toSync;
            var hasChanged = true;
            if (first instanceof uri_1.URI) {
                // check if this has actually changed
                hasChanged = hasChanged && !arrays_1.equals(diagnostics, this.get(first), extHostTypes_1.Diagnostic.isEqual);
                if (!diagnostics) {
                    // remove this entry
                    this.delete(first);
                    return;
                }
                // update single row
                this._data.set(first.toString(), diagnostics.slice());
                toSync = [first];
            }
            else if (Array.isArray(first)) {
                // update many rows
                toSync = [];
                var lastUri = void 0;
                // ensure stable-sort
                arrays_1.mergeSort(first, DiagnosticCollection._compareIndexedTuplesByUri);
                for (var _i = 0, first_1 = first; _i < first_1.length; _i++) {
                    var tuple = first_1[_i];
                    var uri = tuple[0], diagnostics_2 = tuple[1];
                    if (!lastUri || uri.toString() !== lastUri.toString()) {
                        if (lastUri && this._data.get(lastUri.toString()).length === 0) {
                            this._data.delete(lastUri.toString());
                        }
                        lastUri = uri;
                        toSync.push(uri);
                        this._data.set(uri.toString(), []);
                    }
                    if (!diagnostics_2) {
                        // [Uri, undefined] means clear this
                        this._data.get(uri.toString()).length = 0;
                    }
                    else {
                        (_a = this._data.get(uri.toString())).push.apply(_a, diagnostics_2);
                    }
                }
            }
            // send event for extensions
            this._onDidChangeDiagnostics.fire(toSync);
            // if nothing has changed then there is nothing else to do
            // we have updated the diagnostics but we don't send a message
            // to the renderer. tho we have still send an event for other
            // extensions because the diagnostic might carry more information
            // than known to us
            if (!hasChanged) {
                return;
            }
            // compute change and send to main side
            var entries = [];
            for (var _b = 0, toSync_1 = toSync; _b < toSync_1.length; _b++) {
                var uri = toSync_1[_b];
                var marker = void 0;
                var diagnostics_3 = this._data.get(uri.toString());
                if (diagnostics_3) {
                    // no more than N diagnostics per file
                    if (diagnostics_3.length > this._maxDiagnosticsPerFile) {
                        marker = [];
                        var order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];
                        orderLoop: for (var i = 0; i < 4; i++) {
                            for (var _c = 0, diagnostics_1 = diagnostics_3; _c < diagnostics_1.length; _c++) {
                                var diagnostic = diagnostics_1[_c];
                                if (diagnostic.severity === order[i]) {
                                    var len = marker.push(converter.Diagnostic.from(diagnostic));
                                    if (len === this._maxDiagnosticsPerFile) {
                                        break orderLoop;
                                    }
                                }
                            }
                        }
                        // add 'signal' marker for showing omitted errors/warnings
                        marker.push({
                            severity: markers_1.MarkerSeverity.Info,
                            message: nls_1.localize(0, null, diagnostics_3.length - this._maxDiagnosticsPerFile),
                            startLineNumber: marker[marker.length - 1].startLineNumber,
                            startColumn: marker[marker.length - 1].startColumn,
                            endLineNumber: marker[marker.length - 1].endLineNumber,
                            endColumn: marker[marker.length - 1].endColumn
                        });
                    }
                    else {
                        marker = diagnostics_3.map(converter.Diagnostic.from);
                    }
                }
                entries.push([uri, marker]);
            }
            this._proxy.$changeMany(this._owner, entries);
        };
        DiagnosticCollection.prototype.delete = function (uri) {
            this._checkDisposed();
            this._onDidChangeDiagnostics.fire([uri]);
            this._data.delete(uri.toString());
            this._proxy.$changeMany(this._owner, [[uri, undefined]]);
        };
        DiagnosticCollection.prototype.clear = function () {
            this._checkDisposed();
            this._onDidChangeDiagnostics.fire(map_1.keys(this._data));
            this._data.clear();
            this._proxy.$clear(this._owner);
        };
        DiagnosticCollection.prototype.forEach = function (callback, thisArg) {
            var _this = this;
            this._checkDisposed();
            this._data.forEach(function (value, key) {
                var uri = uri_1.URI.parse(key);
                callback.apply(thisArg, [uri, _this.get(uri), _this]);
            });
        };
        DiagnosticCollection.prototype.get = function (uri) {
            this._checkDisposed();
            var result = this._data.get(uri.toString());
            if (Array.isArray(result)) {
                return Object.freeze(result.slice(0));
            }
            return undefined;
        };
        DiagnosticCollection.prototype.has = function (uri) {
            this._checkDisposed();
            return Array.isArray(this._data.get(uri.toString()));
        };
        DiagnosticCollection.prototype._checkDisposed = function () {
            if (this._isDisposed) {
                throw new Error('illegal state - object is disposed');
            }
        };
        DiagnosticCollection._compareIndexedTuplesByUri = function (a, b) {
            if (a[0].toString() < b[0].toString()) {
                return -1;
            }
            else if (a[0].toString() > b[0].toString()) {
                return 1;
            }
            else {
                return 0;
            }
        };
        return DiagnosticCollection;
    }());
    exports.DiagnosticCollection = DiagnosticCollection;
    var ExtHostDiagnostics = /** @class */ (function () {
        function ExtHostDiagnostics(mainContext) {
            this._collections = new Map();
            this._onDidChangeDiagnostics = new event_1.Emitter();
            this.onDidChangeDiagnostics = event_1.mapEvent(event_1.debounceEvent(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._debouncer, 50), ExtHostDiagnostics._mapper);
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDiagnostics);
        }
        ExtHostDiagnostics._debouncer = function (last, current) {
            if (!last) {
                return current;
            }
            else {
                return last.concat(current);
            }
        };
        ExtHostDiagnostics._mapper = function (last) {
            var uris = [];
            var map = new Set();
            for (var _i = 0, last_1 = last; _i < last_1.length; _i++) {
                var uri = last_1[_i];
                if (typeof uri === 'string') {
                    if (!map.has(uri)) {
                        map.add(uri);
                        uris.push(uri_1.URI.parse(uri));
                    }
                }
                else {
                    if (!map.has(uri.toString())) {
                        map.add(uri.toString());
                        uris.push(uri);
                    }
                }
            }
            Object.freeze(uris);
            return { uris: uris };
        };
        ExtHostDiagnostics.prototype.createDiagnosticCollection = function (name) {
            var _a = this, _collections = _a._collections, _proxy = _a._proxy, _onDidChangeDiagnostics = _a._onDidChangeDiagnostics;
            var owner;
            if (!name) {
                name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
                owner = name;
            }
            else if (!_collections.has(name)) {
                owner = name;
            }
            else {
                console.warn("DiagnosticCollection with name '" + name + "' does already exist.");
                do {
                    owner = name + ExtHostDiagnostics._idPool++;
                } while (_collections.has(owner));
            }
            var result = new /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    var _this = _super.call(this, name, owner, ExtHostDiagnostics._maxDiagnosticsPerFile, _proxy, _onDidChangeDiagnostics) || this;
                    _collections.set(owner, _this);
                    return _this;
                }
                class_1.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    _collections.delete(owner);
                };
                return class_1;
            }(DiagnosticCollection));
            return result;
        };
        ExtHostDiagnostics.prototype.getDiagnostics = function (resource) {
            if (resource) {
                return this._getDiagnostics(resource);
            }
            else {
                var index_1 = new Map();
                var res_1 = [];
                this._collections.forEach(function (collection) {
                    collection.forEach(function (uri, diagnostics) {
                        var _a;
                        var idx = index_1.get(uri.toString());
                        if (typeof idx === 'undefined') {
                            idx = res_1.length;
                            index_1.set(uri.toString(), idx);
                            res_1.push([uri, []]);
                        }
                        res_1[idx][1] = (_a = res_1[idx][1]).concat.apply(_a, diagnostics);
                    });
                });
                return res_1;
            }
        };
        ExtHostDiagnostics.prototype._getDiagnostics = function (resource) {
            var res = [];
            this._collections.forEach(function (collection) {
                if (collection.has(resource)) {
                    res = res.concat(collection.get(resource));
                }
            });
            return res;
        };
        ExtHostDiagnostics._idPool = 0;
        ExtHostDiagnostics._maxDiagnosticsPerFile = 1000;
        return ExtHostDiagnostics;
    }());
    exports.ExtHostDiagnostics = ExtHostDiagnostics;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[152/*vs/workbench/api/node/extHostDialogs*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, uri_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDialogs = /** @class */ (function () {
        function ExtHostDialogs(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDialogs);
        }
        ExtHostDialogs.prototype.showOpenDialog = function (options) {
            return this._proxy.$showOpenDialog(options).then(function (filepaths) {
                return filepaths && filepaths.map(uri_1.URI.revive);
            });
        };
        ExtHostDialogs.prototype.showSaveDialog = function (options) {
            return this._proxy.$showSaveDialog(options).then(function (filepath) {
                return filepath && uri_1.URI.revive(filepath);
            });
        };
        return ExtHostDialogs;
    }());
    exports.ExtHostDialogs = ExtHostDialogs;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[153/*vs/workbench/api/node/extHostDocumentContentProviders*/], __M([1/*require*/,0/*exports*/,14/*vs/base/common/errors*/,2/*vs/base/common/uri*/,7/*vs/workbench/api/node/extHostTypes*/,4/*vs/workbench/api/node/extHost.protocol*/,26/*vs/base/common/network*/,17/*vs/base/common/cancellation*/]), function (require, exports, errors_1, uri_1, extHostTypes_1, extHost_protocol_1, network_1, cancellation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentContentProvider = /** @class */ (function () {
        function ExtHostDocumentContentProvider(mainContext, _documentsAndEditors, _logService) {
            this._documentsAndEditors = _documentsAndEditors;
            this._logService = _logService;
            this._documentContentProviders = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocumentContentProviders);
        }
        ExtHostDocumentContentProvider.prototype.dispose = function () {
            // todo@joh
        };
        ExtHostDocumentContentProvider.prototype.registerTextDocumentContentProvider = function (scheme, provider) {
            var _this = this;
            // todo@remote
            // check with scheme from fs-providers!
            if (scheme === network_1.Schemas.file || scheme === network_1.Schemas.untitled) {
                throw new Error("scheme '" + scheme + "' already registered");
            }
            var handle = ExtHostDocumentContentProvider._handlePool++;
            this._documentContentProviders.set(handle, provider);
            this._proxy.$registerTextContentProvider(handle, scheme);
            var subscription;
            if (typeof provider.onDidChange === 'function') {
                subscription = provider.onDidChange(function (uri) {
                    if (uri.scheme !== scheme) {
                        _this._logService.warn("Provider for scheme '" + scheme + "' is firing event for schema '" + uri.scheme + "' which will be IGNORED");
                        return;
                    }
                    if (_this._documentsAndEditors.getDocument(uri.toString())) {
                        _this.$provideTextDocumentContent(handle, uri).then(function (value) {
                            var document = _this._documentsAndEditors.getDocument(uri.toString());
                            if (!document) {
                                // disposed in the meantime
                                return;
                            }
                            // create lines and compare
                            var lines = value.split(/\r\n|\r|\n/);
                            // broadcast event when content changed
                            if (!document.equalLines(lines)) {
                                return _this._proxy.$onVirtualDocumentChange(uri, value);
                            }
                        }, errors_1.onUnexpectedError);
                    }
                });
            }
            return new extHostTypes_1.Disposable(function () {
                if (_this._documentContentProviders.delete(handle)) {
                    _this._proxy.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            });
        };
        ExtHostDocumentContentProvider.prototype.$provideTextDocumentContent = function (handle, uri) {
            var provider = this._documentContentProviders.get(handle);
            if (!provider) {
                return Promise.reject(new Error("unsupported uri-scheme: " + uri.scheme));
            }
            return Promise.resolve(provider.provideTextDocumentContent(uri_1.URI.revive(uri), cancellation_1.CancellationToken.None));
        };
        ExtHostDocumentContentProvider._handlePool = 0;
        return ExtHostDocumentContentProvider;
    }());
    exports.ExtHostDocumentContentProvider = ExtHostDocumentContentProvider;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[154/*vs/workbench/api/node/extHostDocuments*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,68/*vs/workbench/api/node/extHostDocumentData*/,21/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, event_1, lifecycle_1, uri_1, extHost_protocol_1, extHostDocumentData_1, TypeConverters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocuments = /** @class */ (function () {
        function ExtHostDocuments(mainContext, documentsAndEditors) {
            var _this = this;
            this._onDidAddDocument = new event_1.Emitter();
            this._onDidRemoveDocument = new event_1.Emitter();
            this._onDidChangeDocument = new event_1.Emitter();
            this._onDidSaveDocument = new event_1.Emitter();
            this.onDidAddDocument = this._onDidAddDocument.event;
            this.onDidRemoveDocument = this._onDidRemoveDocument.event;
            this.onDidChangeDocument = this._onDidChangeDocument.event;
            this.onDidSaveDocument = this._onDidSaveDocument.event;
            this._documentLoader = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocuments);
            this._documentsAndEditors = documentsAndEditors;
            this._toDispose = [
                this._documentsAndEditors.onDidRemoveDocuments(function (documents) {
                    for (var _i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                        var data = documents_1[_i];
                        _this._onDidRemoveDocument.fire(data.document);
                    }
                }),
                this._documentsAndEditors.onDidAddDocuments(function (documents) {
                    for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
                        var data = documents_2[_i];
                        _this._onDidAddDocument.fire(data.document);
                    }
                })
            ];
        }
        ExtHostDocuments.prototype.dispose = function () {
            lifecycle_1.dispose(this._toDispose);
        };
        ExtHostDocuments.prototype.getAllDocumentData = function () {
            return this._documentsAndEditors.allDocuments();
        };
        ExtHostDocuments.prototype.getDocumentData = function (resource) {
            if (!resource) {
                return undefined;
            }
            var data = this._documentsAndEditors.getDocument(resource.toString());
            if (data) {
                return data;
            }
            return undefined;
        };
        ExtHostDocuments.prototype.ensureDocumentData = function (uri) {
            var _this = this;
            var cached = this._documentsAndEditors.getDocument(uri.toString());
            if (cached) {
                return Promise.resolve(cached);
            }
            var promise = this._documentLoader.get(uri.toString());
            if (!promise) {
                promise = this._proxy.$tryOpenDocument(uri).then(function () {
                    _this._documentLoader.delete(uri.toString());
                    return _this._documentsAndEditors.getDocument(uri.toString());
                }, function (err) {
                    _this._documentLoader.delete(uri.toString());
                    return Promise.reject(err);
                });
                this._documentLoader.set(uri.toString(), promise);
            }
            return promise;
        };
        ExtHostDocuments.prototype.createDocumentData = function (options) {
            return this._proxy.$tryCreateDocument(options).then(function (data) { return uri_1.URI.revive(data); });
        };
        ExtHostDocuments.prototype.$acceptModelModeChanged = function (uriComponents, oldModeId, newModeId) {
            var uri = uri_1.URI.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            // Treat a mode change as a remove + add
            this._onDidRemoveDocument.fire(data.document);
            data._acceptLanguageId(newModeId);
            this._onDidAddDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptModelSaved = function (uriComponents) {
            var uri = uri_1.URI.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            this.$acceptDirtyStateChanged(uriComponents, false);
            this._onDidSaveDocument.fire(data.document);
        };
        ExtHostDocuments.prototype.$acceptDirtyStateChanged = function (uriComponents, isDirty) {
            var uri = uri_1.URI.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: []
            });
        };
        ExtHostDocuments.prototype.$acceptModelChanged = function (uriComponents, events, isDirty) {
            var uri = uri_1.URI.revive(uriComponents);
            var strURL = uri.toString();
            var data = this._documentsAndEditors.getDocument(strURL);
            data._acceptIsDirty(isDirty);
            data.onEvents(events);
            this._onDidChangeDocument.fire({
                document: data.document,
                contentChanges: events.changes.map(function (change) {
                    return {
                        range: TypeConverters.Range.to(change.range),
                        rangeOffset: change.rangeOffset,
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            });
        };
        ExtHostDocuments.prototype.setWordDefinitionFor = function (modeId, wordDefinition) {
            extHostDocumentData_1.setWordDefinitionFor(modeId, wordDefinition);
        };
        return ExtHostDocuments;
    }());
    exports.ExtHostDocuments = ExtHostDocuments;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[155/*vs/workbench/api/node/extHostDocumentsAndEditors*/], __M([1/*require*/,0/*exports*/,118/*assert*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,68/*vs/workbench/api/node/extHostDocumentData*/,70/*vs/workbench/api/node/extHostTextEditor*/,21/*vs/workbench/api/node/extHostTypeConverters*/]), function (require, exports, assert, event_1, lifecycle_1, uri_1, extHost_protocol_1, extHostDocumentData_1, extHostTextEditor_1, typeConverters) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostDocumentsAndEditors = /** @class */ (function () {
        function ExtHostDocumentsAndEditors(_mainContext) {
            this._mainContext = _mainContext;
            this._disposables = [];
            this._editors = new Map();
            this._documents = new Map();
            this._onDidAddDocuments = new event_1.Emitter();
            this._onDidRemoveDocuments = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this.onDidAddDocuments = this._onDidAddDocuments.event;
            this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        }
        ExtHostDocumentsAndEditors.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        ExtHostDocumentsAndEditors.prototype.$acceptDocumentsAndEditorsDelta = function (delta) {
            var removedDocuments = [];
            var addedDocuments = [];
            var removedEditors = [];
            if (delta.removedDocuments) {
                for (var _i = 0, _a = delta.removedDocuments; _i < _a.length; _i++) {
                    var uriComponent = _a[_i];
                    var uri = uri_1.URI.revive(uriComponent);
                    var id = uri.toString();
                    var data = this._documents.get(id);
                    this._documents.delete(id);
                    removedDocuments.push(data);
                }
            }
            if (delta.addedDocuments) {
                for (var _b = 0, _c = delta.addedDocuments; _b < _c.length; _b++) {
                    var data = _c[_b];
                    var resource = uri_1.URI.revive(data.uri);
                    assert.ok(!this._documents.has(resource.toString()), "document '" + resource + " already exists!'");
                    var documentData = new extHostDocumentData_1.ExtHostDocumentData(this._mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadDocuments), resource, data.lines, data.EOL, data.modeId, data.versionId, data.isDirty);
                    this._documents.set(resource.toString(), documentData);
                    addedDocuments.push(documentData);
                }
            }
            if (delta.removedEditors) {
                for (var _d = 0, _e = delta.removedEditors; _d < _e.length; _d++) {
                    var id = _e[_d];
                    var editor = this._editors.get(id);
                    this._editors.delete(id);
                    removedEditors.push(editor);
                }
            }
            if (delta.addedEditors) {
                for (var _f = 0, _g = delta.addedEditors; _f < _g.length; _f++) {
                    var data = _g[_f];
                    var resource = uri_1.URI.revive(data.documentUri);
                    assert.ok(this._documents.has(resource.toString()), "document '" + resource + "' does not exist");
                    assert.ok(!this._editors.has(data.id), "editor '" + data.id + "' already exists!");
                    var documentData = this._documents.get(resource.toString());
                    var editor = new extHostTextEditor_1.ExtHostTextEditor(this._mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors), data.id, documentData, data.selections.map(typeConverters.Selection.to), data.options, data.visibleRanges.map(typeConverters.Range.to), typeConverters.ViewColumn.to(data.editorPosition));
                    this._editors.set(data.id, editor);
                }
            }
            if (delta.newActiveEditor !== undefined) {
                assert.ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), "active editor '" + delta.newActiveEditor + "' does not exist");
                this._activeEditorId = delta.newActiveEditor;
            }
            lifecycle_1.dispose(removedDocuments);
            lifecycle_1.dispose(removedEditors);
            // now that the internal state is complete, fire events
            if (delta.removedDocuments) {
                this._onDidRemoveDocuments.fire(removedDocuments);
            }
            if (delta.addedDocuments) {
                this._onDidAddDocuments.fire(addedDocuments);
            }
            if (delta.removedEditors || delta.addedEditors) {
                this._onDidChangeVisibleTextEditors.fire(this.allEditors());
            }
            if (delta.newActiveEditor !== undefined) {
                this._onDidChangeActiveTextEditor.fire(this.activeEditor());
            }
        };
        ExtHostDocumentsAndEditors.prototype.getDocument = function (strUrl) {
            return this._documents.get(strUrl);
        };
        ExtHostDocumentsAndEditors.prototype.allDocuments = function () {
            var result = [];
            this._documents.forEach(function (data) { return result.push(data); });
            return result;
        };
        ExtHostDocumentsAndEditors.prototype.getEditor = function (id) {
            return this._editors.get(id);
        };
        ExtHostDocumentsAndEditors.prototype.activeEditor = function () {
            if (!this._activeEditorId) {
                return undefined;
            }
            else {
                return this._editors.get(this._activeEditorId);
            }
        };
        ExtHostDocumentsAndEditors.prototype.allEditors = function () {
            var result = [];
            this._editors.forEach(function (data) { return result.push(data); });
            return result;
        };
        return ExtHostDocumentsAndEditors;
    }());
    exports.ExtHostDocumentsAndEditors = ExtHostDocumentsAndEditors;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[156/*vs/workbench/api/node/extHostFileSystem*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,8/*vs/base/common/lifecycle*/,22/*vs/base/common/map*/,7/*vs/workbench/api/node/extHostTypes*/,26/*vs/base/common/network*/]), function (require, exports, uri_1, extHost_protocol_1, lifecycle_1, map_1, extHostTypes_1, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FsLinkProvider = /** @class */ (function () {
        function FsLinkProvider() {
            this._schemes = new Set();
        }
        FsLinkProvider.prototype.add = function (scheme) {
            this._regex = undefined;
            this._schemes.add(scheme);
        };
        FsLinkProvider.prototype.delete = function (scheme) {
            if (this._schemes.delete(scheme)) {
                this._regex = undefined;
            }
        };
        FsLinkProvider.prototype.provideDocumentLinks = function (document) {
            if (this._schemes.size === 0) {
                return undefined;
            }
            if (!this._regex) {
                this._regex = new RegExp("(" + (map_1.values(this._schemes).join('|')) + "):[^\\s]+", 'gi');
            }
            var result = [];
            var max = Math.min(document.lineCount, 2500);
            for (var line = 0; line < max; line++) {
                this._regex.lastIndex = 0;
                var textLine = document.lineAt(line);
                var m = void 0;
                while (m = this._regex.exec(textLine.text)) {
                    var target = uri_1.URI.parse(m[0]);
                    if (target.path[0] !== '/') {
                        continue;
                    }
                    var range = new extHostTypes_1.Range(line, this._regex.lastIndex - m[0].length, line, this._regex.lastIndex);
                    result.push({ target: target, range: range });
                }
            }
            return result;
        };
        return FsLinkProvider;
    }());
    var ExtHostFileSystem = /** @class */ (function () {
        function ExtHostFileSystem(mainContext, extHostLanguageFeatures) {
            this._linkProvider = new FsLinkProvider();
            this._fsProvider = new Map();
            this._usedSchemes = new Set();
            this._watches = new Map();
            this._handlePool = 0;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadFileSystem);
            this._usedSchemes.add(network_1.Schemas.file);
            this._usedSchemes.add(network_1.Schemas.untitled);
            this._usedSchemes.add(network_1.Schemas.vscode);
            this._usedSchemes.add(network_1.Schemas.inMemory);
            this._usedSchemes.add(network_1.Schemas.internal);
            this._usedSchemes.add(network_1.Schemas.http);
            this._usedSchemes.add(network_1.Schemas.https);
            this._usedSchemes.add(network_1.Schemas.mailto);
            this._usedSchemes.add(network_1.Schemas.data);
            extHostLanguageFeatures.registerDocumentLinkProvider('*', this._linkProvider);
        }
        ExtHostFileSystem.prototype.registerFileSystemProvider = function (scheme, provider, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (this._usedSchemes.has(scheme)) {
                throw new Error("a provider for the scheme '" + scheme + "' is already registered");
            }
            var handle = this._handlePool++;
            this._linkProvider.add(scheme);
            this._usedSchemes.add(scheme);
            this._fsProvider.set(handle, provider);
            var capabilites = 2 /* FileReadWrite */;
            if (options.isCaseSensitive) {
                capabilites += 1024 /* PathCaseSensitive */;
            }
            if (options.isReadonly) {
                capabilites += 2048 /* Readonly */;
            }
            if (typeof provider.copy === 'function') {
                capabilites += 8 /* FileFolderCopy */;
            }
            if (typeof provider.open === 'function' && typeof provider.close === 'function'
                && typeof provider.read === 'function' && typeof provider.write === 'function') {
                capabilites += 4 /* FileOpenReadWriteClose */;
            }
            this._proxy.$registerFileSystemProvider(handle, scheme, capabilites);
            var subscription = provider.onDidChangeFile(function (event) {
                var mapped = [];
                for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
                    var e = event_1[_i];
                    var resource = e.uri, type = e.type;
                    if (resource.scheme !== scheme) {
                        // dropping events for wrong scheme
                        continue;
                    }
                    var newType = void 0;
                    switch (type) {
                        case extHostTypes_1.FileChangeType.Changed:
                            newType = 0 /* UPDATED */;
                            break;
                        case extHostTypes_1.FileChangeType.Created:
                            newType = 1 /* ADDED */;
                            break;
                        case extHostTypes_1.FileChangeType.Deleted:
                            newType = 2 /* DELETED */;
                            break;
                    }
                    mapped.push({ resource: resource, type: newType });
                }
                _this._proxy.$onFileSystemChange(handle, mapped);
            });
            return lifecycle_1.toDisposable(function () {
                subscription.dispose();
                _this._linkProvider.delete(scheme);
                _this._usedSchemes.delete(scheme);
                _this._fsProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostFileSystem.prototype.setUriFormatter = function (scheme, formatter) {
            this._proxy.$setUriFormatter(scheme, formatter);
        };
        ExtHostFileSystem._asIStat = function (stat) {
            var type = stat.type, ctime = stat.ctime, mtime = stat.mtime, size = stat.size;
            return { type: type, ctime: ctime, mtime: mtime, size: size };
        };
        ExtHostFileSystem.prototype._checkProviderExists = function (handle) {
            if (!this._fsProvider.has(handle)) {
                var err = new Error();
                err.name = 'ENOPRO';
                err.message = "no provider";
                throw err;
            }
        };
        ExtHostFileSystem.prototype.$stat = function (handle, resource) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).stat(uri_1.URI.revive(resource))).then(ExtHostFileSystem._asIStat);
        };
        ExtHostFileSystem.prototype.$readdir = function (handle, resource) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).readDirectory(uri_1.URI.revive(resource)));
        };
        ExtHostFileSystem.prototype.$readFile = function (handle, resource) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).readFile(uri_1.URI.revive(resource))).then(function (data) {
                return Buffer.isBuffer(data) ? data : Buffer.from(data.buffer, data.byteOffset, data.byteLength);
            });
        };
        ExtHostFileSystem.prototype.$writeFile = function (handle, resource, content, opts) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).writeFile(uri_1.URI.revive(resource), content, opts));
        };
        ExtHostFileSystem.prototype.$delete = function (handle, resource, opts) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).delete(uri_1.URI.revive(resource), opts));
        };
        ExtHostFileSystem.prototype.$rename = function (handle, oldUri, newUri, opts) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).rename(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));
        };
        ExtHostFileSystem.prototype.$copy = function (handle, oldUri, newUri, opts) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).copy(uri_1.URI.revive(oldUri), uri_1.URI.revive(newUri), opts));
        };
        ExtHostFileSystem.prototype.$mkdir = function (handle, resource) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).createDirectory(uri_1.URI.revive(resource)));
        };
        ExtHostFileSystem.prototype.$watch = function (handle, session, resource, opts) {
            this._checkProviderExists(handle);
            var subscription = this._fsProvider.get(handle).watch(uri_1.URI.revive(resource), opts);
            this._watches.set(session, subscription);
        };
        ExtHostFileSystem.prototype.$unwatch = function (session) {
            var subscription = this._watches.get(session);
            if (subscription) {
                subscription.dispose();
                this._watches.delete(session);
            }
        };
        ExtHostFileSystem.prototype.$open = function (handle, resource) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).open(uri_1.URI.revive(resource)));
        };
        ExtHostFileSystem.prototype.$close = function (handle, fd) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).close(fd));
        };
        ExtHostFileSystem.prototype.$read = function (handle, fd, pos, data, offset, length) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).read(fd, pos, data, offset, length));
        };
        ExtHostFileSystem.prototype.$write = function (handle, fd, pos, data, offset, length) {
            this._checkProviderExists(handle);
            return Promise.resolve(this._fsProvider.get(handle).write(fd, pos, data, offset, length));
        };
        return ExtHostFileSystem;
    }());
    exports.ExtHostFileSystem = ExtHostFileSystem;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[157/*vs/workbench/api/node/extHostFileSystemEventService*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/arrays*/,3/*vs/base/common/event*/,23/*vs/base/common/glob*/,2/*vs/base/common/uri*/,4/*vs/workbench/api/node/extHost.protocol*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, arrays_1, event_1, glob_1, uri_1, extHost_protocol_1, typeConverter, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileSystemWatcher = /** @class */ (function () {
        function FileSystemWatcher(dispatcher, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            var _this = this;
            this._onDidCreate = new event_1.Emitter();
            this._onDidChange = new event_1.Emitter();
            this._onDidDelete = new event_1.Emitter();
            this._config = 0;
            if (ignoreCreateEvents) {
                this._config += 1;
            }
            if (ignoreChangeEvents) {
                this._config += 2;
            }
            if (ignoreDeleteEvents) {
                this._config += 4;
            }
            var parsedPattern = glob_1.parse(globPattern);
            var subscription = dispatcher(function (events) {
                if (!ignoreCreateEvents) {
                    for (var _i = 0, _a = events.created; _i < _a.length; _i++) {
                        var created = _a[_i];
                        var uri = uri_1.URI.revive(created);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidCreate.fire(uri);
                        }
                    }
                }
                if (!ignoreChangeEvents) {
                    for (var _b = 0, _c = events.changed; _b < _c.length; _b++) {
                        var changed = _c[_b];
                        var uri = uri_1.URI.revive(changed);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidChange.fire(uri);
                        }
                    }
                }
                if (!ignoreDeleteEvents) {
                    for (var _d = 0, _e = events.deleted; _d < _e.length; _d++) {
                        var deleted = _e[_d];
                        var uri = uri_1.URI.revive(deleted);
                        if (parsedPattern(uri.fsPath)) {
                            _this._onDidDelete.fire(uri);
                        }
                    }
                }
            });
            this._disposable = extHostTypes_1.Disposable.from(this._onDidCreate, this._onDidChange, this._onDidDelete, subscription);
        }
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreCreateEvents", {
            get: function () {
                return Boolean(this._config & 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreChangeEvents", {
            get: function () {
                return Boolean(this._config & 2);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "ignoreDeleteEvents", {
            get: function () {
                return Boolean(this._config & 4);
            },
            enumerable: true,
            configurable: true
        });
        FileSystemWatcher.prototype.dispose = function () {
            this._disposable.dispose();
        };
        Object.defineProperty(FileSystemWatcher.prototype, "onDidCreate", {
            get: function () {
                return this._onDidCreate.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileSystemWatcher.prototype, "onDidDelete", {
            get: function () {
                return this._onDidDelete.event;
            },
            enumerable: true,
            configurable: true
        });
        return FileSystemWatcher;
    }());
    var ExtHostFileSystemEventService = /** @class */ (function () {
        function ExtHostFileSystemEventService(mainContext, _extHostDocumentsAndEditors, _mainThreadTextEditors) {
            if (_mainThreadTextEditors === void 0) { _mainThreadTextEditors = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors); }
            this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
            this._mainThreadTextEditors = _mainThreadTextEditors;
            this._onFileEvent = new event_1.Emitter();
            this._onDidRenameFile = new event_1.Emitter();
            this._onWillRenameFile = new event_1.AsyncEmitter();
            this.onDidRenameFile = this._onDidRenameFile.event;
            //
        }
        ExtHostFileSystemEventService.prototype.createFileSystemWatcher = function (globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            return new FileSystemWatcher(this._onFileEvent.event, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        };
        ExtHostFileSystemEventService.prototype.$onFileEvent = function (events) {
            this._onFileEvent.fire(events);
        };
        ExtHostFileSystemEventService.prototype.$onFileRename = function (oldUri, newUri) {
            this._onDidRenameFile.fire(Object.freeze({ oldUri: uri_1.URI.revive(oldUri), newUri: uri_1.URI.revive(newUri) }));
        };
        ExtHostFileSystemEventService.prototype.getOnWillRenameFileEvent = function (extension) {
            var _this = this;
            return function (listener, thisArg, disposables) {
                var wrappedListener = function () {
                    listener.apply(thisArg, arguments);
                };
                wrappedListener.extension = extension;
                return _this._onWillRenameFile.event(wrappedListener, undefined, disposables);
            };
        };
        ExtHostFileSystemEventService.prototype.$onWillRename = function (oldUriDto, newUriDto) {
            var _this = this;
            var oldUri = uri_1.URI.revive(oldUriDto);
            var newUri = uri_1.URI.revive(newUriDto);
            var edits = [];
            return Promise.resolve(this._onWillRenameFile.fireAsync(function (bucket, _listener) {
                return {
                    oldUri: oldUri,
                    newUri: newUri,
                    waitUntil: function (thenable) {
                        if (Object.isFrozen(bucket)) {
                            throw new TypeError('waitUntil cannot be called async');
                        }
                        var index = bucket.length;
                        var wrappedThenable = Promise.resolve(thenable).then(function (result) {
                            // ignore all results except for WorkspaceEdits. Those
                            // are stored in a spare array
                            if (result instanceof extHostTypes_1.WorkspaceEdit) {
                                edits[index] = result;
                            }
                        });
                        bucket.push(wrappedThenable);
                    }
                };
            }).then(function () {
                if (edits.length === 0) {
                    return undefined;
                }
                // flatten all WorkspaceEdits collected via waitUntil-call
                // and apply them in one go.
                var allEdits = new Array();
                for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                    var edit = edits_1[_i];
                    if (edit) { // sparse array
                        var edits_2 = typeConverter.WorkspaceEdit.from(edit, _this._extHostDocumentsAndEditors).edits;
                        allEdits.push(edits_2);
                    }
                }
                return _this._mainThreadTextEditors.$tryApplyWorkspaceEdit({ edits: arrays_1.flatten(allEdits) });
            }));
        };
        return ExtHostFileSystemEventService;
    }());
    exports.ExtHostFileSystemEventService = ExtHostFileSystemEventService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[158/*vs/workbench/api/node/extHostLanguageFeatures*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,13/*vs/base/common/objects*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/,11/*vs/base/common/async*/,4/*vs/workbench/api/node/extHost.protocol*/,5/*vs/base/common/strings*/,53/*vs/editor/common/core/range*/,9/*vs/base/common/arrays*/,18/*vs/base/common/types*/,123/*vs/editor/common/core/selection*/]), function (require, exports, uri_1, objects_1, typeConvert, extHostTypes_1, async_1, extHost_protocol_1, strings_1, range_1, arrays_1, types_1, selection_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // --- adapter
    var OutlineAdapter = /** @class */ (function () {
        function OutlineAdapter(documents, provider) {
            this._documents = documents;
            this._provider = provider;
        }
        OutlineAdapter.prototype.provideDocumentSymbols = function (resource, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideDocumentSymbols(doc, token); }).then(function (value) {
                if (arrays_1.isFalsyOrEmpty(value)) {
                    return undefined;
                }
                if (value[0] instanceof extHostTypes_1.DocumentSymbol) {
                    return value.map(typeConvert.DocumentSymbol.from);
                }
                else {
                    return OutlineAdapter._asDocumentSymbolTree(resource, value);
                }
            });
        };
        OutlineAdapter._asDocumentSymbolTree = function (resource, info) {
            // first sort by start (and end) and then loop over all elements
            // and build a tree based on containment.
            info = info.slice(0).sort(function (a, b) {
                var res = a.location.range.start.compareTo(b.location.range.start);
                if (res === 0) {
                    res = b.location.range.end.compareTo(a.location.range.end);
                }
                return res;
            });
            var res = [];
            var parentStack = [];
            for (var i = 0; i < info.length; i++) {
                var element = {
                    name: info[i].name,
                    kind: typeConvert.SymbolKind.from(info[i].kind),
                    containerName: info[i].containerName,
                    range: typeConvert.Range.from(info[i].location.range),
                    selectionRange: typeConvert.Range.from(info[i].location.range),
                    children: []
                };
                while (true) {
                    if (parentStack.length === 0) {
                        parentStack.push(element);
                        res.push(element);
                        break;
                    }
                    var parent_1 = parentStack[parentStack.length - 1];
                    if (range_1.Range.containsRange(parent_1.range, element.range) && !range_1.Range.equalsRange(parent_1.range, element.range)) {
                        parent_1.children.push(element);
                        parentStack.push(element);
                        break;
                    }
                    parentStack.pop();
                }
            }
            return res;
        };
        return OutlineAdapter;
    }());
    var CodeLensAdapter = /** @class */ (function () {
        function CodeLensAdapter(_documents, _commands, _heapService, _provider) {
            this._documents = _documents;
            this._commands = _commands;
            this._heapService = _heapService;
            this._provider = _provider;
        }
        CodeLensAdapter.prototype.provideCodeLenses = function (resource, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideCodeLenses(doc, token); }).then(function (lenses) {
                if (Array.isArray(lenses)) {
                    return lenses.map(function (lens) {
                        var id = _this._heapService.keep(lens);
                        return extHost_protocol_1.ObjectIdentifier.mixin({
                            range: typeConvert.Range.from(lens.range),
                            command: _this._commands.toInternal(lens.command)
                        }, id);
                    });
                }
                return undefined;
            });
        };
        CodeLensAdapter.prototype.resolveCodeLens = function (resource, symbol, token) {
            var _this = this;
            var lens = this._heapService.get(extHost_protocol_1.ObjectIdentifier.of(symbol));
            if (!lens) {
                return undefined;
            }
            var resolve;
            if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
                resolve = Promise.resolve(lens);
            }
            else {
                resolve = async_1.asThenable(function () { return _this._provider.resolveCodeLens(lens, token); });
            }
            return resolve.then(function (newLens) {
                newLens = newLens || lens;
                symbol.command = _this._commands.toInternal(newLens.command || CodeLensAdapter._badCmd);
                return symbol;
            });
        };
        CodeLensAdapter._badCmd = { command: 'missing', title: '<<MISSING COMMAND>>' };
        return CodeLensAdapter;
    }());
    function convertToDefinitionLinks(value) {
        if (Array.isArray(value)) {
            return value.map(typeConvert.DefinitionLink.from);
        }
        else if (value) {
            return [typeConvert.DefinitionLink.from(value)];
        }
        return undefined;
    }
    var DefinitionAdapter = /** @class */ (function () {
        function DefinitionAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DefinitionAdapter.prototype.provideDefinition = function (resource, position, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideDefinition(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return DefinitionAdapter;
    }());
    var ImplementationAdapter = /** @class */ (function () {
        function ImplementationAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ImplementationAdapter.prototype.provideImplementation = function (resource, position, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideImplementation(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return ImplementationAdapter;
    }());
    var TypeDefinitionAdapter = /** @class */ (function () {
        function TypeDefinitionAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        TypeDefinitionAdapter.prototype.provideTypeDefinition = function (resource, position, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideTypeDefinition(doc, pos, token); }).then(convertToDefinitionLinks);
        };
        return TypeDefinitionAdapter;
    }());
    var HoverAdapter = /** @class */ (function () {
        function HoverAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        HoverAdapter.prototype.provideHover = function (resource, position, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideHover(doc, pos, token); }).then(function (value) {
                if (!value || arrays_1.isFalsyOrEmpty(value.contents)) {
                    return undefined;
                }
                if (!value.range) {
                    value.range = doc.getWordRangeAtPosition(pos);
                }
                if (!value.range) {
                    value.range = new extHostTypes_1.Range(pos, pos);
                }
                return typeConvert.Hover.from(value);
            });
        };
        return HoverAdapter;
    }());
    var DocumentHighlightAdapter = /** @class */ (function () {
        function DocumentHighlightAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DocumentHighlightAdapter.prototype.provideDocumentHighlights = function (resource, position, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideDocumentHighlights(doc, pos, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.DocumentHighlight.from);
                }
                return undefined;
            });
        };
        return DocumentHighlightAdapter;
    }());
    var ReferenceAdapter = /** @class */ (function () {
        function ReferenceAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ReferenceAdapter.prototype.provideReferences = function (resource, position, context, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideReferences(doc, pos, context, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.location.from);
                }
                return undefined;
            });
        };
        return ReferenceAdapter;
    }());
    var CodeActionAdapter = /** @class */ (function () {
        function CodeActionAdapter(_documents, _commands, _diagnostics, _provider, _logService, _extensionId) {
            this._documents = _documents;
            this._commands = _commands;
            this._diagnostics = _diagnostics;
            this._provider = _provider;
            this._logService = _logService;
            this._extensionId = _extensionId;
        }
        CodeActionAdapter.prototype.provideCodeActions = function (resource, rangeOrSelection, context, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var ran = selection_1.Selection.isISelection(rangeOrSelection)
                ? typeConvert.Selection.to(rangeOrSelection)
                : typeConvert.Range.to(rangeOrSelection);
            var allDiagnostics = [];
            for (var _i = 0, _a = this._diagnostics.getDiagnostics(resource); _i < _a.length; _i++) {
                var diagnostic = _a[_i];
                if (ran.intersection(diagnostic.range)) {
                    allDiagnostics.push(diagnostic);
                }
            }
            var codeActionContext = {
                diagnostics: allDiagnostics,
                only: context.only ? new extHostTypes_1.CodeActionKind(context.only) : undefined
            };
            return async_1.asThenable(function () { return _this._provider.provideCodeActions(doc, ran, codeActionContext, token); }).then(function (commandsOrActions) {
                if (arrays_1.isFalsyOrEmpty(commandsOrActions)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, commandsOrActions_1 = commandsOrActions; _i < commandsOrActions_1.length; _i++) {
                    var candidate = commandsOrActions_1[_i];
                    if (!candidate) {
                        continue;
                    }
                    if (CodeActionAdapter._isCommand(candidate)) {
                        // old school: synthetic code action
                        result.push({
                            _isSynthetic: true,
                            title: candidate.title,
                            command: _this._commands.toInternal(candidate),
                        });
                    }
                    else {
                        if (codeActionContext.only) {
                            if (!candidate.kind) {
                                _this._logService.warn(_this._extensionId + " - Code actions of kind '" + codeActionContext.only.value + " 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.");
                            }
                            else if (!codeActionContext.only.contains(candidate.kind)) {
                                _this._logService.warn(_this._extensionId + " -Code actions of kind '" + codeActionContext.only.value + " 'requested but returned code action is of kind '" + candidate.kind.value + "'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.");
                            }
                        }
                        // new school: convert code action
                        result.push({
                            title: candidate.title,
                            command: candidate.command && _this._commands.toInternal(candidate.command),
                            diagnostics: candidate.diagnostics && candidate.diagnostics.map(typeConvert.Diagnostic.from),
                            edit: candidate.edit && typeConvert.WorkspaceEdit.from(candidate.edit),
                            kind: candidate.kind && candidate.kind.value
                        });
                    }
                }
                return result;
            });
        };
        CodeActionAdapter._isCommand = function (thing) {
            return typeof thing.command === 'string' && typeof thing.title === 'string';
        };
        return CodeActionAdapter;
    }());
    var DocumentFormattingAdapter = /** @class */ (function () {
        function DocumentFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        DocumentFormattingAdapter.prototype.provideDocumentFormattingEdits = function (resource, options, token) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideDocumentFormattingEdits(document, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return DocumentFormattingAdapter;
    }());
    var RangeFormattingAdapter = /** @class */ (function () {
        function RangeFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        RangeFormattingAdapter.prototype.provideDocumentRangeFormattingEdits = function (resource, range, options, token) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var ran = typeConvert.Range.to(range);
            return async_1.asThenable(function () { return _this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return RangeFormattingAdapter;
    }());
    var OnTypeFormattingAdapter = /** @class */ (function () {
        function OnTypeFormattingAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
            this.autoFormatTriggerCharacters = []; // not here
        }
        OnTypeFormattingAdapter.prototype.provideOnTypeFormattingEdits = function (resource, position, ch, options, token) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token); }).then(function (value) {
                if (Array.isArray(value)) {
                    return value.map(typeConvert.TextEdit.from);
                }
                return undefined;
            });
        };
        return OnTypeFormattingAdapter;
    }());
    var NavigateTypeAdapter = /** @class */ (function () {
        function NavigateTypeAdapter(provider) {
            this._symbolCache = Object.create(null);
            this._resultCache = Object.create(null);
            this._provider = provider;
        }
        NavigateTypeAdapter.prototype.provideWorkspaceSymbols = function (search, token) {
            var _this = this;
            var result = extHost_protocol_1.IdObject.mixin({ symbols: [] });
            return async_1.asThenable(function () { return _this._provider.provideWorkspaceSymbols(search, token); }).then(function (value) {
                if (!arrays_1.isFalsyOrEmpty(value)) {
                    for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                        var item = value_1[_i];
                        if (!item) {
                            // drop
                            continue;
                        }
                        if (!item.name) {
                            console.warn('INVALID SymbolInformation, lacks name', item);
                            continue;
                        }
                        var symbol = extHost_protocol_1.IdObject.mixin(typeConvert.WorkspaceSymbol.from(item));
                        _this._symbolCache[symbol._id] = item;
                        result.symbols.push(symbol);
                    }
                }
            }).then(function () {
                if (result.symbols.length > 0) {
                    _this._resultCache[result._id] = [result.symbols[0]._id, result.symbols[result.symbols.length - 1]._id];
                }
                return result;
            });
        };
        NavigateTypeAdapter.prototype.resolveWorkspaceSymbol = function (symbol, token) {
            var _this = this;
            if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
                return Promise.resolve(symbol);
            }
            var item = this._symbolCache[symbol._id];
            if (item) {
                return async_1.asThenable(function () { return _this._provider.resolveWorkspaceSymbol(item, token); }).then(function (value) {
                    return value && objects_1.mixin(symbol, typeConvert.WorkspaceSymbol.from(value), true);
                });
            }
            return undefined;
        };
        NavigateTypeAdapter.prototype.releaseWorkspaceSymbols = function (id) {
            var range = this._resultCache[id];
            if (range) {
                for (var from = range[0], to = range[1]; from <= to; from++) {
                    delete this._symbolCache[from];
                }
                delete this._resultCache[id];
            }
        };
        return NavigateTypeAdapter;
    }());
    var RenameAdapter = /** @class */ (function () {
        function RenameAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        RenameAdapter.supportsResolving = function (provider) {
            return typeof provider.prepareRename === 'function';
        };
        RenameAdapter.prototype.provideRenameEdits = function (resource, position, newName, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideRenameEdits(doc, pos, newName, token); }).then(function (value) {
                if (!value) {
                    return undefined;
                }
                return typeConvert.WorkspaceEdit.from(value);
            }, function (err) {
                var rejectReason = RenameAdapter._asMessage(err);
                if (rejectReason) {
                    return { rejectReason: rejectReason, edits: undefined };
                }
                else {
                    // generic error
                    return Promise.reject(err);
                }
            });
        };
        RenameAdapter.prototype.resolveRenameLocation = function (resource, position, token) {
            var _this = this;
            if (typeof this._provider.prepareRename !== 'function') {
                return Promise.resolve(undefined);
            }
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.prepareRename(doc, pos, token); }).then(function (rangeOrLocation) {
                var range;
                var text;
                if (extHostTypes_1.Range.isRange(rangeOrLocation)) {
                    range = rangeOrLocation;
                    text = doc.getText(rangeOrLocation);
                }
                else if (types_1.isObject(rangeOrLocation)) {
                    range = rangeOrLocation.range;
                    text = rangeOrLocation.placeholder;
                }
                if (!range) {
                    return undefined;
                }
                if (range.start.line > pos.line || range.end.line < pos.line) {
                    console.warn('INVALID rename location: position line must be within range start/end lines');
                    return undefined;
                }
                return { range: typeConvert.Range.from(range), text: text };
            }, function (err) {
                var rejectReason = RenameAdapter._asMessage(err);
                if (rejectReason) {
                    return { rejectReason: rejectReason, range: undefined, text: undefined };
                }
                else {
                    return Promise.reject(err);
                }
            });
        };
        RenameAdapter._asMessage = function (err) {
            if (typeof err === 'string') {
                return err;
            }
            else if (err instanceof Error && typeof err.message === 'string') {
                return err.message;
            }
            else {
                return undefined;
            }
        };
        return RenameAdapter;
    }());
    var SuggestAdapter = /** @class */ (function () {
        function SuggestAdapter(documents, commands, provider) {
            this._cache = new Map();
            this._idPool = 0;
            this._documents = documents;
            this._commands = commands;
            this._provider = provider;
        }
        SuggestAdapter.supportsResolving = function (provider) {
            return typeof provider.resolveCompletionItem === 'function';
        };
        SuggestAdapter.prototype.provideCompletionItems = function (resource, position, context, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideCompletionItems(doc, pos, token, typeConvert.CompletionContext.to(context)); }).then(function (value) {
                var _id = _this._idPool++;
                var result = {
                    _id: _id,
                    suggestions: [],
                };
                var list;
                if (!value) {
                    // undefined and null are valid results
                    return undefined;
                }
                else if (Array.isArray(value)) {
                    list = new extHostTypes_1.CompletionList(value);
                }
                else {
                    list = value;
                    result.incomplete = list.isIncomplete;
                }
                // the default text edit range
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos))
                    .with({ end: pos });
                for (var i = 0; i < list.items.length; i++) {
                    var suggestion = _this._convertCompletionItem(list.items[i], pos, wordRangeBeforePos, i, _id);
                    // check for bad completion item
                    // for the converter did warn
                    if (suggestion) {
                        result.suggestions.push(suggestion);
                    }
                }
                _this._cache.set(_id, list.items);
                return result;
            });
        };
        SuggestAdapter.prototype.resolveCompletionItem = function (resource, position, suggestion, token) {
            var _this = this;
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return Promise.resolve(suggestion);
            }
            var _a = suggestion, _parentId = _a._parentId, _id = _a._id;
            var item = this._cache.has(_parentId) && this._cache.get(_parentId)[_id];
            if (!item) {
                return Promise.resolve(suggestion);
            }
            return async_1.asThenable(function () { return _this._provider.resolveCompletionItem(item, token); }).then(function (resolvedItem) {
                if (!resolvedItem) {
                    return suggestion;
                }
                var doc = _this._documents.getDocumentData(resource).document;
                var pos = typeConvert.Position.to(position);
                var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos)).with({ end: pos });
                var newSuggestion = _this._convertCompletionItem(resolvedItem, pos, wordRangeBeforePos, _id, _parentId);
                if (newSuggestion) {
                    objects_1.mixin(suggestion, newSuggestion, true);
                }
                return suggestion;
            });
        };
        SuggestAdapter.prototype.releaseCompletionItems = function (id) {
            this._cache.delete(id);
        };
        SuggestAdapter.prototype._convertCompletionItem = function (item, position, defaultRange, _id, _parentId) {
            if (typeof item.label !== 'string' || item.label.length === 0) {
                console.warn('INVALID text edit -> must have at least a label');
                return undefined;
            }
            var result = {
                //
                _id: _id,
                _parentId: _parentId,
                //
                label: item.label,
                kind: typeConvert.CompletionItemKind.from(item.kind),
                detail: item.detail,
                documentation: item.documentation,
                filterText: item.filterText,
                sortText: item.sortText,
                preselect: item.preselect,
                //
                range: undefined,
                insertText: undefined,
                insertTextRules: typeConvert.CompletionItemInsertTextRule.from(item.insertTextRules),
                additionalTextEdits: item.additionalTextEdits && item.additionalTextEdits.map(typeConvert.TextEdit.from),
                command: this._commands.toInternal(item.command),
                commitCharacters: item.commitCharacters,
                // help with perf
                _labelLow: item.label.toLowerCase(),
                _filterTextLow: item.filterText && item.filterText.toLowerCase(),
                _sortTextLow: item.sortText && item.sortText.toLowerCase()
            };
            // 'insertText'-logic
            if (item.textEdit) {
                result.insertText = item.textEdit.newText;
            }
            else if (typeof item.insertText === 'string') {
                result.insertText = item.insertText;
            }
            else if (item.insertText instanceof extHostTypes_1.SnippetString) {
                result.insertText = item.insertText.value;
                result.insertTextRules += 4 /* InsertAsSnippet */;
            }
            else {
                result.insertText = item.label;
            }
            // 'overwrite[Before|After]'-logic
            var range;
            if (item.textEdit) {
                range = item.textEdit.range;
            }
            else if (item.range) {
                range = item.range;
            }
            else {
                range = defaultRange;
            }
            result.range = typeConvert.Range.from(range);
            if (!range.isSingleLine || range.start.line !== position.line) {
                console.warn('INVALID text edit -> must be single line and on the same line');
                return undefined;
            }
            return result;
        };
        return SuggestAdapter;
    }());
    var SignatureHelpAdapter = /** @class */ (function () {
        function SignatureHelpAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        SignatureHelpAdapter.prototype.provideSignatureHelp = function (resource, position, context, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            var pos = typeConvert.Position.to(position);
            return async_1.asThenable(function () { return _this._provider.provideSignatureHelp(doc, pos, token, context); }).then(function (value) {
                if (value) {
                    return typeConvert.SignatureHelp.from(value);
                }
                return undefined;
            });
        };
        return SignatureHelpAdapter;
    }());
    var LinkProviderAdapter = /** @class */ (function () {
        function LinkProviderAdapter(_documents, _heapService, _provider) {
            this._documents = _documents;
            this._heapService = _heapService;
            this._provider = _provider;
        }
        LinkProviderAdapter.prototype.provideLinks = function (resource, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideDocumentLinks(doc, token); }).then(function (links) {
                if (!Array.isArray(links)) {
                    return undefined;
                }
                var result = [];
                for (var _i = 0, links_1 = links; _i < links_1.length; _i++) {
                    var link = links_1[_i];
                    var data = typeConvert.DocumentLink.from(link);
                    var id = _this._heapService.keep(link);
                    extHost_protocol_1.ObjectIdentifier.mixin(data, id);
                    result.push(data);
                }
                return result;
            });
        };
        LinkProviderAdapter.prototype.resolveLink = function (link, token) {
            var _this = this;
            if (typeof this._provider.resolveDocumentLink !== 'function') {
                return undefined;
            }
            var id = extHost_protocol_1.ObjectIdentifier.of(link);
            var item = this._heapService.get(id);
            if (!item) {
                return undefined;
            }
            return async_1.asThenable(function () { return _this._provider.resolveDocumentLink(item, token); }).then(function (value) {
                if (value) {
                    return typeConvert.DocumentLink.from(value);
                }
                return undefined;
            });
        };
        return LinkProviderAdapter;
    }());
    var ColorProviderAdapter = /** @class */ (function () {
        function ColorProviderAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        ColorProviderAdapter.prototype.provideColors = function (resource, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideDocumentColors(doc, token); }).then(function (colors) {
                if (!Array.isArray(colors)) {
                    return [];
                }
                var colorInfos = colors.map(function (ci) {
                    return {
                        color: typeConvert.Color.from(ci.color),
                        range: typeConvert.Range.from(ci.range)
                    };
                });
                return colorInfos;
            });
        };
        ColorProviderAdapter.prototype.provideColorPresentations = function (resource, raw, token) {
            var _this = this;
            var document = this._documents.getDocumentData(resource).document;
            var range = typeConvert.Range.to(raw.range);
            var color = typeConvert.Color.to(raw.color);
            return async_1.asThenable(function () { return _this._provider.provideColorPresentations(color, { document: document, range: range }, token); }).then(function (value) {
                return value.map(typeConvert.ColorPresentation.from);
            });
        };
        return ColorProviderAdapter;
    }());
    var FoldingProviderAdapter = /** @class */ (function () {
        function FoldingProviderAdapter(_documents, _provider) {
            this._documents = _documents;
            this._provider = _provider;
        }
        FoldingProviderAdapter.prototype.provideFoldingRanges = function (resource, context, token) {
            var _this = this;
            var doc = this._documents.getDocumentData(resource).document;
            return async_1.asThenable(function () { return _this._provider.provideFoldingRanges(doc, context, token); }).then(function (ranges) {
                if (!Array.isArray(ranges)) {
                    return void 0;
                }
                return ranges.map(typeConvert.FoldingRange.from);
            });
        };
        return FoldingProviderAdapter;
    }());
    var ExtHostLanguageFeatures = /** @class */ (function () {
        function ExtHostLanguageFeatures(mainContext, schemeTransformer, documents, commands, heapMonitor, diagnostics, logService) {
            this._adapter = new Map();
            this._schemeTransformer = schemeTransformer;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadLanguageFeatures);
            this._documents = documents;
            this._commands = commands;
            this._heapService = heapMonitor;
            this._diagnostics = diagnostics;
            this._logService = logService;
        }
        ExtHostLanguageFeatures.prototype._transformDocumentSelector = function (selector) {
            var _this = this;
            if (Array.isArray(selector)) {
                return selector.map(function (sel) { return _this._doTransformDocumentSelector(sel); });
            }
            return [this._doTransformDocumentSelector(selector)];
        };
        ExtHostLanguageFeatures.prototype._doTransformDocumentSelector = function (selector) {
            if (typeof selector === 'string') {
                return {
                    $serialized: true,
                    language: selector
                };
            }
            if (selector) {
                return {
                    $serialized: true,
                    language: selector.language,
                    scheme: this._transformScheme(selector.scheme),
                    pattern: selector.pattern,
                    exclusive: selector.exclusive
                };
            }
            return undefined;
        };
        ExtHostLanguageFeatures.prototype._transformScheme = function (scheme) {
            if (this._schemeTransformer && typeof scheme === 'string') {
                return this._schemeTransformer.transformOutgoing(scheme);
            }
            return scheme;
        };
        ExtHostLanguageFeatures.prototype._createDisposable = function (handle) {
            var _this = this;
            return new extHostTypes_1.Disposable(function () {
                _this._adapter.delete(handle);
                _this._proxy.$unregister(handle);
            });
        };
        ExtHostLanguageFeatures.prototype._nextHandle = function () {
            return ExtHostLanguageFeatures._handlePool++;
        };
        ExtHostLanguageFeatures.prototype._withAdapter = function (handle, ctor, callback) {
            var adapter = this._adapter.get(handle);
            if (!(adapter instanceof ctor)) {
                return Promise.reject(new Error('no adapter found'));
            }
            return callback(adapter);
        };
        ExtHostLanguageFeatures.prototype._addNewAdapter = function (adapter) {
            var handle = this._nextHandle();
            this._adapter.set(handle, adapter);
            return handle;
        };
        // --- outline
        ExtHostLanguageFeatures.prototype.registerDocumentSymbolProvider = function (selector, provider, extension) {
            var handle = this._addNewAdapter(new OutlineAdapter(this._documents, provider));
            this._proxy.$registerOutlineSupport(handle, this._transformDocumentSelector(selector), extension ? extension.displayName || extension.name : undefined);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentSymbols = function (handle, resource, token) {
            return this._withAdapter(handle, OutlineAdapter, function (adapter) { return adapter.provideDocumentSymbols(uri_1.URI.revive(resource), token); });
        };
        // --- code lens
        ExtHostLanguageFeatures.prototype.registerCodeLensProvider = function (selector, provider) {
            var _this = this;
            var handle = this._nextHandle();
            var eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;
            this._adapter.set(handle, new CodeLensAdapter(this._documents, this._commands.converter, this._heapService, provider));
            this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector), eventHandle);
            var result = this._createDisposable(handle);
            if (eventHandle !== undefined) {
                var subscription = provider.onDidChangeCodeLenses(function (_) { return _this._proxy.$emitCodeLensEvent(eventHandle); });
                result = extHostTypes_1.Disposable.from(result, subscription);
            }
            return result;
        };
        ExtHostLanguageFeatures.prototype.$provideCodeLenses = function (handle, resource, token) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.provideCodeLenses(uri_1.URI.revive(resource), token); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCodeLens = function (handle, resource, symbol, token) {
            return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.resolveCodeLens(uri_1.URI.revive(resource), symbol, token); });
        };
        // --- declaration
        ExtHostLanguageFeatures.prototype.registerDefinitionProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DefinitionAdapter(this._documents, provider));
            this._proxy.$registerDeclaractionSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDefinition = function (handle, resource, position, token) {
            return this._withAdapter(handle, DefinitionAdapter, function (adapter) { return adapter.provideDefinition(uri_1.URI.revive(resource), position, token); });
        };
        ExtHostLanguageFeatures.prototype.registerImplementationProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ImplementationAdapter(this._documents, provider));
            this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideImplementation = function (handle, resource, position, token) {
            return this._withAdapter(handle, ImplementationAdapter, function (adapter) { return adapter.provideImplementation(uri_1.URI.revive(resource), position, token); });
        };
        ExtHostLanguageFeatures.prototype.registerTypeDefinitionProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new TypeDefinitionAdapter(this._documents, provider));
            this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideTypeDefinition = function (handle, resource, position, token) {
            return this._withAdapter(handle, TypeDefinitionAdapter, function (adapter) { return adapter.provideTypeDefinition(uri_1.URI.revive(resource), position, token); });
        };
        // --- extra info
        ExtHostLanguageFeatures.prototype.registerHoverProvider = function (selector, provider, extensionId) {
            var handle = this._addNewAdapter(new HoverAdapter(this._documents, provider));
            this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideHover = function (handle, resource, position, token) {
            return this._withAdapter(handle, HoverAdapter, function (adapter) { return adapter.provideHover(uri_1.URI.revive(resource), position, token); });
        };
        // --- occurrences
        ExtHostLanguageFeatures.prototype.registerDocumentHighlightProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DocumentHighlightAdapter(this._documents, provider));
            this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentHighlights = function (handle, resource, position, token) {
            return this._withAdapter(handle, DocumentHighlightAdapter, function (adapter) { return adapter.provideDocumentHighlights(uri_1.URI.revive(resource), position, token); });
        };
        // --- references
        ExtHostLanguageFeatures.prototype.registerReferenceProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ReferenceAdapter(this._documents, provider));
            this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideReferences = function (handle, resource, position, context, token) {
            return this._withAdapter(handle, ReferenceAdapter, function (adapter) { return adapter.provideReferences(uri_1.URI.revive(resource), position, context, token); });
        };
        // --- quick fix
        ExtHostLanguageFeatures.prototype.registerCodeActionProvider = function (selector, provider, extension, metadata) {
            var handle = this._addNewAdapter(new CodeActionAdapter(this._documents, this._commands.converter, this._diagnostics, provider, this._logService, extension ? extension.id : ''));
            this._proxy.$registerQuickFixSupport(handle, this._transformDocumentSelector(selector), metadata && metadata.providedCodeActionKinds ? metadata.providedCodeActionKinds.map(function (kind) { return kind.value; }) : undefined);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCodeActions = function (handle, resource, rangeOrSelection, context, token) {
            return this._withAdapter(handle, CodeActionAdapter, function (adapter) { return adapter.provideCodeActions(uri_1.URI.revive(resource), rangeOrSelection, context, token); });
        };
        // --- formatting
        ExtHostLanguageFeatures.prototype.registerDocumentFormattingEditProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new DocumentFormattingAdapter(this._documents, provider));
            this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentFormattingEdits = function (handle, resource, options, token) {
            return this._withAdapter(handle, DocumentFormattingAdapter, function (adapter) { return adapter.provideDocumentFormattingEdits(uri_1.URI.revive(resource), options, token); });
        };
        ExtHostLanguageFeatures.prototype.registerDocumentRangeFormattingEditProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new RangeFormattingAdapter(this._documents, provider));
            this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentRangeFormattingEdits = function (handle, resource, range, options, token) {
            return this._withAdapter(handle, RangeFormattingAdapter, function (adapter) { return adapter.provideDocumentRangeFormattingEdits(uri_1.URI.revive(resource), range, options, token); });
        };
        ExtHostLanguageFeatures.prototype.registerOnTypeFormattingEditProvider = function (selector, provider, triggerCharacters) {
            var handle = this._addNewAdapter(new OnTypeFormattingAdapter(this._documents, provider));
            this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector), triggerCharacters);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideOnTypeFormattingEdits = function (handle, resource, position, ch, options, token) {
            return this._withAdapter(handle, OnTypeFormattingAdapter, function (adapter) { return adapter.provideOnTypeFormattingEdits(uri_1.URI.revive(resource), position, ch, options, token); });
        };
        // --- navigate types
        ExtHostLanguageFeatures.prototype.registerWorkspaceSymbolProvider = function (provider) {
            var handle = this._addNewAdapter(new NavigateTypeAdapter(provider));
            this._proxy.$registerNavigateTypeSupport(handle);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideWorkspaceSymbols = function (handle, search, token) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.provideWorkspaceSymbols(search, token); });
        };
        ExtHostLanguageFeatures.prototype.$resolveWorkspaceSymbol = function (handle, symbol, token) {
            return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.resolveWorkspaceSymbol(symbol, token); });
        };
        ExtHostLanguageFeatures.prototype.$releaseWorkspaceSymbols = function (handle, id) {
            this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.releaseWorkspaceSymbols(id); });
        };
        // --- rename
        ExtHostLanguageFeatures.prototype.registerRenameProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new RenameAdapter(this._documents, provider));
            this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector), RenameAdapter.supportsResolving(provider));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideRenameEdits = function (handle, resource, position, newName, token) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.provideRenameEdits(uri_1.URI.revive(resource), position, newName, token); });
        };
        ExtHostLanguageFeatures.prototype.$resolveRenameLocation = function (handle, resource, position, token) {
            return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.resolveRenameLocation(uri_1.URI.revive(resource), position, token); });
        };
        // --- suggestion
        ExtHostLanguageFeatures.prototype.registerCompletionItemProvider = function (selector, provider, triggerCharacters) {
            var handle = this._addNewAdapter(new SuggestAdapter(this._documents, this._commands.converter, provider));
            this._proxy.$registerSuggestSupport(handle, this._transformDocumentSelector(selector), triggerCharacters, SuggestAdapter.supportsResolving(provider));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideCompletionItems = function (handle, resource, position, context, token) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.provideCompletionItems(uri_1.URI.revive(resource), position, context, token); });
        };
        ExtHostLanguageFeatures.prototype.$resolveCompletionItem = function (handle, resource, position, suggestion, token) {
            return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.resolveCompletionItem(uri_1.URI.revive(resource), position, suggestion, token); });
        };
        ExtHostLanguageFeatures.prototype.$releaseCompletionItems = function (handle, id) {
            this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.releaseCompletionItems(id); });
        };
        // --- parameter hints
        ExtHostLanguageFeatures.prototype.registerSignatureHelpProvider = function (selector, provider, metadataOrTriggerChars) {
            var metadata = Array.isArray(metadataOrTriggerChars)
                ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }
                : metadataOrTriggerChars;
            var handle = this._addNewAdapter(new SignatureHelpAdapter(this._documents, provider));
            this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector), metadata);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideSignatureHelp = function (handle, resource, position, context, token) {
            return this._withAdapter(handle, SignatureHelpAdapter, function (adapter) { return adapter.provideSignatureHelp(uri_1.URI.revive(resource), position, context, token); });
        };
        // --- links
        ExtHostLanguageFeatures.prototype.registerDocumentLinkProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new LinkProviderAdapter(this._documents, this._heapService, provider));
            this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentLinks = function (handle, resource, token) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.provideLinks(uri_1.URI.revive(resource), token); });
        };
        ExtHostLanguageFeatures.prototype.$resolveDocumentLink = function (handle, link, token) {
            return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.resolveLink(link, token); });
        };
        ExtHostLanguageFeatures.prototype.registerColorProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new ColorProviderAdapter(this._documents, provider));
            this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideDocumentColors = function (handle, resource, token) {
            return this._withAdapter(handle, ColorProviderAdapter, function (adapter) { return adapter.provideColors(uri_1.URI.revive(resource), token); });
        };
        ExtHostLanguageFeatures.prototype.$provideColorPresentations = function (handle, resource, colorInfo, token) {
            return this._withAdapter(handle, ColorProviderAdapter, function (adapter) { return adapter.provideColorPresentations(uri_1.URI.revive(resource), colorInfo, token); });
        };
        ExtHostLanguageFeatures.prototype.registerFoldingRangeProvider = function (selector, provider) {
            var handle = this._addNewAdapter(new FoldingProviderAdapter(this._documents, provider));
            this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector));
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures.prototype.$provideFoldingRanges = function (handle, resource, context, token) {
            return this._withAdapter(handle, FoldingProviderAdapter, function (adapter) { return adapter.provideFoldingRanges(uri_1.URI.revive(resource), context, token); });
        };
        // --- configuration
        ExtHostLanguageFeatures._serializeRegExp = function (regExp) {
            if (typeof regExp === 'undefined') {
                return undefined;
            }
            if (regExp === null) {
                return null;
            }
            return {
                pattern: regExp.source,
                flags: (regExp.global ? 'g' : '') + (regExp.ignoreCase ? 'i' : '') + (regExp.multiline ? 'm' : ''),
            };
        };
        ExtHostLanguageFeatures._serializeIndentationRule = function (indentationRule) {
            if (typeof indentationRule === 'undefined') {
                return undefined;
            }
            if (indentationRule === null) {
                return null;
            }
            return {
                decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
                increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
                indentNextLinePattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern),
                unIndentedLinePattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern),
            };
        };
        ExtHostLanguageFeatures._serializeOnEnterRule = function (onEnterRule) {
            return {
                beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
                afterText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText),
                oneLineAboveText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.oneLineAboveText),
                action: onEnterRule.action
            };
        };
        ExtHostLanguageFeatures._serializeOnEnterRules = function (onEnterRules) {
            if (typeof onEnterRules === 'undefined') {
                return undefined;
            }
            if (onEnterRules === null) {
                return null;
            }
            return onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule);
        };
        ExtHostLanguageFeatures.prototype.setLanguageConfiguration = function (languageId, configuration) {
            var wordPattern = configuration.wordPattern;
            // check for a valid word pattern
            if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {
                throw new Error("Invalid language configuration: wordPattern '" + wordPattern + "' is not allowed to match the empty string.");
            }
            // word definition
            if (wordPattern) {
                this._documents.setWordDefinitionFor(languageId, wordPattern);
            }
            else {
                this._documents.setWordDefinitionFor(languageId, null);
            }
            var handle = this._nextHandle();
            var serializedConfiguration = {
                comments: configuration.comments,
                brackets: configuration.brackets,
                wordPattern: ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern),
                indentationRules: ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules),
                onEnterRules: ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules),
                __electricCharacterSupport: configuration.__electricCharacterSupport,
                __characterPairSupport: configuration.__characterPairSupport,
            };
            this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
            return this._createDisposable(handle);
        };
        ExtHostLanguageFeatures._handlePool = 0;
        return ExtHostLanguageFeatures;
    }());
    exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[159/*vs/workbench/api/node/extHostLanguages*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostLanguages = /** @class */ (function () {
        function ExtHostLanguages(mainContext, documents) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadLanguages);
            this._documents = documents;
        }
        ExtHostLanguages.prototype.getLanguages = function () {
            return this._proxy.$getLanguages();
        };
        ExtHostLanguages.prototype.changeLanguage = function (uri, languageId) {
            var _this = this;
            return this._proxy.$changeLanguage(uri, languageId).then(function () {
                return _this._documents.getDocumentData(uri).document;
            });
        };
        return ExtHostLanguages;
    }());
    exports.ExtHostLanguages = ExtHostLanguages;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[160/*vs/workbench/api/node/extHostMessageService*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isMessageItem(item) {
        return item && item.title;
    }
    var ExtHostMessageService = /** @class */ (function () {
        function ExtHostMessageService(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadMessageService);
        }
        ExtHostMessageService.prototype.showMessage = function (extension, severity, message, optionsOrFirstItem, rest) {
            var options = { extension: extension };
            var items;
            if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {
                items = [optionsOrFirstItem].concat(rest);
            }
            else {
                options.modal = optionsOrFirstItem && optionsOrFirstItem.modal;
                items = rest;
            }
            var commands = [];
            for (var handle = 0; handle < items.length; handle++) {
                var command = items[handle];
                if (typeof command === 'string') {
                    commands.push({ title: command, handle: handle, isCloseAffordance: false });
                }
                else if (typeof command === 'object') {
                    var title = command.title, isCloseAffordance = command.isCloseAffordance;
                    commands.push({ title: title, isCloseAffordance: isCloseAffordance, handle: handle });
                }
                else {
                    console.warn('Invalid message item:', command);
                }
            }
            return this._proxy.$showMessage(severity, message, options, commands).then(function (handle) {
                if (typeof handle === 'number') {
                    return items[handle];
                }
                return undefined;
            });
        };
        return ExtHostMessageService;
    }());
    exports.ExtHostMessageService = ExtHostMessageService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[161/*vs/workbench/api/node/extHostOutputService*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/,2/*vs/base/common/uri*/,10/*path*/,108/*vs/platform/output/node/outputAppender*/,120/*vs/base/common/date*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/]), function (require, exports, extHost_protocol_1, uri_1, path_1, outputAppender_1, date_1, event_1, lifecycle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractExtHostOutputChannel = /** @class */ (function (_super) {
        __extends(AbstractExtHostOutputChannel, _super);
        function AbstractExtHostOutputChannel(name, log, file, proxy) {
            var _this = _super.call(this) || this;
            _this._onDidAppend = _this._register(new event_1.Emitter());
            _this.onDidAppend = _this._onDidAppend.event;
            _this._name = name;
            _this._proxy = proxy;
            _this._id = proxy.$register(_this.name, log, file);
            _this._offset = 0;
            return _this;
        }
        Object.defineProperty(AbstractExtHostOutputChannel.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        AbstractExtHostOutputChannel.prototype.append = function (value) {
            this.validate();
            this._offset += value ? Buffer.from(value).byteLength : 0;
        };
        AbstractExtHostOutputChannel.prototype.update = function () {
            var _this = this;
            this._id.then(function (id) { return _this._proxy.$update(id); });
        };
        AbstractExtHostOutputChannel.prototype.appendLine = function (value) {
            this.validate();
            this.append(value + '\n');
        };
        AbstractExtHostOutputChannel.prototype.clear = function () {
            var _this = this;
            this.validate();
            var till = this._offset;
            this._id.then(function (id) { return _this._proxy.$clear(id, till); });
        };
        AbstractExtHostOutputChannel.prototype.show = function (columnOrPreserveFocus, preserveFocus) {
            var _this = this;
            this.validate();
            this._id.then(function (id) { return _this._proxy.$reveal(id, typeof columnOrPreserveFocus === 'boolean' ? columnOrPreserveFocus : preserveFocus); });
        };
        AbstractExtHostOutputChannel.prototype.hide = function () {
            var _this = this;
            this.validate();
            this._id.then(function (id) { return _this._proxy.$close(id); });
        };
        AbstractExtHostOutputChannel.prototype.validate = function () {
            if (this._disposed) {
                throw new Error('Channel has been closed');
            }
        };
        AbstractExtHostOutputChannel.prototype.dispose = function () {
            var _this = this;
            _super.prototype.dispose.call(this);
            if (!this._disposed) {
                this._id
                    .then(function (id) { return _this._proxy.$dispose(id); })
                    .then(function () { return _this._disposed = true; });
            }
        };
        return AbstractExtHostOutputChannel;
    }(lifecycle_1.Disposable));
    exports.AbstractExtHostOutputChannel = AbstractExtHostOutputChannel;
    var ExtHostPushOutputChannel = /** @class */ (function (_super) {
        __extends(ExtHostPushOutputChannel, _super);
        function ExtHostPushOutputChannel(name, proxy) {
            return _super.call(this, name, false, null, proxy) || this;
        }
        ExtHostPushOutputChannel.prototype.append = function (value) {
            var _this = this;
            _super.prototype.append.call(this, value);
            this._id.then(function (id) { return _this._proxy.$append(id, value); });
            this._onDidAppend.fire();
        };
        return ExtHostPushOutputChannel;
    }(AbstractExtHostOutputChannel));
    exports.ExtHostPushOutputChannel = ExtHostPushOutputChannel;
    var ExtHostOutputChannelBackedByFile = /** @class */ (function (_super) {
        __extends(ExtHostOutputChannelBackedByFile, _super);
        function ExtHostOutputChannelBackedByFile(name, outputDir, proxy) {
            var _this = this;
            var fileName = ExtHostOutputChannelBackedByFile._namePool++ + "-" + name;
            var file = uri_1.URI.file(path_1.posix.join(outputDir, fileName + ".log"));
            _this = _super.call(this, name, false, file, proxy) || this;
            _this._appender = new outputAppender_1.OutputAppender(fileName, file.fsPath);
            return _this;
        }
        ExtHostOutputChannelBackedByFile.prototype.append = function (value) {
            _super.prototype.append.call(this, value);
            this._appender.append(value);
            this._onDidAppend.fire();
        };
        ExtHostOutputChannelBackedByFile.prototype.update = function () {
            this._appender.flush();
            _super.prototype.update.call(this);
        };
        ExtHostOutputChannelBackedByFile.prototype.show = function (columnOrPreserveFocus, preserveFocus) {
            this._appender.flush();
            _super.prototype.show.call(this, columnOrPreserveFocus, preserveFocus);
        };
        ExtHostOutputChannelBackedByFile.prototype.clear = function () {
            this._appender.flush();
            _super.prototype.clear.call(this);
        };
        ExtHostOutputChannelBackedByFile._namePool = 1;
        return ExtHostOutputChannelBackedByFile;
    }(AbstractExtHostOutputChannel));
    exports.ExtHostOutputChannelBackedByFile = ExtHostOutputChannelBackedByFile;
    var ExtHostLogFileOutputChannel = /** @class */ (function (_super) {
        __extends(ExtHostLogFileOutputChannel, _super);
        function ExtHostLogFileOutputChannel(name, file, proxy) {
            return _super.call(this, name, true, file, proxy) || this;
        }
        ExtHostLogFileOutputChannel.prototype.append = function (value) {
            throw new Error('Not supported');
        };
        return ExtHostLogFileOutputChannel;
    }(AbstractExtHostOutputChannel));
    exports.ExtHostLogFileOutputChannel = ExtHostLogFileOutputChannel;
    var ExtHostOutputService = /** @class */ (function () {
        function ExtHostOutputService(logsLocation, mainContext) {
            this._channels = new Map();
            this._outputDir = path_1.posix.join(logsLocation.fsPath, "output_logging_" + date_1.toLocalISOString(new Date()).replace(/-|:|\.\d+Z$/g, ''));
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadOutputService);
        }
        ExtHostOutputService.prototype.$setVisibleChannel = function (channelId) {
            if (this._visibleChannelDisposable) {
                this._visibleChannelDisposable = lifecycle_1.dispose(this._visibleChannelDisposable);
            }
            if (channelId) {
                var channel_1 = this._channels.get(channelId);
                if (channel_1) {
                    this._visibleChannelDisposable = channel_1.onDidAppend(function () { return channel_1.update(); });
                }
            }
        };
        ExtHostOutputService.prototype.createOutputChannel = function (name) {
            var _this = this;
            var channel = this._createOutputChannel(name);
            channel._id.then(function (id) { return _this._channels.set(id, channel); });
            return channel;
        };
        ExtHostOutputService.prototype._createOutputChannel = function (name) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            else {
                // Do not crash if logger cannot be created
                try {
                    return new ExtHostOutputChannelBackedByFile(name, this._outputDir, this._proxy);
                }
                catch (error) {
                    console.log(error);
                    return new ExtHostPushOutputChannel(name, this._proxy);
                }
            }
        };
        ExtHostOutputService.prototype.createOutputChannelFromLogFile = function (name, file) {
            name = name.trim();
            if (!name) {
                throw new Error('illegal argument `name`. must not be falsy');
            }
            if (!file) {
                throw new Error('illegal argument `file`. must not be falsy');
            }
            return new ExtHostLogFileOutputChannel(name, file, this._proxy);
        };
        return ExtHostOutputService;
    }());
    exports.ExtHostOutputService = ExtHostOutputService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[162/*vs/workbench/api/node/extHostQuickOpen*/], __M([1/*require*/,0/*exports*/,11/*vs/base/common/async*/,17/*vs/base/common/cancellation*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,4/*vs/workbench/api/node/extHost.protocol*/,2/*vs/base/common/uri*/,7/*vs/workbench/api/node/extHostTypes*/,14/*vs/base/common/errors*/]), function (require, exports, async_1, cancellation_1, event_1, lifecycle_1, extHost_protocol_1, uri_1, extHostTypes_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostQuickOpen = /** @class */ (function () {
        function ExtHostQuickOpen(mainContext, workspace, commands) {
            this._sessions = new Map();
            this._instances = 0;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadQuickOpen);
            this._workspace = workspace;
            this._commands = commands;
        }
        ExtHostQuickOpen.prototype.showQuickPick = function (itemsOrItemsPromise, enableProposedApi, options, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // clear state from last invocation
            this._onDidSelectItem = undefined;
            var itemsPromise = Promise.resolve(itemsOrItemsPromise);
            var instance = ++this._instances;
            var quickPickWidget = this._proxy.$show(instance, {
                placeHolder: options && options.placeHolder,
                matchOnDescription: options && options.matchOnDescription,
                matchOnDetail: options && options.matchOnDetail,
                ignoreFocusLost: options && options.ignoreFocusOut,
                canPickMany: options && options.canPickMany
            }, token);
            var widgetClosedMarker = {};
            var widgetClosedPromise = quickPickWidget.then(function () { return widgetClosedMarker; });
            return Promise.race([widgetClosedPromise, itemsPromise]).then(function (result) {
                if (result === widgetClosedMarker) {
                    return undefined;
                }
                return itemsPromise.then(function (items) {
                    var pickItems = [];
                    for (var handle = 0; handle < items.length; handle++) {
                        var item = items[handle];
                        var label = void 0;
                        var description = void 0;
                        var detail = void 0;
                        var picked = void 0;
                        var alwaysShow = void 0;
                        if (typeof item === 'string') {
                            label = item;
                        }
                        else {
                            label = item.label;
                            description = item.description;
                            detail = item.detail;
                            picked = item.picked;
                            alwaysShow = item.alwaysShow;
                        }
                        pickItems.push({
                            label: label,
                            description: description,
                            handle: handle,
                            detail: detail,
                            picked: picked,
                            alwaysShow: alwaysShow
                        });
                    }
                    // handle selection changes
                    if (options && typeof options.onDidSelectItem === 'function') {
                        _this._onDidSelectItem = function (handle) {
                            options.onDidSelectItem(items[handle]);
                        };
                    }
                    // show items
                    _this._proxy.$setItems(instance, pickItems);
                    return quickPickWidget.then(function (handle) {
                        if (typeof handle === 'number') {
                            return items[handle];
                        }
                        else if (Array.isArray(handle)) {
                            return handle.map(function (h) { return items[h]; });
                        }
                        return undefined;
                    });
                });
            }).then(null, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return undefined;
                }
                _this._proxy.$setError(instance, err);
                return Promise.reject(err);
            });
        };
        ExtHostQuickOpen.prototype.$onItemSelected = function (handle) {
            if (this._onDidSelectItem) {
                this._onDidSelectItem(handle);
            }
        };
        // ---- input
        ExtHostQuickOpen.prototype.showInput = function (options, token) {
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            // global validate fn used in callback below
            this._validateInput = options && options.validateInput;
            return this._proxy.$input(options, typeof this._validateInput === 'function', token)
                .then(null, function (err) {
                if (errors_1.isPromiseCanceledError(err)) {
                    return undefined;
                }
                return Promise.reject(err);
            });
        };
        ExtHostQuickOpen.prototype.$validateInput = function (input) {
            var _this = this;
            if (this._validateInput) {
                return async_1.asThenable(function () { return _this._validateInput(input); });
            }
            return undefined;
        };
        // ---- workspace folder picker
        ExtHostQuickOpen.prototype.showWorkspaceFolderPick = function (options, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            return this._commands.executeCommand('_workbench.pickWorkspaceFolder', [options]).then(function (selectedFolder) {
                if (!selectedFolder) {
                    return undefined;
                }
                return _this._workspace.getWorkspaceFolders().filter(function (folder) { return folder.uri.toString() === selectedFolder.uri.toString(); })[0];
            });
        };
        // ---- QuickInput
        ExtHostQuickOpen.prototype.createQuickPick = function (extensionId, enableProposedApi) {
            var _this = this;
            var session = new ExtHostQuickPick(this._proxy, extensionId, enableProposedApi, function () { return _this._sessions.delete(session._id); });
            this._sessions.set(session._id, session);
            return session;
        };
        ExtHostQuickOpen.prototype.createInputBox = function (extensionId) {
            var _this = this;
            var session = new ExtHostInputBox(this._proxy, extensionId, function () { return _this._sessions.delete(session._id); });
            this._sessions.set(session._id, session);
            return session;
        };
        ExtHostQuickOpen.prototype.$onDidChangeValue = function (sessionId, value) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidChangeValue(value);
            }
        };
        ExtHostQuickOpen.prototype.$onDidAccept = function (sessionId) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidAccept();
            }
        };
        ExtHostQuickOpen.prototype.$onDidChangeActive = function (sessionId, handles) {
            var session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeActive(handles);
            }
        };
        ExtHostQuickOpen.prototype.$onDidChangeSelection = function (sessionId, handles) {
            var session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeSelection(handles);
            }
        };
        ExtHostQuickOpen.prototype.$onDidTriggerButton = function (sessionId, handle) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidTriggerButton(handle);
            }
        };
        ExtHostQuickOpen.prototype.$onDidHide = function (sessionId) {
            var session = this._sessions.get(sessionId);
            if (session) {
                session._fireDidHide();
            }
        };
        return ExtHostQuickOpen;
    }());
    exports.ExtHostQuickOpen = ExtHostQuickOpen;
    var ExtHostQuickInput = /** @class */ (function () {
        function ExtHostQuickInput(_proxy, _extensionId, _onDidDispose) {
            this._proxy = _proxy;
            this._extensionId = _extensionId;
            this._onDidDispose = _onDidDispose;
            this._id = ExtHostQuickPick._nextId++;
            this._visible = false;
            this._expectingHide = false;
            this._enabled = true;
            this._busy = false;
            this._ignoreFocusOut = true;
            this._value = '';
            this._buttons = [];
            this._handlesToButtons = new Map();
            this._onDidAcceptEmitter = new event_1.Emitter();
            this._onDidChangeValueEmitter = new event_1.Emitter();
            this._onDidTriggerButtonEmitter = new event_1.Emitter();
            this._onDidHideEmitter = new event_1.Emitter();
            this._pendingUpdate = { id: this._id };
            this._disposed = false;
            this._disposables = [
                this._onDidTriggerButtonEmitter,
                this._onDidHideEmitter,
                this._onDidAcceptEmitter,
                this._onDidChangeValueEmitter
            ];
            this.onDidChangeValue = this._onDidChangeValueEmitter.event;
            this.onDidAccept = this._onDidAcceptEmitter.event;
            this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;
            this.onDidHide = this._onDidHideEmitter.event;
        }
        Object.defineProperty(ExtHostQuickInput.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                this._title = title;
                this.update({ title: title });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "step", {
            get: function () {
                return this._steps;
            },
            set: function (step) {
                this._steps = step;
                this.update({ step: step });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "totalSteps", {
            get: function () {
                return this._totalSteps;
            },
            set: function (totalSteps) {
                this._totalSteps = totalSteps;
                this.update({ totalSteps: totalSteps });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                this.update({ enabled: enabled });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "busy", {
            get: function () {
                return this._busy;
            },
            set: function (busy) {
                this._busy = busy;
                this.update({ busy: busy });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "ignoreFocusOut", {
            get: function () {
                return this._ignoreFocusOut;
            },
            set: function (ignoreFocusOut) {
                this._ignoreFocusOut = ignoreFocusOut;
                this.update({ ignoreFocusOut: ignoreFocusOut });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
                this.update({ value: value });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._placeholder = placeholder;
                this.update({ placeholder: placeholder });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickInput.prototype, "buttons", {
            get: function () {
                return this._buttons;
            },
            set: function (buttons) {
                var _this = this;
                this._buttons = buttons.slice();
                this._handlesToButtons.clear();
                buttons.forEach(function (button, i) {
                    var handle = button === extHostTypes_1.QuickInputButtons.Back ? -1 : i;
                    _this._handlesToButtons.set(handle, button);
                });
                this.update({
                    buttons: buttons.map(function (button, i) { return ({
                        iconPath: getIconUris(button.iconPath),
                        tooltip: button.tooltip,
                        handle: button === extHostTypes_1.QuickInputButtons.Back ? -1 : i,
                    }); })
                });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostQuickInput.prototype.show = function () {
            this._visible = true;
            this._expectingHide = true;
            this.update({ visible: true });
        };
        ExtHostQuickInput.prototype.hide = function () {
            this._visible = false;
            this.update({ visible: false });
        };
        ExtHostQuickInput.prototype._fireDidAccept = function () {
            this._onDidAcceptEmitter.fire();
        };
        ExtHostQuickInput.prototype._fireDidChangeValue = function (value) {
            this._value = value;
            this._onDidChangeValueEmitter.fire(value);
        };
        ExtHostQuickInput.prototype._fireDidTriggerButton = function (handle) {
            var button = this._handlesToButtons.get(handle);
            this._onDidTriggerButtonEmitter.fire(button);
        };
        ExtHostQuickInput.prototype._fireDidHide = function () {
            if (this._expectingHide) {
                this._expectingHide = false;
                this._onDidHideEmitter.fire();
            }
        };
        ExtHostQuickInput.prototype.dispose = function () {
            if (this._disposed) {
                return;
            }
            this._disposed = true;
            this._fireDidHide();
            this._disposables = lifecycle_1.dispose(this._disposables);
            if (this._updateTimeout) {
                clearTimeout(this._updateTimeout);
                this._updateTimeout = undefined;
            }
            this._onDidDispose();
            this._proxy.$dispose(this._id);
        };
        ExtHostQuickInput.prototype.update = function (properties) {
            var _this = this;
            if (this._disposed) {
                return;
            }
            for (var _i = 0, _a = Object.keys(properties); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = properties[key];
                this._pendingUpdate[key] = value === undefined ? null : value;
            }
            if ('visible' in this._pendingUpdate) {
                if (this._updateTimeout) {
                    clearTimeout(this._updateTimeout);
                    this._updateTimeout = undefined;
                }
                this.dispatchUpdate();
            }
            else if (this._visible && !this._updateTimeout) {
                // Defer the update so that multiple changes to setters dont cause a redraw each
                this._updateTimeout = setTimeout(function () {
                    _this._updateTimeout = undefined;
                    _this.dispatchUpdate();
                }, 0);
            }
        };
        ExtHostQuickInput.prototype.dispatchUpdate = function () {
            this._proxy.$createOrUpdate(this._pendingUpdate);
            this._pendingUpdate = { id: this._id };
        };
        ExtHostQuickInput._nextId = 1;
        return ExtHostQuickInput;
    }());
    function getIconUris(iconPath) {
        var light = getLightIconUri(iconPath);
        return { dark: getDarkIconUri(iconPath) || light, light: light };
    }
    function getLightIconUri(iconPath) {
        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon)) {
            if (typeof iconPath === 'string'
                || iconPath instanceof uri_1.URI) {
                return getIconUri(iconPath);
            }
            return getIconUri(iconPath['light']);
        }
        return undefined;
    }
    function getDarkIconUri(iconPath) {
        if (iconPath && !(iconPath instanceof extHostTypes_1.ThemeIcon) && iconPath['dark']) {
            return getIconUri(iconPath['dark']);
        }
        return undefined;
    }
    function getIconUri(iconPath) {
        if (iconPath instanceof uri_1.URI) {
            return iconPath;
        }
        return uri_1.URI.file(iconPath);
    }
    var ExtHostQuickPick = /** @class */ (function (_super) {
        __extends(ExtHostQuickPick, _super);
        function ExtHostQuickPick(proxy, extensionId, enableProposedApi, onDispose) {
            var _this = _super.call(this, proxy, extensionId, onDispose) || this;
            _this._items = [];
            _this._handlesToItems = new Map();
            _this._itemsToHandles = new Map();
            _this._canSelectMany = false;
            _this._matchOnDescription = true;
            _this._matchOnDetail = true;
            _this._activeItems = [];
            _this._onDidChangeActiveEmitter = new event_1.Emitter();
            _this._selectedItems = [];
            _this._onDidChangeSelectionEmitter = new event_1.Emitter();
            _this.onDidChangeActive = _this._onDidChangeActiveEmitter.event;
            _this.onDidChangeSelection = _this._onDidChangeSelectionEmitter.event;
            _this._disposables.push(_this._onDidChangeActiveEmitter, _this._onDidChangeSelectionEmitter);
            _this.update({ type: 'quickPick' });
            return _this;
        }
        Object.defineProperty(ExtHostQuickPick.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                var _this = this;
                this._items = items.slice();
                this._handlesToItems.clear();
                this._itemsToHandles.clear();
                items.forEach(function (item, i) {
                    _this._handlesToItems.set(i, item);
                    _this._itemsToHandles.set(item, i);
                });
                this.update({
                    items: items.map(function (item, i) { return ({
                        label: item.label,
                        description: item.description,
                        handle: i,
                        detail: item.detail,
                        picked: item.picked,
                        alwaysShow: item.alwaysShow
                    }); })
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "canSelectMany", {
            get: function () {
                return this._canSelectMany;
            },
            set: function (canSelectMany) {
                this._canSelectMany = canSelectMany;
                this.update({ canSelectMany: canSelectMany });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "matchOnDescription", {
            get: function () {
                return this._matchOnDescription;
            },
            set: function (matchOnDescription) {
                this._matchOnDescription = matchOnDescription;
                this.update({ matchOnDescription: matchOnDescription });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "matchOnDetail", {
            get: function () {
                return this._matchOnDetail;
            },
            set: function (matchOnDetail) {
                this._matchOnDetail = matchOnDetail;
                this.update({ matchOnDetail: matchOnDetail });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "activeItems", {
            get: function () {
                return this._activeItems;
            },
            set: function (activeItems) {
                var _this = this;
                this._activeItems = activeItems.filter(function (item) { return _this._itemsToHandles.has(item); });
                this.update({ activeItems: this._activeItems.map(function (item) { return _this._itemsToHandles.get(item); }) });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostQuickPick.prototype, "selectedItems", {
            get: function () {
                return this._selectedItems;
            },
            set: function (selectedItems) {
                var _this = this;
                this._selectedItems = selectedItems.filter(function (item) { return _this._itemsToHandles.has(item); });
                this.update({ selectedItems: this._selectedItems.map(function (item) { return _this._itemsToHandles.get(item); }) });
            },
            enumerable: true,
            configurable: true
        });
        ExtHostQuickPick.prototype._fireDidChangeActive = function (handles) {
            var _this = this;
            var items = handles.map(function (handle) { return _this._handlesToItems.get(handle); });
            this._activeItems = items;
            this._onDidChangeActiveEmitter.fire(items);
        };
        ExtHostQuickPick.prototype._fireDidChangeSelection = function (handles) {
            var _this = this;
            var items = handles.map(function (handle) { return _this._handlesToItems.get(handle); });
            this._selectedItems = items;
            this._onDidChangeSelectionEmitter.fire(items);
        };
        return ExtHostQuickPick;
    }(ExtHostQuickInput));
    var ExtHostInputBox = /** @class */ (function (_super) {
        __extends(ExtHostInputBox, _super);
        function ExtHostInputBox(proxy, extensionId, onDispose) {
            var _this = _super.call(this, proxy, extensionId, onDispose) || this;
            _this.update({ type: 'inputBox' });
            return _this;
        }
        Object.defineProperty(ExtHostInputBox.prototype, "password", {
            get: function () {
                return this._password;
            },
            set: function (password) {
                this._password = password;
                this.update({ password: password });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostInputBox.prototype, "prompt", {
            get: function () {
                return this._prompt;
            },
            set: function (prompt) {
                this._prompt = prompt;
                this.update({ prompt: prompt });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostInputBox.prototype, "validationMessage", {
            get: function () {
                return this._validationMessage;
            },
            set: function (validationMessage) {
                this._validationMessage = validationMessage;
                this.update({ validationMessage: validationMessage });
            },
            enumerable: true,
            configurable: true
        });
        return ExtHostInputBox;
    }(ExtHostQuickInput));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[163/*vs/workbench/api/node/extHostSCM*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,3/*vs/base/common/event*/,75/*vs/base/common/decorators*/,8/*vs/base/common/lifecycle*/,11/*vs/base/common/async*/,4/*vs/workbench/api/node/extHost.protocol*/,9/*vs/base/common/arrays*/,67/*vs/base/common/comparers*/,33/*vs/platform/log/common/log*/]), function (require, exports, uri_1, event_1, decorators_1, lifecycle_1, async_1, extHost_protocol_1, arrays_1, comparers_1, log_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getIconPath(decorations) {
        if (!decorations) {
            return undefined;
        }
        else if (typeof decorations.iconPath === 'string') {
            return uri_1.URI.file(decorations.iconPath).toString();
        }
        else if (decorations.iconPath) {
            return "" + decorations.iconPath;
        }
        return undefined;
    }
    function compareResourceThemableDecorations(a, b) {
        if (!a.iconPath && !b.iconPath) {
            return 0;
        }
        else if (!a.iconPath) {
            return -1;
        }
        else if (!b.iconPath) {
            return 1;
        }
        var aPath = typeof a.iconPath === 'string' ? a.iconPath : a.iconPath.fsPath;
        var bPath = typeof b.iconPath === 'string' ? b.iconPath : b.iconPath.fsPath;
        return comparers_1.comparePaths(aPath, bPath);
    }
    function compareResourceStatesDecorations(a, b) {
        var result = 0;
        if (a.strikeThrough !== b.strikeThrough) {
            return a.strikeThrough ? 1 : -1;
        }
        if (a.faded !== b.faded) {
            return a.faded ? 1 : -1;
        }
        if (a.tooltip !== b.tooltip) {
            return (a.tooltip || '').localeCompare(b.tooltip);
        }
        result = compareResourceThemableDecorations(a, b);
        if (result !== 0) {
            return result;
        }
        if (a.light && b.light) {
            result = compareResourceThemableDecorations(a.light, b.light);
        }
        else if (a.light) {
            return 1;
        }
        else if (b.light) {
            return -1;
        }
        if (result !== 0) {
            return result;
        }
        if (a.dark && b.dark) {
            result = compareResourceThemableDecorations(a.dark, b.dark);
        }
        else if (a.dark) {
            return 1;
        }
        else if (b.dark) {
            return -1;
        }
        return result;
    }
    function compareResourceStates(a, b) {
        var result = comparers_1.comparePaths(a.resourceUri.fsPath, b.resourceUri.fsPath, true);
        if (result !== 0) {
            return result;
        }
        if (a.decorations && b.decorations) {
            result = compareResourceStatesDecorations(a.decorations, b.decorations);
        }
        else if (a.decorations) {
            return 1;
        }
        else if (b.decorations) {
            return -1;
        }
        return result;
    }
    function compareArgs(a, b) {
        for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    function commandEquals(a, b) {
        return a.command === b.command
            && a.title === b.title
            && a.tooltip === b.tooltip
            && (a.arguments && b.arguments ? compareArgs(a.arguments, b.arguments) : a.arguments === b.arguments);
    }
    function commandListEquals(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i++) {
            if (!commandEquals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    var ExtHostSCMInputBox = /** @class */ (function () {
        function ExtHostSCMInputBox(_extension, _proxy, _sourceControlHandle) {
            this._extension = _extension;
            this._proxy = _proxy;
            this._sourceControlHandle = _sourceControlHandle;
            this._value = '';
            this._onDidChange = new event_1.Emitter();
            this._placeholder = '';
            this._visible = true;
            // noop
        }
        Object.defineProperty(ExtHostSCMInputBox.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._proxy.$setInputBoxValue(this._sourceControlHandle, value);
                this.updateValue(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            set: function (placeholder) {
                this._proxy.$setInputBoxPlaceholder(this._sourceControlHandle, placeholder);
                this._placeholder = placeholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "validateInput", {
            get: function () {
                if (!this._extension.enableProposedApi) {
                    throw new Error("[" + this._extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + this._extension.id);
                }
                return this._validateInput;
            },
            set: function (fn) {
                if (!this._extension.enableProposedApi) {
                    throw new Error("[" + this._extension.id + "]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api " + this._extension.id);
                }
                if (fn && typeof fn !== 'function') {
                    console.warn('Invalid SCM input box validation function');
                    return;
                }
                this._validateInput = fn;
                this._proxy.$setValidationProviderIsEnabled(this._sourceControlHandle, !!fn);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSCMInputBox.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (visible) {
                visible = !!visible;
                this._visible = visible;
                this._proxy.$setInputBoxVisibility(this._sourceControlHandle, visible);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSCMInputBox.prototype.$onInputBoxValueChange = function (value) {
            this.updateValue(value);
        };
        ExtHostSCMInputBox.prototype.updateValue = function (value) {
            this._value = value;
            this._onDidChange.fire(value);
        };
        return ExtHostSCMInputBox;
    }());
    exports.ExtHostSCMInputBox = ExtHostSCMInputBox;
    var ExtHostSourceControlResourceGroup = /** @class */ (function () {
        function ExtHostSourceControlResourceGroup(_proxy, _commands, _sourceControlHandle, _id, _label) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._sourceControlHandle = _sourceControlHandle;
            this._id = _id;
            this._label = _label;
            this._resourceHandlePool = 0;
            this._resourceStates = [];
            this._resourceStatesMap = new Map();
            this._resourceStatesCommandsMap = new Map();
            this._onDidUpdateResourceStates = new event_1.Emitter();
            this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event;
            this._onDidDispose = new event_1.Emitter();
            this.onDidDispose = this._onDidDispose.event;
            this._handlesSnapshot = [];
            this._resourceSnapshot = [];
            this._hideWhenEmpty = undefined;
            this.handle = ExtHostSourceControlResourceGroup._handlePool++;
            this._disposables = [];
            this._proxy.$registerGroup(_sourceControlHandle, this.handle, _id, _label);
        }
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "id", {
            get: function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "label", {
            get: function () { return this._label; },
            set: function (label) {
                this._label = label;
                this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "hideWhenEmpty", {
            get: function () { return this._hideWhenEmpty; },
            set: function (hideWhenEmpty) {
                this._hideWhenEmpty = hideWhenEmpty;
                this._proxy.$updateGroup(this._sourceControlHandle, this.handle, { hideWhenEmpty: hideWhenEmpty });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControlResourceGroup.prototype, "resourceStates", {
            get: function () { return this._resourceStates.slice(); },
            set: function (resources) {
                this._resourceStates = resources.slice();
                this._onDidUpdateResourceStates.fire();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControlResourceGroup.prototype.getResourceState = function (handle) {
            return this._resourceStatesMap.get(handle);
        };
        ExtHostSourceControlResourceGroup.prototype.$executeResourceCommand = function (handle) {
            var _this = this;
            var command = this._resourceStatesCommandsMap.get(handle);
            if (!command) {
                return Promise.resolve(null);
            }
            return async_1.asThenable(function () {
                var _a;
                return (_a = _this._commands).executeCommand.apply(_a, [command.command].concat(command.arguments));
            });
        };
        ExtHostSourceControlResourceGroup.prototype._takeResourceStateSnapshot = function () {
            var _this = this;
            var _a;
            var snapshot = this._resourceStates.slice().sort(compareResourceStates);
            var diffs = arrays_1.sortedDiff(this._resourceSnapshot, snapshot, compareResourceStates);
            var splices = diffs.map(function (diff) {
                var toInsert = diff.toInsert.map(function (r) {
                    var handle = _this._resourceHandlePool++;
                    _this._resourceStatesMap.set(handle, r);
                    var sourceUri = r.resourceUri;
                    var iconPath = getIconPath(r.decorations);
                    var lightIconPath = r.decorations && getIconPath(r.decorations.light) || iconPath;
                    var darkIconPath = r.decorations && getIconPath(r.decorations.dark) || iconPath;
                    var icons = [];
                    if (r.command) {
                        _this._resourceStatesCommandsMap.set(handle, r.command);
                    }
                    if (lightIconPath || darkIconPath) {
                        icons.push(lightIconPath);
                    }
                    if (darkIconPath !== lightIconPath) {
                        icons.push(darkIconPath);
                    }
                    var tooltip = (r.decorations && r.decorations.tooltip) || '';
                    var strikeThrough = r.decorations && !!r.decorations.strikeThrough;
                    var faded = r.decorations && !!r.decorations.faded;
                    var source = r.decorations && r.decorations.source || undefined;
                    var letter = r.decorations && r.decorations.letter || undefined;
                    var color = r.decorations && r.decorations.color || undefined;
                    var rawResource = [handle, sourceUri, icons, tooltip, strikeThrough, faded, source, letter, color];
                    return { rawResource: rawResource, handle: handle };
                });
                return { start: diff.start, deleteCount: diff.deleteCount, toInsert: toInsert };
            });
            var rawResourceSplices = splices
                .map(function (_a) {
                var start = _a.start, deleteCount = _a.deleteCount, toInsert = _a.toInsert;
                return [start, deleteCount, toInsert.map(function (i) { return i.rawResource; })];
            });
            var reverseSplices = splices.reverse();
            for (var _i = 0, reverseSplices_1 = reverseSplices; _i < reverseSplices_1.length; _i++) {
                var _b = reverseSplices_1[_i], start = _b.start, deleteCount = _b.deleteCount, toInsert = _b.toInsert;
                var handles = toInsert.map(function (i) { return i.handle; });
                var handlesToDelete = (_a = this._handlesSnapshot).splice.apply(_a, [start, deleteCount].concat(handles));
                for (var _c = 0, handlesToDelete_1 = handlesToDelete; _c < handlesToDelete_1.length; _c++) {
                    var handle = handlesToDelete_1[_c];
                    this._resourceStatesMap.delete(handle);
                    this._resourceStatesCommandsMap.delete(handle);
                }
            }
            this._resourceSnapshot = snapshot;
            return rawResourceSplices;
        };
        ExtHostSourceControlResourceGroup.prototype.dispose = function () {
            this._proxy.$unregisterGroup(this._sourceControlHandle, this.handle);
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._onDidDispose.fire();
        };
        ExtHostSourceControlResourceGroup._handlePool = 0;
        return ExtHostSourceControlResourceGroup;
    }());
    var ExtHostSourceControl = /** @class */ (function () {
        function ExtHostSourceControl(_extension, _proxy, _commands, _id, _label, _rootUri) {
            this._proxy = _proxy;
            this._commands = _commands;
            this._id = _id;
            this._label = _label;
            this._rootUri = _rootUri;
            this._groups = new Map();
            this._count = undefined;
            this._quickDiffProvider = undefined;
            this._commitTemplate = undefined;
            this._acceptInputCommand = undefined;
            this._statusBarCommands = undefined;
            this._selected = false;
            this._onDidChangeSelection = new event_1.Emitter();
            this.onDidChangeSelection = this._onDidChangeSelection.event;
            this.handle = ExtHostSourceControl._handlePool++;
            this.updatedResourceGroups = new Set();
            this._inputBox = new ExtHostSCMInputBox(_extension, this._proxy, this.handle);
            this._proxy.$registerSourceControl(this.handle, _id, _label, _rootUri);
        }
        Object.defineProperty(ExtHostSourceControl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "rootUri", {
            get: function () {
                return this._rootUri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "inputBox", {
            get: function () { return this._inputBox; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "count", {
            get: function () {
                return this._count;
            },
            set: function (count) {
                if (this._count === count) {
                    return;
                }
                this._count = count;
                this._proxy.$updateSourceControl(this.handle, { count: count });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "quickDiffProvider", {
            get: function () {
                return this._quickDiffProvider;
            },
            set: function (quickDiffProvider) {
                this._quickDiffProvider = quickDiffProvider;
                this._proxy.$updateSourceControl(this.handle, { hasQuickDiffProvider: !!quickDiffProvider });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "commitTemplate", {
            get: function () {
                return this._commitTemplate;
            },
            set: function (commitTemplate) {
                this._commitTemplate = commitTemplate;
                this._proxy.$updateSourceControl(this.handle, { commitTemplate: commitTemplate });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "acceptInputCommand", {
            get: function () {
                return this._acceptInputCommand;
            },
            set: function (acceptInputCommand) {
                this._acceptInputCommand = acceptInputCommand;
                var internal = this._commands.converter.toInternal(acceptInputCommand);
                this._proxy.$updateSourceControl(this.handle, { acceptInputCommand: internal });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "statusBarCommands", {
            get: function () {
                return this._statusBarCommands;
            },
            set: function (statusBarCommands) {
                var _this = this;
                if (this._statusBarCommands && statusBarCommands && commandListEquals(this._statusBarCommands, statusBarCommands)) {
                    return;
                }
                this._statusBarCommands = statusBarCommands;
                var internal = (statusBarCommands || []).map(function (c) { return _this._commands.converter.toInternal(c); });
                this._proxy.$updateSourceControl(this.handle, { statusBarCommands: internal });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostSourceControl.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostSourceControl.prototype.createResourceGroup = function (id, label) {
            var _this = this;
            var group = new ExtHostSourceControlResourceGroup(this._proxy, this._commands, this.handle, id, label);
            var updateListener = group.onDidUpdateResourceStates(function () {
                _this.updatedResourceGroups.add(group);
                _this.eventuallyUpdateResourceStates();
            });
            event_1.once(group.onDidDispose)(function () {
                _this.updatedResourceGroups.delete(group);
                updateListener.dispose();
                _this._groups.delete(group.handle);
            });
            this._groups.set(group.handle, group);
            return group;
        };
        ExtHostSourceControl.prototype.eventuallyUpdateResourceStates = function () {
            var splices = [];
            this.updatedResourceGroups.forEach(function (group) {
                var snapshot = group._takeResourceStateSnapshot();
                if (snapshot.length === 0) {
                    return;
                }
                splices.push([group.handle, snapshot]);
            });
            if (splices.length > 0) {
                this._proxy.$spliceResourceStates(this.handle, splices);
            }
            this.updatedResourceGroups.clear();
        };
        ExtHostSourceControl.prototype.getResourceGroup = function (handle) {
            return this._groups.get(handle);
        };
        ExtHostSourceControl.prototype.setSelectionState = function (selected) {
            this._selected = selected;
            this._onDidChangeSelection.fire(selected);
        };
        ExtHostSourceControl.prototype.dispose = function () {
            this._groups.forEach(function (group) { return group.dispose(); });
            this._proxy.$unregisterSourceControl(this.handle);
        };
        ExtHostSourceControl._handlePool = 0;
        __decorate([
            decorators_1.debounce(100)
        ], ExtHostSourceControl.prototype, "eventuallyUpdateResourceStates", null);
        return ExtHostSourceControl;
    }());
    var ExtHostSCM = /** @class */ (function () {
        function ExtHostSCM(mainContext, _commands, logService) {
            var _this = this;
            this._commands = _commands;
            this.logService = logService;
            this._sourceControls = new Map();
            this._sourceControlsByExtension = new Map();
            this._onDidChangeActiveProvider = new event_1.Emitter();
            this._selectedSourceControlHandles = new Set();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadSCM);
            _commands.registerArgumentProcessor({
                processArgument: function (arg) {
                    if (arg && arg.$mid === 3) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        var group = sourceControl.getResourceGroup(arg.groupHandle);
                        if (!group) {
                            return arg;
                        }
                        return group.getResourceState(arg.handle);
                    }
                    else if (arg && arg.$mid === 4) {
                        var sourceControl = _this._sourceControls.get(arg.sourceControlHandle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl.getResourceGroup(arg.groupHandle);
                    }
                    else if (arg && arg.$mid === 5) {
                        var sourceControl = _this._sourceControls.get(arg.handle);
                        if (!sourceControl) {
                            return arg;
                        }
                        return sourceControl;
                    }
                    return arg;
                }
            });
        }
        Object.defineProperty(ExtHostSCM.prototype, "onDidChangeActiveProvider", {
            get: function () { return this._onDidChangeActiveProvider.event; },
            enumerable: true,
            configurable: true
        });
        ExtHostSCM.prototype.createSourceControl = function (extension, id, label, rootUri) {
            this.logService.trace('ExtHostSCM#createSourceControl', extension.id, id, label, rootUri);
            var handle = ExtHostSCM._handlePool++;
            var sourceControl = new ExtHostSourceControl(extension, this._proxy, this._commands, id, label, rootUri);
            this._sourceControls.set(handle, sourceControl);
            var sourceControls = this._sourceControlsByExtension.get(extension.id) || [];
            sourceControls.push(sourceControl);
            this._sourceControlsByExtension.set(extension.id, sourceControls);
            return sourceControl;
        };
        // Deprecated
        ExtHostSCM.prototype.getLastInputBox = function (extension) {
            this.logService.trace('ExtHostSCM#getLastInputBox', extension.id);
            var sourceControls = this._sourceControlsByExtension.get(extension.id);
            var sourceControl = sourceControls && sourceControls[sourceControls.length - 1];
            var inputBox = sourceControl && sourceControl.inputBox;
            return inputBox;
        };
        ExtHostSCM.prototype.$provideOriginalResource = function (sourceControlHandle, uriComponents, token) {
            var uri = uri_1.URI.revive(uriComponents);
            this.logService.trace('ExtHostSCM#$provideOriginalResource', sourceControlHandle, uri.toString());
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl || !sourceControl.quickDiffProvider) {
                return Promise.resolve(null);
            }
            return async_1.asThenable(function () { return sourceControl.quickDiffProvider.provideOriginalResource(uri, token); });
        };
        ExtHostSCM.prototype.$onInputBoxValueChange = function (sourceControlHandle, value) {
            this.logService.trace('ExtHostSCM#$onInputBoxValueChange', sourceControlHandle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(null);
            }
            sourceControl.inputBox.$onInputBoxValueChange(value);
            return Promise.resolve(null);
        };
        ExtHostSCM.prototype.$executeResourceCommand = function (sourceControlHandle, groupHandle, handle) {
            this.logService.trace('ExtHostSCM#$executeResourceCommand', sourceControlHandle, groupHandle, handle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(null);
            }
            var group = sourceControl.getResourceGroup(groupHandle);
            if (!group) {
                return Promise.resolve(null);
            }
            return group.$executeResourceCommand(handle);
        };
        ExtHostSCM.prototype.$validateInput = function (sourceControlHandle, value, cursorPosition) {
            this.logService.trace('ExtHostSCM#$validateInput', sourceControlHandle);
            var sourceControl = this._sourceControls.get(sourceControlHandle);
            if (!sourceControl) {
                return Promise.resolve(undefined);
            }
            if (!sourceControl.inputBox.validateInput) {
                return Promise.resolve(undefined);
            }
            return async_1.asThenable(function () { return sourceControl.inputBox.validateInput(value, cursorPosition); }).then(function (result) {
                if (!result) {
                    return Promise.resolve(undefined);
                }
                return Promise.resolve([result.message, result.type]);
            });
        };
        ExtHostSCM.prototype.$setSelectedSourceControls = function (selectedSourceControlHandles) {
            var _this = this;
            this.logService.trace('ExtHostSCM#$setSelectedSourceControls', selectedSourceControlHandles);
            var set = new Set();
            for (var _i = 0, selectedSourceControlHandles_1 = selectedSourceControlHandles; _i < selectedSourceControlHandles_1.length; _i++) {
                var handle = selectedSourceControlHandles_1[_i];
                set.add(handle);
            }
            set.forEach(function (handle) {
                if (!_this._selectedSourceControlHandles.has(handle)) {
                    var sourceControl = _this._sourceControls.get(handle);
                    if (!sourceControl) {
                        return;
                    }
                    sourceControl.setSelectionState(true);
                }
            });
            this._selectedSourceControlHandles.forEach(function (handle) {
                if (!set.has(handle)) {
                    var sourceControl = _this._sourceControls.get(handle);
                    if (!sourceControl) {
                        return;
                    }
                    sourceControl.setSelectionState(false);
                }
            });
            this._selectedSourceControlHandles = set;
            return Promise.resolve(null);
        };
        ExtHostSCM._handlePool = 0;
        ExtHostSCM = __decorate([
            __param(2, log_1.ILogService)
        ], ExtHostSCM);
        return ExtHostSCM;
    }());
    exports.ExtHostSCM = ExtHostSCM;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[164/*vs/workbench/api/node/extHostStatusBar*/], __M([1/*require*/,0/*exports*/,7/*vs/workbench/api/node/extHostTypes*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, extHostTypes_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStatusBarEntry = /** @class */ (function () {
        function ExtHostStatusBarEntry(proxy, extensionId, alignment, priority) {
            if (alignment === void 0) { alignment = extHostTypes_1.StatusBarAlignment.Left; }
            this._id = ExtHostStatusBarEntry.ID_GEN++;
            this._proxy = proxy;
            this._alignment = alignment;
            this._priority = priority;
            this._extensionId = extensionId;
        }
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "alignment", {
            get: function () {
                return this._alignment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "priority", {
            get: function () {
                return this._priority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (tooltip) {
                this._tooltip = tooltip;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this._color = color;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostStatusBarEntry.prototype, "command", {
            get: function () {
                return this._command;
            },
            set: function (command) {
                this._command = command;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        ExtHostStatusBarEntry.prototype.show = function () {
            this._visible = true;
            this.update();
        };
        ExtHostStatusBarEntry.prototype.hide = function () {
            clearTimeout(this._timeoutHandle);
            this._visible = false;
            this._proxy.$dispose(this.id);
        };
        ExtHostStatusBarEntry.prototype.update = function () {
            var _this = this;
            if (this._disposed || !this._visible) {
                return;
            }
            clearTimeout(this._timeoutHandle);
            // Defer the update so that multiple changes to setters dont cause a redraw each
            this._timeoutHandle = setTimeout(function () {
                _this._timeoutHandle = undefined;
                // Set to status bar
                _this._proxy.$setEntry(_this.id, _this._extensionId, _this.text, _this.tooltip, _this.command, _this.color, _this._alignment === extHostTypes_1.StatusBarAlignment.Left ? 0 /* LEFT */ : 1 /* RIGHT */, _this._priority);
            }, 0);
        };
        ExtHostStatusBarEntry.prototype.dispose = function () {
            this.hide();
            this._disposed = true;
        };
        ExtHostStatusBarEntry.ID_GEN = 0;
        return ExtHostStatusBarEntry;
    }());
    exports.ExtHostStatusBarEntry = ExtHostStatusBarEntry;
    var StatusBarMessage = /** @class */ (function () {
        function StatusBarMessage(statusBar) {
            this._messages = [];
            this._item = statusBar.createStatusBarEntry(void 0, extHostTypes_1.StatusBarAlignment.Left, Number.MIN_VALUE);
        }
        StatusBarMessage.prototype.dispose = function () {
            this._messages.length = 0;
            this._item.dispose();
        };
        StatusBarMessage.prototype.setMessage = function (message) {
            var _this = this;
            var data = { message: message }; // use object to not confuse equal strings
            this._messages.unshift(data);
            this._update();
            return new extHostTypes_1.Disposable(function () {
                var idx = _this._messages.indexOf(data);
                if (idx >= 0) {
                    _this._messages.splice(idx, 1);
                    _this._update();
                }
            });
        };
        StatusBarMessage.prototype._update = function () {
            if (this._messages.length > 0) {
                this._item.text = this._messages[0].message;
                this._item.show();
            }
            else {
                this._item.hide();
            }
        };
        return StatusBarMessage;
    }());
    var ExtHostStatusBar = /** @class */ (function () {
        function ExtHostStatusBar(mainContext) {
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadStatusBar);
            this._statusMessage = new StatusBarMessage(this);
        }
        ExtHostStatusBar.prototype.createStatusBarEntry = function (extensionId, alignment, priority) {
            return new ExtHostStatusBarEntry(this._proxy, extensionId, alignment, priority);
        };
        ExtHostStatusBar.prototype.setStatusBarMessage = function (text, timeoutOrThenable) {
            var d = this._statusMessage.setMessage(text);
            var handle;
            if (typeof timeoutOrThenable === 'number') {
                handle = setTimeout(function () { return d.dispose(); }, timeoutOrThenable);
            }
            else if (typeof timeoutOrThenable !== 'undefined') {
                timeoutOrThenable.then(function () { return d.dispose(); }, function () { return d.dispose(); });
            }
            return new extHostTypes_1.Disposable(function () {
                d.dispose();
                clearTimeout(handle);
            });
        };
        return ExtHostStatusBar;
    }());
    exports.ExtHostStatusBar = ExtHostStatusBar;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[165/*vs/workbench/api/node/extHostStorage*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/,3/*vs/base/common/event*/]), function (require, exports, extHost_protocol_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostStorage = /** @class */ (function () {
        function ExtHostStorage(mainContext) {
            this._onDidChangeStorage = new event_1.Emitter();
            this.onDidChangeStorage = this._onDidChangeStorage.event;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadStorage);
        }
        ExtHostStorage.prototype.getValue = function (shared, key, defaultValue) {
            return this._proxy.$getValue(shared, key).then(function (value) { return value || defaultValue; });
        };
        ExtHostStorage.prototype.setValue = function (shared, key, value) {
            return this._proxy.$setValue(shared, key, value);
        };
        ExtHostStorage.prototype.$acceptValue = function (shared, key, value) {
            this._onDidChangeStorage.fire({ shared: shared, key: key, value: value });
        };
        return ExtHostStorage;
    }());
    exports.ExtHostStorage = ExtHostStorage;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[166/*vs/workbench/api/node/extHostTask*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/uri*/,86/*vs/nls!vs/workbench/api/node/extHostTask*/,13/*vs/base/common/objects*/,11/*vs/base/common/async*/,3/*vs/base/common/event*/,121/*vs/workbench/parts/tasks/common/tasks*/,4/*vs/workbench/api/node/extHost.protocol*/,7/*vs/workbench/api/node/extHostTypes*/,73/*vs/workbench/api/node/extHostDebugService*/,17/*vs/base/common/cancellation*/]), function (require, exports, uri_1, nls, Objects, async_1, event_1, tasks, extHost_protocol_1, types, extHostDebugService_1, cancellation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /*
    namespace ProblemPattern {
        export function from(value: vscode.ProblemPattern | vscode.MultiLineProblemPattern): Problems.ProblemPattern | Problems.MultiLineProblemPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (Array.isArray(value)) {
                let result: Problems.ProblemPattern[] = [];
                for (let pattern of value) {
                    let converted = fromSingle(pattern);
                    if (!converted) {
                        return undefined;
                    }
                    result.push(converted);
                }
                return result;
            } else {
                return fromSingle(value);
            }
        }
    
        function copyProperty(target: Problems.ProblemPattern, source: vscode.ProblemPattern, tk: keyof Problems.ProblemPattern) {
            let sk: keyof vscode.ProblemPattern = tk;
            let value = source[sk];
            if (typeof value === 'number') {
                target[tk] = value;
            }
        }
    
        function getValue(value: number, defaultValue: number): number {
            if (value !== void 0 && value === null) {
                return value;
            }
            return defaultValue;
        }
    
        function fromSingle(problemPattern: vscode.ProblemPattern): Problems.ProblemPattern {
            if (problemPattern === void 0 || problemPattern === null || !(problemPattern.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.ProblemPattern = {
                regexp: problemPattern.regexp
            };
            copyProperty(result, problemPattern, 'file');
            copyProperty(result, problemPattern, 'location');
            copyProperty(result, problemPattern, 'line');
            copyProperty(result, problemPattern, 'character');
            copyProperty(result, problemPattern, 'endLine');
            copyProperty(result, problemPattern, 'endCharacter');
            copyProperty(result, problemPattern, 'severity');
            copyProperty(result, problemPattern, 'code');
            copyProperty(result, problemPattern, 'message');
            if (problemPattern.loop === true || problemPattern.loop === false) {
                result.loop = problemPattern.loop;
            }
            if (result.location) {
                result.file = getValue(result.file, 1);
                result.message = getValue(result.message, 0);
            } else {
                result.file = getValue(result.file, 1);
                result.line = getValue(result.line, 2);
                result.character = getValue(result.character, 3);
                result.message = getValue(result.message, 0);
            }
            return result;
        }
    }
    
    namespace ApplyTo {
        export function from(value: vscode.ApplyToKind): Problems.ApplyToKind {
            if (value === void 0 || value === null) {
                return Problems.ApplyToKind.allDocuments;
            }
            switch (value) {
                case types.ApplyToKind.OpenDocuments:
                    return Problems.ApplyToKind.openDocuments;
                case types.ApplyToKind.ClosedDocuments:
                    return Problems.ApplyToKind.closedDocuments;
            }
            return Problems.ApplyToKind.allDocuments;
        }
    }
    
    namespace FileLocation {
        export function from(value: vscode.FileLocationKind | string): { kind: Problems.FileLocationKind; prefix?: string } {
            if (value === void 0 || value === null) {
                return { kind: Problems.FileLocationKind.Auto };
            }
            if (typeof value === 'string') {
                return { kind: Problems.FileLocationKind.Relative, prefix: value };
            }
            switch (value) {
                case types.FileLocationKind.Absolute:
                    return { kind: Problems.FileLocationKind.Absolute };
                case types.FileLocationKind.Relative:
                    return { kind: Problems.FileLocationKind.Relative, prefix: '${workspaceFolder}' };
            }
            return { kind: Problems.FileLocationKind.Auto };
        }
    }
    
    namespace WatchingPattern {
        export function from(value: RegExp | vscode.BackgroundPattern): Problems.WatchingPattern {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (value instanceof RegExp) {
                return { regexp: value };
            }
            if (!(value.regexp instanceof RegExp)) {
                return undefined;
            }
            let result: Problems.WatchingPattern = {
                regexp: value.regexp
            };
            if (typeof value.file === 'number') {
                result.file = value.file;
            }
            return result;
        }
    }
    
    namespace BackgroundMonitor {
        export function from(value: vscode.BackgroundMonitor): Problems.WatchingMatcher {
            if (value === void 0 || value === null) {
                return undefined;
            }
            let result: Problems.WatchingMatcher = {
                activeOnStart: !!value.activeOnStart,
                beginsPattern: WatchingPattern.from(value.beginsPattern),
                endsPattern: WatchingPattern.from(value.endsPattern)
            };
            return result;
        }
    }
    
    namespace ProblemMatcher {
        export function from(values: (string | vscode.ProblemMatcher)[]): (string | Problems.ProblemMatcher)[] {
            if (values === void 0 || values === null) {
                return undefined;
            }
            let result: (string | Problems.ProblemMatcher)[] = [];
            for (let value of values) {
                let converted = typeof value === 'string' ? value : fromSingle(value);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
    
        function fromSingle(problemMatcher: vscode.ProblemMatcher): Problems.ProblemMatcher {
            if (problemMatcher === void 0 || problemMatcher === null) {
                return undefined;
            }
    
            let location = FileLocation.from(problemMatcher.fileLocation);
            let result: Problems.ProblemMatcher = {
                owner: typeof problemMatcher.owner === 'string' ? problemMatcher.owner : UUID.generateUuid(),
                applyTo: ApplyTo.from(problemMatcher.applyTo),
                fileLocation: location.kind,
                filePrefix: location.prefix,
                pattern: ProblemPattern.from(problemMatcher.pattern),
                severity: fromDiagnosticSeverity(problemMatcher.severity),
            };
            return result;
        }
    }
    */
    var TaskRevealKind;
    (function (TaskRevealKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return tasks.RevealKind.Always;
            }
            switch (value) {
                case types.TaskRevealKind.Silent:
                    return tasks.RevealKind.Silent;
                case types.TaskRevealKind.Never:
                    return tasks.RevealKind.Never;
            }
            return tasks.RevealKind.Always;
        }
        TaskRevealKind.from = from;
    })(TaskRevealKind || (TaskRevealKind = {}));
    var TaskPanelKind;
    (function (TaskPanelKind) {
        function from(value) {
            if (value === void 0 || value === null) {
                return tasks.PanelKind.Shared;
            }
            switch (value) {
                case types.TaskPanelKind.Dedicated:
                    return tasks.PanelKind.Dedicated;
                case types.TaskPanelKind.New:
                    return tasks.PanelKind.New;
                default:
                    return tasks.PanelKind.Shared;
            }
        }
        TaskPanelKind.from = from;
    })(TaskPanelKind || (TaskPanelKind = {}));
    var PresentationOptions;
    (function (PresentationOptions) {
        function from(value) {
            if (value === void 0 || value === null) {
                return { reveal: tasks.RevealKind.Always, echo: true, focus: false, panel: tasks.PanelKind.Shared, showReuseMessage: true, clear: false };
            }
            return {
                reveal: TaskRevealKind.from(value.reveal),
                echo: value.echo === void 0 ? true : !!value.echo,
                focus: !!value.focus,
                panel: TaskPanelKind.from(value.panel),
                showReuseMessage: value.showReuseMessage === void 0 ? true : !!value.showReuseMessage,
                clear: value.clear === void 0 ? false : !!value.clear,
            };
        }
        PresentationOptions.from = from;
    })(PresentationOptions || (PresentationOptions = {}));
    var Strings;
    (function (Strings) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var element = value_1[_i];
                if (typeof element !== 'string') {
                    return [];
                }
            }
            return value;
        }
        Strings.from = from;
    })(Strings || (Strings = {}));
    var CommandOptions;
    (function (CommandOptions) {
        function isShellConfiguration(value) {
            return value && typeof value.executable === 'string';
        }
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {};
            if (typeof value.cwd === 'string') {
                result.cwd = value.cwd;
            }
            if (value.env) {
                result.env = Object.create(null);
                Object.keys(value.env).forEach(function (key) {
                    var envValue = value.env[key];
                    if (typeof envValue === 'string') {
                        result.env[key] = envValue;
                    }
                });
            }
            if (isShellConfiguration(value)) {
                result.shell = ShellConfiguration.from(value);
            }
            return result;
        }
        CommandOptions.from = from;
    })(CommandOptions || (CommandOptions = {}));
    var ShellQuoteOptions;
    (function (ShellQuoteOptions) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return {
                escape: value.escape,
                strong: value.strong,
                weak: value.strong
            };
        }
        ShellQuoteOptions.from = from;
    })(ShellQuoteOptions || (ShellQuoteOptions = {}));
    var ShellConfiguration;
    (function (ShellConfiguration) {
        function from(value) {
            if (value === void 0 || value === null || !value.executable) {
                return undefined;
            }
            var result = {
                executable: value.executable,
                args: Strings.from(value.shellArgs),
                quoting: ShellQuoteOptions.from(value.quotes)
            };
            return result;
        }
        ShellConfiguration.from = from;
    })(ShellConfiguration || (ShellConfiguration = {}));
    var ShellString;
    (function (ShellString) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value.slice(0);
        }
        ShellString.from = from;
    })(ShellString || (ShellString = {}));
    var Tasks;
    (function (Tasks) {
        function from(tasks, rootFolder, extension) {
            if (tasks === void 0 || tasks === null) {
                return [];
            }
            var result = [];
            for (var _i = 0, tasks_1 = tasks; _i < tasks_1.length; _i++) {
                var task = tasks_1[_i];
                var converted = fromSingle(task, rootFolder, extension);
                if (converted) {
                    result.push(converted);
                }
            }
            return result;
        }
        Tasks.from = from;
        function fromSingle(task, rootFolder, extension) {
            if (typeof task.name !== 'string') {
                return undefined;
            }
            var command;
            var execution = task.execution;
            if (execution instanceof types.ProcessExecution) {
                command = getProcessCommand(execution);
            }
            else if (execution instanceof types.ShellExecution) {
                command = getShellCommand(execution);
            }
            else {
                return undefined;
            }
            if (command === void 0) {
                return undefined;
            }
            command.presentation = PresentationOptions.from(task.presentationOptions);
            var taskScope = task.scope;
            var workspaceFolder;
            var scope;
            // For backwards compatibility
            if (taskScope === void 0) {
                scope = 3 /* Folder */;
                workspaceFolder = rootFolder;
            }
            else if (taskScope === types.TaskScope.Global) {
                scope = 1 /* Global */;
            }
            else if (taskScope === types.TaskScope.Workspace) {
                scope = 2 /* Workspace */;
            }
            else {
                scope = 3 /* Folder */;
                workspaceFolder = taskScope;
            }
            var source = {
                kind: tasks.TaskSourceKind.Extension,
                label: typeof task.source === 'string' ? task.source : extension.name,
                extension: extension.id,
                scope: scope,
                workspaceFolder: undefined
            };
            // We can't transfer a workspace folder object from the extension host to main since they differ
            // in shape and we don't have backwards converting function. So transfer the URI and resolve the
            // workspace folder on the main side.
            source.__workspaceFolder = workspaceFolder ? workspaceFolder.uri : undefined;
            source.__definition = task.definition;
            var label = nls.localize(0, null, source.label, task.name);
            // The definition id will be prefix on the main side since we compute it there.
            var id = "" + extension.id;
            var result = {
                _id: id,
                _source: source,
                _label: label,
                type: task.definition.type,
                defines: undefined,
                name: task.name,
                identifier: label,
                group: task.group ? task.group.id : undefined,
                command: command,
                isBackground: !!task.isBackground,
                problemMatchers: task.problemMatchers.slice(),
                hasDefinedMatchers: task.hasDefinedMatchers
            };
            return result;
        }
        function getProcessCommand(value) {
            if (typeof value.process !== 'string') {
                return undefined;
            }
            var result = {
                name: value.process,
                args: Strings.from(value.args),
                runtime: tasks.RuntimeType.Process,
                suppressTaskName: true,
                presentation: undefined
            };
            if (value.options) {
                result.options = CommandOptions.from(value.options);
            }
            return result;
        }
        function getShellCommand(value) {
            if (value.args) {
                if (typeof value.command !== 'string' && typeof value.command.value !== 'string') {
                    return undefined;
                }
                var result = {
                    name: value.command,
                    args: ShellString.from(value.args),
                    runtime: tasks.RuntimeType.Shell,
                    presentation: undefined
                };
                if (value.options) {
                    result.options = CommandOptions.from(value.options);
                }
                return result;
            }
            else {
                if (typeof value.commandLine !== 'string') {
                    return undefined;
                }
                var result = {
                    name: value.commandLine,
                    runtime: tasks.RuntimeType.Shell,
                    presentation: undefined
                };
                if (value.options) {
                    result.options = CommandOptions.from(value.options);
                }
                return result;
            }
        }
    })(Tasks || (Tasks = {}));
    var TaskDefinitionDTO;
    (function (TaskDefinitionDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskDefinitionDTO.to = to;
    })(TaskDefinitionDTO || (TaskDefinitionDTO = {}));
    var TaskPresentationOptionsDTO;
    (function (TaskPresentationOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        TaskPresentationOptionsDTO.to = to;
    })(TaskPresentationOptionsDTO || (TaskPresentationOptionsDTO = {}));
    var ProcessExecutionOptionsDTO;
    (function (ProcessExecutionOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ProcessExecutionOptionsDTO.to = to;
    })(ProcessExecutionOptionsDTO || (ProcessExecutionOptionsDTO = {}));
    var ProcessExecutionDTO;
    (function (ProcessExecutionDTO) {
        function is(value) {
            var candidate = value;
            return candidate && !!candidate.process;
        }
        ProcessExecutionDTO.is = is;
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {
                process: value.process,
                args: value.args
            };
            if (value.options) {
                result.options = ProcessExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ProcessExecutionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return new types.ProcessExecution(value.process, value.args, value.options);
        }
        ProcessExecutionDTO.to = to;
    })(ProcessExecutionDTO || (ProcessExecutionDTO = {}));
    var ShellExecutionOptionsDTO;
    (function (ShellExecutionOptionsDTO) {
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            return value;
        }
        ShellExecutionOptionsDTO.to = to;
    })(ShellExecutionOptionsDTO || (ShellExecutionOptionsDTO = {}));
    var ShellExecutionDTO;
    (function (ShellExecutionDTO) {
        function is(value) {
            var candidate = value;
            return candidate && (!!candidate.commandLine || !!candidate.command);
        }
        ShellExecutionDTO.is = is;
        function from(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var result = {};
            if (value.commandLine !== void 0) {
                result.commandLine = value.commandLine;
            }
            else {
                result.command = value.command;
                result.args = value.args;
            }
            if (value.options) {
                result.options = ShellExecutionOptionsDTO.from(value.options);
            }
            return result;
        }
        ShellExecutionDTO.from = from;
        function to(value) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            if (value.commandLine) {
                return new types.ShellExecution(value.commandLine, value.options);
            }
            else {
                return new types.ShellExecution(value.command, value.args ? value.args : [], value.options);
            }
        }
        ShellExecutionDTO.to = to;
    })(ShellExecutionDTO || (ShellExecutionDTO = {}));
    var TaskHandleDTO;
    (function (TaskHandleDTO) {
        function from(value) {
            var folder;
            if (value.scope !== void 0 && typeof value.scope !== 'number') {
                folder = value.scope.uri;
            }
            return {
                id: value._id,
                workspaceFolder: folder
            };
        }
        TaskHandleDTO.from = from;
    })(TaskHandleDTO || (TaskHandleDTO = {}));
    var TaskDTO;
    (function (TaskDTO) {
        function from(value, extension) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var execution;
            if (value.execution instanceof types.ProcessExecution) {
                execution = ProcessExecutionDTO.from(value.execution);
            }
            else if (value.execution instanceof types.ShellExecution) {
                execution = ShellExecutionDTO.from(value.execution);
            }
            var definition = TaskDefinitionDTO.from(value.definition);
            var scope;
            if (value.scope) {
                if (typeof value.scope === 'number') {
                    scope = value.scope;
                }
                else {
                    scope = value.scope.uri.toJSON();
                }
            }
            if (!definition || !scope) {
                return undefined;
            }
            var group = value.group ? value.group.id : undefined;
            var result = {
                _id: value._id,
                definition: definition,
                name: value.name,
                source: {
                    extensionId: extension.id,
                    label: value.source,
                    scope: scope
                },
                execution: execution,
                isBackground: value.isBackground,
                group: group,
                presentationOptions: TaskPresentationOptionsDTO.from(value.presentationOptions),
                problemMatchers: value.problemMatchers,
                hasDefinedMatchers: value.hasDefinedMatchers
            };
            return result;
        }
        TaskDTO.from = from;
        function to(value, workspace) {
            if (value === void 0 || value === null) {
                return undefined;
            }
            var execution;
            if (ProcessExecutionDTO.is(value.execution)) {
                execution = ProcessExecutionDTO.to(value.execution);
            }
            else if (ShellExecutionDTO.is(value.execution)) {
                execution = ShellExecutionDTO.to(value.execution);
            }
            var definition = TaskDefinitionDTO.to(value.definition);
            var scope;
            if (value.source) {
                if (value.source.scope !== void 0) {
                    if (typeof value.source.scope === 'number') {
                        scope = value.source.scope;
                    }
                    else {
                        scope = workspace.resolveWorkspaceFolder(uri_1.URI.revive(value.source.scope));
                    }
                }
                else {
                    scope = types.TaskScope.Workspace;
                }
            }
            if (!definition || !scope) {
                return undefined;
            }
            var result = new types.Task(definition, scope, value.name, value.source.label, execution, value.problemMatchers);
            if (value.isBackground !== void 0) {
                result.isBackground = value.isBackground;
            }
            if (value.group !== void 0) {
                result.group = types.TaskGroup.from(value.group);
            }
            if (value.presentationOptions) {
                result.presentationOptions = TaskPresentationOptionsDTO.to(value.presentationOptions);
            }
            if (value._id) {
                result._id = value._id;
            }
            return result;
        }
        TaskDTO.to = to;
    })(TaskDTO || (TaskDTO = {}));
    var TaskFilterDTO;
    (function (TaskFilterDTO) {
        function from(value) {
            return value;
        }
        TaskFilterDTO.from = from;
        function to(value) {
            if (!value) {
                return undefined;
            }
            return Objects.assign(Object.create(null), value);
        }
        TaskFilterDTO.to = to;
    })(TaskFilterDTO || (TaskFilterDTO = {}));
    var TaskExecutionImpl = /** @class */ (function () {
        function TaskExecutionImpl(_tasks, _id, _task) {
            this._tasks = _tasks;
            this._id = _id;
            this._task = _task;
        }
        Object.defineProperty(TaskExecutionImpl.prototype, "task", {
            get: function () {
                return this._task;
            },
            enumerable: true,
            configurable: true
        });
        TaskExecutionImpl.prototype.terminate = function () {
            this._tasks.terminateTask(this);
        };
        TaskExecutionImpl.prototype.fireDidStartProcess = function (value) {
        };
        TaskExecutionImpl.prototype.fireDidEndProcess = function (value) {
        };
        return TaskExecutionImpl;
    }());
    var TaskExecutionDTO;
    (function (TaskExecutionDTO) {
        function to(value, tasks) {
            return new TaskExecutionImpl(tasks, value.id, TaskDTO.to(value.task, tasks.extHostWorkspace));
        }
        TaskExecutionDTO.to = to;
        function from(value) {
            return {
                id: value._id,
                task: undefined
            };
        }
        TaskExecutionDTO.from = from;
    })(TaskExecutionDTO || (TaskExecutionDTO = {}));
    var ExtHostTask = /** @class */ (function () {
        function ExtHostTask(mainContext, workspaceService, editorService, configurationService) {
            this._onDidExecuteTask = new event_1.Emitter();
            this._onDidTerminateTask = new event_1.Emitter();
            this._onDidTaskProcessStarted = new event_1.Emitter();
            this._onDidTaskProcessEnded = new event_1.Emitter();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTask);
            this._workspaceService = workspaceService;
            this._editorService = editorService;
            this._configurationService = configurationService;
            this._handleCounter = 0;
            this._handlers = new Map();
            this._taskExecutions = new Map();
        }
        Object.defineProperty(ExtHostTask.prototype, "extHostWorkspace", {
            get: function () {
                return this._workspaceService;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.registerTaskProvider = function (extension, provider) {
            var _this = this;
            if (!provider) {
                return new types.Disposable(function () { });
            }
            var handle = this.nextHandle();
            this._handlers.set(handle, { provider: provider, extension: extension });
            this._proxy.$registerTaskProvider(handle);
            return new types.Disposable(function () {
                _this._handlers.delete(handle);
                _this._proxy.$unregisterTaskProvider(handle);
            });
        };
        ExtHostTask.prototype.registerTaskSystem = function (scheme, info) {
            this._proxy.$registerTaskSystem(scheme, info);
        };
        ExtHostTask.prototype.fetchTasks = function (filter) {
            var _this = this;
            return this._proxy.$fetchTasks(TaskFilterDTO.from(filter)).then(function (values) {
                var result = [];
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var value = values_1[_i];
                    var task = TaskDTO.to(value, _this._workspaceService);
                    if (task) {
                        result.push(task);
                    }
                }
                return result;
            });
        };
        ExtHostTask.prototype.executeTask = function (extension, task) {
            var _this = this;
            var tTask = task;
            // We have a preserved ID. So the task didn't change.
            if (tTask._id !== void 0) {
                return this._proxy.$executeTask(TaskHandleDTO.from(tTask)).then(function (value) { return _this.getTaskExecution(value, task); });
            }
            else {
                var dto = TaskDTO.from(task, extension);
                if (dto === void 0) {
                    return Promise.reject(new Error('Task is not valid'));
                }
                return this._proxy.$executeTask(dto).then(function (value) { return _this.getTaskExecution(value, task); });
            }
        };
        Object.defineProperty(ExtHostTask.prototype, "taskExecutions", {
            get: function () {
                var result = [];
                this._taskExecutions.forEach(function (value) { return result.push(value); });
                return result;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.terminateTask = function (execution) {
            if (!(execution instanceof TaskExecutionImpl)) {
                throw new Error('No valid task execution provided');
            }
            return this._proxy.$terminateTask(execution._id);
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidStartTask", {
            get: function () {
                return this._onDidExecuteTask.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidStartTask = function (execution) {
            this._onDidExecuteTask.fire({
                execution: this.getTaskExecution(execution)
            });
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidEndTask", {
            get: function () {
                return this._onDidTerminateTask.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$OnDidEndTask = function (execution) {
            var _execution = this.getTaskExecution(execution);
            this._taskExecutions.delete(execution.id);
            this._onDidTerminateTask.fire({
                execution: _execution
            });
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidStartTaskProcess", {
            get: function () {
                return this._onDidTaskProcessStarted.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidStartTaskProcess = function (value) {
            var execution = this.getTaskExecution(value.id);
            if (execution) {
                this._onDidTaskProcessStarted.fire({
                    execution: execution,
                    processId: value.processId
                });
            }
        };
        Object.defineProperty(ExtHostTask.prototype, "onDidEndTaskProcess", {
            get: function () {
                return this._onDidTaskProcessEnded.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTask.prototype.$onDidEndTaskProcess = function (value) {
            var execution = this.getTaskExecution(value.id);
            if (execution) {
                this._onDidTaskProcessEnded.fire({
                    execution: execution,
                    exitCode: value.exitCode
                });
            }
        };
        ExtHostTask.prototype.$provideTasks = function (handle, validTypes) {
            var _this = this;
            var handler = this._handlers.get(handle);
            if (!handler) {
                return Promise.reject(new Error('no handler found'));
            }
            return async_1.asThenable(function () { return handler.provider.provideTasks(cancellation_1.CancellationToken.None); }).then(function (value) {
                var sanitized = [];
                for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                    var task = value_2[_i];
                    if (task.definition && validTypes[task.definition.type] === true) {
                        sanitized.push(task);
                    }
                    else {
                        sanitized.push(task);
                        console.warn("The task [" + task.source + ", " + task.name + "] uses an undefined task type. The task will be ignored in the future.");
                    }
                }
                var workspaceFolders = _this._workspaceService.getWorkspaceFolders();
                return {
                    tasks: Tasks.from(sanitized, workspaceFolders && workspaceFolders.length > 0 ? workspaceFolders[0] : undefined, handler.extension),
                    extension: handler.extension
                };
            });
        };
        ExtHostTask.prototype.$resolveVariables = function (uriComponents, variables) {
            var uri = uri_1.URI.revive(uriComponents);
            var result = Object.create(null);
            var workspaceFolder = this._workspaceService.resolveWorkspaceFolder(uri);
            var resolver = new extHostDebugService_1.ExtHostVariableResolverService(this._workspaceService, this._editorService, this._configurationService);
            var ws = {
                uri: workspaceFolder.uri,
                name: workspaceFolder.name,
                index: workspaceFolder.index,
                toResource: function () {
                    throw new Error('Not implemented');
                }
            };
            for (var _i = 0, variables_1 = variables; _i < variables_1.length; _i++) {
                var variable = variables_1[_i];
                result[variable] = resolver.resolve(ws, variable);
            }
            return result;
        };
        ExtHostTask.prototype.nextHandle = function () {
            return this._handleCounter++;
        };
        ExtHostTask.prototype.getTaskExecution = function (execution, task) {
            if (typeof execution === 'string') {
                return this._taskExecutions.get(execution);
            }
            var result = this._taskExecutions.get(execution.id);
            if (result) {
                return result;
            }
            result = new TaskExecutionImpl(this, execution.id, task ? task : TaskDTO.to(execution.task, this._workspaceService));
            this._taskExecutions.set(execution.id, result);
            return result;
        };
        return ExtHostTask;
    }());
    exports.ExtHostTask = ExtHostTask;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
























define(__m[167/*vs/workbench/api/node/extHostTerminalService*/], __M([1/*require*/,0/*exports*/,30/*os*/,6/*vs/base/common/platform*/,127/*vs/workbench/parts/terminal/node/terminalEnvironment*/,3/*vs/base/common/event*/,4/*vs/workbench/api/node/extHost.protocol*/,126/*vs/workbench/parts/terminal/common/terminal*/,128/*vs/workbench/parts/terminal/node/terminalProcess*/,11/*vs/base/common/async*/]), function (require, exports, os, platform, terminalEnvironment, event_1, extHost_protocol_1, terminal_1, terminalProcess_1, async_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RENDERER_NO_PROCESS_ID = -1;
    var BaseExtHostTerminal = /** @class */ (function () {
        function BaseExtHostTerminal(_proxy, id) {
            var _this = this;
            this._proxy = _proxy;
            this._disposed = false;
            this._queuedRequests = [];
            this._idPromise = new Promise(function (c) {
                if (id !== undefined) {
                    _this._id = id;
                    c(id);
                }
                else {
                    _this._idPromiseComplete = c;
                }
            });
        }
        BaseExtHostTerminal.prototype.dispose = function () {
            if (!this._disposed) {
                this._disposed = true;
                this._queueApiRequest(this._proxy.$dispose, []);
            }
        };
        BaseExtHostTerminal.prototype._checkDisposed = function () {
            if (this._disposed) {
                throw new Error('Terminal has already been disposed');
            }
        };
        BaseExtHostTerminal.prototype._queueApiRequest = function (callback, args) {
            var request = new ApiRequest(callback, args);
            if (!this._id) {
                this._queuedRequests.push(request);
                return;
            }
            request.run(this._proxy, this._id);
        };
        BaseExtHostTerminal.prototype._runQueuedRequests = function (id) {
            var _this = this;
            this._id = id;
            this._idPromiseComplete(id);
            this._queuedRequests.forEach(function (r) {
                r.run(_this._proxy, _this._id);
            });
            this._queuedRequests.length = 0;
        };
        return BaseExtHostTerminal;
    }());
    exports.BaseExtHostTerminal = BaseExtHostTerminal;
    var ExtHostTerminal = /** @class */ (function (_super) {
        __extends(ExtHostTerminal, _super);
        function ExtHostTerminal(proxy, _name, id, pid) {
            var _this = _super.call(this, proxy, id) || this;
            _this._name = _name;
            _this._onData = new event_1.Emitter();
            _this._pidPromise = new Promise(function (c) {
                if (pid === RENDERER_NO_PROCESS_ID) {
                    c(undefined);
                }
                else {
                    _this._pidPromiseComplete = c;
                }
            });
            return _this;
        }
        Object.defineProperty(ExtHostTerminal.prototype, "onDidWriteData", {
            get: function () {
                var _this = this;
                // Tell the main side to start sending data if it's not already
                this._idPromise.then(function (c) {
                    _this._proxy.$registerOnDataListener(_this._id);
                });
                return this._onData && this._onData.event;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminal.prototype.create = function (shellPath, shellArgs, cwd, env, waitOnExit) {
            var _this = this;
            this._proxy.$createTerminal(this._name, shellPath, shellArgs, cwd, env, waitOnExit).then(function (id) {
                _this._runQueuedRequests(id);
            });
        };
        Object.defineProperty(ExtHostTerminal.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (name) {
                this._name = name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminal.prototype, "processId", {
            get: function () {
                return this._pidPromise;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminal.prototype.sendText = function (text, addNewLine) {
            if (addNewLine === void 0) { addNewLine = true; }
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$sendText, [text, addNewLine]);
        };
        ExtHostTerminal.prototype.show = function (preserveFocus) {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$show, [preserveFocus]);
        };
        ExtHostTerminal.prototype.hide = function () {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$hide, []);
        };
        ExtHostTerminal.prototype._setProcessId = function (processId) {
            // The event may fire 2 times when the panel is restored
            if (this._pidPromiseComplete) {
                this._pidPromiseComplete(processId);
                this._pidPromiseComplete = null;
            }
        };
        ExtHostTerminal.prototype._fireOnData = function (data) {
            this._onData.fire(data);
        };
        return ExtHostTerminal;
    }(BaseExtHostTerminal));
    exports.ExtHostTerminal = ExtHostTerminal;
    var ExtHostTerminalRenderer = /** @class */ (function (_super) {
        __extends(ExtHostTerminalRenderer, _super);
        function ExtHostTerminalRenderer(proxy, _name, _terminal) {
            var _this = _super.call(this, proxy) || this;
            _this._name = _name;
            _this._terminal = _terminal;
            _this._onInput = new event_1.Emitter();
            _this._onDidChangeMaximumDimensions = new event_1.Emitter();
            _this._proxy.$createTerminalRenderer(_this._name).then(function (id) {
                _this._runQueuedRequests(id);
                _this._terminal._runQueuedRequests(id);
            });
            return _this;
        }
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "name", {
            get: function () { return this._name; },
            set: function (newName) {
                this._name = newName;
                this._checkDisposed();
                this._queueApiRequest(this._proxy.$terminalRendererSetName, [this._name]);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "onDidAcceptInput", {
            get: function () {
                this._checkDisposed();
                this._queueApiRequest(this._proxy.$terminalRendererRegisterOnInputListener, [this._id]);
                // Tell the main side to start sending data if it's not already
                // this._proxy.$terminalRendererRegisterOnDataListener(this._id);
                return this._onInput && this._onInput.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "dimensions", {
            get: function () { return this._dimensions; },
            set: function (dimensions) {
                this._checkDisposed();
                this._dimensions = dimensions;
                this._queueApiRequest(this._proxy.$terminalRendererSetDimensions, [dimensions]);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "maximumDimensions", {
            get: function () {
                if (!this._maximumDimensions) {
                    return undefined;
                }
                return {
                    rows: this._maximumDimensions.rows,
                    columns: this._maximumDimensions.columns
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "onDidChangeMaximumDimensions", {
            get: function () {
                return this._onDidChangeMaximumDimensions && this._onDidChangeMaximumDimensions.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalRenderer.prototype, "terminal", {
            get: function () {
                return this._terminal;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminalRenderer.prototype.write = function (data) {
            this._checkDisposed();
            this._queueApiRequest(this._proxy.$terminalRendererWrite, [data]);
        };
        ExtHostTerminalRenderer.prototype._fireOnInput = function (data) {
            this._onInput.fire(data);
        };
        ExtHostTerminalRenderer.prototype._setMaximumDimensions = function (columns, rows) {
            if (this._maximumDimensions && this._maximumDimensions.columns === columns && this._maximumDimensions.rows === rows) {
                return;
            }
            this._maximumDimensions = { columns: columns, rows: rows };
            this._onDidChangeMaximumDimensions.fire(this.maximumDimensions);
        };
        return ExtHostTerminalRenderer;
    }(BaseExtHostTerminal));
    exports.ExtHostTerminalRenderer = ExtHostTerminalRenderer;
    var ExtHostTerminalService = /** @class */ (function () {
        function ExtHostTerminalService(mainContext, _extHostConfiguration, _logService) {
            this._extHostConfiguration = _extHostConfiguration;
            this._logService = _logService;
            this._terminals = [];
            this._terminalProcesses = {};
            this._terminalRenderers = [];
            this._getTerminalPromises = {};
            this._onDidCloseTerminal = new event_1.Emitter();
            this._onDidOpenTerminal = new event_1.Emitter();
            this._onDidChangeActiveTerminal = new event_1.Emitter();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTerminalService);
        }
        Object.defineProperty(ExtHostTerminalService.prototype, "activeTerminal", {
            get: function () { return this._activeTerminal; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "terminals", {
            get: function () { return this._terminals; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidCloseTerminal", {
            get: function () { return this._onDidCloseTerminal && this._onDidCloseTerminal.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidOpenTerminal", {
            get: function () { return this._onDidOpenTerminal && this._onDidOpenTerminal.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostTerminalService.prototype, "onDidChangeActiveTerminal", {
            get: function () { return this._onDidChangeActiveTerminal && this._onDidChangeActiveTerminal.event; },
            enumerable: true,
            configurable: true
        });
        ExtHostTerminalService.prototype.createTerminal = function (name, shellPath, shellArgs) {
            var terminal = new ExtHostTerminal(this._proxy, name);
            terminal.create(shellPath, shellArgs);
            this._terminals.push(terminal);
            return terminal;
        };
        ExtHostTerminalService.prototype.createTerminalFromOptions = function (options) {
            var terminal = new ExtHostTerminal(this._proxy, options.name);
            terminal.create(options.shellPath, options.shellArgs, options.cwd, options.env /*, options.waitOnExit*/);
            this._terminals.push(terminal);
            return terminal;
        };
        ExtHostTerminalService.prototype.createTerminalRenderer = function (name) {
            var terminal = new ExtHostTerminal(this._proxy, name);
            terminal._setProcessId(undefined);
            this._terminals.push(terminal);
            var renderer = new ExtHostTerminalRenderer(this._proxy, name, terminal);
            this._terminalRenderers.push(renderer);
            return renderer;
        };
        ExtHostTerminalService.prototype.$acceptActiveTerminalChanged = function (id) {
            var _this = this;
            var original = this._activeTerminal;
            if (id === null) {
                this._activeTerminal = undefined;
                if (original !== this._activeTerminal) {
                    this._onDidChangeActiveTerminal.fire(this._activeTerminal);
                }
            }
            this._performTerminalIdAction(id, function (terminal) {
                if (terminal) {
                    _this._activeTerminal = terminal;
                    if (original !== _this._activeTerminal) {
                        _this._onDidChangeActiveTerminal.fire(_this._activeTerminal);
                    }
                }
            });
        };
        ExtHostTerminalService.prototype.$acceptTerminalProcessData = function (id, data) {
            this._getTerminalByIdEventually(id).then(function (terminal) {
                if (terminal) {
                    terminal._fireOnData(data);
                }
            });
        };
        ExtHostTerminalService.prototype.$acceptTerminalRendererDimensions = function (id, cols, rows) {
            var renderer = this._getTerminalRendererById(id);
            if (renderer) {
                renderer._setMaximumDimensions(cols, rows);
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalRendererInput = function (id, data) {
            var renderer = this._getTerminalRendererById(id);
            if (renderer) {
                renderer._fireOnInput(data);
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalTitleChange = function (id, name) {
            var extHostTerminal = this._getTerminalObjectById(this.terminals, id);
            if (extHostTerminal) {
                extHostTerminal.name = name;
            }
        };
        ExtHostTerminalService.prototype.$acceptTerminalClosed = function (id) {
            var index = this._getTerminalObjectIndexById(this.terminals, id);
            if (index === null) {
                return;
            }
            var terminal = this._terminals.splice(index, 1)[0];
            this._onDidCloseTerminal.fire(terminal);
        };
        ExtHostTerminalService.prototype.$acceptTerminalOpened = function (id, name) {
            var index = this._getTerminalObjectIndexById(this._terminals, id);
            if (index !== null) {
                // The terminal has already been created (via createTerminal*), only fire the event
                this._onDidOpenTerminal.fire(this.terminals[index]);
                return;
            }
            var renderer = this._getTerminalRendererById(id);
            var terminal = new ExtHostTerminal(this._proxy, name, id, renderer ? RENDERER_NO_PROCESS_ID : undefined);
            this._terminals.push(terminal);
            this._onDidOpenTerminal.fire(terminal);
        };
        ExtHostTerminalService.prototype.$acceptTerminalProcessId = function (id, processId) {
            this._performTerminalIdAction(id, function (terminal) { return terminal._setProcessId(processId); });
        };
        ExtHostTerminalService.prototype._performTerminalIdAction = function (id, callback) {
            var _this = this;
            var terminal = this._getTerminalById(id);
            if (terminal) {
                callback(terminal);
            }
            else {
                // Retry one more time in case the terminal has not yet been initialized.
                setTimeout(function () {
                    terminal = _this._getTerminalById(id);
                    if (terminal) {
                        callback(terminal);
                    }
                }, terminal_1.EXT_HOST_CREATION_DELAY);
            }
        };
        ExtHostTerminalService.prototype.$createProcess = function (id, shellLaunchConfig, cols, rows) {
            // TODO: This function duplicates a lot of TerminalProcessManager.createProcess, ideally
            // they would be merged into a single implementation.
            var _this = this;
            var terminalConfig = this._extHostConfiguration.getConfiguration('terminal.integrated');
            if (!shellLaunchConfig.executable) {
                // TODO: This duplicates some of TerminalConfigHelper.mergeDefaultShellPathAndArgs and should be merged
                // this._configHelper.mergeDefaultShellPathAndArgs(shellLaunchConfig);
                var platformKey = platform.isWindows ? 'windows' : platform.isMacintosh ? 'osx' : 'linux';
                var shellConfigValue = terminalConfig.get("shell." + platformKey);
                var shellArgsConfigValue = terminalConfig.get("shellArgs." + platformKey);
                shellLaunchConfig.executable = shellConfigValue;
                shellLaunchConfig.args = shellArgsConfigValue;
            }
            // TODO: Base the cwd on the last active workspace root
            // const lastActiveWorkspaceRootUri = this._historyService.getLastActiveWorkspaceRoot(Schemas.file);
            // this.initialCwd = terminalEnvironment.getCwd(shellLaunchConfig, lastActiveWorkspaceRootUri, this._configHelper);
            var initialCwd = os.homedir();
            // TODO: Pull in and resolve config settings
            // // Resolve env vars from config and shell
            // const lastActiveWorkspaceRoot = this._workspaceContextService.getWorkspaceFolder(lastActiveWorkspaceRootUri);
            // const platformKey = platform.isWindows ? 'windows' : (platform.isMacintosh ? 'osx' : 'linux');
            // const envFromConfig = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...this._configHelper.config.env[platformKey] }, lastActiveWorkspaceRoot);
            // const envFromShell = terminalEnvironment.resolveConfigurationVariables(this._configurationResolverService, { ...shellLaunchConfig.env }, lastActiveWorkspaceRoot);
            // Merge process env with the env from config
            var env = __assign({}, process.env);
            // terminalEnvironment.mergeEnvironments(env, envFromConfig);
            terminalEnvironment.mergeEnvironments(env, shellLaunchConfig.env);
            // Continue env initialization, merging in the env from the launch
            // config and adding keys that are needed to create the process
            var locale = terminalConfig.get('setLocaleVariables') ? platform.locale : undefined;
            terminalEnvironment.addTerminalEnvironmentKeys(env, locale);
            // Fork the process and listen for messages
            this._logService.debug("Terminal process launching on ext host", shellLaunchConfig, initialCwd, cols, rows, env);
            this._terminalProcesses[id] = new terminalProcess_1.TerminalProcess(shellLaunchConfig, initialCwd, cols, rows, env);
            this._terminalProcesses[id].onProcessIdReady(function (pid) { return _this._proxy.$sendProcessPid(id, pid); });
            this._terminalProcesses[id].onProcessTitleChanged(function (title) { return _this._proxy.$sendProcessTitle(id, title); });
            this._terminalProcesses[id].onProcessData(function (data) { return _this._proxy.$sendProcessData(id, data); });
            this._terminalProcesses[id].onProcessExit(function (exitCode) { return _this._onProcessExit(id, exitCode); });
        };
        ExtHostTerminalService.prototype.$acceptProcessInput = function (id, data) {
            this._terminalProcesses[id].input(data);
        };
        ExtHostTerminalService.prototype.$acceptProcessResize = function (id, cols, rows) {
            try {
                this._terminalProcesses[id].resize(cols, rows);
            }
            catch (error) {
                // We tried to write to a closed pipe / channel.
                if (error.code !== 'EPIPE' && error.code !== 'ERR_IPC_CHANNEL_CLOSED') {
                    throw (error);
                }
            }
        };
        ExtHostTerminalService.prototype.$acceptProcessShutdown = function (id, immediate) {
            this._terminalProcesses[id].shutdown(immediate);
        };
        ExtHostTerminalService.prototype._onProcessExit = function (id, exitCode) {
            // Remove listeners
            this._terminalProcesses[id].dispose();
            // Remove process reference
            delete this._terminalProcesses[id];
            // Send exit event to main side
            this._proxy.$sendProcessExit(id, exitCode);
        };
        ExtHostTerminalService.prototype._getTerminalByIdEventually = function (id, retries) {
            var _this = this;
            if (retries === void 0) { retries = 5; }
            if (!this._getTerminalPromises[id]) {
                this._getTerminalPromises[id] = this._createGetTerminalPromise(id, retries);
            }
            else {
                this._getTerminalPromises[id].then(function (c) {
                    return _this._createGetTerminalPromise(id, retries);
                });
            }
            return this._getTerminalPromises[id];
        };
        ExtHostTerminalService.prototype._createGetTerminalPromise = function (id, retries) {
            var _this = this;
            if (retries === void 0) { retries = 5; }
            return new Promise(function (c) {
                if (retries === 0) {
                    c(undefined);
                    return;
                }
                var terminal = _this._getTerminalById(id);
                if (terminal) {
                    c(terminal);
                }
                else {
                    // This should only be needed immediately after createTerminalRenderer is called as
                    // the ExtHostTerminal has not yet been iniitalized
                    async_1.timeout(200).then(function () { return c(_this._getTerminalByIdEventually(id, retries - 1)); });
                }
            });
        };
        ExtHostTerminalService.prototype._getTerminalById = function (id) {
            return this._getTerminalObjectById(this._terminals, id);
        };
        ExtHostTerminalService.prototype._getTerminalRendererById = function (id) {
            return this._getTerminalObjectById(this._terminalRenderers, id);
        };
        ExtHostTerminalService.prototype._getTerminalObjectById = function (array, id) {
            var index = this._getTerminalObjectIndexById(array, id);
            return index !== null ? array[index] : null;
        };
        ExtHostTerminalService.prototype._getTerminalObjectIndexById = function (array, id) {
            var index = null;
            array.some(function (item, i) {
                var thisId = item._id;
                if (thisId === id) {
                    index = i;
                    return true;
                }
                return false;
            });
            return index;
        };
        return ExtHostTerminalService;
    }());
    exports.ExtHostTerminalService = ExtHostTerminalService;
    var ApiRequest = /** @class */ (function () {
        function ApiRequest(callback, args) {
            this._callback = callback;
            this._args = args;
        }
        ApiRequest.prototype.run = function (proxy, id) {
            this._callback.apply(proxy, [id].concat(this._args));
        };
        return ApiRequest;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[168/*vs/workbench/api/node/extHostTextEditors*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,4/*vs/workbench/api/node/extHost.protocol*/,70/*vs/workbench/api/node/extHostTextEditor*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, event_1, extHost_protocol_1, extHostTextEditor_1, TypeConverters, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostEditors = /** @class */ (function () {
        function ExtHostEditors(mainContext, extHostDocumentsAndEditors) {
            var _this = this;
            this._onDidChangeTextEditorSelection = new event_1.Emitter();
            this._onDidChangeTextEditorOptions = new event_1.Emitter();
            this._onDidChangeTextEditorVisibleRanges = new event_1.Emitter();
            this._onDidChangeTextEditorViewColumn = new event_1.Emitter();
            this._onDidChangeActiveTextEditor = new event_1.Emitter();
            this._onDidChangeVisibleTextEditors = new event_1.Emitter();
            this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
            this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
            this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
            this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
            this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
            this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors);
            this._extHostDocumentsAndEditors = extHostDocumentsAndEditors;
            this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors(function (e) { return _this._onDidChangeVisibleTextEditors.fire(e); });
            this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor(function (e) { return _this._onDidChangeActiveTextEditor.fire(e); });
        }
        ExtHostEditors.prototype.getActiveTextEditor = function () {
            return this._extHostDocumentsAndEditors.activeEditor();
        };
        ExtHostEditors.prototype.getVisibleTextEditors = function () {
            return this._extHostDocumentsAndEditors.allEditors();
        };
        ExtHostEditors.prototype.showTextDocument = function (document, columnOrOptions, preserveFocus) {
            var _this = this;
            var options;
            if (typeof columnOrOptions === 'number') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions),
                    preserveFocus: preserveFocus
                };
            }
            else if (typeof columnOrOptions === 'object') {
                options = {
                    position: TypeConverters.ViewColumn.from(columnOrOptions.viewColumn),
                    preserveFocus: columnOrOptions.preserveFocus,
                    selection: typeof columnOrOptions.selection === 'object' ? TypeConverters.Range.from(columnOrOptions.selection) : undefined,
                    pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined
                };
            }
            else {
                options = {
                    preserveFocus: false
                };
            }
            return this._proxy.$tryShowTextDocument(document.uri, options).then(function (id) {
                var editor = _this._extHostDocumentsAndEditors.getEditor(id);
                if (editor) {
                    return editor;
                }
                else {
                    throw new Error("Failed to show text document " + document.uri.toString() + ", should show in editor #" + id);
                }
            });
        };
        ExtHostEditors.prototype.createTextEditorDecorationType = function (options) {
            return new extHostTextEditor_1.TextEditorDecorationType(this._proxy, options);
        };
        ExtHostEditors.prototype.applyWorkspaceEdit = function (edit) {
            var dto = TypeConverters.WorkspaceEdit.from(edit, this._extHostDocumentsAndEditors);
            return this._proxy.$tryApplyWorkspaceEdit(dto);
        };
        // --- called from main thread
        ExtHostEditors.prototype.$acceptEditorPropertiesChanged = function (id, data) {
            var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
            // (1) set all properties
            if (data.options) {
                textEditor._acceptOptions(data.options);
            }
            if (data.selections) {
                var selections = data.selections.selections.map(TypeConverters.Selection.to);
                textEditor._acceptSelections(selections);
            }
            if (data.visibleRanges) {
                var visibleRanges = data.visibleRanges.map(TypeConverters.Range.to);
                textEditor._acceptVisibleRanges(visibleRanges);
            }
            // (2) fire change events
            if (data.options) {
                this._onDidChangeTextEditorOptions.fire({
                    textEditor: textEditor,
                    options: data.options
                });
            }
            if (data.selections) {
                var kind = extHostTypes_1.TextEditorSelectionChangeKind.fromValue(data.selections.source);
                var selections = data.selections.selections.map(TypeConverters.Selection.to);
                this._onDidChangeTextEditorSelection.fire({
                    textEditor: textEditor,
                    selections: selections,
                    kind: kind
                });
            }
            if (data.visibleRanges) {
                var visibleRanges = data.visibleRanges.map(TypeConverters.Range.to);
                this._onDidChangeTextEditorVisibleRanges.fire({
                    textEditor: textEditor,
                    visibleRanges: visibleRanges
                });
            }
        };
        ExtHostEditors.prototype.$acceptEditorPositionData = function (data) {
            for (var id in data) {
                var textEditor = this._extHostDocumentsAndEditors.getEditor(id);
                var viewColumn = TypeConverters.ViewColumn.to(data[id]);
                if (textEditor.viewColumn !== viewColumn) {
                    textEditor._acceptViewColumn(viewColumn);
                    this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor, viewColumn: viewColumn });
                }
            }
        };
        ExtHostEditors.prototype.getDiffInformation = function (id) {
            return Promise.resolve(this._proxy.$getDiffInformation(id));
        };
        return ExtHostEditors;
    }());
    exports.ExtHostEditors = ExtHostEditors;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[169/*vs/workbench/api/node/extHostUrls*/], __M([1/*require*/,0/*exports*/,4/*vs/workbench/api/node/extHost.protocol*/,2/*vs/base/common/uri*/,8/*vs/base/common/lifecycle*/,14/*vs/base/common/errors*/]), function (require, exports, extHost_protocol_1, uri_1, lifecycle_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostUrls = /** @class */ (function () {
        function ExtHostUrls(mainContext) {
            this.handles = new Set();
            this.handlers = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadUrls);
        }
        ExtHostUrls.prototype.registerUriHandler = function (extensionId, handler) {
            var _this = this;
            if (this.handles.has(extensionId)) {
                throw new Error("Protocol handler already registered for extension " + extensionId);
            }
            var handle = ExtHostUrls.HandlePool++;
            this.handles.add(extensionId);
            this.handlers.set(handle, handler);
            this._proxy.$registerUriHandler(handle, extensionId);
            return lifecycle_1.toDisposable(function () {
                _this.handles.delete(extensionId);
                _this.handlers.delete(handle);
                _this._proxy.$unregisterUriHandler(handle);
            });
        };
        ExtHostUrls.prototype.$handleExternalUri = function (handle, uri) {
            var handler = this.handlers.get(handle);
            if (!handler) {
                return Promise.resolve(null);
            }
            try {
                handler.handleUri(uri_1.URI.revive(uri));
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
            }
            return Promise.resolve(null);
        };
        ExtHostUrls.HandlePool = 0;
        return ExtHostUrls;
    }());
    exports.ExtHostUrls = ExtHostUrls;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[170/*vs/workbench/api/node/extHostWebview*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,2/*vs/base/common/uri*/,21/*vs/workbench/api/node/extHostTypeConverters*/,4/*vs/workbench/api/node/extHost.protocol*/,7/*vs/workbench/api/node/extHostTypes*/]), function (require, exports, event_1, uri_1, typeConverters, extHost_protocol_1, extHostTypes_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostWebview = /** @class */ (function () {
        function ExtHostWebview(handle, proxy, options) {
            this._isDisposed = false;
            this._onMessageEmitter = new event_1.Emitter();
            this.onDidReceiveMessage = this._onMessageEmitter.event;
            this._handle = handle;
            this._proxy = proxy;
            this._options = options;
        }
        ExtHostWebview.prototype.dispose = function () {
            this._onMessageEmitter.dispose();
        };
        Object.defineProperty(ExtHostWebview.prototype, "html", {
            get: function () {
                this.assertNotDisposed();
                return this._html;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._html !== value) {
                    this._html = value;
                    this._proxy.$setHtml(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebview.prototype, "options", {
            get: function () {
                this.assertNotDisposed();
                return this._options;
            },
            set: function (newOptions) {
                this.assertNotDisposed();
                this._proxy.$setOptions(this._handle, newOptions);
                this._options = newOptions;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebview.prototype.postMessage = function (message) {
            this.assertNotDisposed();
            return this._proxy.$postMessage(this._handle, message);
        };
        ExtHostWebview.prototype.assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Webview is disposed');
            }
        };
        return ExtHostWebview;
    }());
    exports.ExtHostWebview = ExtHostWebview;
    var ExtHostWebviewPanel = /** @class */ (function () {
        function ExtHostWebviewPanel(handle, proxy, viewType, title, viewColumn, editorOptions, webview) {
            this._isDisposed = false;
            this._visible = true;
            this._active = true;
            this._onDisposeEmitter = new event_1.Emitter();
            this.onDidDispose = this._onDisposeEmitter.event;
            this._onDidChangeViewStateEmitter = new event_1.Emitter();
            this.onDidChangeViewState = this._onDidChangeViewStateEmitter.event;
            this._handle = handle;
            this._proxy = proxy;
            this._viewType = viewType;
            this._options = editorOptions;
            this._viewColumn = viewColumn;
            this._title = title;
            this._webview = webview;
        }
        ExtHostWebviewPanel.prototype.dispose = function () {
            if (this._isDisposed) {
                return;
            }
            this._isDisposed = true;
            this._onDisposeEmitter.fire();
            this._proxy.$disposeWebview(this._handle);
            this._webview.dispose();
            this._onDisposeEmitter.dispose();
            this._onDidChangeViewStateEmitter.dispose();
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "webview", {
            get: function () {
                this.assertNotDisposed();
                return this._webview;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "viewType", {
            get: function () {
                this.assertNotDisposed();
                return this._viewType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "title", {
            get: function () {
                this.assertNotDisposed();
                return this._title;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._title !== value) {
                    this._title = value;
                    this._proxy.$setTitle(this._handle, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "iconPath", {
            get: function () {
                this.assertNotDisposed();
                return this._iconPath;
            },
            set: function (value) {
                this.assertNotDisposed();
                if (this._iconPath !== value) {
                    this._iconPath = value;
                    this._proxy.$setIconPath(this._handle, uri_1.URI.isUri(value) ? { light: value, dark: value } : value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWebviewPanel.prototype, "viewColumn", {
            get: function () {
                this.assertNotDisposed();
                return this._viewColumn;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setViewColumn = function (value) {
            this.assertNotDisposed();
            this._viewColumn = value;
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "active", {
            get: function () {
                this.assertNotDisposed();
                return this._active;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setActive = function (value) {
            this.assertNotDisposed();
            this._active = value;
        };
        Object.defineProperty(ExtHostWebviewPanel.prototype, "visible", {
            get: function () {
                this.assertNotDisposed();
                return this._visible;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWebviewPanel.prototype._setVisible = function (value) {
            this.assertNotDisposed();
            this._visible = value;
        };
        ExtHostWebviewPanel.prototype.postMessage = function (message) {
            this.assertNotDisposed();
            return this._proxy.$postMessage(this._handle, message);
        };
        ExtHostWebviewPanel.prototype.reveal = function (viewColumn, preserveFocus) {
            this.assertNotDisposed();
            this._proxy.$reveal(this._handle, {
                viewColumn: viewColumn ? typeConverters.ViewColumn.from(viewColumn) : undefined,
                preserveFocus: !!preserveFocus
            });
        };
        ExtHostWebviewPanel.prototype.assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Webview is disposed');
            }
        };
        return ExtHostWebviewPanel;
    }());
    exports.ExtHostWebviewPanel = ExtHostWebviewPanel;
    var ExtHostWebviews = /** @class */ (function () {
        function ExtHostWebviews(mainContext) {
            this._webviewPanels = new Map();
            this._serializers = new Map();
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWebviews);
        }
        ExtHostWebviews.newHandle = function () {
            return ExtHostWebviews.webviewHandlePool++ + '';
        };
        ExtHostWebviews.prototype.createWebview = function (extension, viewType, title, showOptions, options) {
            if (options === void 0) { options = {}; }
            var viewColumn = typeof showOptions === 'object' ? showOptions.viewColumn : showOptions;
            var webviewShowOptions = {
                viewColumn: typeConverters.ViewColumn.from(viewColumn),
                preserveFocus: typeof showOptions === 'object' && !!showOptions.preserveFocus
            };
            var handle = ExtHostWebviews.newHandle();
            this._proxy.$createWebviewPanel(handle, viewType, title, webviewShowOptions, options, extension.id, extension.extensionLocation);
            var webview = new ExtHostWebview(handle, this._proxy, options);
            var panel = new ExtHostWebviewPanel(handle, this._proxy, viewType, title, viewColumn, options, webview);
            this._webviewPanels.set(handle, panel);
            return panel;
        };
        ExtHostWebviews.prototype.registerWebviewPanelSerializer = function (viewType, serializer) {
            var _this = this;
            if (this._serializers.has(viewType)) {
                throw new Error("Serializer for '" + viewType + "' already registered");
            }
            this._serializers.set(viewType, serializer);
            this._proxy.$registerSerializer(viewType);
            return new extHostTypes_1.Disposable(function () {
                _this._serializers.delete(viewType);
                _this._proxy.$unregisterSerializer(viewType);
            });
        };
        ExtHostWebviews.prototype.$onMessage = function (handle, message) {
            var panel = this.getWebviewPanel(handle);
            if (panel) {
                panel.webview._onMessageEmitter.fire(message);
            }
        };
        ExtHostWebviews.prototype.$onDidChangeWebviewPanelViewState = function (handle, newState) {
            var panel = this.getWebviewPanel(handle);
            if (!panel) {
                return;
            }
            var viewColumn = typeConverters.ViewColumn.to(newState.position);
            if (panel.active !== newState.active || panel.visible !== newState.visible || panel.viewColumn !== viewColumn) {
                panel._setActive(newState.active);
                panel._setVisible(newState.visible);
                panel._setViewColumn(viewColumn);
                panel._onDidChangeViewStateEmitter.fire({ webviewPanel: panel });
            }
        };
        ExtHostWebviews.prototype.$onDidDisposeWebviewPanel = function (handle) {
            var panel = this.getWebviewPanel(handle);
            if (panel) {
                panel.dispose();
                this._webviewPanels.delete(handle);
            }
            return Promise.resolve(void 0);
        };
        ExtHostWebviews.prototype.$deserializeWebviewPanel = function (webviewHandle, viewType, title, state, position, options) {
            var serializer = this._serializers.get(viewType);
            if (!serializer) {
                return Promise.reject(new Error("No serializer found for '" + viewType + "'"));
            }
            var webview = new ExtHostWebview(webviewHandle, this._proxy, options);
            var revivedPanel = new ExtHostWebviewPanel(webviewHandle, this._proxy, viewType, title, typeConverters.ViewColumn.to(position), options, webview);
            this._webviewPanels.set(webviewHandle, revivedPanel);
            return serializer.deserializeWebviewPanel(revivedPanel, state);
        };
        ExtHostWebviews.prototype.getWebviewPanel = function (handle) {
            return this._webviewPanels.get(handle);
        };
        ExtHostWebviews.webviewHandlePool = 1;
        return ExtHostWebviews;
    }());
    exports.ExtHostWebviews = ExtHostWebviews;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[171/*vs/workbench/api/node/extHostWindow*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/event*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, event_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostWindow = /** @class */ (function () {
        function ExtHostWindow(mainContext) {
            var _this = this;
            this._onDidChangeWindowState = new event_1.Emitter();
            this.onDidChangeWindowState = this._onDidChangeWindowState.event;
            this._state = ExtHostWindow.InitialState;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWindow);
            this._proxy.$getWindowVisibility().then(function (isFocused) { return _this.$onDidChangeWindowFocus(isFocused); });
        }
        Object.defineProperty(ExtHostWindow.prototype, "state", {
            get: function () { return this._state; },
            enumerable: true,
            configurable: true
        });
        ExtHostWindow.prototype.$onDidChangeWindowFocus = function (focused) {
            if (focused === this._state.focused) {
                return;
            }
            this._state = __assign({}, this._state, { focused: focused });
            this._onDidChangeWindowState.fire(this._state);
        };
        ExtHostWindow.InitialState = {
            focused: true
        };
        return ExtHostWindow;
    }());
    exports.ExtHostWindow = ExtHostWindow;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[172/*vs/workbench/api/node/extHostWorkspace*/], __M([1/*require*/,0/*exports*/,10/*path*/,9/*vs/base/common/arrays*/,17/*vs/base/common/cancellation*/,3/*vs/base/common/event*/,22/*vs/base/common/map*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,24/*vs/base/common/resources*/,5/*vs/base/common/strings*/,2/*vs/base/common/uri*/,88/*vs/nls!vs/workbench/api/node/extHostWorkspace*/,107/*vs/platform/notification/common/notification*/,41/*vs/platform/search/common/search*/,117/*vs/platform/workspace/common/workspace*/,7/*vs/workbench/api/node/extHostTypes*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, path_1, arrays_1, cancellation_1, event_1, map_1, paths_1, platform_1, resources_1, strings_1, uri_1, nls_1, notification_1, search_1, workspace_1, extHostTypes_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isFolderEqual(folderA, folderB) {
        return resources_1.isEqual(folderA, folderB, !platform_1.isLinux);
    }
    function compareWorkspaceFolderByUri(a, b) {
        return isFolderEqual(a.uri, b.uri) ? 0 : strings_1.compare(a.uri.toString(), b.uri.toString());
    }
    function compareWorkspaceFolderByUriAndNameAndIndex(a, b) {
        if (a.index !== b.index) {
            return a.index < b.index ? -1 : 1;
        }
        return isFolderEqual(a.uri, b.uri) ? strings_1.compare(a.name, b.name) : strings_1.compare(a.uri.toString(), b.uri.toString());
    }
    function delta(oldFolders, newFolders, compare) {
        var oldSortedFolders = oldFolders.slice(0).sort(compare);
        var newSortedFolders = newFolders.slice(0).sort(compare);
        return arrays_1.delta(oldSortedFolders, newSortedFolders, compare);
    }
    var ExtHostWorkspaceImpl = /** @class */ (function (_super) {
        __extends(ExtHostWorkspaceImpl, _super);
        function ExtHostWorkspaceImpl(id, _name, folders) {
            var _this = _super.call(this, id, folders.map(function (f) { return new workspace_1.WorkspaceFolder(f); })) || this;
            _this._name = _name;
            _this._workspaceFolders = [];
            _this._structure = map_1.TernarySearchTree.forPaths();
            // setup the workspace folder data structure
            folders.forEach(function (folder) {
                _this._workspaceFolders.push(folder);
                _this._structure.set(folder.uri.toString(), folder);
            });
            return _this;
        }
        ExtHostWorkspaceImpl.toExtHostWorkspace = function (data, previousConfirmedWorkspace, previousUnconfirmedWorkspace) {
            if (!data) {
                return { workspace: null, added: [], removed: [] };
            }
            var id = data.id, name = data.name, folders = data.folders;
            var newWorkspaceFolders = [];
            // If we have an existing workspace, we try to find the folders that match our
            // data and update their properties. It could be that an extension stored them
            // for later use and we want to keep them "live" if they are still present.
            var oldWorkspace = previousConfirmedWorkspace;
            if (oldWorkspace) {
                folders.forEach(function (folderData, index) {
                    var folderUri = uri_1.URI.revive(folderData.uri);
                    var existingFolder = ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri);
                    if (existingFolder) {
                        existingFolder.name = folderData.name;
                        existingFolder.index = folderData.index;
                        newWorkspaceFolders.push(existingFolder);
                    }
                    else {
                        newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index: index });
                    }
                });
            }
            else {
                newWorkspaceFolders.push.apply(newWorkspaceFolders, folders.map(function (_a) {
                    var uri = _a.uri, name = _a.name, index = _a.index;
                    return ({ uri: uri_1.URI.revive(uri), name: name, index: index });
                }));
            }
            // make sure to restore sort order based on index
            newWorkspaceFolders.sort(function (f1, f2) { return f1.index < f2.index ? -1 : 1; });
            var workspace = new ExtHostWorkspaceImpl(id, name, newWorkspaceFolders);
            var _a = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri), added = _a.added, removed = _a.removed;
            return { workspace: workspace, added: added, removed: removed };
        };
        ExtHostWorkspaceImpl._findFolder = function (workspace, folderUriToFind) {
            for (var i = 0; i < workspace.folders.length; i++) {
                var folder = workspace.workspaceFolders[i];
                if (isFolderEqual(folder.uri, folderUriToFind)) {
                    return folder;
                }
            }
            return undefined;
        };
        Object.defineProperty(ExtHostWorkspaceImpl.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWorkspaceImpl.prototype, "workspaceFolders", {
            get: function () {
                return this._workspaceFolders.slice(0);
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWorkspaceImpl.prototype.getWorkspaceFolder = function (uri, resolveParent) {
            if (resolveParent && this._structure.get(uri.toString())) {
                // `uri` is a workspace folder so we check for its parent
                uri = resources_1.dirname(uri);
            }
            return this._structure.findSubstr(uri.toString());
        };
        ExtHostWorkspaceImpl.prototype.resolveWorkspaceFolder = function (uri) {
            return this._structure.get(uri.toString());
        };
        return ExtHostWorkspaceImpl;
    }(workspace_1.Workspace));
    var ExtHostWorkspace = /** @class */ (function () {
        function ExtHostWorkspace(mainContext, data, _logService, _requestIdProvider) {
            this._logService = _logService;
            this._requestIdProvider = _requestIdProvider;
            this._onDidChangeWorkspace = new event_1.Emitter();
            this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
            this._activeSearchCallbacks = [];
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadWorkspace);
            this._messageService = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadMessageService);
            this._confirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace(data).workspace;
        }
        Object.defineProperty(ExtHostWorkspace.prototype, "workspace", {
            // --- workspace ---
            get: function () {
                return this._actualWorkspace;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWorkspace.prototype, "name", {
            get: function () {
                return this._actualWorkspace ? this._actualWorkspace.name : undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ExtHostWorkspace.prototype, "_actualWorkspace", {
            get: function () {
                return this._unconfirmedWorkspace || this._confirmedWorkspace;
            },
            enumerable: true,
            configurable: true
        });
        ExtHostWorkspace.prototype.getWorkspaceFolders = function () {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.workspaceFolders.slice(0);
        };
        ExtHostWorkspace.prototype.updateWorkspaceFolders = function (extension, index, deleteCount) {
            var _this = this;
            var workspaceFoldersToAdd = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                workspaceFoldersToAdd[_i - 3] = arguments[_i];
            }
            var validatedDistinctWorkspaceFoldersToAdd = [];
            if (Array.isArray(workspaceFoldersToAdd)) {
                workspaceFoldersToAdd.forEach(function (folderToAdd) {
                    if (uri_1.URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some(function (f) { return isFolderEqual(f.uri, folderToAdd.uri); })) {
                        validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || resources_1.basenameOrAuthority(folderToAdd.uri) });
                    }
                });
            }
            if (!!this._unconfirmedWorkspace) {
                return false; // prevent accumulated calls without a confirmed workspace
            }
            if ([index, deleteCount].some(function (i) { return typeof i !== 'number' || i < 0; })) {
                return false; // validate numbers
            }
            if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
                return false; // nothing to delete or add
            }
            var currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
            if (index + deleteCount > currentWorkspaceFolders.length) {
                return false; // cannot delete more than we have
            }
            // Simulate the updateWorkspaceFolders method on our data to do more validation
            var newWorkspaceFolders = currentWorkspaceFolders.slice(0);
            newWorkspaceFolders.splice.apply(newWorkspaceFolders, [index, deleteCount].concat(validatedDistinctWorkspaceFoldersToAdd.map(function (f) { return ({ uri: f.uri, name: f.name || resources_1.basenameOrAuthority(f.uri), index: undefined }); })));
            var _loop_1 = function (i) {
                var folder = newWorkspaceFolders[i];
                if (newWorkspaceFolders.some(function (otherFolder, index) { return index !== i && isFolderEqual(folder.uri, otherFolder.uri); })) {
                    return { value: false };
                }
            };
            for (var i = 0; i < newWorkspaceFolders.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            newWorkspaceFolders.forEach(function (f, index) { return f.index = index; }); // fix index
            var _a = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex), added = _a.added, removed = _a.removed;
            if (added.length === 0 && removed.length === 0) {
                return false; // nothing actually changed
            }
            // Trigger on main side
            if (this._proxy) {
                var extName_1 = extension.displayName || extension.name;
                this._proxy.$updateWorkspaceFolders(extName_1, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(null, function (error) {
                    // in case of an error, make sure to clear out the unconfirmed workspace
                    // because we cannot expect the acknowledgement from the main side for this
                    _this._unconfirmedWorkspace = undefined;
                    // show error to user
                    _this._messageService.$showMessage(notification_1.Severity.Error, nls_1.localize(0, null, extName_1, error.toString()), { extension: extension }, []);
                });
            }
            // Try to accept directly
            this.trySetWorkspaceFolders(newWorkspaceFolders);
            return true;
        };
        ExtHostWorkspace.prototype.getWorkspaceFolder = function (uri, resolveParent) {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
        };
        ExtHostWorkspace.prototype.resolveWorkspaceFolder = function (uri) {
            if (!this._actualWorkspace) {
                return undefined;
            }
            return this._actualWorkspace.resolveWorkspaceFolder(uri);
        };
        ExtHostWorkspace.prototype.getPath = function () {
            // this is legacy from the days before having
            // multi-root and we keep it only alive if there
            // is just one workspace folder.
            if (!this._actualWorkspace) {
                return undefined;
            }
            var folders = this._actualWorkspace.folders;
            if (folders.length === 0) {
                return undefined;
            }
            // #54483 @Joh Why are we still using fsPath?
            return folders[0].uri.fsPath;
        };
        ExtHostWorkspace.prototype.getRelativePath = function (pathOrUri, includeWorkspace) {
            var path;
            if (typeof pathOrUri === 'string') {
                path = pathOrUri;
            }
            else if (typeof pathOrUri !== 'undefined') {
                path = pathOrUri.fsPath;
            }
            if (!path) {
                return path;
            }
            var folder = this.getWorkspaceFolder(typeof pathOrUri === 'string' ? uri_1.URI.file(pathOrUri) : pathOrUri, true);
            if (!folder) {
                return path;
            }
            if (typeof includeWorkspace === 'undefined') {
                includeWorkspace = this._actualWorkspace.folders.length > 1;
            }
            var result = path_1.relative(folder.uri.fsPath, path);
            if (includeWorkspace) {
                result = folder.name + "/" + result;
            }
            return paths_1.normalize(result, true);
        };
        ExtHostWorkspace.prototype.trySetWorkspaceFolders = function (folders) {
            // Update directly here. The workspace is unconfirmed as long as we did not get an
            // acknowledgement from the main side (via $acceptWorkspaceData)
            if (this._actualWorkspace) {
                this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({
                    id: this._actualWorkspace.id,
                    name: this._actualWorkspace.name,
                    configuration: this._actualWorkspace.configuration,
                    folders: folders
                }, this._actualWorkspace).workspace;
            }
        };
        ExtHostWorkspace.prototype.$acceptWorkspaceData = function (data) {
            var _a = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace), workspace = _a.workspace, added = _a.added, removed = _a.removed;
            // Update our workspace object. We have a confirmed workspace, so we drop our
            // unconfirmed workspace.
            this._confirmedWorkspace = workspace;
            this._unconfirmedWorkspace = undefined;
            // Events
            this._onDidChangeWorkspace.fire(Object.freeze({
                added: added,
                removed: removed,
            }));
        };
        // --- search ---
        ExtHostWorkspace.prototype.findFiles = function (include, exclude, maxResults, extensionId, token) {
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            this._logService.trace("extHostWorkspace#findFiles: fileSearch, extension: " + extensionId + ", entryPoint: findFiles");
            var includePattern;
            var includeFolder;
            if (include) {
                if (typeof include === 'string') {
                    includePattern = include;
                }
                else {
                    includePattern = include.pattern;
                    // include.base must be an absolute path
                    includeFolder = include.baseFolder || uri_1.URI.file(include.base);
                }
            }
            var excludePatternOrDisregardExcludes;
            if (exclude === null) {
                excludePatternOrDisregardExcludes = false;
            }
            else if (exclude) {
                if (typeof exclude === 'string') {
                    excludePatternOrDisregardExcludes = exclude;
                }
                else {
                    excludePatternOrDisregardExcludes = exclude.pattern;
                }
            }
            if (token && token.isCancellationRequested) {
                return Promise.resolve([]);
            }
            return this._proxy.$startFileSearch(includePattern, includeFolder, excludePatternOrDisregardExcludes, maxResults, token)
                .then(function (data) { return Array.isArray(data) ? data.map(uri_1.URI.revive) : []; });
        };
        ExtHostWorkspace.prototype.findTextInFiles = function (query, options, callback, extensionId, token) {
            var _this = this;
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            this._logService.trace("extHostWorkspace#findTextInFiles: textSearch, extension: " + extensionId + ", entryPoint: findTextInFiles");
            var requestId = this._requestIdProvider.getNext();
            var globPatternToString = function (pattern) {
                if (typeof pattern === 'string') {
                    return pattern;
                }
                return path_1.join(pattern.base, pattern.pattern);
            };
            var previewOptions = typeof options.previewOptions === 'undefined' ?
                {
                    matchLines: 100,
                    charsPerLine: 10000
                } :
                options.previewOptions;
            var queryOptions = {
                ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,
                disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,
                disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,
                disregardExcludeSettings: options.exclude === null,
                fileEncoding: options.encoding,
                maxResults: options.maxResults,
                previewOptions: previewOptions,
                afterContext: options.afterContext,
                beforeContext: options.beforeContext,
                includePattern: options.include && globPatternToString(options.include),
                excludePattern: options.exclude && globPatternToString(options.exclude)
            };
            var isCanceled = false;
            this._activeSearchCallbacks[requestId] = function (p) {
                if (isCanceled) {
                    return;
                }
                var uri = uri_1.URI.revive(p.resource);
                p.results.forEach(function (result) {
                    if (search_1.resultIsMatch(result)) {
                        callback({
                            uri: uri,
                            preview: {
                                text: result.preview.text,
                                matches: arrays_1.mapArrayOrNot(result.preview.matches, function (m) { return new extHostTypes_1.Range(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn); })
                            },
                            ranges: arrays_1.mapArrayOrNot(result.ranges, function (r) { return new extHostTypes_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn); })
                        });
                    }
                    else {
                        callback({
                            uri: uri,
                            text: result.text,
                            lineNumber: result.lineNumber
                        });
                    }
                });
            };
            if (token.isCancellationRequested) {
                return Promise.resolve(undefined);
            }
            return this._proxy.$startTextSearch(query, queryOptions, requestId, token).then(function (result) {
                delete _this._activeSearchCallbacks[requestId];
                return result;
            }, function (err) {
                delete _this._activeSearchCallbacks[requestId];
                return Promise.reject(err);
            });
        };
        ExtHostWorkspace.prototype.$handleTextSearchResult = function (result, requestId) {
            if (this._activeSearchCallbacks[requestId]) {
                this._activeSearchCallbacks[requestId](result);
            }
        };
        ExtHostWorkspace.prototype.saveAll = function (includeUntitled) {
            return this._proxy.$saveAll(includeUntitled);
        };
        ExtHostWorkspace.prototype.resolveProxy = function (url) {
            return this._proxy.$resolveProxy(url);
        };
        return ExtHostWorkspace;
    }());
    exports.ExtHostWorkspace = ExtHostWorkspace;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[173/*vs/workbench/services/extensions/node/rpcProtocol*/], __M([1/*require*/,0/*exports*/,11/*vs/base/common/async*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/,3/*vs/base/common/event*/,8/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,20/*vs/base/common/winjs.base*/,143/*vs/workbench/services/extensions/node/lazyPromise*/,71/*vs/workbench/services/extensions/node/proxyIdentifier*/]), function (require, exports, async_1, cancellation_1, errors, event_1, lifecycle_1, uri_1, winjs_base_1, lazyPromise_1, proxyIdentifier_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _transformOutgoingURIs(obj, transformer, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj instanceof uri_1.URI) {
                return transformer.transformOutgoing(obj);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    var r = _transformOutgoingURIs(obj[key], transformer, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function transformOutgoingURIs(obj, transformer) {
        var result = _transformOutgoingURIs(obj, transformer, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    exports.transformOutgoingURIs = transformOutgoingURIs;
    function _transformIncomingURIs(obj, transformer, depth) {
        if (!obj || depth > 200) {
            return null;
        }
        if (typeof obj === 'object') {
            if (obj.$mid === 1) {
                return transformer.transformIncoming(obj);
            }
            // walk object (or array)
            for (var key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    var r = _transformIncomingURIs(obj[key], transformer, depth + 1);
                    if (r !== null) {
                        obj[key] = r;
                    }
                }
            }
        }
        return null;
    }
    function transformIncomingURIs(obj, transformer) {
        var result = _transformIncomingURIs(obj, transformer, 0);
        if (result === null) {
            // no change
            return obj;
        }
        return result;
    }
    var RequestInitiator;
    (function (RequestInitiator) {
        RequestInitiator[RequestInitiator["LocalSide"] = 0] = "LocalSide";
        RequestInitiator[RequestInitiator["OtherSide"] = 1] = "OtherSide";
    })(RequestInitiator = exports.RequestInitiator || (exports.RequestInitiator = {}));
    var ResponsiveState;
    (function (ResponsiveState) {
        ResponsiveState[ResponsiveState["Responsive"] = 0] = "Responsive";
        ResponsiveState[ResponsiveState["Unresponsive"] = 1] = "Unresponsive";
    })(ResponsiveState = exports.ResponsiveState || (exports.ResponsiveState = {}));
    var noop = function () { };
    var RPCProtocol = /** @class */ (function (_super) {
        __extends(RPCProtocol, _super);
        function RPCProtocol(protocol, logger, transformer) {
            if (logger === void 0) { logger = null; }
            if (transformer === void 0) { transformer = null; }
            var _this = _super.call(this) || this;
            _this._onDidChangeResponsiveState = _this._register(new event_1.Emitter());
            _this.onDidChangeResponsiveState = _this._onDidChangeResponsiveState.event;
            _this._protocol = protocol;
            _this._logger = logger;
            _this._uriTransformer = transformer;
            _this._isDisposed = false;
            _this._locals = [];
            _this._proxies = [];
            for (var i = 0, len = proxyIdentifier_1.ProxyIdentifier.count; i < len; i++) {
                _this._locals[i] = null;
                _this._proxies[i] = null;
            }
            _this._lastMessageId = 0;
            _this._cancelInvokedHandlers = Object.create(null);
            _this._pendingRPCReplies = {};
            _this._responsiveState = 0 /* Responsive */;
            _this._unacknowledgedCount = 0;
            _this._unresponsiveTime = 0;
            _this._asyncCheckUresponsive = _this._register(new async_1.RunOnceScheduler(function () { return _this._checkUnresponsive(); }, 1000));
            _this._protocol.onMessage(function (msg) { return _this._receiveOneMessage(msg); });
            return _this;
        }
        RPCProtocol.prototype.dispose = function () {
            var _this = this;
            this._isDisposed = true;
            // Release all outstanding promises with a canceled error
            Object.keys(this._pendingRPCReplies).forEach(function (msgId) {
                var pending = _this._pendingRPCReplies[msgId];
                pending.resolveErr(errors.canceled());
            });
        };
        RPCProtocol.prototype._onWillSendRequest = function (req) {
            if (this._unacknowledgedCount === 0) {
                // Since this is the first request we are sending in a while,
                // mark this moment as the start for the countdown to unresponsive time
                this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
            }
            this._unacknowledgedCount++;
            if (!this._asyncCheckUresponsive.isScheduled()) {
                this._asyncCheckUresponsive.schedule();
            }
        };
        RPCProtocol.prototype._onDidReceiveAcknowledge = function (req) {
            // The next possible unresponsive time is now + delta.
            this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
            this._unacknowledgedCount--;
            if (this._unacknowledgedCount === 0) {
                // No more need to check for unresponsive
                this._asyncCheckUresponsive.cancel();
            }
            // The ext host is responsive!
            this._setResponsiveState(0 /* Responsive */);
        };
        RPCProtocol.prototype._checkUnresponsive = function () {
            if (this._unacknowledgedCount === 0) {
                // Not waiting for anything => cannot say if it is responsive or not
                return;
            }
            if (Date.now() > this._unresponsiveTime) {
                // Unresponsive!!
                this._setResponsiveState(1 /* Unresponsive */);
            }
            else {
                // Not (yet) unresponsive, be sure to check again soon
                this._asyncCheckUresponsive.schedule();
            }
        };
        RPCProtocol.prototype._setResponsiveState = function (newResponsiveState) {
            if (this._responsiveState === newResponsiveState) {
                // no change
                return;
            }
            this._responsiveState = newResponsiveState;
            this._onDidChangeResponsiveState.fire(this._responsiveState);
        };
        Object.defineProperty(RPCProtocol.prototype, "responsiveState", {
            get: function () {
                return this._responsiveState;
            },
            enumerable: true,
            configurable: true
        });
        RPCProtocol.prototype.transformIncomingURIs = function (obj) {
            if (!this._uriTransformer) {
                return obj;
            }
            return transformIncomingURIs(obj, this._uriTransformer);
        };
        RPCProtocol.prototype.getProxy = function (identifier) {
            var rpcId = identifier.nid;
            if (!this._proxies[rpcId]) {
                this._proxies[rpcId] = this._createProxy(rpcId);
            }
            return this._proxies[rpcId];
        };
        RPCProtocol.prototype._createProxy = function (rpcId) {
            var _this = this;
            var handler = {
                get: function (target, name) {
                    if (!target[name] && name.charCodeAt(0) === 36 /* DollarSign */) {
                        target[name] = function () {
                            var myArgs = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                myArgs[_i] = arguments[_i];
                            }
                            return _this._remoteCall(rpcId, name, myArgs);
                        };
                    }
                    return target[name];
                }
            };
            return new Proxy(Object.create(null), handler);
        };
        RPCProtocol.prototype.set = function (identifier, value) {
            this._locals[identifier.nid] = value;
            return value;
        };
        RPCProtocol.prototype.assertRegistered = function (identifiers) {
            for (var i = 0, len = identifiers.length; i < len; i++) {
                var identifier = identifiers[i];
                if (!this._locals[identifier.nid]) {
                    throw new Error("Missing actor " + identifier.sid + " (isMain: " + identifier.isMain + ")");
                }
            }
        };
        RPCProtocol.prototype._receiveOneMessage = function (rawmsg) {
            if (this._isDisposed) {
                return;
            }
            var msgLength = rawmsg.length;
            var buff = MessageBuffer.read(rawmsg, 0);
            var messageType = buff.readUInt8();
            var req = buff.readUInt32();
            switch (messageType) {
                case 1 /* RequestJSONArgs */:
                case 2 /* RequestJSONArgsWithCancellation */: {
                    var _a = MessageIO.deserializeRequestJSONArgs(buff), rpcId = _a.rpcId, method = _a.method, args = _a.args;
                    if (this._uriTransformer) {
                        args = transformIncomingURIs(args, this._uriTransformer);
                    }
                    this._receiveRequest(msgLength, req, rpcId, method, args, (messageType === 2 /* RequestJSONArgsWithCancellation */));
                    break;
                }
                case 3 /* RequestMixedArgs */:
                case 4 /* RequestMixedArgsWithCancellation */: {
                    var _b = MessageIO.deserializeRequestMixedArgs(buff), rpcId = _b.rpcId, method = _b.method, args = _b.args;
                    if (this._uriTransformer) {
                        args = transformIncomingURIs(args, this._uriTransformer);
                    }
                    this._receiveRequest(msgLength, req, rpcId, method, args, (messageType === 4 /* RequestMixedArgsWithCancellation */));
                    break;
                }
                case 5 /* Acknowledged */: {
                    if (this._logger) {
                        this._logger.logIncoming(msgLength, req, 0 /* LocalSide */, "ack");
                    }
                    this._onDidReceiveAcknowledge(req);
                    break;
                }
                case 6 /* Cancel */: {
                    this._receiveCancel(msgLength, req);
                    break;
                }
                case 7 /* ReplyOKEmpty */: {
                    this._receiveReply(msgLength, req, undefined);
                    break;
                }
                case 9 /* ReplyOKJSON */: {
                    var value = MessageIO.deserializeReplyOKJSON(buff);
                    if (this._uriTransformer) {
                        value = transformIncomingURIs(value, this._uriTransformer);
                    }
                    this._receiveReply(msgLength, req, value);
                    break;
                }
                case 8 /* ReplyOKBuffer */: {
                    var value = MessageIO.deserializeReplyOKBuffer(buff);
                    this._receiveReply(msgLength, req, value);
                    break;
                }
                case 10 /* ReplyErrError */: {
                    var err = MessageIO.deserializeReplyErrError(buff);
                    if (this._uriTransformer) {
                        err = transformIncomingURIs(err, this._uriTransformer);
                    }
                    this._receiveReplyErr(msgLength, req, err);
                    break;
                }
                case 11 /* ReplyErrEmpty */: {
                    this._receiveReplyErr(msgLength, req, undefined);
                    break;
                }
            }
        };
        RPCProtocol.prototype._receiveRequest = function (msgLength, req, rpcId, method, args, usesCancellationToken) {
            var _this = this;
            if (this._logger) {
                this._logger.logIncoming(msgLength, req, 1 /* OtherSide */, "receiveRequest " + proxyIdentifier_1.getStringIdentifierForProxy(rpcId) + "." + method + "(", args);
            }
            var callId = String(req);
            var promise;
            var cancel;
            if (usesCancellationToken) {
                var cancellationTokenSource_1 = new cancellation_1.CancellationTokenSource();
                args.push(cancellationTokenSource_1.token);
                promise = this._invokeHandler(rpcId, method, args);
                cancel = function () { return cancellationTokenSource_1.cancel(); };
            }
            else {
                // cannot be cancelled
                promise = this._invokeHandler(rpcId, method, args);
                cancel = noop;
            }
            this._cancelInvokedHandlers[callId] = cancel;
            // Acknowledge the request
            var msg = MessageIO.serializeAcknowledged(req);
            if (this._logger) {
                this._logger.logOutgoing(msg.byteLength, req, 1 /* OtherSide */, "ack");
            }
            this._protocol.send(msg);
            promise.then(function (r) {
                delete _this._cancelInvokedHandlers[callId];
                if (_this._uriTransformer) {
                    r = transformOutgoingURIs(r, _this._uriTransformer);
                }
                var msg = MessageIO.serializeReplyOK(req, r);
                if (_this._logger) {
                    _this._logger.logOutgoing(msg.byteLength, req, 1 /* OtherSide */, "reply:", r);
                }
                _this._protocol.send(msg);
            }, function (err) {
                delete _this._cancelInvokedHandlers[callId];
                var msg = MessageIO.serializeReplyErr(req, err);
                if (_this._logger) {
                    _this._logger.logOutgoing(msg.byteLength, req, 1 /* OtherSide */, "replyErr:", err);
                }
                _this._protocol.send(msg);
            });
        };
        RPCProtocol.prototype._receiveCancel = function (msgLength, req) {
            if (this._logger) {
                this._logger.logIncoming(msgLength, req, 1 /* OtherSide */, "receiveCancel");
            }
            var callId = String(req);
            if (this._cancelInvokedHandlers[callId]) {
                this._cancelInvokedHandlers[callId]();
            }
        };
        RPCProtocol.prototype._receiveReply = function (msgLength, req, value) {
            if (this._logger) {
                this._logger.logIncoming(msgLength, req, 0 /* LocalSide */, "receiveReply:", value);
            }
            var callId = String(req);
            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
                return;
            }
            var pendingReply = this._pendingRPCReplies[callId];
            delete this._pendingRPCReplies[callId];
            pendingReply.resolveOk(value);
        };
        RPCProtocol.prototype._receiveReplyErr = function (msgLength, req, value) {
            if (this._logger) {
                this._logger.logIncoming(msgLength, req, 0 /* LocalSide */, "receiveReplyErr:", value);
            }
            var callId = String(req);
            if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
                return;
            }
            var pendingReply = this._pendingRPCReplies[callId];
            delete this._pendingRPCReplies[callId];
            var err = null;
            if (value && value.$isError) {
                err = new Error();
                err.name = value.name;
                err.message = value.message;
                err.stack = value.stack;
            }
            pendingReply.resolveErr(err);
        };
        RPCProtocol.prototype._invokeHandler = function (rpcId, methodName, args) {
            try {
                return winjs_base_1.TPromise.as(this._doInvokeHandler(rpcId, methodName, args));
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        RPCProtocol.prototype._doInvokeHandler = function (rpcId, methodName, args) {
            var actor = this._locals[rpcId];
            if (!actor) {
                throw new Error('Unknown actor ' + proxyIdentifier_1.getStringIdentifierForProxy(rpcId));
            }
            var method = actor[methodName];
            if (typeof method !== 'function') {
                throw new Error('Unknown method ' + methodName + ' on actor ' + proxyIdentifier_1.getStringIdentifierForProxy(rpcId));
            }
            return method.apply(actor, args);
        };
        RPCProtocol.prototype._remoteCall = function (rpcId, methodName, args) {
            var _this = this;
            if (this._isDisposed) {
                return winjs_base_1.TPromise.wrapError(errors.canceled());
            }
            var cancellationToken = null;
            if (args.length > 0 && cancellation_1.CancellationToken.isCancellationToken(args[args.length - 1])) {
                cancellationToken = args.pop();
            }
            if (cancellationToken && cancellationToken.isCancellationRequested) {
                // No need to do anything...
                return winjs_base_1.TPromise.wrapError(errors.canceled());
            }
            var req = ++this._lastMessageId;
            var callId = String(req);
            var result = new lazyPromise_1.LazyPromise();
            if (cancellationToken) {
                cancellationToken.onCancellationRequested(function () {
                    var msg = MessageIO.serializeCancel(req);
                    if (_this._logger) {
                        _this._logger.logOutgoing(msg.byteLength, req, 0 /* LocalSide */, "cancel");
                    }
                    _this._protocol.send(MessageIO.serializeCancel(req));
                });
            }
            this._pendingRPCReplies[callId] = result;
            this._onWillSendRequest(req);
            if (this._uriTransformer) {
                args = transformOutgoingURIs(args, this._uriTransformer);
            }
            var msg = MessageIO.serializeRequest(req, rpcId, methodName, args, !!cancellationToken);
            if (this._logger) {
                this._logger.logOutgoing(msg.byteLength, req, 0 /* LocalSide */, "request: " + proxyIdentifier_1.getStringIdentifierForProxy(rpcId) + "." + methodName + "(", args);
            }
            this._protocol.send(msg);
            return result;
        };
        RPCProtocol.UNRESPONSIVE_TIME = 10 * 1000; // 10s
        return RPCProtocol;
    }(lifecycle_1.Disposable));
    exports.RPCProtocol = RPCProtocol;
    var MessageBuffer = /** @class */ (function () {
        function MessageBuffer(buff, offset) {
            this._buff = buff;
            this._offset = offset;
        }
        MessageBuffer.alloc = function (type, req, messageSize) {
            var result = new MessageBuffer(Buffer.allocUnsafe(messageSize + 1 /* type */ + 4 /* req */), 0);
            result.writeUInt8(type);
            result.writeUInt32(req);
            return result;
        };
        MessageBuffer.read = function (buff, offset) {
            return new MessageBuffer(buff, offset);
        };
        Object.defineProperty(MessageBuffer.prototype, "buffer", {
            get: function () {
                return this._buff;
            },
            enumerable: true,
            configurable: true
        });
        MessageBuffer.sizeUInt8 = function () {
            return 1;
        };
        MessageBuffer.prototype.writeUInt8 = function (n) {
            this._buff.writeUInt8(n, this._offset, true);
            this._offset += 1;
        };
        MessageBuffer.prototype.readUInt8 = function () {
            var n = this._buff.readUInt8(this._offset, true);
            this._offset += 1;
            return n;
        };
        MessageBuffer.prototype.writeUInt32 = function (n) {
            this._buff.writeUInt32BE(n, this._offset, true);
            this._offset += 4;
        };
        MessageBuffer.prototype.readUInt32 = function () {
            var n = this._buff.readUInt32BE(this._offset, true);
            this._offset += 4;
            return n;
        };
        MessageBuffer.sizeShortString = function (str, strByteLength) {
            return 1 /* string length */ + strByteLength /* actual string */;
        };
        MessageBuffer.prototype.writeShortString = function (str, strByteLength) {
            this._buff.writeUInt8(strByteLength, this._offset, true);
            this._offset += 1;
            this._buff.write(str, this._offset, strByteLength, 'utf8');
            this._offset += strByteLength;
        };
        MessageBuffer.prototype.readShortString = function () {
            var strLength = this._buff.readUInt8(this._offset, true);
            this._offset += 1;
            var str = this._buff.toString('utf8', this._offset, this._offset + strLength);
            this._offset += strLength;
            return str;
        };
        MessageBuffer.sizeLongString = function (str, strByteLength) {
            return 4 /* string length */ + strByteLength /* actual string */;
        };
        MessageBuffer.prototype.writeLongString = function (str, strByteLength) {
            this._buff.writeUInt32LE(strByteLength, this._offset, true);
            this._offset += 4;
            this._buff.write(str, this._offset, strByteLength, 'utf8');
            this._offset += strByteLength;
        };
        MessageBuffer.prototype.readLongString = function () {
            var strLength = this._buff.readUInt32LE(this._offset, true);
            this._offset += 4;
            var str = this._buff.toString('utf8', this._offset, this._offset + strLength);
            this._offset += strLength;
            return str;
        };
        MessageBuffer.sizeBuffer = function (buff, buffByteLength) {
            return 4 /* buffer length */ + buffByteLength /* actual buffer */;
        };
        MessageBuffer.prototype.writeBuffer = function (buff, buffByteLength) {
            this._buff.writeUInt32LE(buffByteLength, this._offset, true);
            this._offset += 4;
            buff.copy(this._buff, this._offset);
            this._offset += buffByteLength;
        };
        MessageBuffer.prototype.readBuffer = function () {
            var buffLength = this._buff.readUInt32LE(this._offset, true);
            this._offset += 4;
            var buff = this._buff.slice(this._offset, this._offset + buffLength);
            this._offset += buffLength;
            return buff;
        };
        MessageBuffer.sizeMixedArray = function (arr, arrLengths) {
            var size = 0;
            size += 1; // arr length
            for (var i = 0, len = arr.length; i < len; i++) {
                var el = arr[i];
                var elLength = arrLengths[i];
                size += 1; // arg type
                if (typeof el === 'string') {
                    size += this.sizeLongString(el, elLength);
                }
                else {
                    size += this.sizeBuffer(el, elLength);
                }
            }
            return size;
        };
        MessageBuffer.prototype.writeMixedArray = function (arr, arrLengths) {
            this._buff.writeUInt8(arr.length, this._offset, true);
            this._offset += 1;
            for (var i = 0, len = arr.length; i < len; i++) {
                var el = arr[i];
                var elLength = arrLengths[i];
                if (typeof el === 'string') {
                    this.writeUInt8(1 /* String */);
                    this.writeLongString(el, elLength);
                }
                else {
                    this.writeUInt8(2 /* Buffer */);
                    this.writeBuffer(el, elLength);
                }
            }
        };
        MessageBuffer.prototype.readMixedArray = function () {
            var arrLen = this._buff.readUInt8(this._offset, true);
            this._offset += 1;
            var arr = new Array(arrLen);
            for (var i = 0; i < arrLen; i++) {
                var argType = this.readUInt8();
                if (argType === 1 /* String */) {
                    arr[i] = this.readLongString();
                }
                else {
                    arr[i] = this.readBuffer();
                }
            }
            return arr;
        };
        return MessageBuffer;
    }());
    var MessageIO = /** @class */ (function () {
        function MessageIO() {
        }
        MessageIO._arrayContainsBuffer = function (arr) {
            for (var i = 0, len = arr.length; i < len; i++) {
                if (Buffer.isBuffer(arr[i])) {
                    return true;
                }
            }
            return false;
        };
        MessageIO.serializeRequest = function (req, rpcId, method, args, usesCancellationToken) {
            if (this._arrayContainsBuffer(args)) {
                var massagedArgs = new Array(args.length);
                var argsLengths = new Array(args.length);
                for (var i = 0, len = args.length; i < len; i++) {
                    var arg = args[i];
                    if (Buffer.isBuffer(arg)) {
                        massagedArgs[i] = arg;
                        argsLengths[i] = arg.byteLength;
                    }
                    else {
                        massagedArgs[i] = safeStringify(arg);
                        argsLengths[i] = Buffer.byteLength(massagedArgs[i], 'utf8');
                    }
                }
                return this._requestMixedArgs(req, rpcId, method, massagedArgs, argsLengths, usesCancellationToken);
            }
            return this._requestJSONArgs(req, rpcId, method, safeStringify(args), usesCancellationToken);
        };
        MessageIO._requestJSONArgs = function (req, rpcId, method, args, usesCancellationToken) {
            var methodByteLength = Buffer.byteLength(method, 'utf8');
            var argsByteLength = Buffer.byteLength(args, 'utf8');
            var len = 0;
            len += MessageBuffer.sizeUInt8();
            len += MessageBuffer.sizeShortString(method, methodByteLength);
            len += MessageBuffer.sizeLongString(args, argsByteLength);
            var result = MessageBuffer.alloc(usesCancellationToken ? 2 /* RequestJSONArgsWithCancellation */ : 1 /* RequestJSONArgs */, req, len);
            result.writeUInt8(rpcId);
            result.writeShortString(method, methodByteLength);
            result.writeLongString(args, argsByteLength);
            return result.buffer;
        };
        MessageIO.deserializeRequestJSONArgs = function (buff) {
            var rpcId = buff.readUInt8();
            var method = buff.readShortString();
            var args = buff.readLongString();
            return {
                rpcId: rpcId,
                method: method,
                args: JSON.parse(args)
            };
        };
        MessageIO._requestMixedArgs = function (req, rpcId, method, args, argsLengths, usesCancellationToken) {
            var methodByteLength = Buffer.byteLength(method, 'utf8');
            var len = 0;
            len += MessageBuffer.sizeUInt8();
            len += MessageBuffer.sizeShortString(method, methodByteLength);
            len += MessageBuffer.sizeMixedArray(args, argsLengths);
            var result = MessageBuffer.alloc(usesCancellationToken ? 4 /* RequestMixedArgsWithCancellation */ : 3 /* RequestMixedArgs */, req, len);
            result.writeUInt8(rpcId);
            result.writeShortString(method, methodByteLength);
            result.writeMixedArray(args, argsLengths);
            return result.buffer;
        };
        MessageIO.deserializeRequestMixedArgs = function (buff) {
            var rpcId = buff.readUInt8();
            var method = buff.readShortString();
            var rawargs = buff.readMixedArray();
            var args = new Array(rawargs.length);
            for (var i = 0, len = rawargs.length; i < len; i++) {
                var rawarg = rawargs[i];
                if (typeof rawarg === 'string') {
                    args[i] = JSON.parse(rawarg);
                }
                else {
                    args[i] = rawarg;
                }
            }
            return {
                rpcId: rpcId,
                method: method,
                args: args
            };
        };
        MessageIO.serializeAcknowledged = function (req) {
            return MessageBuffer.alloc(5 /* Acknowledged */, req, 0).buffer;
        };
        MessageIO.serializeCancel = function (req) {
            return MessageBuffer.alloc(6 /* Cancel */, req, 0).buffer;
        };
        MessageIO.serializeReplyOK = function (req, res) {
            if (typeof res === 'undefined') {
                return this._serializeReplyOKEmpty(req);
            }
            if (Buffer.isBuffer(res)) {
                return this._serializeReplyOKBuffer(req, res);
            }
            return this._serializeReplyOKJSON(req, safeStringify(res));
        };
        MessageIO._serializeReplyOKEmpty = function (req) {
            return MessageBuffer.alloc(7 /* ReplyOKEmpty */, req, 0).buffer;
        };
        MessageIO._serializeReplyOKBuffer = function (req, res) {
            var resByteLength = res.byteLength;
            var len = 0;
            len += MessageBuffer.sizeBuffer(res, resByteLength);
            var result = MessageBuffer.alloc(8 /* ReplyOKBuffer */, req, len);
            result.writeBuffer(res, resByteLength);
            return result.buffer;
        };
        MessageIO.deserializeReplyOKBuffer = function (buff) {
            return buff.readBuffer();
        };
        MessageIO._serializeReplyOKJSON = function (req, res) {
            var resByteLength = Buffer.byteLength(res, 'utf8');
            var len = 0;
            len += MessageBuffer.sizeLongString(res, resByteLength);
            var result = MessageBuffer.alloc(9 /* ReplyOKJSON */, req, len);
            result.writeLongString(res, resByteLength);
            return result.buffer;
        };
        MessageIO.deserializeReplyOKJSON = function (buff) {
            var res = buff.readLongString();
            return JSON.parse(res);
        };
        MessageIO.serializeReplyErr = function (req, err) {
            if (err instanceof Error) {
                return this._serializeReplyErrEror(req, err);
            }
            return this._serializeReplyErrEmpty(req);
        };
        MessageIO._serializeReplyErrEror = function (req, _err) {
            var err = safeStringify(errors.transformErrorForSerialization(_err));
            var errByteLength = Buffer.byteLength(err, 'utf8');
            var len = 0;
            len += MessageBuffer.sizeLongString(err, errByteLength);
            var result = MessageBuffer.alloc(10 /* ReplyErrError */, req, len);
            result.writeLongString(err, errByteLength);
            return result.buffer;
        };
        MessageIO.deserializeReplyErrError = function (buff) {
            var err = buff.readLongString();
            return JSON.parse(err);
        };
        MessageIO._serializeReplyErrEmpty = function (req) {
            return MessageBuffer.alloc(11 /* ReplyErrEmpty */, req, 0).buffer;
        };
        return MessageIO;
    }());
    function safeStringify(obj) {
        try {
            return JSON.stringify(obj);
        }
        catch (err) {
            return 'null';
        }
    }
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["RequestJSONArgs"] = 1] = "RequestJSONArgs";
        MessageType[MessageType["RequestJSONArgsWithCancellation"] = 2] = "RequestJSONArgsWithCancellation";
        MessageType[MessageType["RequestMixedArgs"] = 3] = "RequestMixedArgs";
        MessageType[MessageType["RequestMixedArgsWithCancellation"] = 4] = "RequestMixedArgsWithCancellation";
        MessageType[MessageType["Acknowledged"] = 5] = "Acknowledged";
        MessageType[MessageType["Cancel"] = 6] = "Cancel";
        MessageType[MessageType["ReplyOKEmpty"] = 7] = "ReplyOKEmpty";
        MessageType[MessageType["ReplyOKBuffer"] = 8] = "ReplyOKBuffer";
        MessageType[MessageType["ReplyOKJSON"] = 9] = "ReplyOKJSON";
        MessageType[MessageType["ReplyErrError"] = 10] = "ReplyErrError";
        MessageType[MessageType["ReplyErrEmpty"] = 11] = "ReplyErrEmpty";
    })(MessageType || (MessageType = {}));
    var ArgType;
    (function (ArgType) {
        ArgType[ArgType["String"] = 1] = "String";
        ArgType[ArgType["Buffer"] = 2] = "Buffer";
    })(ArgType || (ArgType = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[174/*vs/workbench/services/search/node/legacy/textSearch*/], __M([1/*require*/,0/*exports*/,10/*path*/,14/*vs/base/common/errors*/]), function (require, exports, path, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Engine = /** @class */ (function () {
        function Engine(config, walker, workerProvider) {
            this.isCanceled = false;
            this.isDone = false;
            this.totalBytes = 0;
            this.processedBytes = 0;
            this.progressed = 0;
            this.walkerIsDone = false;
            this.limitReached = false;
            this.numResults = 0;
            this.nextWorker = 0;
            this.config = makeRawSearch(config);
            this.config2 = config;
            this.walker = walker;
            this.workerProvider = workerProvider;
        }
        Engine.prototype.cancel = function () {
            this.isCanceled = true;
            this.walker.cancel();
            this.workers.forEach(function (w) {
                w.cancel()
                    .then(null, errors_1.onUnexpectedError);
            });
        };
        Engine.prototype.initializeWorkers = function () {
            this.workers.forEach(function (w) {
                w.initialize()
                    .then(null, errors_1.onUnexpectedError);
            });
        };
        Engine.prototype.search = function (onResult, onProgress, done) {
            var _this = this;
            this.workers = this.workerProvider.getWorkers();
            this.initializeWorkers();
            var fileEncoding = this.config.folderQueries.length === 1 ?
                this.config.folderQueries[0].fileEncoding || 'utf8' :
                'utf8';
            var progress = function () {
                if (++_this.progressed % Engine.PROGRESS_FLUSH_CHUNK_SIZE === 0) {
                    onProgress({ total: _this.totalBytes, worked: _this.processedBytes }); // buffer progress in chunks to reduce pressure
                }
            };
            var unwind = function (processed) {
                _this.processedBytes += processed;
                // Emit progress() unless we got canceled or hit the limit
                if (processed && !_this.isDone && !_this.isCanceled && !_this.limitReached) {
                    progress();
                }
                // Emit done()
                if (!_this.isDone && _this.processedBytes === _this.totalBytes && _this.walkerIsDone) {
                    _this.isDone = true;
                    done(_this.walkerError, {
                        limitHit: _this.limitReached,
                        stats: _this.walker.getStats()
                    });
                }
            };
            var run = function (batch, batchBytes) {
                var worker = _this.workers[_this.nextWorker];
                _this.nextWorker = (_this.nextWorker + 1) % _this.workers.length;
                var maxResults = _this.config.maxResults && (_this.config.maxResults - _this.numResults);
                var searchArgs = { absolutePaths: batch, maxResults: maxResults, pattern: _this.config.contentPattern, fileEncoding: fileEncoding, previewOptions: _this.config.previewOptions };
                worker.search(searchArgs).then(function (result) {
                    if (!result || _this.limitReached || _this.isCanceled) {
                        return unwind(batchBytes);
                    }
                    var matches = result.matches;
                    onResult(matches);
                    _this.numResults += result.numMatches;
                    if (_this.config.maxResults && _this.numResults >= _this.config.maxResults) {
                        // It's possible to go over maxResults like this, but it's much simpler than trying to extract the exact number
                        // of file matches, line matches, and matches within a line to == maxResults.
                        _this.limitReached = true;
                    }
                    unwind(batchBytes);
                }, function (error) {
                    // An error on the worker's end, not in reading the file, but in processing the batch. Log and continue.
                    errors_1.onUnexpectedError(error);
                    unwind(batchBytes);
                });
            };
            // Walk over the file system
            var nextBatch = [];
            var nextBatchBytes = 0;
            var batchFlushBytes = Math.pow(2, 20); // 1MB
            this.walker.walk(this.config2.folderQueries, this.config2.extraFileResources, function (result) {
                var bytes = result.size || 1;
                _this.totalBytes += bytes;
                // If we have reached the limit or we are canceled, ignore it
                if (_this.limitReached || _this.isCanceled) {
                    return unwind(bytes);
                }
                // Indicate progress to the outside
                progress();
                var absolutePath = result.base ? [result.base, result.relativePath].join(path.sep) : result.relativePath;
                nextBatch.push(absolutePath);
                nextBatchBytes += bytes;
                if (nextBatchBytes >= batchFlushBytes) {
                    run(nextBatch, nextBatchBytes);
                    nextBatch = [];
                    nextBatchBytes = 0;
                }
            }, onProgress, function (error, isLimitHit) {
                _this.walkerIsDone = true;
                _this.walkerError = error;
                // Send any remaining paths to a worker, or unwind if we're stopping
                if (nextBatch.length) {
                    if (_this.limitReached || _this.isCanceled) {
                        unwind(nextBatchBytes);
                    }
                    else {
                        run(nextBatch, nextBatchBytes);
                    }
                }
                else {
                    unwind(0);
                }
            });
        };
        Engine.PROGRESS_FLUSH_CHUNK_SIZE = 50; // optimization: number of files to process before emitting progress event
        return Engine;
    }());
    exports.Engine = Engine;
    /**
     * Exported for tests
     */
    function makeRawSearch(query) {
        var rawSearch = {
            folderQueries: [],
            extraFiles: [],
            excludePattern: query.excludePattern,
            includePattern: query.includePattern,
            maxResults: query.maxResults,
            useRipgrep: query.useRipgrep,
            disregardIgnoreFiles: query.folderQueries.some(function (fq) { return fq.disregardIgnoreFiles; }),
            disregardGlobalIgnoreFiles: query.folderQueries.some(function (fq) { return fq.disregardGlobalIgnoreFiles; }),
            ignoreSymlinks: query.folderQueries.some(function (fq) { return fq.ignoreSymlinks; }),
            previewOptions: query.previewOptions
        };
        for (var _i = 0, _a = query.folderQueries; _i < _a.length; _i++) {
            var q = _a[_i];
            rawSearch.folderQueries.push({
                excludePattern: q.excludePattern,
                includePattern: q.includePattern,
                fileEncoding: q.fileEncoding,
                disregardIgnoreFiles: q.disregardIgnoreFiles,
                disregardGlobalIgnoreFiles: q.disregardGlobalIgnoreFiles,
                folder: q.folder.fsPath
            });
        }
        if (query.extraFileResources) {
            for (var _b = 0, _c = query.extraFileResources; _b < _c.length; _b++) {
                var r = _c[_b];
                rawSearch.extraFiles.push(r.fsPath);
            }
        }
        rawSearch.contentPattern = query.contentPattern;
        return rawSearch;
    }
    exports.makeRawSearch = makeRawSearch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[175/*vs/workbench/services/search/node/legacy/worker/searchWorkerIpc*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SearchWorkerChannel = /** @class */ (function () {
        function SearchWorkerChannel(worker) {
            this.worker = worker;
        }
        SearchWorkerChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        SearchWorkerChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'initialize': return this.worker.initialize();
                case 'search': return this.worker.search(arg);
                case 'cancel': return this.worker.cancel();
            }
            return undefined;
        };
        return SearchWorkerChannel;
    }());
    exports.SearchWorkerChannel = SearchWorkerChannel;
    var SearchWorkerChannelClient = /** @class */ (function () {
        function SearchWorkerChannelClient(channel) {
            this.channel = channel;
        }
        SearchWorkerChannelClient.prototype.initialize = function () {
            return this.channel.call('initialize');
        };
        SearchWorkerChannelClient.prototype.search = function (args) {
            return this.channel.call('search', args);
        };
        SearchWorkerChannelClient.prototype.cancel = function () {
            return this.channel.call('cancel');
        };
        return SearchWorkerChannelClient;
    }());
    exports.SearchWorkerChannelClient = SearchWorkerChannelClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[176/*vs/workbench/services/search/node/legacy/textSearchWorkerProvider*/], __M([1/*require*/,0/*exports*/,30/*os*/,44/*vs/base/parts/ipc/node/ipc*/,178/*vs/base/parts/ipc/node/ipc.cp*/,175/*vs/workbench/services/search/node/legacy/worker/searchWorkerIpc*/,28/*vs/base/common/amd*/]), function (require, exports, os, ipc, ipc_cp_1, searchWorkerIpc_1, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextSearchWorkerProvider = /** @class */ (function () {
        function TextSearchWorkerProvider() {
            this.workers = [];
        }
        TextSearchWorkerProvider.prototype.getWorkers = function () {
            var numWorkers = os.cpus().length;
            while (this.workers.length < numWorkers) {
                this.createWorker();
            }
            return this.workers;
        };
        TextSearchWorkerProvider.prototype.createWorker = function () {
            var client = new ipc_cp_1.Client(amd_1.getPathFromAmdModule(require, 'bootstrap-fork'), {
                serverName: 'Search Worker ' + this.workers.length,
                args: ['--type=searchWorker'],
                timeout: 30 * 1000,
                env: {
                    AMD_ENTRYPOINT: 'vs/workbench/services/search/node/legacy/worker/searchWorkerApp',
                    PIPE_LOGGING: 'true',
                    VERBOSE_LOGGING: process.env.VERBOSE_LOGGING
                },
                useQueue: true
            });
            var channel = ipc.getNextTickChannel(client.getChannel('searchWorker'));
            var channelClient = new searchWorkerIpc_1.SearchWorkerChannelClient(channel);
            this.workers.push(channelClient);
        };
        return TextSearchWorkerProvider;
    }());
    exports.TextSearchWorkerProvider = TextSearchWorkerProvider;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[39/*vs/workbench/services/search/node/ripgrepSearchUtils*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/strings*/,33/*vs/platform/log/common/log*/,41/*vs/platform/search/common/search*/,9/*vs/base/common/arrays*/]), function (require, exports, strings_1, log_1, search_1, arrays_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function anchorGlob(glob) {
        return strings_1.startsWith(glob, '**') || strings_1.startsWith(glob, '/') ? glob : "/" + glob;
    }
    exports.anchorGlob = anchorGlob;
    /**
     * Create a vscode.TextSearchResult by using our internal TextSearchResult type for its previewOptions logic.
     */
    function createTextSearchResult(uri, text, range, previewOptions) {
        var searchRange = arrays_1.mapArrayOrNot(range, rangeToSearchRange);
        var internalResult = new search_1.TextSearchMatch(text, searchRange, previewOptions);
        var internalPreviewRange = internalResult.preview.matches;
        return {
            ranges: arrays_1.mapArrayOrNot(searchRange, searchRangeToRange),
            uri: uri,
            preview: {
                text: internalResult.preview.text,
                matches: arrays_1.mapArrayOrNot(internalPreviewRange, searchRangeToRange)
            }
        };
    }
    exports.createTextSearchResult = createTextSearchResult;
    function rangeToSearchRange(range) {
        return new search_1.SearchRange(range.start.line, range.start.character, range.end.line, range.end.character);
    }
    function searchRangeToRange(range) {
        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    }
    var Position = /** @class */ (function () {
        function Position(line, character) {
            this.line = line;
            this.character = character;
        }
        Position.prototype.isBefore = function (other) { return false; };
        Position.prototype.isBeforeOrEqual = function (other) { return false; };
        Position.prototype.isAfter = function (other) { return false; };
        Position.prototype.isAfterOrEqual = function (other) { return false; };
        Position.prototype.isEqual = function (other) { return false; };
        Position.prototype.compareTo = function (other) { return 0; };
        Position.prototype.translate = function (_) { return null; };
        Position.prototype.with = function (_) { return null; };
        return Position;
    }());
    exports.Position = Position;
    var Range = /** @class */ (function () {
        function Range(startLine, startCol, endLine, endCol) {
            this.start = new Position(startLine, startCol);
            this.end = new Position(endLine, endCol);
        }
        Range.prototype.contains = function (positionOrRange) { return false; };
        Range.prototype.isEqual = function (other) { return false; };
        Range.prototype.intersection = function (range) { return null; };
        Range.prototype.union = function (other) { return null; };
        Range.prototype.with = function (_) { return null; };
        return Range;
    }());
    exports.Range = Range;
    var OutputChannel = /** @class */ (function () {
        function OutputChannel(logService) {
            this.logService = logService;
        }
        OutputChannel.prototype.appendLine = function (msg) {
            this.logService.debug('RipgrepSearchEH#search', msg);
        };
        OutputChannel = __decorate([
            __param(0, log_1.ILogService)
        ], OutputChannel);
        return OutputChannel;
    }());
    exports.OutputChannel = OutputChannel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[32/*vs/workbench/services/search/node/search*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/glob*/,20/*vs/base/common/winjs.base*/]), function (require, exports, glob, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializedSearchComplete(arg) {
        if (arg.type === 'error') {
            return true;
        }
        else if (arg.type === 'success') {
            return true;
        }
        else {
            return false;
        }
    }
    exports.isSerializedSearchComplete = isSerializedSearchComplete;
    function isSerializedSearchSuccess(arg) {
        return arg.type === 'success';
    }
    exports.isSerializedSearchSuccess = isSerializedSearchSuccess;
    function isSerializedFileMatch(arg) {
        return !!arg.path;
    }
    exports.isSerializedFileMatch = isSerializedFileMatch;
    var FileMatch = /** @class */ (function () {
        function FileMatch(path) {
            this.path = path;
            this.results = [];
        }
        FileMatch.prototype.addMatch = function (match) {
            this.results.push(match);
        };
        FileMatch.prototype.serialize = function () {
            return {
                path: this.path,
                results: this.results,
                numMatches: this.results.length
            };
        };
        return FileMatch;
    }());
    exports.FileMatch = FileMatch;
    /**
     *  Computes the patterns that the provider handles. Discards sibling clauses and 'false' patterns
     */
    function resolvePatternsForProvider(globalPattern, folderPattern) {
        var merged = __assign({}, (globalPattern || {}), (folderPattern || {}));
        return Object.keys(merged)
            .filter(function (key) {
            var value = merged[key];
            return typeof value === 'boolean' && value;
        });
    }
    exports.resolvePatternsForProvider = resolvePatternsForProvider;
    var QueryGlobTester = /** @class */ (function () {
        function QueryGlobTester(config, folderQuery) {
            this._excludeExpression = __assign({}, (config.excludePattern || {}), (folderQuery.excludePattern || {}));
            this._parsedExcludeExpression = glob.parse(this._excludeExpression);
            // Empty includeExpression means include nothing, so no {} shortcuts
            var includeExpression = config.includePattern;
            if (folderQuery.includePattern) {
                if (includeExpression) {
                    includeExpression = __assign({}, includeExpression, folderQuery.includePattern);
                }
                else {
                    includeExpression = folderQuery.includePattern;
                }
            }
            if (includeExpression) {
                this._parsedIncludeExpression = glob.parse(includeExpression);
            }
        }
        /**
         * Guaranteed sync - siblingsFn should not return a promise.
         */
        QueryGlobTester.prototype.includedInQuerySync = function (testPath, basename, hasSibling) {
            if (this._parsedExcludeExpression && this._parsedExcludeExpression(testPath, basename, hasSibling)) {
                return false;
            }
            if (this._parsedIncludeExpression && !this._parsedIncludeExpression(testPath, basename, hasSibling)) {
                return false;
            }
            return true;
        };
        /**
         * Guaranteed async.
         */
        QueryGlobTester.prototype.includedInQuery = function (testPath, basename, hasSibling) {
            var _this = this;
            var excludeP = this._parsedExcludeExpression ?
                winjs_base_1.TPromise.as(this._parsedExcludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :
                winjs_base_1.TPromise.wrap(false);
            return excludeP.then(function (excluded) {
                if (excluded) {
                    return false;
                }
                return _this._parsedIncludeExpression ?
                    winjs_base_1.TPromise.as(_this._parsedIncludeExpression(testPath, basename, hasSibling)).then(function (result) { return !!result; }) :
                    winjs_base_1.TPromise.wrap(true);
            }).then(function (included) {
                return included;
            });
        };
        QueryGlobTester.prototype.hasSiblingExcludeClauses = function () {
            return hasSiblingClauses(this._excludeExpression);
        };
        return QueryGlobTester;
    }());
    exports.QueryGlobTester = QueryGlobTester;
    function hasSiblingClauses(pattern) {
        for (var key in pattern) {
            if (typeof pattern[key] !== 'boolean') {
                return true;
            }
        }
        return false;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[179/*vs/workbench/api/node/extHostSearch.fileIndex*/], __M([1/*require*/,0/*exports*/,10/*path*/,9/*vs/base/common/arrays*/,11/*vs/base/common/async*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/,23/*vs/base/common/glob*/,24/*vs/base/common/resources*/,36/*vs/base/common/stopwatch*/,5/*vs/base/common/strings*/,20/*vs/base/common/winjs.base*/,52/*vs/base/parts/quickopen/common/quickOpenScorer*/,32/*vs/workbench/services/search/node/search*/]), function (require, exports, path, arrays, async_1, cancellation_1, errors_1, glob, resources, stopwatch_1, strings, winjs_base_1, quickOpenScorer_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileIndexSearchEngine = /** @class */ (function () {
        function FileIndexSearchEngine(config, provider) {
            this.config = config;
            this.provider = provider;
            this.filesWalked = 0;
            this.dirsWalked = 0;
            this.filePattern = config.filePattern;
            this.includePattern = config.includePattern && glob.parse(config.includePattern);
            this.maxResults = config.maxResults || null;
            this.exists = config.exists;
            this.resultCount = 0;
            this.isLimitHit = false;
            this.activeCancellationTokens = new Set();
            if (this.filePattern) {
                this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();
            }
            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);
        }
        FileIndexSearchEngine.prototype.cancel = function () {
            this.isCanceled = true;
            this.activeCancellationTokens.forEach(function (t) { return t.cancel(); });
            this.activeCancellationTokens = new Set();
        };
        FileIndexSearchEngine.prototype.search = function (_onResult) {
            var _this = this;
            // Searches a single folder
            var folderQuery = this.config.folderQueries[0];
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var onResult = function (match) {
                    _this.resultCount++;
                    _onResult(match);
                };
                if (_this.isCanceled) {
                    throw errors_1.canceled();
                }
                // For each extra file
                if (_this.config.extraFileResources) {
                    _this.config.extraFileResources
                        .forEach(function (extraFile) {
                        var extraFileStr = extraFile.toString(); // ?
                        var basename = path.basename(extraFileStr);
                        if (_this.globalExcludePattern && _this.globalExcludePattern(extraFileStr, basename)) {
                            return; // excluded
                        }
                        // File: Check for match on file pattern and include pattern
                        _this.matchFile(onResult, { base: extraFile, basename: basename });
                    });
                }
                return Promise.all(_this.config.folderQueries.map(function (fq) { return _this.searchInFolder(folderQuery, onResult); })).then(function (stats) {
                    resolve({
                        isLimitHit: _this.isLimitHit,
                        stats: {
                            directoriesWalked: _this.dirsWalked,
                            filesWalked: _this.filesWalked,
                            fileWalkTime: stats.map(function (s) { return s.fileWalkTime; }).reduce(function (s, c) { return s + c; }, 0),
                            providerTime: stats.map(function (s) { return s.providerTime; }).reduce(function (s, c) { return s + c; }, 0),
                            providerResultCount: stats.map(function (s) { return s.providerResultCount; }).reduce(function (s, c) { return s + c; }, 0)
                        }
                    });
                }, function (errs) {
                    if (!Array.isArray(errs)) {
                        errs = [errs];
                    }
                    errs = errs.filter(function (e) { return !!e; });
                    return Promise.reject(errs[0]);
                });
            });
        };
        FileIndexSearchEngine.prototype.searchInFolder = function (fq, onResult) {
            var _this = this;
            var cancellation = new cancellation_1.CancellationTokenSource();
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var options = _this.getSearchOptionsForFolder(fq);
                var tree = _this.initDirectoryTree();
                var queryTester = new search_1.QueryGlobTester(_this.config, fq);
                var noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
                var onProviderResult = function (uri) {
                    if (_this.isCanceled) {
                        return;
                    }
                    // TODO@rob - ???
                    var relativePath = path.relative(fq.folder.path, uri.path);
                    if (noSiblingsClauses) {
                        var basename = path.basename(uri.path);
                        _this.matchFile(onResult, { base: fq.folder, relativePath: relativePath, basename: basename, original: uri });
                        return;
                    }
                    // TODO: Optimize siblings clauses with ripgrep here.
                    _this.addDirectoryEntries(tree, fq.folder, relativePath, onResult);
                };
                var providerSW;
                var providerTime;
                var fileWalkTime;
                new winjs_base_1.TPromise(function (resolve) { return process.nextTick(resolve); })
                    .then(function () {
                    _this.activeCancellationTokens.add(cancellation);
                    providerSW = stopwatch_1.StopWatch.create();
                    return _this.provider.provideFileIndex(options, cancellation.token);
                })
                    .then(function (results) {
                    providerTime = providerSW.elapsed();
                    var postProcessSW = stopwatch_1.StopWatch.create();
                    _this.activeCancellationTokens.delete(cancellation);
                    if (_this.isCanceled) {
                        return null;
                    }
                    results.forEach(onProviderResult);
                    _this.matchDirectoryTree(tree, queryTester, onResult);
                    fileWalkTime = postProcessSW.elapsed();
                    return null;
                }).then(function () {
                    cancellation.dispose();
                    resolve({
                        providerTime: providerTime,
                        fileWalkTime: fileWalkTime,
                        directoriesWalked: _this.dirsWalked,
                        filesWalked: _this.filesWalked
                    });
                }, function (err) {
                    cancellation.dispose();
                    reject(err);
                });
            });
        };
        FileIndexSearchEngine.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = search_1.resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
            var excludes = search_1.resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
            return {
                folder: fq.folder,
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !fq.disregardIgnoreFiles,
                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
                followSymlinks: !fq.ignoreSymlinks
            };
        };
        FileIndexSearchEngine.prototype.initDirectoryTree = function () {
            var tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        };
        FileIndexSearchEngine.prototype.addDirectoryEntries = function (_a, base, relativeFile, onResult) {
            var pathToEntries = _a.pathToEntries;
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFile === this.filePattern) {
                var basename = path.basename(this.filePattern);
                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
            }
            function add(relativePath) {
                var basename = path.basename(relativePath);
                var dirname = path.dirname(relativePath);
                var entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base: base,
                    relativePath: relativePath,
                    basename: basename
                });
            }
            add(relativeFile);
        };
        FileIndexSearchEngine.prototype.matchDirectoryTree = function (_a, queryTester, onResult) {
            var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
            var self = this;
            var filePattern = this.filePattern;
            function matchDirectory(entries) {
                self.dirsWalked++;
                for (var i = 0, n = entries.length; i < n; i++) {
                    var entry = entries[i];
                    var relativePath = entry.relativePath, basename = entry.basename;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what she
                    // is searching for and we want to include the result in that case anyway
                    var hasSibling = glob.hasSiblingFn(function () { return entries.map(function (entry) { return entry.basename; }); });
                    if (!queryTester.includedInQuerySync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    var sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        self.filesWalked++;
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.matchFile(onResult, entry);
                    }
                    if (self.isLimitHit) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        };
        FileIndexSearchEngine.prototype.matchFile = function (onResult, candidate) {
            if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {
                if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {
                    this.isLimitHit = true;
                    this.cancel();
                }
                if (!this.isLimitHit) {
                    onResult(candidate);
                }
            }
        };
        FileIndexSearchEngine.prototype.isFilePatternMatch = function (path) {
            // Check for search pattern
            if (this.filePattern) {
                if (this.filePattern === '*') {
                    return true; // support the all-matching wildcard
                }
                return strings.fuzzyContains(path, this.normalizedFilePatternLowercase);
            }
            // No patterns means we match all
            return true;
        };
        return FileIndexSearchEngine;
    }());
    exports.FileIndexSearchEngine = FileIndexSearchEngine;
    var FileIndexSearchManager = /** @class */ (function () {
        function FileIndexSearchManager() {
            this.caches = Object.create(null);
            this.folderCacheKeys = new Map();
        }
        FileIndexSearchManager.prototype.fileSearch = function (config, provider, onBatch, token) {
            var _this = this;
            if (config.sortByScore) {
                var sortedSearch = this.trySortedSearchFromCache(config, token);
                if (!sortedSearch) {
                    var engineConfig = config.maxResults ? __assign({}, config, { maxResults: null }) :
                        config;
                    var engine_1 = new FileIndexSearchEngine(engineConfig, provider);
                    sortedSearch = this.doSortedSearch(engine_1, config, token);
                }
                return sortedSearch.then(function (complete) {
                    _this.sendAsBatches(complete.results, onBatch, FileIndexSearchManager.BATCH_SIZE);
                    return complete;
                });
            }
            var engine = new FileIndexSearchEngine(config, provider);
            return this.doSearch(engine, token)
                .then(function (complete) {
                _this.sendAsBatches(complete.results, onBatch, FileIndexSearchManager.BATCH_SIZE);
                return {
                    limitHit: complete.limitHit,
                    stats: {
                        type: 'fileIndexProvider',
                        detailStats: complete.stats,
                        fromCache: false,
                        resultCount: complete.results.length
                    }
                };
            });
        };
        FileIndexSearchManager.prototype.getFolderCacheKey = function (config) {
            var uri = config.folderQueries[0].folder.toString();
            var folderCacheKey = config.cacheKey && uri + "_" + config.cacheKey;
            if (!this.folderCacheKeys.get(config.cacheKey)) {
                this.folderCacheKeys.set(config.cacheKey, new Set());
            }
            this.folderCacheKeys.get(config.cacheKey).add(folderCacheKey);
            return folderCacheKey;
        };
        FileIndexSearchManager.prototype.rawMatchToSearchItem = function (match) {
            return {
                resource: match.original || resources.joinPath(match.base, match.relativePath)
            };
        };
        FileIndexSearchManager.prototype.doSortedSearch = function (engine, config, token) {
            var _this = this;
            var allResultsPromise = async_1.createCancelablePromise(function (token) {
                return _this.doSearch(engine, token);
            });
            var folderCacheKey = this.getFolderCacheKey(config);
            var cache;
            if (folderCacheKey) {
                cache = this.getOrCreateCache(folderCacheKey);
                var cacheRow_1 = {
                    promise: allResultsPromise,
                    resolved: false
                };
                cache.resultsToSearchCache[config.filePattern] = cacheRow_1;
                allResultsPromise.then(function () {
                    cacheRow_1.resolved = true;
                }, function (err) {
                    delete cache.resultsToSearchCache[config.filePattern];
                });
                allResultsPromise = this.preventCancellation(allResultsPromise);
            }
            return Promise.resolve(allResultsPromise.then(function (complete) {
                var scorerCache = cache ? cache.scorerCache : Object.create(null);
                var sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && stopwatch_1.StopWatch.create();
                return _this.sortResults(config, complete.results, scorerCache, token)
                    .then(function (sortedResults) {
                    // sortingTime: -1 indicates a "sorted" search that was not sorted, i.e. populating the cache when quickopen is opened.
                    // Contrasting with findFiles which is not sorted and will have sortingTime: undefined
                    var sortingTime = sortSW ? sortSW.elapsed() : -1;
                    return {
                        limitHit: complete.limitHit || typeof config.maxResults === 'number' && complete.results.length > config.maxResults,
                        results: sortedResults,
                        stats: {
                            detailStats: complete.stats,
                            fromCache: false,
                            resultCount: sortedResults.length,
                            sortingTime: sortingTime,
                            type: 'fileIndexProvider'
                        }
                    };
                });
            }));
        };
        FileIndexSearchManager.prototype.getOrCreateCache = function (cacheKey) {
            var existing = this.caches[cacheKey];
            if (existing) {
                return existing;
            }
            return this.caches[cacheKey] = new Cache();
        };
        FileIndexSearchManager.prototype.trySortedSearchFromCache = function (config, token) {
            var _this = this;
            var folderCacheKey = this.getFolderCacheKey(config);
            var cache = folderCacheKey && this.caches[folderCacheKey];
            if (!cache) {
                return undefined;
            }
            var cached = this.getResultsFromCache(cache, config.filePattern, token);
            if (cached) {
                return cached.then(function (complete) {
                    var sortSW = stopwatch_1.StopWatch.create();
                    return _this.sortResults(config, complete.results, cache.scorerCache, token)
                        .then(function (sortedResults) {
                        if (token && token.isCancellationRequested) {
                            throw errors_1.canceled();
                        }
                        return {
                            limitHit: complete.limitHit || typeof config.maxResults === 'number' && complete.results.length > config.maxResults,
                            results: sortedResults,
                            stats: {
                                fromCache: true,
                                detailStats: complete.stats,
                                type: 'fileIndexProvider',
                                resultCount: sortedResults.length,
                                sortingTime: sortSW.elapsed()
                            }
                        };
                    });
                });
            }
            return undefined;
        };
        FileIndexSearchManager.prototype.sortResults = function (config, results, scorerCache, token) {
            // we use the same compare function that is used later when showing the results using fuzzy scoring
            // this is very important because we are also limiting the number of results by config.maxResults
            // and as such we want the top items to be included in this result set if the number of items
            // exceeds config.maxResults.
            var query = quickOpenScorer_1.prepareQuery(config.filePattern);
            var compare = function (matchA, matchB) { return quickOpenScorer_1.compareItemsByScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache); };
            return arrays.topAsync(results, compare, config.maxResults, 10000, token);
        };
        FileIndexSearchManager.prototype.sendAsBatches = function (rawMatches, onBatch, batchSize) {
            var _this = this;
            var serializedMatches = rawMatches.map(function (rawMatch) { return _this.rawMatchToSearchItem(rawMatch); });
            if (batchSize && batchSize > 0) {
                for (var i = 0; i < serializedMatches.length; i += batchSize) {
                    onBatch(serializedMatches.slice(i, i + batchSize));
                }
            }
            else {
                onBatch(serializedMatches);
            }
        };
        FileIndexSearchManager.prototype.getResultsFromCache = function (cache, searchValue, token) {
            var cacheLookupSW = stopwatch_1.StopWatch.create();
            if (path.isAbsolute(searchValue)) {
                return null; // bypass cache if user looks up an absolute path where matching goes directly on disk
            }
            // Find cache entries by prefix of search value
            var hasPathSep = searchValue.indexOf(path.sep) >= 0;
            var cacheRow;
            for (var previousSearch in cache.resultsToSearchCache) {
                // If we narrow down, we might be able to reuse the cached results
                if (strings.startsWith(searchValue, previousSearch)) {
                    if (hasPathSep && previousSearch.indexOf(path.sep) < 0) {
                        continue; // since a path character widens the search for potential more matches, require it in previous search too
                    }
                    var row = cache.resultsToSearchCache[previousSearch];
                    cacheRow = {
                        promise: this.preventCancellation(row.promise),
                        resolved: row.resolved
                    };
                    break;
                }
            }
            if (!cacheRow) {
                return null;
            }
            var cacheLookupTime = cacheLookupSW.elapsed();
            var cacheFilterSW = stopwatch_1.StopWatch.create();
            return new winjs_base_1.TPromise(function (c, e) {
                token.onCancellationRequested(function () { return e(errors_1.canceled()); });
                cacheRow.promise.then(function (complete) {
                    if (token && token.isCancellationRequested) {
                        e(errors_1.canceled());
                    }
                    // Pattern match on results
                    var results = [];
                    var normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();
                    for (var i = 0; i < complete.results.length; i++) {
                        var entry = complete.results[i];
                        // Check if this entry is a match for the search value
                        if (!strings.fuzzyContains(entry.relativePath, normalizedSearchValueLowercase)) {
                            continue;
                        }
                        results.push(entry);
                    }
                    c({
                        limitHit: complete.limitHit,
                        results: results,
                        stats: {
                            cacheWasResolved: cacheRow.resolved,
                            cacheLookupTime: cacheLookupTime,
                            cacheFilterTime: cacheFilterSW.elapsed(),
                            cacheEntryCount: complete.results.length
                        }
                    });
                }, e);
            });
        };
        FileIndexSearchManager.prototype.doSearch = function (engine, token) {
            token.onCancellationRequested(function () { return engine.cancel(); });
            var results = [];
            var onResult = function (match) { return results.push(match); };
            return engine.search(onResult).then(function (result) {
                return {
                    limitHit: result.isLimitHit,
                    results: results,
                    stats: result.stats
                };
            });
        };
        FileIndexSearchManager.prototype.clearCache = function (cacheKey) {
            var _this = this;
            if (!this.folderCacheKeys.has(cacheKey)) {
                return Promise.resolve(undefined);
            }
            var expandedKeys = this.folderCacheKeys.get(cacheKey);
            expandedKeys.forEach(function (key) { return delete _this.caches[key]; });
            this.folderCacheKeys.delete(cacheKey);
            return Promise.resolve(undefined);
        };
        FileIndexSearchManager.prototype.preventCancellation = function (promise) {
            return new /** @class */ (function () {
                function class_1() {
                }
                class_1.prototype.cancel = function () {
                    // Do nothing
                };
                class_1.prototype.then = function (resolve, reject) {
                    return promise.then(resolve, reject);
                };
                class_1.prototype.catch = function (reject) {
                    return this.then(undefined, reject);
                };
                return class_1;
            }());
        };
        FileIndexSearchManager.BATCH_SIZE = 512;
        return FileIndexSearchManager;
    }());
    exports.FileIndexSearchManager = FileIndexSearchManager;
    var Cache = /** @class */ (function () {
        function Cache() {
            this.resultsToSearchCache = Object.create(null);
            this.scorerCache = Object.create(null);
        }
        return Cache;
    }());
    var FileMatchItemAccessor = new /** @class */ (function () {
        function class_2() {
        }
        class_2.prototype.getItemLabel = function (match) {
            return match.basename; // e.g. myFile.txt
        };
        class_2.prototype.getItemDescription = function (match) {
            return match.relativePath.substr(0, match.relativePath.length - match.basename.length - 1); // e.g. some/path/to/file
        };
        class_2.prototype.getItemPath = function (match) {
            return match.relativePath; // e.g. some/path/to/file/myFile.txt
        };
        return class_2;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[180/*vs/workbench/services/search/node/fileSearchManager*/], __M([1/*require*/,0/*exports*/,10/*path*/,17/*vs/base/common/cancellation*/,35/*vs/base/common/errorMessage*/,23/*vs/base/common/glob*/,24/*vs/base/common/resources*/,36/*vs/base/common/stopwatch*/,20/*vs/base/common/winjs.base*/,32/*vs/workbench/services/search/node/search*/]), function (require, exports, path, cancellation_1, errorMessage_1, glob, resources, stopwatch_1, winjs_base_1, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileSearchEngine = /** @class */ (function () {
        function FileSearchEngine(config, provider) {
            this.config = config;
            this.provider = provider;
            this.filePattern = config.filePattern;
            this.includePattern = config.includePattern && glob.parse(config.includePattern);
            this.maxResults = config.maxResults || null;
            this.exists = config.exists;
            this.resultCount = 0;
            this.isLimitHit = false;
            this.activeCancellationTokens = new Set();
            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);
        }
        FileSearchEngine.prototype.cancel = function () {
            this.isCanceled = true;
            this.activeCancellationTokens.forEach(function (t) { return t.cancel(); });
            this.activeCancellationTokens = new Set();
        };
        FileSearchEngine.prototype.search = function (_onResult) {
            var _this = this;
            var folderQueries = this.config.folderQueries;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var onResult = function (match) {
                    _this.resultCount++;
                    _onResult(match);
                };
                // Support that the file pattern is a full path to a file that exists
                if (_this.isCanceled) {
                    return resolve({ limitHit: _this.isLimitHit });
                }
                // For each extra file
                if (_this.config.extraFileResources) {
                    _this.config.extraFileResources
                        .forEach(function (extraFile) {
                        var extraFileStr = extraFile.toString(); // ?
                        var basename = path.basename(extraFileStr);
                        if (_this.globalExcludePattern && _this.globalExcludePattern(extraFileStr, basename)) {
                            return; // excluded
                        }
                        // File: Check for match on file pattern and include pattern
                        _this.matchFile(onResult, { base: extraFile, basename: basename });
                    });
                }
                // For each root folder
                winjs_base_1.TPromise.join(folderQueries.map(function (fq) {
                    return _this.searchInFolder(fq, onResult);
                })).then(function (stats) {
                    resolve({
                        limitHit: _this.isLimitHit,
                        stats: stats[0] // Only looking at single-folder workspace stats...
                    });
                }, function (errs) {
                    var errMsg = errs
                        .map(function (err) { return errorMessage_1.toErrorMessage(err); })
                        .filter(function (msg) { return !!msg; })[0];
                    reject(new Error(errMsg));
                });
            });
        };
        FileSearchEngine.prototype.searchInFolder = function (fq, onResult) {
            var _this = this;
            var cancellation = new cancellation_1.CancellationTokenSource();
            return new winjs_base_1.TPromise(function (resolve, reject) {
                var options = _this.getSearchOptionsForFolder(fq);
                var tree = _this.initDirectoryTree();
                var queryTester = new search_1.QueryGlobTester(_this.config, fq);
                var noSiblingsClauses = !queryTester.hasSiblingExcludeClauses();
                var providerSW;
                new winjs_base_1.TPromise(function (_resolve) { return process.nextTick(_resolve); })
                    .then(function () {
                    _this.activeCancellationTokens.add(cancellation);
                    providerSW = stopwatch_1.StopWatch.create();
                    return _this.provider.provideFileSearchResults({
                        pattern: _this.config.filePattern || ''
                    }, options, cancellation.token);
                })
                    .then(function (results) {
                    var providerTime = providerSW.elapsed();
                    var postProcessSW = stopwatch_1.StopWatch.create();
                    if (_this.isCanceled) {
                        return null;
                    }
                    if (results) {
                        results.forEach(function (result) {
                            var relativePath = path.relative(fq.folder.fsPath, result.fsPath);
                            if (noSiblingsClauses) {
                                var basename = path.basename(result.fsPath);
                                _this.matchFile(onResult, { base: fq.folder, relativePath: relativePath, basename: basename });
                                return;
                            }
                            // TODO: Optimize siblings clauses with ripgrep here.
                            _this.addDirectoryEntries(tree, fq.folder, relativePath, onResult);
                        });
                    }
                    _this.activeCancellationTokens.delete(cancellation);
                    if (_this.isCanceled) {
                        return null;
                    }
                    _this.matchDirectoryTree(tree, queryTester, onResult);
                    return {
                        providerTime: providerTime,
                        postProcessTime: postProcessSW.elapsed()
                    };
                }).then(function (stats) {
                    cancellation.dispose();
                    resolve(stats);
                }, function (err) {
                    cancellation.dispose();
                    reject(err);
                });
            });
        };
        FileSearchEngine.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = search_1.resolvePatternsForProvider(this.config.includePattern, fq.includePattern);
            var excludes = search_1.resolvePatternsForProvider(this.config.excludePattern, fq.excludePattern);
            return {
                folder: fq.folder,
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !fq.disregardIgnoreFiles,
                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
                followSymlinks: !fq.ignoreSymlinks,
                maxResults: this.config.maxResults
            };
        };
        FileSearchEngine.prototype.initDirectoryTree = function () {
            var tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        };
        FileSearchEngine.prototype.addDirectoryEntries = function (_a, base, relativeFile, onResult) {
            var pathToEntries = _a.pathToEntries;
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFile === this.filePattern) {
                var basename = path.basename(this.filePattern);
                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
            }
            function add(relativePath) {
                var basename = path.basename(relativePath);
                var dirname = path.dirname(relativePath);
                var entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base: base,
                    relativePath: relativePath,
                    basename: basename
                });
            }
            add(relativeFile);
        };
        FileSearchEngine.prototype.matchDirectoryTree = function (_a, queryTester, onResult) {
            var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
            var self = this;
            var filePattern = this.filePattern;
            function matchDirectory(entries) {
                var hasSibling = glob.hasSiblingFn(function () { return entries.map(function (entry) { return entry.basename; }); });
                for (var i = 0, n = entries.length; i < n; i++) {
                    var entry = entries[i];
                    var relativePath = entry.relativePath, basename = entry.basename;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what she
                    // is searching for and we want to include the result in that case anyway
                    if (!queryTester.includedInQuerySync(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    var sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.matchFile(onResult, entry);
                    }
                    if (self.isLimitHit) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        };
        FileSearchEngine.prototype.matchFile = function (onResult, candidate) {
            if (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename)) {
                if (this.exists || (this.maxResults && this.resultCount >= this.maxResults)) {
                    this.isLimitHit = true;
                    this.cancel();
                }
                if (!this.isLimitHit) {
                    onResult(candidate);
                }
            }
        };
        return FileSearchEngine;
    }());
    var FileSearchManager = /** @class */ (function () {
        function FileSearchManager() {
        }
        FileSearchManager.prototype.fileSearch = function (config, provider, onBatch, token) {
            var _this = this;
            var engine = new FileSearchEngine(config, provider);
            var resultCount = 0;
            var onInternalResult = function (batch) {
                resultCount += batch.length;
                onBatch(batch.map(function (m) { return _this.rawMatchToSearchItem(m); }));
            };
            return this.doSearch(engine, FileSearchManager.BATCH_SIZE, onInternalResult, token).then(function (result) {
                return {
                    limitHit: result.limitHit,
                    stats: {
                        fromCache: false,
                        type: 'fileSearchProvider',
                        resultCount: resultCount,
                        detailStats: result.stats
                    }
                };
            });
        };
        FileSearchManager.prototype.rawMatchToSearchItem = function (match) {
            if (match.relativePath) {
                return {
                    resource: resources.joinPath(match.base, match.relativePath)
                };
            }
            else {
                // extraFileResources
                return {
                    resource: match.base
                };
            }
        };
        FileSearchManager.prototype.doSearch = function (engine, batchSize, onResultBatch, token) {
            token.onCancellationRequested(function () {
                engine.cancel();
            });
            var _onResult = function (match) {
                if (match) {
                    batch.push(match);
                    if (batchSize > 0 && batch.length >= batchSize) {
                        onResultBatch(batch);
                        batch = [];
                    }
                }
            };
            var batch = [];
            return engine.search(_onResult).then(function (result) {
                if (batch.length) {
                    onResultBatch(batch);
                }
                return result;
            }, function (error) {
                if (batch.length) {
                    onResultBatch(batch);
                }
                return winjs_base_1.TPromise.wrapError(error);
            });
        };
        FileSearchManager.BATCH_SIZE = 512;
        return FileSearchManager;
    }());
    exports.FileSearchManager = FileSearchManager;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[40/*vs/workbench/services/search/node/textSearchManager*/], __M([1/*require*/,0/*exports*/,10/*path*/,9/*vs/base/common/arrays*/,17/*vs/base/common/cancellation*/,35/*vs/base/common/errorMessage*/,23/*vs/base/common/glob*/,24/*vs/base/common/resources*/,2/*vs/base/common/uri*/,20/*vs/base/common/winjs.base*/,69/*vs/base/node/encoding*/,31/*vs/base/node/extfs*/,32/*vs/workbench/services/search/node/search*/]), function (require, exports, path, arrays_1, cancellation_1, errorMessage_1, glob, resources, uri_1, winjs_base_1, encoding_1, extfs, search_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextSearchManager = /** @class */ (function () {
        function TextSearchManager(query, provider, _extfs) {
            if (_extfs === void 0) { _extfs = extfs; }
            this.query = query;
            this.provider = provider;
            this._extfs = _extfs;
            this.resultCount = 0;
        }
        TextSearchManager.prototype.search = function (onProgress, token) {
            var _this = this;
            var folderQueries = this.query.folderQueries;
            var tokenSource = new cancellation_1.CancellationTokenSource();
            token.onCancellationRequested(function () { return tokenSource.cancel(); });
            return new winjs_base_1.TPromise(function (resolve, reject) {
                _this.collector = new TextSearchResultsCollector(onProgress);
                var isCanceled = false;
                var onResult = function (match, folderIdx) {
                    if (isCanceled) {
                        return;
                    }
                    if (_this.resultCount >= _this.query.maxResults) {
                        _this.isLimitHit = true;
                        isCanceled = true;
                        tokenSource.cancel();
                    }
                    if (!_this.isLimitHit) {
                        _this.resultCount++;
                        _this.collector.add(match, folderIdx);
                    }
                };
                // For each root folder
                winjs_base_1.TPromise.join(folderQueries.map(function (fq, i) {
                    return _this.searchInFolder(fq, function (r) { return onResult(r, i); }, tokenSource.token);
                })).then(function (results) {
                    tokenSource.dispose();
                    _this.collector.flush();
                    var someFolderHitLImit = results.some(function (result) { return result && result.limitHit; });
                    resolve({
                        limitHit: _this.isLimitHit || someFolderHitLImit,
                        stats: {
                            type: 'textSearchProvider'
                        }
                    });
                }, function (errs) {
                    tokenSource.dispose();
                    var errMsg = errs
                        .map(function (err) { return errorMessage_1.toErrorMessage(err); })
                        .filter(function (msg) { return !!msg; })[0];
                    reject(new Error(errMsg));
                });
            });
        };
        TextSearchManager.prototype.searchInFolder = function (folderQuery, onResult, token) {
            var _this = this;
            var queryTester = new search_1.QueryGlobTester(this.query, folderQuery);
            var testingPs = [];
            var progress = {
                report: function (result) {
                    // TODO: validate result.ranges vs result.preview.matches
                    var hasSibling = folderQuery.folder.scheme === 'file' && glob.hasSiblingPromiseFn(function () {
                        return _this.readdir(path.dirname(result.uri.fsPath));
                    });
                    var relativePath = path.relative(folderQuery.folder.fsPath, result.uri.fsPath);
                    testingPs.push(queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling)
                        .then(function (included) {
                        if (included) {
                            onResult(result);
                        }
                    }));
                }
            };
            var searchOptions = this.getSearchOptionsForFolder(folderQuery);
            return new winjs_base_1.TPromise(function (resolve) { return process.nextTick(resolve); })
                .then(function () { return _this.provider.provideTextSearchResults(patternInfoToQuery(_this.query.contentPattern), searchOptions, progress, token); })
                .then(function (result) {
                return winjs_base_1.TPromise.join(testingPs)
                    .then(function () { return result; });
            });
        };
        TextSearchManager.prototype.readdir = function (dirname) {
            var _this = this;
            return new winjs_base_1.TPromise(function (resolve, reject) {
                _this._extfs.readdir(dirname, function (err, files) {
                    if (err) {
                        return reject(err);
                    }
                    resolve(files);
                });
            });
        };
        TextSearchManager.prototype.getSearchOptionsForFolder = function (fq) {
            var includes = search_1.resolvePatternsForProvider(this.query.includePattern, fq.includePattern);
            var excludes = search_1.resolvePatternsForProvider(this.query.excludePattern, fq.excludePattern);
            var options = {
                folder: uri_1.URI.from(fq.folder),
                excludes: excludes,
                includes: includes,
                useIgnoreFiles: !fq.disregardIgnoreFiles,
                useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
                followSymlinks: !fq.ignoreSymlinks,
                encoding: fq.fileEncoding && encoding_1.toCanonicalName(fq.fileEncoding),
                maxFileSize: this.query.maxFileSize,
                maxResults: this.query.maxResults,
                previewOptions: this.query.previewOptions,
                afterContext: this.query.afterContext,
                beforeContext: this.query.beforeContext
            };
            options.usePCRE2 = this.query.usePCRE2;
            return options;
        };
        return TextSearchManager;
    }());
    exports.TextSearchManager = TextSearchManager;
    function patternInfoToQuery(patternInfo) {
        return {
            isCaseSensitive: patternInfo.isCaseSensitive || false,
            isRegExp: patternInfo.isRegExp || false,
            isWordMatch: patternInfo.isWordMatch || false,
            isMultiline: patternInfo.isMultiline || false,
            pattern: patternInfo.pattern
        };
    }
    var TextSearchResultsCollector = /** @class */ (function () {
        function TextSearchResultsCollector(_onResult) {
            var _this = this;
            this._onResult = _onResult;
            this._batchedCollector = new BatchedCollector(512, function (items) { return _this.sendItems(items); });
        }
        TextSearchResultsCollector.prototype.add = function (data, folderIdx) {
            // Collects TextSearchResults into IInternalFileMatches and collates using BatchedCollector.
            // This is efficient for ripgrep which sends results back one file at a time. It wouldn't be efficient for other search
            // providers that send results in random order. We could do this step afterwards instead.
            if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {
                this.pushToCollector();
                this._currentFileMatch = null;
            }
            if (!this._currentFileMatch) {
                this._currentFolderIdx = folderIdx;
                this._currentFileMatch = {
                    resource: data.uri,
                    results: []
                };
            }
            this._currentFileMatch.results.push(extensionResultToFrontendResult(data));
        };
        TextSearchResultsCollector.prototype.pushToCollector = function () {
            var size = this._currentFileMatch ?
                this._currentFileMatch.results.length :
                0;
            this._batchedCollector.addItem(this._currentFileMatch, size);
        };
        TextSearchResultsCollector.prototype.flush = function () {
            this.pushToCollector();
            this._batchedCollector.flush();
        };
        TextSearchResultsCollector.prototype.sendItems = function (items) {
            this._onResult(items);
        };
        return TextSearchResultsCollector;
    }());
    exports.TextSearchResultsCollector = TextSearchResultsCollector;
    function extensionResultToFrontendResult(data) {
        // Warning: result from RipgrepTextSearchEH has fake vscode.Range. Don't depend on any other props beyond these...
        if (extensionResultIsMatch(data)) {
            return {
                preview: {
                    matches: arrays_1.mapArrayOrNot(data.preview.matches, function (m) { return ({
                        startLineNumber: m.start.line,
                        startColumn: m.start.character,
                        endLineNumber: m.end.line,
                        endColumn: m.end.character
                    }); }),
                    text: data.preview.text
                },
                ranges: arrays_1.mapArrayOrNot(data.ranges, function (r) { return ({
                    startLineNumber: r.start.line,
                    startColumn: r.start.character,
                    endLineNumber: r.end.line,
                    endColumn: r.end.character
                }); })
            };
        }
        else {
            return {
                text: data.text,
                lineNumber: data.lineNumber
            };
        }
    }
    function extensionResultIsMatch(data) {
        return !!data.preview;
    }
    exports.extensionResultIsMatch = extensionResultIsMatch;
    /**
     * Collects items that have a size - before the cumulative size of collected items reaches START_BATCH_AFTER_COUNT, the callback is called for every
     * set of items collected.
     * But after that point, the callback is called with batches of maxBatchSize.
     * If the batch isn't filled within some time, the callback is also called.
     */
    var BatchedCollector = /** @class */ (function () {
        function BatchedCollector(maxBatchSize, cb) {
            this.maxBatchSize = maxBatchSize;
            this.cb = cb;
            this.totalNumberCompleted = 0;
            this.batch = [];
            this.batchSize = 0;
        }
        BatchedCollector.prototype.addItem = function (item, size) {
            if (!item) {
                return;
            }
            this.addItemToBatch(item, size);
        };
        BatchedCollector.prototype.addItems = function (items, size) {
            if (!items) {
                return;
            }
            this.addItemsToBatch(items, size);
        };
        BatchedCollector.prototype.addItemToBatch = function (item, size) {
            this.batch.push(item);
            this.batchSize += size;
            this.onUpdate();
        };
        BatchedCollector.prototype.addItemsToBatch = function (item, size) {
            this.batch = this.batch.concat(item);
            this.batchSize += size;
            this.onUpdate();
        };
        BatchedCollector.prototype.onUpdate = function () {
            var _this = this;
            if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {
                // Flush because we aren't batching yet
                this.flush();
            }
            else if (this.batchSize >= this.maxBatchSize) {
                // Flush because the batch is full
                this.flush();
            }
            else if (!this.timeoutHandle) {
                // No timeout running, start a timeout to flush
                this.timeoutHandle = setTimeout(function () {
                    _this.flush();
                }, BatchedCollector.TIMEOUT);
            }
        };
        BatchedCollector.prototype.flush = function () {
            if (this.batchSize) {
                this.totalNumberCompleted += this.batchSize;
                this.cb(this.batch);
                this.batch = [];
                this.batchSize = 0;
                if (this.timeoutHandle) {
                    clearTimeout(this.timeoutHandle);
                    this.timeoutHandle = 0;
                }
            }
        };
        BatchedCollector.TIMEOUT = 4000;
        // After START_BATCH_AFTER_COUNT items have been collected, stop flushing on timeout
        BatchedCollector.START_BATCH_AFTER_COUNT = 50;
        return BatchedCollector;
    }());
    exports.BatchedCollector = BatchedCollector;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[182/*vs/workbench/node/proxyResolver*/], __M([1/*require*/,0/*exports*/,204/*http*/,196/*https*/,198/*url*/,13/*vs/base/common/objects*/,199/*vscode-proxy-agent*/,35/*vs/base/common/errorMessage*/,2/*vs/base/common/uri*/]), function (require, exports, http, https, nodeurl, objects_1, vscode_proxy_agent_1, errorMessage_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function connectProxyResolver(extHostWorkspace, extHostConfiguration, extensionService, extHostLogService, mainThreadTelemetry) {
        var agent = createProxyAgent(extHostWorkspace, extHostLogService, mainThreadTelemetry);
        var lookup = createPatchedModules(extHostConfiguration, agent);
        return configureModuleLoading(extensionService, lookup);
    }
    exports.connectProxyResolver = connectProxyResolver;
    function createProxyAgent(extHostWorkspace, extHostLogService, mainThreadTelemetry) {
        var timeout;
        var count = 0;
        var duration = 0;
        var errorCount = 0;
        function logEvent() {
            timeout = undefined;
            /* __GDPR__
                "resolveProxy" : {
                    "count": { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true },
                    "duration": { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true },
                    "errorCount": { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true }
                }
            */
            mainThreadTelemetry.$publicLog('resolveProxy', { count: count, duration: duration, errorCount: errorCount });
            count = duration = errorCount = 0;
        }
        function resolveProxy(url, callback) {
            if (!timeout) {
                timeout = setTimeout(logEvent, 10 * 60 * 1000);
            }
            var start = Date.now();
            extHostWorkspace.resolveProxy(url)
                .then(function (proxy) {
                callback(proxy);
            }).then(function () {
                count++;
                duration = Date.now() - start + duration;
            }, function (err) {
                errorCount++;
                extHostLogService.error('resolveProxy', errorMessage_1.toErrorMessage(err));
                callback();
            });
        }
        return new vscode_proxy_agent_1.ProxyAgent({ resolveProxy: resolveProxy });
    }
    function createPatchedModules(extHostConfiguration, agent) {
        var setting = {
            config: extHostConfiguration.getConfiguration('http')
                .get('systemProxy') || 'off'
        };
        extHostConfiguration.onDidChangeConfiguration(function (e) {
            setting.config = extHostConfiguration.getConfiguration('http')
                .get('systemProxy') || 'off';
        });
        return {
            http: {
                off: objects_1.assign({}, http, patches(http, agent, { config: 'off' }, true)),
                on: objects_1.assign({}, http, patches(http, agent, { config: 'on' }, true)),
                force: objects_1.assign({}, http, patches(http, agent, { config: 'force' }, true)),
                onRequest: objects_1.assign({}, http, patches(http, agent, setting, true)),
                default: objects_1.assign(http, patches(http, agent, setting, false)) // run last
            },
            https: {
                off: objects_1.assign({}, https, patches(https, agent, { config: 'off' }, true)),
                on: objects_1.assign({}, https, patches(https, agent, { config: 'on' }, true)),
                force: objects_1.assign({}, https, patches(https, agent, { config: 'force' }, true)),
                onRequest: objects_1.assign({}, https, patches(https, agent, setting, true)),
                default: objects_1.assign(https, patches(https, agent, setting, false)) // run last
            }
        };
    }
    function patches(originals, agent, setting, onRequest) {
        return {
            get: patch(originals.get),
            request: patch(originals.request)
        };
        function patch(original) {
            function patched(url, options, callback) {
                if (typeof url !== 'string' && !(url && url.searchParams)) {
                    callback = options;
                    options = url;
                    url = null;
                }
                if (typeof options === 'function') {
                    callback = options;
                    options = null;
                }
                options = options || {};
                var config = onRequest && options._vscodeSystemProxy || setting.config;
                if (config === 'off') {
                    return original.apply(null, arguments);
                }
                if (!options.socketPath && (config === 'force' || config === 'on' && !options.agent)) {
                    if (url) {
                        var parsed = typeof url === 'string' ? nodeurl.parse(url) : url;
                        options = __assign({ protocol: parsed.protocol, hostname: parsed.hostname, port: parsed.port, path: parsed.pathname }, options);
                    }
                    options.agent = agent;
                    return original(options, callback);
                }
                return original.apply(null, arguments);
            }
            return patched;
        }
    }
    function configureModuleLoading(extensionService, lookup) {
        return extensionService.getExtensionPathIndex()
            .then(function (extensionPaths) {
            var node_module = require.__$__nodeRequire('module');
            var original = node_module._load;
            node_module._load = function load(request, parent, isMain) {
                if (request !== 'http' && request !== 'https') {
                    return original.apply(this, arguments);
                }
                var modules = lookup[request];
                var ext = extensionPaths.findSubstr(uri_1.URI.file(parent.filename).fsPath);
                if (ext && ext.enableProposedApi) {
                    return modules[ext.systemProxy] || modules.onRequest;
                }
                return modules.default;
            };
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[183/*vs/workbench/services/search/node/ripgrepFileSearch*/], __M([1/*require*/,0/*exports*/,25/*child_process*/,10/*path*/,45/*vs/base/common/normalization*/,13/*vs/base/common/objects*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,5/*vs/base/common/strings*/,39/*vs/workbench/services/search/node/ripgrepSearchUtils*/,184/*vscode-ripgrep*/]), function (require, exports, cp, path, normalization_1, objects, paths, platform_1, strings, ripgrepSearchUtils_1, vscode_ripgrep_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // If vscode-ripgrep is in an .asar file, then the binary is unpacked.
    var rgDiskPath = vscode_ripgrep_1.rgPath.replace(/\bnode_modules\.asar\b/, 'node_modules.asar.unpacked');
    function spawnRipgrepCmd(config, folderQuery, includePattern, excludePattern) {
        var rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern);
        var cwd = folderQuery.folder.fsPath;
        return {
            cmd: cp.spawn(rgDiskPath, rgArgs.args, { cwd: cwd }),
            siblingClauses: rgArgs.siblingClauses,
            rgArgs: rgArgs,
            cwd: cwd
        };
    }
    exports.spawnRipgrepCmd = spawnRipgrepCmd;
    function getRgArgs(config, folderQuery, includePattern, excludePattern) {
        var args = ['--files', '--hidden', '--case-sensitive'];
        // includePattern can't have siblingClauses
        foldersToIncludeGlobs([folderQuery], includePattern, false).forEach(function (globArg) {
            var inclusion = ripgrepSearchUtils_1.anchorGlob(globArg);
            args.push('-g', inclusion);
            if (platform_1.isMacintosh) {
                var normalized = normalization_1.normalizeNFD(inclusion);
                if (normalized !== inclusion) {
                    args.push('-g', normalized);
                }
            }
        });
        var siblingClauses;
        var rgGlobs = foldersToRgExcludeGlobs([folderQuery], excludePattern, undefined, false);
        rgGlobs.globArgs.forEach(function (globArg) {
            var exclusion = "!" + ripgrepSearchUtils_1.anchorGlob(globArg);
            args.push('-g', exclusion);
            if (platform_1.isMacintosh) {
                var normalized = normalization_1.normalizeNFD(exclusion);
                if (normalized !== exclusion) {
                    args.push('-g', normalized);
                }
            }
        });
        siblingClauses = rgGlobs.siblingClauses;
        if (folderQuery.disregardIgnoreFiles !== false) {
            // Don't use .gitignore or .ignore
            args.push('--no-ignore');
        }
        else {
            args.push('--no-ignore-parent');
        }
        // Follow symlinks
        if (!folderQuery.ignoreSymlinks) {
            args.push('--follow');
        }
        if (config.exists) {
            args.push('--quiet');
        }
        args.push('--no-config');
        if (folderQuery.disregardGlobalIgnoreFiles) {
            args.push('--no-ignore-global');
        }
        return { args: args, siblingClauses: siblingClauses };
    }
    function foldersToRgExcludeGlobs(folderQueries, globalExclude, excludesToSkip, absoluteGlobs) {
        if (absoluteGlobs === void 0) { absoluteGlobs = true; }
        var globArgs = [];
        var siblingClauses = {};
        folderQueries.forEach(function (folderQuery) {
            var totalExcludePattern = objects.assign({}, folderQuery.excludePattern || {}, globalExclude || {});
            var result = globExprsToRgGlobs(totalExcludePattern, absoluteGlobs && folderQuery.folder.fsPath, excludesToSkip);
            globArgs.push.apply(globArgs, result.globArgs);
            if (result.siblingClauses) {
                siblingClauses = objects.assign(siblingClauses, result.siblingClauses);
            }
        });
        return { globArgs: globArgs, siblingClauses: siblingClauses };
    }
    exports.foldersToRgExcludeGlobs = foldersToRgExcludeGlobs;
    function foldersToIncludeGlobs(folderQueries, globalInclude, absoluteGlobs) {
        if (absoluteGlobs === void 0) { absoluteGlobs = true; }
        var globArgs = [];
        folderQueries.forEach(function (folderQuery) {
            var totalIncludePattern = objects.assign({}, globalInclude || {}, folderQuery.includePattern || {});
            var result = globExprsToRgGlobs(totalIncludePattern, absoluteGlobs && folderQuery.folder.fsPath);
            globArgs.push.apply(globArgs, result.globArgs);
        });
        return globArgs;
    }
    exports.foldersToIncludeGlobs = foldersToIncludeGlobs;
    function globExprsToRgGlobs(patterns, folder, excludesToSkip) {
        var globArgs = [];
        var siblingClauses = null;
        Object.keys(patterns)
            .forEach(function (key) {
            if (excludesToSkip && excludesToSkip.has(key)) {
                return;
            }
            if (!key) {
                return;
            }
            var value = patterns[key];
            key = trimTrailingSlash(folder ? getAbsoluteGlob(folder, key) : key);
            // glob.ts requires forward slashes, but a UNC path still must start with \\
            // #38165 and #38151
            if (strings.startsWith(key, '\\\\')) {
                key = '\\\\' + key.substr(2).replace(/\\/g, '/');
            }
            else {
                key = key.replace(/\\/g, '/');
            }
            if (typeof value === 'boolean' && value) {
                if (strings.startsWith(key, '\\\\')) {
                    // Absolute globs UNC paths don't work properly, see #58758
                    key += '**';
                }
                globArgs.push(fixDriveC(key));
            }
            else if (value && value.when) {
                if (!siblingClauses) {
                    siblingClauses = {};
                }
                siblingClauses[key] = value;
            }
        });
        return { globArgs: globArgs, siblingClauses: siblingClauses };
    }
    /**
     * Resolves a glob like "node_modules/**" in "/foo/bar" to "/foo/bar/node_modules/**".
     * Special cases C:/foo paths to write the glob like /foo instead - see https://github.com/BurntSushi/ripgrep/issues/530.
     *
     * Exported for testing
     */
    function getAbsoluteGlob(folder, key) {
        return paths.isAbsolute(key) ?
            key :
            path.join(folder, key);
    }
    exports.getAbsoluteGlob = getAbsoluteGlob;
    function trimTrailingSlash(str) {
        str = strings.rtrim(str, '\\');
        return strings.rtrim(str, '/');
    }
    function fixDriveC(path) {
        var root = paths.getRoot(path);
        return root.toLowerCase() === 'c:/' ?
            path.replace(/^c:[/\\]/i, '/') :
            path;
    }
    exports.fixDriveC = fixDriveC;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[76/*vs/workbench/services/search/node/fileSearch*/], __M([1/*require*/,0/*exports*/,25/*child_process*/,27/*fs*/,10/*path*/,57/*string_decoder*/,9/*vs/base/common/arrays*/,35/*vs/base/common/errorMessage*/,23/*vs/base/common/glob*/,45/*vs/base/common/normalization*/,13/*vs/base/common/objects*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,36/*vs/base/common/stopwatch*/,5/*vs/base/common/strings*/,18/*vs/base/common/types*/,31/*vs/base/node/extfs*/,56/*vs/base/node/flow*/,183/*vs/workbench/services/search/node/ripgrepFileSearch*/]), function (require, exports, childProcess, fs, path, string_decoder_1, arrays, errorMessage_1, glob, normalization, objects, paths_1, platform, stopwatch_1, strings, types, extfs, flow, ripgrepFileSearch_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Traversal;
    (function (Traversal) {
        Traversal[Traversal["Node"] = 1] = "Node";
        Traversal[Traversal["MacFind"] = 2] = "MacFind";
        Traversal[Traversal["LinuxFind"] = 3] = "LinuxFind";
        Traversal[Traversal["Ripgrep"] = 4] = "Ripgrep";
    })(Traversal || (Traversal = {}));
    var killCmds = new Set();
    process.on('exit', function () {
        killCmds.forEach(function (cmd) { return cmd(); });
    });
    var FileWalker = /** @class */ (function () {
        function FileWalker(config, maxFileSize) {
            var _this = this;
            this.config = config;
            this.useRipgrep = config.useRipgrep !== false;
            this.filePattern = config.filePattern;
            this.includePattern = config.includePattern && glob.parse(config.includePattern);
            this.maxResults = config.maxResults || null;
            this.exists = config.exists;
            this.maxFilesize = maxFileSize || null;
            this.walkedPaths = Object.create(null);
            this.resultCount = 0;
            this.isLimitHit = false;
            this.directoriesWalked = 0;
            this.filesWalked = 0;
            this.traversal = Traversal.Node;
            this.errors = [];
            if (this.filePattern) {
                this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();
            }
            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);
            this.folderExcludePatterns = new Map();
            config.folderQueries.forEach(function (folderQuery) {
                var folderExcludeExpression = objects.assign({}, folderQuery.excludePattern || {}, _this.config.excludePattern || {});
                // Add excludes for other root folders
                var fqPath = folderQuery.folder.fsPath;
                config.folderQueries
                    .map(function (rootFolderQuery) { return rootFolderQuery.folder.fsPath; })
                    .filter(function (rootFolder) { return rootFolder !== fqPath; })
                    .forEach(function (otherRootFolder) {
                    // Exclude nested root folders
                    if (paths_1.isEqualOrParent(otherRootFolder, fqPath)) {
                        folderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;
                    }
                });
                _this.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));
            });
        }
        FileWalker.prototype.cancel = function () {
            this.isCanceled = true;
        };
        FileWalker.prototype.walk = function (folderQueries, extraFiles, onResult, onMessage, done) {
            var _this = this;
            this.fileWalkSW = stopwatch_1.StopWatch.create(false);
            // Support that the file pattern is a full path to a file that exists
            if (this.isCanceled) {
                return done(null, this.isLimitHit);
            }
            // For each extra file
            if (extraFiles) {
                extraFiles.forEach(function (extraFilePath) {
                    var basename = path.basename(extraFilePath.fsPath);
                    if (_this.globalExcludePattern && _this.globalExcludePattern(extraFilePath.fsPath, basename)) {
                        return; // excluded
                    }
                    // File: Check for match on file pattern and include pattern
                    _this.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, basename: basename });
                });
            }
            var traverse = this.nodeJSTraversal;
            if (!this.maxFilesize) {
                if (this.useRipgrep) {
                    this.traversal = Traversal.Ripgrep;
                    traverse = this.cmdTraversal;
                }
                else if (platform.isMacintosh) {
                    this.traversal = Traversal.MacFind;
                    traverse = this.cmdTraversal;
                }
                else if (platform.isLinux) {
                    this.traversal = Traversal.LinuxFind;
                    traverse = this.cmdTraversal;
                }
            }
            var isNodeTraversal = traverse === this.nodeJSTraversal;
            if (!isNodeTraversal) {
                this.cmdSW = stopwatch_1.StopWatch.create(false);
            }
            // For each root folder
            flow.parallel(folderQueries, function (folderQuery, rootFolderDone) {
                _this.call(traverse, _this, folderQuery, onResult, onMessage, function (err) {
                    if (err) {
                        var errorMessage = errorMessage_1.toErrorMessage(err);
                        console.error(errorMessage);
                        _this.errors.push(errorMessage);
                        rootFolderDone(err, undefined);
                    }
                    else {
                        rootFolderDone(undefined, undefined);
                    }
                });
            }, function (errors, result) {
                _this.fileWalkSW.stop();
                var err = errors ? errors.filter(function (e) { return !!e; })[0] : null;
                done(err, _this.isLimitHit);
            });
        };
        FileWalker.prototype.call = function (fun, that) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            try {
                fun.apply(that, args);
            }
            catch (e) {
                args[args.length - 1](e);
            }
        };
        FileWalker.prototype.cmdTraversal = function (folderQuery, onResult, onMessage, cb) {
            var _this = this;
            var rootFolder = folderQuery.folder.fsPath;
            var isMac = platform.isMacintosh;
            var cmd;
            var killCmd = function () { return cmd && cmd.kill(); };
            killCmds.add(killCmd);
            var done = function (err) {
                killCmds.delete(killCmd);
                done = function () { };
                cb(err);
            };
            var leftover = '';
            var first = true;
            var tree = this.initDirectoryTree();
            var useRipgrep = this.useRipgrep;
            var noSiblingsClauses;
            if (useRipgrep) {
                var ripgrep = ripgrepFileSearch_1.spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath).expression);
                cmd = ripgrep.cmd;
                noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;
                var escapedArgs = ripgrep.rgArgs.args
                    .map(function (arg) { return arg.match(/^-/) ? arg : "'" + arg + "'"; })
                    .join(' ');
                var rgCmd = "rg " + escapedArgs + "\n - cwd: " + ripgrep.cwd;
                if (ripgrep.rgArgs.siblingClauses) {
                    rgCmd += "\n - Sibling clauses: " + JSON.stringify(ripgrep.rgArgs.siblingClauses);
                }
                onMessage({ message: rgCmd });
            }
            else {
                cmd = this.spawnFindCmd(folderQuery);
            }
            this.cmdResultCount = 0;
            this.collectStdout(cmd, 'utf8', useRipgrep, onMessage, function (err, stdout, last) {
                if (err) {
                    done(err);
                    return;
                }
                if (_this.isLimitHit) {
                    done();
                    return;
                }
                // Mac: uses NFD unicode form on disk, but we want NFC
                var normalized = leftover + (isMac ? normalization.normalizeNFC(stdout) : stdout);
                var relativeFiles = normalized.split(useRipgrep ? '\n' : '\n./');
                if (!useRipgrep && first && normalized.length >= 2) {
                    first = false;
                    relativeFiles[0] = relativeFiles[0].trim().substr(2);
                }
                if (last) {
                    var n = relativeFiles.length;
                    relativeFiles[n - 1] = relativeFiles[n - 1].trim();
                    if (!relativeFiles[n - 1]) {
                        relativeFiles.pop();
                    }
                }
                else {
                    leftover = relativeFiles.pop();
                }
                if (relativeFiles.length && relativeFiles[0].indexOf('\n') !== -1) {
                    done(new Error('Splitting up files failed'));
                    return;
                }
                _this.cmdResultCount += relativeFiles.length;
                if (useRipgrep && noSiblingsClauses) {
                    for (var _i = 0, relativeFiles_1 = relativeFiles; _i < relativeFiles_1.length; _i++) {
                        var relativePath = relativeFiles_1[_i];
                        var basename = path.basename(relativePath);
                        _this.matchFile(onResult, { base: rootFolder, relativePath: relativePath, basename: basename });
                        if (_this.isLimitHit) {
                            killCmd();
                            break;
                        }
                    }
                    if (last || _this.isLimitHit) {
                        done();
                    }
                    return;
                }
                // TODO: Optimize siblings clauses with ripgrep here.
                _this.addDirectoryEntries(tree, rootFolder, relativeFiles, onResult);
                if (last) {
                    _this.matchDirectoryTree(tree, rootFolder, onResult);
                    done();
                }
            });
        };
        /**
         * Public for testing.
         */
        FileWalker.prototype.spawnFindCmd = function (folderQuery) {
            var excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath);
            var basenames = excludePattern.getBasenameTerms();
            var pathTerms = excludePattern.getPathTerms();
            var args = ['-L', '.'];
            if (basenames.length || pathTerms.length) {
                args.push('-not', '(', '(');
                for (var _i = 0, basenames_1 = basenames; _i < basenames_1.length; _i++) {
                    var basename = basenames_1[_i];
                    args.push('-name', basename);
                    args.push('-o');
                }
                for (var _a = 0, pathTerms_1 = pathTerms; _a < pathTerms_1.length; _a++) {
                    var path_1 = pathTerms_1[_a];
                    args.push('-path', path_1);
                    args.push('-o');
                }
                args.pop();
                args.push(')', '-prune', ')');
            }
            args.push('-type', 'f');
            return childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });
        };
        /**
         * Public for testing.
         */
        FileWalker.prototype.readStdout = function (cmd, encoding, isRipgrep, cb) {
            var all = '';
            this.collectStdout(cmd, encoding, isRipgrep, function () { }, function (err, stdout, last) {
                if (err) {
                    cb(err);
                    return;
                }
                all += stdout;
                if (last) {
                    cb(null, all);
                }
            });
        };
        FileWalker.prototype.collectStdout = function (cmd, encoding, isRipgrep, onMessage, cb) {
            var _this = this;
            var onData = function (err, stdout, last) {
                if (err || last) {
                    onData = function () { };
                    if (_this.cmdSW) {
                        _this.cmdSW.stop();
                    }
                }
                cb(err, stdout, last);
            };
            var gotData = false;
            if (cmd.stdout) {
                // Should be non-null, but #38195
                this.forwardData(cmd.stdout, encoding, onData);
                cmd.stdout.once('data', function () { return gotData = true; });
            }
            else {
                onMessage({ message: 'stdout is null' });
            }
            var stderr;
            if (cmd.stderr) {
                // Should be non-null, but #38195
                stderr = this.collectData(cmd.stderr);
            }
            else {
                onMessage({ message: 'stderr is null' });
            }
            cmd.on('error', function (err) {
                onData(err);
            });
            cmd.on('close', function (code) {
                // ripgrep returns code=1 when no results are found
                var stderrText;
                if (isRipgrep ? (!gotData && (stderrText = _this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) : code !== 0) {
                    onData(new Error("command failed with error code " + code + ": " + _this.decodeData(stderr, encoding)));
                }
                else {
                    if (isRipgrep && _this.exists && code === 0) {
                        _this.isLimitHit = true;
                    }
                    onData(null, '', true);
                }
            });
        };
        FileWalker.prototype.forwardData = function (stream, encoding, cb) {
            var decoder = new string_decoder_1.StringDecoder(encoding);
            stream.on('data', function (data) {
                cb(null, decoder.write(data));
            });
            return decoder;
        };
        FileWalker.prototype.collectData = function (stream) {
            var buffers = [];
            stream.on('data', function (data) {
                buffers.push(data);
            });
            return buffers;
        };
        FileWalker.prototype.decodeData = function (buffers, encoding) {
            var decoder = new string_decoder_1.StringDecoder(encoding);
            return buffers.map(function (buffer) { return decoder.write(buffer); }).join('');
        };
        FileWalker.prototype.initDirectoryTree = function () {
            var tree = {
                rootEntries: [],
                pathToEntries: Object.create(null)
            };
            tree.pathToEntries['.'] = tree.rootEntries;
            return tree;
        };
        FileWalker.prototype.addDirectoryEntries = function (_a, base, relativeFiles, onResult) {
            var pathToEntries = _a.pathToEntries;
            // Support relative paths to files from a root resource (ignores excludes)
            if (relativeFiles.indexOf(this.filePattern) !== -1) {
                var basename = path.basename(this.filePattern);
                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename: basename });
            }
            function add(relativePath) {
                var basename = path.basename(relativePath);
                var dirname = path.dirname(relativePath);
                var entries = pathToEntries[dirname];
                if (!entries) {
                    entries = pathToEntries[dirname] = [];
                    add(dirname);
                }
                entries.push({
                    base: base,
                    relativePath: relativePath,
                    basename: basename
                });
            }
            relativeFiles.forEach(add);
        };
        FileWalker.prototype.matchDirectoryTree = function (_a, rootFolder, onResult) {
            var rootEntries = _a.rootEntries, pathToEntries = _a.pathToEntries;
            var self = this;
            var excludePattern = this.folderExcludePatterns.get(rootFolder);
            var filePattern = this.filePattern;
            function matchDirectory(entries) {
                self.directoriesWalked++;
                var hasSibling = glob.hasSiblingFn(function () { return entries.map(function (entry) { return entry.basename; }); });
                for (var i = 0, n = entries.length; i < n; i++) {
                    var entry = entries[i];
                    var relativePath = entry.relativePath, basename = entry.basename;
                    // Check exclude pattern
                    // If the user searches for the exact file name, we adjust the glob matching
                    // to ignore filtering by siblings because the user seems to know what she
                    // is searching for and we want to include the result in that case anyway
                    if (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {
                        continue;
                    }
                    var sub = pathToEntries[relativePath];
                    if (sub) {
                        matchDirectory(sub);
                    }
                    else {
                        self.filesWalked++;
                        if (relativePath === filePattern) {
                            continue; // ignore file if its path matches with the file pattern because that is already matched above
                        }
                        self.matchFile(onResult, entry);
                    }
                    if (self.isLimitHit) {
                        break;
                    }
                }
            }
            matchDirectory(rootEntries);
        };
        FileWalker.prototype.nodeJSTraversal = function (folderQuery, onResult, onMessage, done) {
            var _this = this;
            this.directoriesWalked++;
            extfs.readdir(folderQuery.folder.fsPath, function (error, files) {
                if (error || _this.isCanceled || _this.isLimitHit) {
                    return done();
                }
                if (_this.isCanceled || _this.isLimitHit) {
                    return done();
                }
                return _this.doWalk(folderQuery, '', files, onResult, done);
            });
        };
        FileWalker.prototype.getStats = function () {
            return {
                cmdTime: this.cmdSW && this.cmdSW.elapsed(),
                fileWalkTime: this.fileWalkSW.elapsed(),
                traversal: Traversal[this.traversal],
                directoriesWalked: this.directoriesWalked,
                filesWalked: this.filesWalked,
                cmdResultCount: this.cmdResultCount
            };
        };
        FileWalker.prototype.doWalk = function (folderQuery, relativeParentPath, files, onResult, done) {
            var _this = this;
            var rootFolder = folderQuery.folder;
            // Execute tasks on each file in parallel to optimize throughput
            var hasSibling = glob.hasSiblingFn(function () { return files; });
            flow.parallel(files, function (file, clb) {
                // Check canceled
                if (_this.isCanceled || _this.isLimitHit) {
                    return clb(null, undefined);
                }
                // Check exclude pattern
                // If the user searches for the exact file name, we adjust the glob matching
                // to ignore filtering by siblings because the user seems to know what she
                // is searching for and we want to include the result in that case anyway
                var currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;
                if (_this.folderExcludePatterns.get(folderQuery.folder.fsPath).test(currentRelativePath, file, _this.config.filePattern !== file ? hasSibling : undefined)) {
                    return clb(null, undefined);
                }
                // Use lstat to detect links
                var currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);
                fs.lstat(currentAbsolutePath, function (error, lstat) {
                    if (error || _this.isCanceled || _this.isLimitHit) {
                        return clb(null, undefined);
                    }
                    // If the path is a link, we must instead use fs.stat() to find out if the
                    // link is a directory or not because lstat will always return the stat of
                    // the link which is always a file.
                    _this.statLinkIfNeeded(currentAbsolutePath, lstat, function (error, stat) {
                        if (error || _this.isCanceled || _this.isLimitHit) {
                            return clb(null, undefined);
                        }
                        // Directory: Follow directories
                        if (stat.isDirectory()) {
                            _this.directoriesWalked++;
                            // to really prevent loops with links we need to resolve the real path of them
                            return _this.realPathIfNeeded(currentAbsolutePath, lstat, function (error, realpath) {
                                if (error || _this.isCanceled || _this.isLimitHit) {
                                    return clb(null, undefined);
                                }
                                if (_this.walkedPaths[realpath]) {
                                    return clb(null, undefined); // escape when there are cycles (can happen with symlinks)
                                }
                                _this.walkedPaths[realpath] = true; // remember as walked
                                // Continue walking
                                return extfs.readdir(currentAbsolutePath, function (error, children) {
                                    if (error || _this.isCanceled || _this.isLimitHit) {
                                        return clb(null, undefined);
                                    }
                                    _this.doWalk(folderQuery, currentRelativePath, children, onResult, function (err) { return clb(err, undefined); });
                                });
                            });
                        }
                        // File: Check for match on file pattern and include pattern
                        else {
                            _this.filesWalked++;
                            if (currentRelativePath === _this.filePattern) {
                                return clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those
                            }
                            if (_this.maxFilesize && types.isNumber(stat.size) && stat.size > _this.maxFilesize) {
                                return clb(null, undefined); // ignore file if max file size is hit
                            }
                            _this.matchFile(onResult, { base: rootFolder.fsPath, relativePath: currentRelativePath, basename: file, size: stat.size });
                        }
                        // Unwind
                        return clb(null, undefined);
                    });
                });
            }, function (error) {
                if (error) {
                    error = arrays.coalesce(error); // find any error by removing null values first
                }
                return done(error && error.length > 0 ? error[0] : null);
            });
        };
        FileWalker.prototype.matchFile = function (onResult, candidate) {
            if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {
                this.resultCount++;
                if (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {
                    this.isLimitHit = true;
                }
                if (!this.isLimitHit) {
                    onResult(candidate);
                }
            }
        };
        FileWalker.prototype.isFilePatternMatch = function (path) {
            // Check for search pattern
            if (this.filePattern) {
                if (this.filePattern === '*') {
                    return true; // support the all-matching wildcard
                }
                return strings.fuzzyContains(path, this.normalizedFilePatternLowercase);
            }
            // No patterns means we match all
            return true;
        };
        FileWalker.prototype.statLinkIfNeeded = function (path, lstat, clb) {
            if (lstat.isSymbolicLink()) {
                return fs.stat(path, clb); // stat the target the link points to
            }
            return clb(null, lstat); // not a link, so the stat is already ok for us
        };
        FileWalker.prototype.realPathIfNeeded = function (path, lstat, clb) {
            if (lstat.isSymbolicLink()) {
                return fs.realpath(path, function (error, realpath) {
                    if (error) {
                        return clb(error);
                    }
                    return clb(null, realpath);
                });
            }
            return clb(null, path);
        };
        return FileWalker;
    }());
    exports.FileWalker = FileWalker;
    var Engine = /** @class */ (function () {
        function Engine(config) {
            this.folderQueries = config.folderQueries;
            this.extraFiles = config.extraFileResources;
            this.walker = new FileWalker(config);
        }
        Engine.prototype.search = function (onResult, onProgress, done) {
            var _this = this;
            this.walker.walk(this.folderQueries, this.extraFiles, onResult, onProgress, function (err, isLimitHit) {
                done(err, {
                    limitHit: isLimitHit,
                    stats: _this.walker.getStats()
                });
            });
        };
        Engine.prototype.cancel = function () {
            this.walker.cancel();
        };
        return Engine;
    }());
    exports.Engine = Engine;
    /**
     * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.
     * The absolute and relative expressions don't "have" to be kept separate, but this keeps us from having to path.join every single
     * file searched, it's only used for a text search with a searchPath
     */
    var AbsoluteAndRelativeParsedExpression = /** @class */ (function () {
        function AbsoluteAndRelativeParsedExpression(expression, root) {
            this.expression = expression;
            this.root = root;
            this.init(expression);
        }
        /**
         * Split the IExpression into its absolute and relative components, and glob.parse them separately.
         */
        AbsoluteAndRelativeParsedExpression.prototype.init = function (expr) {
            var absoluteGlobExpr;
            var relativeGlobExpr;
            Object.keys(expr)
                .filter(function (key) { return expr[key]; })
                .forEach(function (key) {
                if (path.isAbsolute(key)) {
                    absoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();
                    absoluteGlobExpr[key] = expr[key];
                }
                else {
                    relativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();
                    relativeGlobExpr[key] = expr[key];
                }
            });
            this.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });
            this.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });
        };
        AbsoluteAndRelativeParsedExpression.prototype.test = function (_path, basename, hasSibling) {
            return (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||
                (this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));
        };
        AbsoluteAndRelativeParsedExpression.prototype.getBasenameTerms = function () {
            var basenameTerms = [];
            if (this.absoluteParsedExpr) {
                basenameTerms.push.apply(basenameTerms, glob.getBasenameTerms(this.absoluteParsedExpr));
            }
            if (this.relativeParsedExpr) {
                basenameTerms.push.apply(basenameTerms, glob.getBasenameTerms(this.relativeParsedExpr));
            }
            return basenameTerms;
        };
        AbsoluteAndRelativeParsedExpression.prototype.getPathTerms = function () {
            var pathTerms = [];
            if (this.absoluteParsedExpr) {
                pathTerms.push.apply(pathTerms, glob.getPathTerms(this.absoluteParsedExpr));
            }
            if (this.relativeParsedExpr) {
                pathTerms.push.apply(pathTerms, glob.getPathTerms(this.relativeParsedExpr));
            }
            return pathTerms;
        };
        return AbsoluteAndRelativeParsedExpression;
    }());
    function rgErrorMsgForDisplay(msg) {
        var lines = msg.trim().split('\n');
        var firstLine = lines[0].trim();
        if (strings.startsWith(firstLine, 'Error parsing regex')) {
            return firstLine;
        }
        if (strings.startsWith(firstLine, 'regex parse error')) {
            return strings.uppercaseFirstLetter(lines[lines.length - 1].trim());
        }
        if (strings.startsWith(firstLine, 'error parsing glob') ||
            strings.startsWith(firstLine, 'unsupported encoding')) {
            // Uppercase first letter
            return firstLine.charAt(0).toUpperCase() + firstLine.substr(1);
        }
        if (firstLine === "Literal '\\n' not allowed.") {
            // I won't localize this because none of the Ripgrep error messages are localized
            return "Literal '\\n' currently not supported";
        }
        if (strings.startsWith(firstLine, 'Literal ')) {
            // Other unsupported chars
            return firstLine;
        }
        return undefined;
    }
    exports.rgErrorMsgForDisplay = rgErrorMsgForDisplay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[186/*vs/workbench/services/search/node/legacy/rawLegacyTextSearchService*/], __M([1/*require*/,0/*exports*/,27/*fs*/,187/*graceful-fs*/,58/*vs/platform/files/node/files*/,76/*vs/workbench/services/search/node/fileSearch*/,174/*vs/workbench/services/search/node/legacy/textSearch*/,176/*vs/workbench/services/search/node/legacy/textSearchWorkerProvider*/,40/*vs/workbench/services/search/node/textSearchManager*/]), function (require, exports, fs, gracefulFs, files_1, fileSearch_1, textSearch_1, textSearchWorkerProvider_1, textSearchManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    gracefulFs.gracefulify(fs);
    var LegacyTextSearchService = /** @class */ (function () {
        function LegacyTextSearchService() {
        }
        LegacyTextSearchService.prototype.textSearch = function (config, progressCallback, token) {
            if (!this.textSearchWorkerProvider) {
                this.textSearchWorkerProvider = new textSearchWorkerProvider_1.TextSearchWorkerProvider();
            }
            var engine = new textSearch_1.Engine(config, new fileSearch_1.FileWalker({
                type: 1 /* File */,
                folderQueries: config.folderQueries,
                extraFileResources: config.extraFileResources,
                includePattern: config.includePattern,
                excludePattern: config.excludePattern,
                useRipgrep: false
            }, files_1.MAX_FILE_SIZE), this.textSearchWorkerProvider);
            return this.doTextSearch(engine, progressCallback, LegacyTextSearchService.BATCH_SIZE, token);
        };
        LegacyTextSearchService.prototype.doTextSearch = function (engine, progressCallback, batchSize, token) {
            if (token) {
                token.onCancellationRequested(function () { return engine.cancel(); });
            }
            return new Promise(function (c, e) {
                // Use BatchedCollector to get new results to the frontend every 2s at least, until 50 results have been returned
                var collector = new textSearchManager_1.BatchedCollector(batchSize, progressCallback);
                engine.search(function (matches) {
                    var totalMatches = matches.reduce(function (acc, m) { return acc + m.numMatches; }, 0);
                    collector.addItems(matches, totalMatches);
                }, function (progress) {
                    progressCallback(progress);
                }, function (error, stats) {
                    collector.flush();
                    if (error) {
                        e(error);
                    }
                    else {
                        c({
                            type: 'success',
                            limitHit: stats.limitHit,
                            stats: null
                        });
                    }
                });
            });
        };
        LegacyTextSearchService.BATCH_SIZE = 512;
        return LegacyTextSearchService;
    }());
    exports.LegacyTextSearchService = LegacyTextSearchService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
























define(__m[51/*vs/workbench/services/search/node/ripgrepTextSearchEngine*/], __M([1/*require*/,0/*exports*/,25/*child_process*/,197/*events*/,10/*path*/,57/*string_decoder*/,5/*vs/base/common/strings*/,2/*vs/base/common/uri*/,41/*vs/platform/search/common/search*/,184/*vscode-ripgrep*/,39/*vs/workbench/services/search/node/ripgrepSearchUtils*/]), function (require, exports, cp, events_1, path, string_decoder_1, strings_1, uri_1, search_1, vscode_ripgrep_1, ripgrepSearchUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // If vscode-ripgrep is in an .asar file, then the binary is unpacked.
    var rgDiskPath = vscode_ripgrep_1.rgPath.replace(/\bnode_modules\.asar\b/, 'node_modules.asar.unpacked');
    var RipgrepTextSearchEngine = /** @class */ (function () {
        function RipgrepTextSearchEngine(outputChannel) {
            this.outputChannel = outputChannel;
        }
        RipgrepTextSearchEngine.prototype.provideTextSearchResults = function (query, options, progress, token) {
            var _this = this;
            this.outputChannel.appendLine("provideTextSearchResults " + query.pattern + ", " + JSON.stringify(__assign({}, options, {
                folder: options.folder.toString()
            })));
            return new Promise(function (resolve, reject) {
                token.onCancellationRequested(function () { return cancel(); });
                var rgArgs = getRgArgs(query, options);
                var cwd = options.folder.fsPath;
                var escapedArgs = rgArgs
                    .map(function (arg) { return arg.match(/^-/) ? arg : "'" + arg + "'"; })
                    .join(' ');
                _this.outputChannel.appendLine("rg " + escapedArgs + "\n - cwd: " + cwd);
                var rgProc = cp.spawn(rgDiskPath, rgArgs, { cwd: cwd });
                rgProc.on('error', function (e) {
                    console.error(e);
                    _this.outputChannel.appendLine('Error: ' + (e && e.message));
                    reject(search_1.serializeSearchError(new search_1.SearchError(e && e.message, search_1.SearchErrorCode.rgProcessError)));
                });
                var gotResult = false;
                var ripgrepParser = new RipgrepParser(options.maxResults, cwd, options.previewOptions);
                ripgrepParser.on('result', function (match) {
                    gotResult = true;
                    progress.report(match);
                });
                var isDone = false;
                var cancel = function () {
                    isDone = true;
                    if (rgProc) {
                        rgProc.kill();
                    }
                    if (ripgrepParser) {
                        ripgrepParser.cancel();
                    }
                };
                var limitHit = false;
                ripgrepParser.on('hitLimit', function () {
                    limitHit = true;
                    cancel();
                });
                rgProc.stdout.on('data', function (data) {
                    ripgrepParser.handleData(data);
                });
                var gotData = false;
                rgProc.stdout.once('data', function () { return gotData = true; });
                var stderr = '';
                rgProc.stderr.on('data', function (data) {
                    var message = data.toString();
                    _this.outputChannel.appendLine(message);
                    stderr += message;
                });
                rgProc.on('close', function () {
                    _this.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');
                    _this.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');
                    _this.outputChannel.appendLine('');
                    if (isDone) {
                        resolve({ limitHit: limitHit });
                    }
                    else {
                        // Trigger last result
                        ripgrepParser.flush();
                        rgProc = null;
                        var searchError = void 0;
                        if (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {
                            reject(search_1.serializeSearchError(new search_1.SearchError(searchError.message, searchError.code)));
                        }
                        else {
                            resolve({ limitHit: limitHit });
                        }
                    }
                });
            });
        };
        return RipgrepTextSearchEngine;
    }());
    exports.RipgrepTextSearchEngine = RipgrepTextSearchEngine;
    /**
     * Read the first line of stderr and return an error for display or undefined, based on a whitelist.
     * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be
     * "failed" when a fatal error was produced.
     */
    function rgErrorMsgForDisplay(msg) {
        var firstLine = msg.split('\n')[0].trim();
        if (strings_1.startsWith(firstLine, 'regex parse error')) {
            return new search_1.SearchError('Regex parse error', search_1.SearchErrorCode.regexParseError);
        }
        var match = firstLine.match(/grep config error: unknown encoding: (.*)/);
        if (match) {
            return new search_1.SearchError("Unknown encoding: " + match[1], search_1.SearchErrorCode.unknownEncoding);
        }
        if (strings_1.startsWith(firstLine, 'error parsing glob')) {
            // Uppercase first letter
            return new search_1.SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), search_1.SearchErrorCode.globParseError);
        }
        if (strings_1.startsWith(firstLine, 'the literal')) {
            // Uppercase first letter
            return new search_1.SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), search_1.SearchErrorCode.invalidLiteral);
        }
        return undefined;
    }
    exports.rgErrorMsgForDisplay = rgErrorMsgForDisplay;
    var RipgrepParser = /** @class */ (function (_super) {
        __extends(RipgrepParser, _super);
        function RipgrepParser(maxResults, rootFolder, previewOptions) {
            var _this = _super.call(this) || this;
            _this.maxResults = maxResults;
            _this.rootFolder = rootFolder;
            _this.previewOptions = previewOptions;
            _this.remainder = '';
            _this.isDone = false;
            _this.hitLimit = false;
            _this.numResults = 0;
            _this.stringDecoder = new string_decoder_1.StringDecoder();
            return _this;
        }
        RipgrepParser.prototype.cancel = function () {
            this.isDone = true;
        };
        RipgrepParser.prototype.flush = function () {
            this.handleDecodedData(this.stringDecoder.end());
        };
        RipgrepParser.prototype.handleData = function (data) {
            var dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);
            this.handleDecodedData(dataStr);
        };
        RipgrepParser.prototype.handleDecodedData = function (decodedData) {
            // If the previous data chunk didn't end in a newline, prepend it to this chunk
            var dataStr = this.remainder ?
                this.remainder + decodedData :
                decodedData;
            var dataLines = dataStr.split(/\r\n|\n/);
            this.remainder = dataLines[dataLines.length - 1] ? dataLines.pop() : '';
            for (var l = 0; l < dataLines.length; l++) {
                var line = dataLines[l];
                if (line) { // Empty line at the end of each chunk
                    this.handleLine(line);
                }
            }
        };
        RipgrepParser.prototype.handleLine = function (outputLine) {
            var _this = this;
            if (this.isDone) {
                return;
            }
            var parsedLine;
            try {
                parsedLine = JSON.parse(outputLine);
            }
            catch (e) {
                throw new Error("malformed line from rg: " + outputLine);
            }
            if (parsedLine.type === 'match') {
                var matchPath = bytesOrTextToString(parsedLine.data.path);
                var uri = uri_1.URI.file(path.join(this.rootFolder, matchPath));
                var result = this.createTextSearchMatch(parsedLine.data, uri);
                this.onResult(result);
                if (this.hitLimit) {
                    this.cancel();
                    this.emit('hitLimit');
                }
            }
            else if (parsedLine.type === 'context') {
                var contextPath = bytesOrTextToString(parsedLine.data.path);
                var uri = uri_1.URI.file(path.join(this.rootFolder, contextPath));
                var result = this.createTextSearchContext(parsedLine.data, uri);
                result.forEach(function (r) { return _this.onResult(r); });
            }
        };
        RipgrepParser.prototype.createTextSearchMatch = function (data, uri) {
            var _this = this;
            var lineNumber = data.line_number - 1;
            var fullText = bytesOrTextToString(data.lines);
            var fullTextBytes = Buffer.from(fullText);
            var prevMatchEnd = 0;
            var prevMatchEndCol = 0;
            var prevMatchEndLine = lineNumber;
            var ranges = data.submatches.map(function (match, i) {
                if (_this.hitLimit) {
                    return null;
                }
                _this.numResults++;
                if (_this.numResults >= _this.maxResults) {
                    // Finish the line, then report the result below
                    _this.hitLimit = true;
                }
                var matchText = bytesOrTextToString(match.match);
                var inBetweenChars = fullTextBytes.slice(prevMatchEnd, match.start).toString().length;
                var startCol = prevMatchEndCol + inBetweenChars;
                var stats = getNumLinesAndLastNewlineLength(matchText);
                var startLineNumber = prevMatchEndLine;
                var endLineNumber = stats.numLines + startLineNumber;
                var endCol = stats.numLines > 0 ?
                    stats.lastLineLength :
                    stats.lastLineLength + startCol;
                if (lineNumber === 0 && i === 0 && strings_1.startsWithUTF8BOM(matchText)) {
                    matchText = strings_1.stripUTF8BOM(matchText);
                    startCol -= 3;
                    endCol -= 3;
                }
                prevMatchEnd = match.end;
                prevMatchEndCol = endCol;
                prevMatchEndLine = endLineNumber;
                return new ripgrepSearchUtils_1.Range(startLineNumber, startCol, endLineNumber, endCol);
            })
                .filter(function (r) { return !!r; });
            return ripgrepSearchUtils_1.createTextSearchResult(uri, fullText, ranges, this.previewOptions);
        };
        RipgrepParser.prototype.createTextSearchContext = function (data, uri) {
            var text = bytesOrTextToString(data.lines);
            var startLine = data.line_number;
            return text
                .replace(/\r?\n$/, '')
                .split('\n')
                .map(function (line, i) {
                return {
                    text: line,
                    uri: uri,
                    lineNumber: startLine + i
                };
            });
        };
        RipgrepParser.prototype.onResult = function (match) {
            this.emit('result', match);
        };
        return RipgrepParser;
    }(events_1.EventEmitter));
    exports.RipgrepParser = RipgrepParser;
    function bytesOrTextToString(obj) {
        return obj.bytes ?
            Buffer.from(obj.bytes, 'base64').toString() :
            obj.text;
    }
    function getNumLinesAndLastNewlineLength(text) {
        var re = /\n/g;
        var numLines = 0;
        var lastNewlineIdx = -1;
        var match;
        while (match = re.exec(text)) {
            numLines++;
            lastNewlineIdx = match.index;
        }
        var lastLineLength = lastNewlineIdx >= 0 ?
            text.length - lastNewlineIdx - 1 :
            text.length;
        return { numLines: numLines, lastLineLength: lastLineLength };
    }
    function getRgArgs(query, options) {
        var args = ['--hidden', '--heading', '--line-number', '--color', 'ansi', '--colors', 'path:none', '--colors', 'line:none', '--colors', 'match:fg:red', '--colors', 'match:style:nobold'];
        args.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');
        options.includes
            .map(ripgrepSearchUtils_1.anchorGlob)
            .forEach(function (globArg) { return args.push('-g', globArg); });
        options.excludes
            .map(ripgrepSearchUtils_1.anchorGlob)
            .forEach(function (rgGlob) { return args.push('-g', "!" + rgGlob); });
        if (options.maxFileSize) {
            args.push('--max-filesize', options.maxFileSize + '');
        }
        if (options.useIgnoreFiles) {
            args.push('--no-ignore-parent');
        }
        else {
            // Don't use .gitignore or .ignore
            args.push('--no-ignore');
        }
        if (options.followSymlinks) {
            args.push('--follow');
        }
        if (options.encoding) {
            args.push('--encoding', options.encoding);
        }
        var pattern = query.pattern;
        // Ripgrep handles -- as a -- arg separator. Only --.
        // - is ok, --- is ok, --some-flag is also ok. Need to special case.
        if (pattern === '--') {
            query.isRegExp = true;
            pattern = '\\-\\-';
        }
        if (options.usePCRE2) {
            args.push('--pcre2');
            if (query.isRegExp) {
                pattern = unicodeEscapesToPCRE2(pattern);
            }
        }
        var searchPatternAfterDoubleDashes;
        if (query.isWordMatch) {
            var regexp = strings_1.createRegExp(pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });
            var regexpStr = regexp.source.replace(/\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.
            args.push('--regexp', regexpStr);
        }
        else if (query.isRegExp) {
            args.push('--regexp', fixRegexEndingPattern(query.pattern));
        }
        else {
            searchPatternAfterDoubleDashes = pattern;
            args.push('--fixed-strings');
        }
        args.push('--no-config');
        if (!options.useGlobalIgnoreFiles) {
            args.push('--no-ignore-global');
        }
        args.push('--json');
        if (query.isMultiline) {
            args.push('--multiline');
        }
        if (options.beforeContext) {
            args.push('--before-context', options.beforeContext + '');
        }
        if (options.afterContext) {
            args.push('--after-context', options.afterContext + '');
        }
        // Folder to search
        args.push('--');
        if (searchPatternAfterDoubleDashes) {
            // Put the query after --, in case the query starts with a dash
            args.push(searchPatternAfterDoubleDashes);
        }
        args.push('.');
        return args;
    }
    function unicodeEscapesToPCRE2(pattern) {
        var reg = /((?:[^\\]|^)(?:\\\\)*)\\u([a-z0-9]{4})(?!\d)/g;
        // Replace an unescaped $ at the end of the pattern with \r?$
        // Match $ preceeded by none or even number of literal \
        while (pattern.match(reg)) {
            pattern = pattern.replace(reg, "$1\\x{$2}");
        }
        return pattern;
    }
    exports.unicodeEscapesToPCRE2 = unicodeEscapesToPCRE2;
    function fixRegexEndingPattern(pattern) {
        // Replace an unescaped $ at the end of the pattern with \r?$
        // Match $ preceeded by none or even number of literal \
        return pattern.match(/([^\\]|^)(\\\\)*\$$/) ?
            pattern.replace(/\$$/, '\\r?$') :
            pattern;
    }
    exports.fixRegexEndingPattern = fixRegexEndingPattern;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[189/*vs/workbench/services/search/node/ripgrepSearchProvider*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/cancellation*/,51/*vs/workbench/services/search/node/ripgrepTextSearchEngine*/]), function (require, exports, cancellation_1, ripgrepTextSearchEngine_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var RipgrepSearchProvider = /** @class */ (function () {
        function RipgrepSearchProvider(outputChannel) {
            var _this = this;
            this.outputChannel = outputChannel;
            this.inProgress = new Set();
            process.once('exit', function () { return _this.dispose(); });
        }
        RipgrepSearchProvider.prototype.provideTextSearchResults = function (query, options, progress, token) {
            var engine = new ripgrepTextSearchEngine_1.RipgrepTextSearchEngine(this.outputChannel);
            return this.withToken(token, function (token) { return engine.provideTextSearchResults(query, options, progress, token); });
        };
        RipgrepSearchProvider.prototype.withToken = function (token, fn) {
            return __awaiter(this, void 0, void 0, function () {
                var merged, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            merged = mergedTokenSource(token);
                            this.inProgress.add(merged);
                            return [4 /*yield*/, fn(merged.token)];
                        case 1:
                            result = _a.sent();
                            this.inProgress.delete(merged);
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        RipgrepSearchProvider.prototype.dispose = function () {
            this.inProgress.forEach(function (engine) { return engine.cancel(); });
        };
        return RipgrepSearchProvider;
    }());
    exports.RipgrepSearchProvider = RipgrepSearchProvider;
    function mergedTokenSource(token) {
        var tokenSource = new cancellation_1.CancellationTokenSource();
        token.onCancellationRequested(function () { return tokenSource.cancel(); });
        return tokenSource;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[190/*vs/workbench/services/search/node/textSearchAdapter*/], __M([1/*require*/,0/*exports*/,31/*vs/base/node/extfs*/,51/*vs/workbench/services/search/node/ripgrepTextSearchEngine*/,40/*vs/workbench/services/search/node/textSearchManager*/]), function (require, exports, extfs, ripgrepTextSearchEngine_1, textSearchManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TextSearchEngineAdapter = /** @class */ (function () {
        function TextSearchEngineAdapter(query) {
            this.query = query;
        }
        TextSearchEngineAdapter.prototype.search = function (token, onResult, onMessage) {
            if (!this.query.folderQueries.length && !this.query.extraFileResources.length) {
                return Promise.resolve({
                    type: 'success',
                    limitHit: false,
                    stats: {
                        type: 'searchProcess'
                    }
                });
            }
            var pretendOutputChannel = {
                appendLine: function (msg) {
                    onMessage({ message: msg });
                }
            };
            var textSearchManager = new textSearchManager_1.TextSearchManager(this.query, new ripgrepTextSearchEngine_1.RipgrepTextSearchEngine(pretendOutputChannel), extfs);
            return new Promise(function (resolve, reject) {
                return textSearchManager
                    .search(function (matches) {
                    onResult(matches.map(fileMatchToSerialized));
                }, token)
                    .then(function (c) { return resolve({ limitHit: c.limitHit, stats: null, type: 'success' }); }, reject);
            });
        };
        return TextSearchEngineAdapter;
    }());
    exports.TextSearchEngineAdapter = TextSearchEngineAdapter;
    function fileMatchToSerialized(match) {
        return {
            path: match.resource.fsPath,
            results: match.results,
            numMatches: match.results.reduce(function (sum, r) {
                if (!!r.ranges) {
                    var m = r;
                    return sum + (Array.isArray(m.ranges) ? m.ranges.length : 1);
                }
                else {
                    return sum + 1;
                }
            }, 0)
        };
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[191/*vs/workbench/services/search/node/rawSearchService*/], __M([1/*require*/,0/*exports*/,27/*fs*/,187/*graceful-fs*/,10/*path*/,9/*vs/base/common/arrays*/,11/*vs/base/common/async*/,14/*vs/base/common/errors*/,3/*vs/base/common/event*/,13/*vs/base/common/objects*/,36/*vs/base/common/stopwatch*/,5/*vs/base/common/strings*/,2/*vs/base/common/uri*/,20/*vs/base/common/winjs.base*/,52/*vs/base/parts/quickopen/common/quickOpenScorer*/,58/*vs/platform/files/node/files*/,76/*vs/workbench/services/search/node/fileSearch*/,186/*vs/workbench/services/search/node/legacy/rawLegacyTextSearchService*/,190/*vs/workbench/services/search/node/textSearchAdapter*/]), function (require, exports, fs, gracefulFs, path_1, arrays, async_1, errors_1, event_1, objects, stopwatch_1, strings, uri_1, winjs_base_1, quickOpenScorer_1, files_1, fileSearch_1, rawLegacyTextSearchService_1, textSearchAdapter_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    gracefulFs.gracefulify(fs);
    var SearchService = /** @class */ (function () {
        function SearchService() {
            this.legacyTextSearchService = new rawLegacyTextSearchService_1.LegacyTextSearchService();
            this.caches = Object.create(null);
        }
        SearchService.prototype.fileSearch = function (config) {
            var _this = this;
            var promise;
            var query = reviveQuery(config);
            var emitter = new event_1.Emitter({
                onFirstListenerDidAdd: function () {
                    promise = async_1.createCancelablePromise(function (token) {
                        return _this.doFileSearchWithEngine(fileSearch_1.Engine, query, function (p) { return emitter.fire(p); }, token);
                    });
                    promise.then(function (c) { return emitter.fire(c); }, function (err) { return emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }); });
                },
                onLastListenerRemove: function () {
                    promise.cancel();
                }
            });
            return emitter.event;
        };
        SearchService.prototype.textSearch = function (rawQuery) {
            var _this = this;
            var promise;
            var query = reviveQuery(rawQuery);
            var emitter = new event_1.Emitter({
                onFirstListenerDidAdd: function () {
                    promise = async_1.createCancelablePromise(function (token) {
                        return (rawQuery.useRipgrep ?
                            _this.ripgrepTextSearch(query, function (p) { return emitter.fire(p); }, token) :
                            _this.legacyTextSearchService.textSearch(query, function (p) { return emitter.fire(p); }, token));
                    });
                    promise.then(function (c) { return emitter.fire(c); }, function (err) { return emitter.fire({ type: 'error', error: { message: err.message, stack: err.stack } }); });
                },
                onLastListenerRemove: function () {
                    promise.cancel();
                }
            });
            return emitter.event;
        };
        SearchService.prototype.ripgrepTextSearch = function (config, progressCallback, token) {
            config.maxFileSize = files_1.MAX_FILE_SIZE;
            var engine = new textSearchAdapter_1.TextSearchEngineAdapter(config);
            return engine.search(token, progressCallback, progressCallback);
        };
        SearchService.prototype.doFileSearch = function (config, progressCallback, token) {
            return this.doFileSearchWithEngine(fileSearch_1.Engine, config, progressCallback, token);
        };
        SearchService.prototype.doFileSearchWithEngine = function (EngineClass, config, progressCallback, token, batchSize) {
            var _this = this;
            if (batchSize === void 0) { batchSize = SearchService.BATCH_SIZE; }
            var resultCount = 0;
            var fileProgressCallback = function (progress) {
                if (Array.isArray(progress)) {
                    resultCount += progress.length;
                    progressCallback(progress.map(function (m) { return _this.rawMatchToSearchItem(m); }));
                }
                else if (progress.relativePath) {
                    resultCount++;
                    progressCallback(_this.rawMatchToSearchItem(progress));
                }
                else {
                    progressCallback(progress);
                }
            };
            if (config.sortByScore) {
                var sortedSearch_1 = this.trySortedSearchFromCache(config, fileProgressCallback, token);
                if (!sortedSearch_1) {
                    var walkerConfig = config.maxResults ? objects.assign({}, config, { maxResults: null }) : config;
                    var engine_1 = new EngineClass(walkerConfig);
                    sortedSearch_1 = this.doSortedSearch(engine_1, config, progressCallback, fileProgressCallback, token);
                }
                return new winjs_base_1.TPromise(function (c, e) {
                    sortedSearch_1.then(function (_a) {
                        var result = _a[0], rawMatches = _a[1];
                        var serializedMatches = rawMatches.map(function (rawMatch) { return _this.rawMatchToSearchItem(rawMatch); });
                        _this.sendProgress(serializedMatches, progressCallback, batchSize);
                        c(result);
                    }, e);
                });
            }
            var engine = new EngineClass(config);
            return this.doSearch(engine, fileProgressCallback, batchSize, token).then(function (complete) {
                return {
                    limitHit: complete.limitHit,
                    type: 'success',
                    stats: {
                        detailStats: complete.stats,
                        type: 'searchProcess',
                        fromCache: false,
                        resultCount: resultCount,
                        sortingTime: undefined
                    }
                };
            });
        };
        SearchService.prototype.rawMatchToSearchItem = function (match) {
            return { path: match.base ? path_1.join(match.base, match.relativePath) : match.relativePath };
        };
        SearchService.prototype.doSortedSearch = function (engine, config, progressCallback, fileProgressCallback, token) {
            var _this = this;
            var emitter = new event_1.Emitter();
            var allResultsPromise = async_1.createCancelablePromise(function (token) {
                var results = [];
                var innerProgressCallback = function (progress) {
                    if (Array.isArray(progress)) {
                        results = progress;
                    }
                    else {
                        fileProgressCallback(progress);
                        emitter.fire(progress);
                    }
                };
                return _this.doSearch(engine, innerProgressCallback, -1, token)
                    .then(function (result) {
                    return [result, results];
                });
            });
            var cache;
            if (config.cacheKey) {
                cache = this.getOrCreateCache(config.cacheKey);
                var cacheRow_1 = {
                    promise: allResultsPromise,
                    event: emitter.event,
                    resolved: false
                };
                cache.resultsToSearchCache[config.filePattern] = cacheRow_1;
                allResultsPromise.then(function () {
                    cacheRow_1.resolved = true;
                }, function (err) {
                    delete cache.resultsToSearchCache[config.filePattern];
                });
                allResultsPromise = this.preventCancellation(allResultsPromise);
            }
            return winjs_base_1.TPromise.wrap(allResultsPromise.then(function (_a) {
                var result = _a[0], results = _a[1];
                var scorerCache = cache ? cache.scorerCache : Object.create(null);
                var sortSW = (typeof config.maxResults !== 'number' || config.maxResults > 0) && stopwatch_1.StopWatch.create(false);
                return _this.sortResults(config, results, scorerCache, token)
                    .then(function (sortedResults) {
                    // sortingTime: -1 indicates a "sorted" search that was not sorted, i.e. populating the cache when quickopen is opened.
                    // Contrasting with findFiles which is not sorted and will have sortingTime: undefined
                    var sortingTime = sortSW ? sortSW.elapsed() : -1;
                    return [{
                            type: 'success',
                            stats: {
                                detailStats: result.stats,
                                sortingTime: sortingTime,
                                fromCache: false,
                                type: 'searchProcess',
                                workspaceFolderCount: config.folderQueries.length,
                                resultCount: sortedResults.length
                            },
                            limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults
                        }, sortedResults];
                });
            }));
        };
        SearchService.prototype.getOrCreateCache = function (cacheKey) {
            var existing = this.caches[cacheKey];
            if (existing) {
                return existing;
            }
            return this.caches[cacheKey] = new Cache();
        };
        SearchService.prototype.trySortedSearchFromCache = function (config, progressCallback, token) {
            var _this = this;
            var cache = config.cacheKey && this.caches[config.cacheKey];
            if (!cache) {
                return undefined;
            }
            var cached = this.getResultsFromCache(cache, config.filePattern, progressCallback, token);
            if (cached) {
                return cached.then(function (_a) {
                    var result = _a[0], results = _a[1], cacheStats = _a[2];
                    var sortSW = stopwatch_1.StopWatch.create(false);
                    return _this.sortResults(config, results, cache.scorerCache, token)
                        .then(function (sortedResults) {
                        var sortingTime = sortSW.elapsed();
                        var stats = {
                            fromCache: true,
                            detailStats: cacheStats,
                            type: 'searchProcess',
                            resultCount: results.length,
                            sortingTime: sortingTime
                        };
                        return [
                            {
                                type: 'success',
                                limitHit: result.limitHit || typeof config.maxResults === 'number' && results.length > config.maxResults,
                                stats: stats
                            },
                            sortedResults
                        ];
                    });
                });
            }
            return undefined;
        };
        SearchService.prototype.sortResults = function (config, results, scorerCache, token) {
            // we use the same compare function that is used later when showing the results using fuzzy scoring
            // this is very important because we are also limiting the number of results by config.maxResults
            // and as such we want the top items to be included in this result set if the number of items
            // exceeds config.maxResults.
            var query = quickOpenScorer_1.prepareQuery(config.filePattern);
            var compare = function (matchA, matchB) { return quickOpenScorer_1.compareItemsByScore(matchA, matchB, query, true, FileMatchItemAccessor, scorerCache); };
            return arrays.topAsync(results, compare, config.maxResults, 10000, token);
        };
        SearchService.prototype.sendProgress = function (results, progressCb, batchSize) {
            if (batchSize && batchSize > 0) {
                for (var i = 0; i < results.length; i += batchSize) {
                    progressCb(results.slice(i, i + batchSize));
                }
            }
            else {
                progressCb(results);
            }
        };
        SearchService.prototype.getResultsFromCache = function (cache, searchValue, progressCallback, token) {
            var cacheLookupSW = stopwatch_1.StopWatch.create(false);
            // Find cache entries by prefix of search value
            var hasPathSep = searchValue.indexOf(path_1.sep) >= 0;
            var cachedRow;
            for (var previousSearch in cache.resultsToSearchCache) {
                // If we narrow down, we might be able to reuse the cached results
                if (strings.startsWith(searchValue, previousSearch)) {
                    if (hasPathSep && previousSearch.indexOf(path_1.sep) < 0) {
                        continue; // since a path character widens the search for potential more matches, require it in previous search too
                    }
                    var row = cache.resultsToSearchCache[previousSearch];
                    cachedRow = {
                        promise: this.preventCancellation(row.promise),
                        event: row.event,
                        resolved: row.resolved
                    };
                    break;
                }
            }
            if (!cachedRow) {
                return null;
            }
            var cacheLookupTime = cacheLookupSW.elapsed();
            var cacheFilterSW = stopwatch_1.StopWatch.create(false);
            var listener = cachedRow.event(progressCallback);
            if (token) {
                token.onCancellationRequested(function () {
                    listener.dispose();
                });
            }
            return winjs_base_1.TPromise.wrap(cachedRow.promise.then(function (_a) {
                var complete = _a[0], cachedEntries = _a[1];
                if (token && token.isCancellationRequested) {
                    throw errors_1.canceled();
                }
                // Pattern match on results
                var results = [];
                var normalizedSearchValueLowercase = strings.stripWildcards(searchValue).toLowerCase();
                for (var i = 0; i < cachedEntries.length; i++) {
                    var entry = cachedEntries[i];
                    // Check if this entry is a match for the search value
                    if (!strings.fuzzyContains(entry.relativePath, normalizedSearchValueLowercase)) {
                        continue;
                    }
                    results.push(entry);
                }
                return [complete, results, {
                        cacheWasResolved: cachedRow.resolved,
                        cacheLookupTime: cacheLookupTime,
                        cacheFilterTime: cacheFilterSW.elapsed(),
                        cacheEntryCount: cachedEntries.length
                    }];
            }));
        };
        SearchService.prototype.doSearch = function (engine, progressCallback, batchSize, token) {
            return new winjs_base_1.TPromise(function (c, e) {
                var batch = [];
                if (token) {
                    token.onCancellationRequested(function () { return engine.cancel(); });
                }
                engine.search(function (match) {
                    if (match) {
                        if (batchSize) {
                            batch.push(match);
                            if (batchSize > 0 && batch.length >= batchSize) {
                                progressCallback(batch);
                                batch = [];
                            }
                        }
                        else {
                            progressCallback(match);
                        }
                    }
                }, function (progress) {
                    progressCallback(progress);
                }, function (error, complete) {
                    if (batch.length) {
                        progressCallback(batch);
                    }
                    if (error) {
                        e(error);
                    }
                    else {
                        c(complete);
                    }
                });
            });
        };
        SearchService.prototype.clearCache = function (cacheKey) {
            delete this.caches[cacheKey];
            return winjs_base_1.TPromise.as(undefined);
        };
        /**
         * Return a CancelablePromise which is not actually cancelable
         * TODO@rob - Is this really needed?
         */
        SearchService.prototype.preventCancellation = function (promise) {
            return new /** @class */ (function () {
                function class_1() {
                }
                class_1.prototype.cancel = function () {
                    // Do nothing
                };
                class_1.prototype.then = function (resolve, reject) {
                    return promise.then(resolve, reject);
                };
                class_1.prototype.catch = function (reject) {
                    return this.then(undefined, reject);
                };
                return class_1;
            }());
        };
        SearchService.BATCH_SIZE = 512;
        return SearchService;
    }());
    exports.SearchService = SearchService;
    var Cache = /** @class */ (function () {
        function Cache() {
            this.resultsToSearchCache = Object.create(null);
            this.scorerCache = Object.create(null);
        }
        return Cache;
    }());
    var FileMatchItemAccessor = new /** @class */ (function () {
        function class_2() {
        }
        class_2.prototype.getItemLabel = function (match) {
            return match.basename; // e.g. myFile.txt
        };
        class_2.prototype.getItemDescription = function (match) {
            return match.relativePath.substr(0, match.relativePath.length - match.basename.length - 1); // e.g. some/path/to/file
        };
        class_2.prototype.getItemPath = function (match) {
            return match.relativePath; // e.g. some/path/to/file/myFile.txt
        };
        return class_2;
    }());
    function reviveQuery(rawQuery) {
        return __assign({}, rawQuery, {
            folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
            extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(function (components) { return uri_1.URI.revive(components); })
        });
    }
    function reviveFolderQuery(rawFolderQuery) {
        return __assign({}, rawFolderQuery, { folder: uri_1.URI.revive(rawFolderQuery.folder) });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[192/*vs/workbench/api/node/extHostSearch*/], __M([1/*require*/,0/*exports*/,8/*vs/base/common/lifecycle*/,2/*vs/base/common/uri*/,31/*vs/base/node/extfs*/,179/*vs/workbench/api/node/extHostSearch.fileIndex*/,180/*vs/workbench/services/search/node/fileSearchManager*/,191/*vs/workbench/services/search/node/rawSearchService*/,189/*vs/workbench/services/search/node/ripgrepSearchProvider*/,39/*vs/workbench/services/search/node/ripgrepSearchUtils*/,32/*vs/workbench/services/search/node/search*/,40/*vs/workbench/services/search/node/textSearchManager*/,4/*vs/workbench/api/node/extHost.protocol*/]), function (require, exports, lifecycle_1, uri_1, extfs, extHostSearch_fileIndex_1, fileSearchManager_1, rawSearchService_1, ripgrepSearchProvider_1, ripgrepSearchUtils_1, search_1, textSearchManager_1, extHost_protocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtHostSearch = /** @class */ (function () {
        function ExtHostSearch(mainContext, _schemeTransformer, _logService, configService, _extfs) {
            if (_extfs === void 0) { _extfs = extfs; }
            this._schemeTransformer = _schemeTransformer;
            this._logService = _logService;
            this._extfs = _extfs;
            this._textSearchProvider = new Map();
            this._textSearchUsedSchemes = new Set();
            this._fileSearchProvider = new Map();
            this._fileSearchUsedSchemes = new Set();
            this._fileIndexProvider = new Map();
            this._fileIndexUsedSchemes = new Set();
            this._handlePool = 0;
            this._proxy = mainContext.getProxy(extHost_protocol_1.MainContext.MainThreadSearch);
            this._fileSearchManager = new fileSearchManager_1.FileSearchManager();
            this._fileIndexSearchManager = new extHostSearch_fileIndex_1.FileIndexSearchManager();
            registerEHProviders(this, _logService, configService);
        }
        ExtHostSearch.prototype._transformScheme = function (scheme) {
            if (this._schemeTransformer) {
                return this._schemeTransformer.transformOutgoing(scheme);
            }
            return scheme;
        };
        ExtHostSearch.prototype.registerTextSearchProvider = function (scheme, provider) {
            var _this = this;
            if (this._textSearchUsedSchemes.has(scheme)) {
                throw new Error("a provider for the scheme '" + scheme + "' is already registered");
            }
            this._textSearchUsedSchemes.add(scheme);
            var handle = this._handlePool++;
            this._textSearchProvider.set(handle, provider);
            this._proxy.$registerTextSearchProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._textSearchUsedSchemes.delete(scheme);
                _this._textSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostSearch.prototype.registerFileSearchProvider = function (scheme, provider) {
            var _this = this;
            if (this._fileSearchUsedSchemes.has(scheme)) {
                throw new Error("a provider for the scheme '" + scheme + "' is already registered");
            }
            this._fileSearchUsedSchemes.add(scheme);
            var handle = this._handlePool++;
            this._fileSearchProvider.set(handle, provider);
            this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._fileSearchUsedSchemes.delete(scheme);
                _this._fileSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostSearch.prototype.registerInternalFileSearchProvider = function (scheme, provider) {
            var _this = this;
            var handle = this._handlePool++;
            this._internalFileSearchProvider = provider;
            this._internalFileSearchHandle = handle;
            this._proxy.$registerFileSearchProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._internalFileSearchProvider = null;
                _this._proxy.$unregisterProvider(handle);
            });
        };
        ExtHostSearch.prototype.registerFileIndexProvider = function (scheme, provider) {
            var _this = this;
            if (this._fileIndexUsedSchemes.has(scheme)) {
                throw new Error("a provider for the scheme '" + scheme + "' is already registered");
            }
            this._fileIndexUsedSchemes.add(scheme);
            var handle = this._handlePool++;
            this._fileIndexProvider.set(handle, provider);
            this._proxy.$registerFileIndexProvider(handle, this._transformScheme(scheme));
            return lifecycle_1.toDisposable(function () {
                _this._fileIndexUsedSchemes.delete(scheme);
                _this._fileSearchProvider.delete(handle);
                _this._proxy.$unregisterProvider(handle); // TODO@roblou - unregisterFileIndexProvider
            });
        };
        ExtHostSearch.prototype.$provideFileSearchResults = function (handle, session, rawQuery, token) {
            var _this = this;
            var query = reviveQuery(rawQuery);
            if (handle === this._internalFileSearchHandle) {
                return this.doInternalFileSearch(handle, session, query, token);
            }
            else {
                var provider = this._fileSearchProvider.get(handle);
                if (provider) {
                    return this._fileSearchManager.fileSearch(query, provider, function (batch) {
                        _this._proxy.$handleFileMatch(handle, session, batch.map(function (p) { return p.resource; }));
                    }, token);
                }
                else {
                    var indexProvider = this._fileIndexProvider.get(handle);
                    return this._fileIndexSearchManager.fileSearch(query, indexProvider, function (batch) {
                        _this._proxy.$handleFileMatch(handle, session, batch.map(function (p) { return p.resource; }));
                    }, token);
                }
            }
        };
        ExtHostSearch.prototype.doInternalFileSearch = function (handle, session, rawQuery, token) {
            var _this = this;
            var onResult = function (ev) {
                if (search_1.isSerializedFileMatch(ev)) {
                    ev = [ev];
                }
                if (Array.isArray(ev)) {
                    _this._proxy.$handleFileMatch(handle, session, ev.map(function (m) { return uri_1.URI.file(m.path); }));
                    return;
                }
                if (ev.message) {
                    _this._logService.debug('ExtHostSearch', ev.message);
                }
            };
            return this._internalFileSearchProvider.doFileSearch(rawQuery, onResult, token);
        };
        ExtHostSearch.prototype.$clearCache = function (cacheKey) {
            if (this._internalFileSearchProvider) {
                this._internalFileSearchProvider.clearCache(cacheKey);
            }
            // Actually called once per provider.
            // Only relevant to file index search.
            return this._fileIndexSearchManager.clearCache(cacheKey);
        };
        ExtHostSearch.prototype.$provideTextSearchResults = function (handle, session, rawQuery, token) {
            var _this = this;
            var provider = this._textSearchProvider.get(handle);
            if (!provider.provideTextSearchResults) {
                return Promise.resolve(undefined);
            }
            var query = reviveQuery(rawQuery);
            var engine = new textSearchManager_1.TextSearchManager(query, provider, this._extfs);
            return engine.search(function (progress) { return _this._proxy.$handleTextMatch(handle, session, progress); }, token);
        };
        return ExtHostSearch;
    }());
    exports.ExtHostSearch = ExtHostSearch;
    function registerEHProviders(extHostSearch, logService, configService) {
        if (configService.getConfiguration('searchRipgrep').enable || configService.getConfiguration('search').runInExtensionHost) {
            var outputChannel = new ripgrepSearchUtils_1.OutputChannel(logService);
            extHostSearch.registerTextSearchProvider('file', new ripgrepSearchProvider_1.RipgrepSearchProvider(outputChannel));
            extHostSearch.registerInternalFileSearchProvider('file', new rawSearchService_1.SearchService());
        }
    }
    function reviveQuery(rawQuery) {
        return __assign({}, rawQuery, {
            folderQueries: rawQuery.folderQueries && rawQuery.folderQueries.map(reviveFolderQuery),
            extraFileResources: rawQuery.extraFileResources && rawQuery.extraFileResources.map(function (components) { return uri_1.URI.revive(components); })
        });
    }
    function reviveFolderQuery(rawFolderQuery) {
        return __assign({}, rawFolderQuery, { folder: uri_1.URI.revive(rawFolderQuery.folder) });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[193/*vs/workbench/api/node/extHost.api.impl*/], __M([1/*require*/,0/*exports*/,81/*vs/nls!vs/workbench/api/node/extHost.api.impl*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/,3/*vs/base/common/event*/,12/*vs/base/common/paths*/,6/*vs/base/common/platform*/,29/*vs/base/common/severity*/,2/*vs/base/common/uri*/,185/*vs/editor/common/config/editorOptions*/,99/*vs/editor/common/model*/,103/*vs/editor/common/modes/languageConfiguration*/,55/*vs/editor/common/modes/languageSelector*/,101/*vs/platform/files/common/files*/,63/*vs/platform/node/package*/,50/*vs/platform/node/product*/,4/*vs/workbench/api/node/extHost.protocol*/,135/*vs/workbench/api/node/extHostApiCommands*/,146/*vs/workbench/api/node/extHostClipboard*/,147/*vs/workbench/api/node/extHostCommands*/,148/*vs/workbench/api/node/extHostComments*/,73/*vs/workbench/api/node/extHostDebugService*/,150/*vs/workbench/api/node/extHostDecorations*/,151/*vs/workbench/api/node/extHostDiagnostics*/,152/*vs/workbench/api/node/extHostDialogs*/,153/*vs/workbench/api/node/extHostDocumentContentProviders*/,136/*vs/workbench/api/node/extHostDocumentSaveParticipant*/,154/*vs/workbench/api/node/extHostDocuments*/,155/*vs/workbench/api/node/extHostDocumentsAndEditors*/,43/*vs/workbench/api/node/extHostExtensionActivator*/,156/*vs/workbench/api/node/extHostFileSystem*/,157/*vs/workbench/api/node/extHostFileSystemEventService*/,119/*vs/workbench/api/node/extHostHeapService*/,158/*vs/workbench/api/node/extHostLanguageFeatures*/,159/*vs/workbench/api/node/extHostLanguages*/,160/*vs/workbench/api/node/extHostMessageService*/,161/*vs/workbench/api/node/extHostOutputService*/,137/*vs/workbench/api/node/extHostProgress*/,162/*vs/workbench/api/node/extHostQuickOpen*/,163/*vs/workbench/api/node/extHostSCM*/,192/*vs/workbench/api/node/extHostSearch*/,164/*vs/workbench/api/node/extHostStatusBar*/,166/*vs/workbench/api/node/extHostTask*/,167/*vs/workbench/api/node/extHostTerminalService*/,168/*vs/workbench/api/node/extHostTextEditors*/,141/*vs/workbench/api/node/extHostTreeViews*/,21/*vs/workbench/api/node/extHostTypeConverters*/,7/*vs/workbench/api/node/extHostTypes*/,169/*vs/workbench/api/node/extHostUrls*/,170/*vs/workbench/api/node/extHostWebview*/,171/*vs/workbench/api/node/extHostWindow*/,46/*vs/workbench/services/extensions/common/extensions*/]), function (require, exports, nls_1, cancellation_1, errors, event_1, paths, platform, severity_1, uri_1, editorOptions_1, model_1, languageConfiguration, languageSelector_1, files, package_1, product_1, extHost_protocol_1, extHostApiCommands_1, extHostClipboard_1, extHostCommands_1, extHostComments_1, extHostDebugService_1, extHostDecorations_1, extHostDiagnostics_1, extHostDialogs_1, extHostDocumentContentProviders_1, extHostDocumentSaveParticipant_1, extHostDocuments_1, extHostDocumentsAndEditors_1, extHostExtensionActivator_1, extHostFileSystem_1, extHostFileSystemEventService_1, extHostHeapService_1, extHostLanguageFeatures_1, extHostLanguages_1, extHostMessageService_1, extHostOutputService_1, extHostProgress_1, extHostQuickOpen_1, extHostSCM_1, extHostSearch_1, extHostStatusBar_1, extHostTask_1, extHostTerminalService_1, extHostTextEditors_1, extHostTreeViews_1, typeConverters, extHostTypes, extHostUrls_1, extHostWebview_1, extHostWindow_1, extensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function proposedApiFunction(extension, fn) {
        if (extension.enableProposedApi) {
            return fn;
        }
        else {
            return extensions_1.throwProposedApiError.bind(null, extension);
        }
    }
    /**
     * This method instantiates and returns the extension API surface
     */
    function createApiFactory(initData, rpcProtocol, extHostWorkspace, extHostConfiguration, extensionService, extHostLogService, extHostStorage) {
        var schemeTransformer = null;
        // Addressable instances
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostLogService, extHostLogService);
        var extHostHeapService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostHeapService, new extHostHeapService_1.ExtHostHeapService());
        var extHostDecorations = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDecorations, new extHostDecorations_1.ExtHostDecorations(rpcProtocol));
        var extHostWebviews = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWebviews, new extHostWebview_1.ExtHostWebviews(rpcProtocol));
        var extHostUrls = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostUrls, new extHostUrls_1.ExtHostUrls(rpcProtocol));
        var extHostDocumentsAndEditors = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentsAndEditors, new extHostDocumentsAndEditors_1.ExtHostDocumentsAndEditors(rpcProtocol));
        var extHostDocuments = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocuments, new extHostDocuments_1.ExtHostDocuments(rpcProtocol, extHostDocumentsAndEditors));
        var extHostDocumentContentProviders = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentContentProviders, new extHostDocumentContentProviders_1.ExtHostDocumentContentProvider(rpcProtocol, extHostDocumentsAndEditors, extHostLogService));
        var extHostDocumentSaveParticipant = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDocumentSaveParticipant, new extHostDocumentSaveParticipant_1.ExtHostDocumentSaveParticipant(extHostLogService, extHostDocuments, rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadTextEditors)));
        var extHostEditors = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostEditors, new extHostTextEditors_1.ExtHostEditors(rpcProtocol, extHostDocumentsAndEditors));
        var extHostCommands = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostCommands, new extHostCommands_1.ExtHostCommands(rpcProtocol, extHostHeapService, extHostLogService));
        var extHostTreeViews = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTreeViews, new extHostTreeViews_1.ExtHostTreeViews(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadTreeViews), extHostCommands, extHostLogService));
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWorkspace, extHostWorkspace);
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostConfiguration, extHostConfiguration);
        var extHostDiagnostics = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDiagnostics, new extHostDiagnostics_1.ExtHostDiagnostics(rpcProtocol));
        var extHostLanguageFeatures = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostLanguageFeatures, new extHostLanguageFeatures_1.ExtHostLanguageFeatures(rpcProtocol, schemeTransformer, extHostDocuments, extHostCommands, extHostHeapService, extHostDiagnostics, extHostLogService));
        var extHostFileSystem = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostFileSystem, new extHostFileSystem_1.ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures));
        var extHostFileSystemEvent = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostFileSystemEventService, new extHostFileSystemEventService_1.ExtHostFileSystemEventService(rpcProtocol, extHostDocumentsAndEditors));
        var extHostQuickOpen = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostQuickOpen, new extHostQuickOpen_1.ExtHostQuickOpen(rpcProtocol, extHostWorkspace, extHostCommands));
        var extHostTerminalService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTerminalService, new extHostTerminalService_1.ExtHostTerminalService(rpcProtocol, extHostConfiguration, extHostLogService));
        var extHostDebugService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostDebugService, new extHostDebugService_1.ExtHostDebugService(rpcProtocol, extHostWorkspace, extensionService, extHostDocumentsAndEditors, extHostConfiguration, extHostTerminalService, extHostCommands));
        var extHostSCM = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostSCM, new extHostSCM_1.ExtHostSCM(rpcProtocol, extHostCommands, extHostLogService));
        var extHostSearch = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostSearch, new extHostSearch_1.ExtHostSearch(rpcProtocol, schemeTransformer, extHostLogService, extHostConfiguration));
        var extHostTask = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostTask, new extHostTask_1.ExtHostTask(rpcProtocol, extHostWorkspace, extHostDocumentsAndEditors, extHostConfiguration));
        var extHostWindow = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostWindow, new extHostWindow_1.ExtHostWindow(rpcProtocol));
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostExtensionService, extensionService);
        var extHostProgress = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostProgress, new extHostProgress_1.ExtHostProgress(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadProgress)));
        var exthostCommentProviders = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostComments, new extHostComments_1.ExtHostComments(rpcProtocol, extHostCommands.converter, extHostDocuments));
        var extHostOutputService = rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostOutputService, new extHostOutputService_1.ExtHostOutputService(initData.logsLocation, rpcProtocol));
        rpcProtocol.set(extHost_protocol_1.ExtHostContext.ExtHostStorage, extHostStorage);
        // Check that no named customers are missing
        var expected = Object.keys(extHost_protocol_1.ExtHostContext).map(function (key) { return extHost_protocol_1.ExtHostContext[key]; });
        rpcProtocol.assertRegistered(expected);
        // Other instances
        var extHostClipboard = new extHostClipboard_1.ExtHostClipboard(rpcProtocol);
        var extHostMessageService = new extHostMessageService_1.ExtHostMessageService(rpcProtocol);
        var extHostDialogs = new extHostDialogs_1.ExtHostDialogs(rpcProtocol);
        var extHostStatusBar = new extHostStatusBar_1.ExtHostStatusBar(rpcProtocol);
        var extHostLanguages = new extHostLanguages_1.ExtHostLanguages(rpcProtocol, extHostDocuments);
        // Register an output channel for exthost log
        extHostOutputService.createOutputChannelFromLogFile(nls_1.localize(0, null), extHostLogService.logFile);
        // Register API-ish commands
        extHostApiCommands_1.ExtHostApiCommands.register(extHostCommands);
        return function (extension) {
            var _this = this;
            // Check document selectors for being overly generic. Technically this isn't a problem but
            // in practice many extensions say they support `fooLang` but need fs-access to do so. Those
            // extension should specify then the `file`-scheme, e.g `{ scheme: 'fooLang', language: 'fooLang' }`
            // We only inform once, it is not a warning because we just want to raise awareness and because
            // we cannot say if the extension is doing it right or wrong...
            var checkSelector = (function () {
                var done = (!extension.isUnderDevelopment);
                function informOnce(selector) {
                    if (!done) {
                        console.info("Extension '" + extension.id + "' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305");
                        done = true;
                    }
                }
                return function perform(selector) {
                    if (Array.isArray(selector)) {
                        selector.forEach(perform);
                    }
                    else if (typeof selector === 'string') {
                        informOnce(selector);
                    }
                    else {
                        if (typeof selector.scheme === 'undefined') {
                            informOnce(selector);
                        }
                        if (!extension.enableProposedApi && typeof selector.exclusive === 'boolean') {
                            extensions_1.throwProposedApiError(extension);
                        }
                    }
                    return selector;
                };
            })();
            // namespace: commands
            var commands = {
                registerCommand: function (id, command, thisArgs) {
                    return extHostCommands.registerCommand(true, id, command, thisArgs);
                },
                registerTextEditorCommand: function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(true, id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var activeTextEditor = extHostEditors.getActiveTextEditor();
                        if (!activeTextEditor) {
                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                            return undefined;
                        }
                        return activeTextEditor.edit(function (edit) {
                            args.unshift(activeTextEditor, edit);
                            callback.apply(thisArg, args);
                        }).then(function (result) {
                            if (!result) {
                                console.warn('Edits from command ' + id + ' were not applied.');
                            }
                        }, function (err) {
                            console.warn('An error occurred while running command ' + id, err);
                        });
                    });
                },
                registerDiffInformationCommand: proposedApiFunction(extension, function (id, callback, thisArg) {
                    return extHostCommands.registerCommand(true, id, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return __awaiter(_this, void 0, void 0, function () {
                            var activeTextEditor, diff;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        activeTextEditor = extHostEditors.getActiveTextEditor();
                                        if (!activeTextEditor) {
                                            console.warn('Cannot execute ' + id + ' because there is no active text editor.');
                                            return [2 /*return*/, undefined];
                                        }
                                        return [4 /*yield*/, extHostEditors.getDiffInformation(activeTextEditor.id)];
                                    case 1:
                                        diff = _a.sent();
                                        callback.apply(thisArg, [diff].concat(args));
                                        return [2 /*return*/];
                                }
                            });
                        });
                    });
                }),
                executeCommand: function (id) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return extHostCommands.executeCommand.apply(extHostCommands, [id].concat(args));
                },
                getCommands: function (filterInternal) {
                    if (filterInternal === void 0) { filterInternal = false; }
                    return extHostCommands.getCommands(filterInternal);
                }
            };
            // namespace: env
            var env = Object.freeze({
                get machineId() { return initData.telemetryInfo.machineId; },
                get sessionId() { return initData.telemetryInfo.sessionId; },
                get language() { return platform.language; },
                get appName() { return product_1.default.nameLong; },
                get appRoot() { return initData.environment.appRoot.fsPath; },
                get logLevel() {
                    extensions_1.checkProposedApiEnabled(extension);
                    return extHostLogService.getLevel();
                },
                get onDidChangeLogLevel() {
                    extensions_1.checkProposedApiEnabled(extension);
                    return extHostLogService.onDidChangeLogLevel;
                },
                get clipboard() {
                    extensions_1.checkProposedApiEnabled(extension);
                    return extHostClipboard;
                }
            });
            // namespace: extensions
            var extensions = {
                getExtension: function (extensionId) {
                    var desc = extensionService.getExtensionDescription(extensionId);
                    if (desc) {
                        return new Extension(extensionService, desc);
                    }
                    return undefined;
                },
                get all() {
                    return extensionService.getAllExtensionDescriptions().map(function (desc) { return new Extension(extensionService, desc); });
                }
            };
            // namespace: languages
            var languages = {
                createDiagnosticCollection: function (name) {
                    return extHostDiagnostics.createDiagnosticCollection(name);
                },
                get onDidChangeDiagnostics() {
                    return extHostDiagnostics.onDidChangeDiagnostics;
                },
                getDiagnostics: function (resource) {
                    return extHostDiagnostics.getDiagnostics(resource);
                },
                getLanguages: function () {
                    return extHostLanguages.getLanguages();
                },
                setTextDocumentLanguage: function (document, languageId) {
                    return extHostLanguages.changeLanguage(document.uri, languageId);
                },
                match: function (selector, document) {
                    return languageSelector_1.score(typeConverters.LanguageSelector.from(selector), document.uri, document.languageId, true);
                },
                registerCodeActionsProvider: function (selector, provider, metadata) {
                    return extHostLanguageFeatures.registerCodeActionProvider(checkSelector(selector), provider, extension, metadata);
                },
                registerCodeLensProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerCodeLensProvider(checkSelector(selector), provider);
                },
                registerDefinitionProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDefinitionProvider(checkSelector(selector), provider);
                },
                registerImplementationProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerImplementationProvider(checkSelector(selector), provider);
                },
                registerTypeDefinitionProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerTypeDefinitionProvider(checkSelector(selector), provider);
                },
                registerHoverProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerHoverProvider(checkSelector(selector), provider, extension.id);
                },
                registerDocumentHighlightProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentHighlightProvider(checkSelector(selector), provider);
                },
                registerReferenceProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerReferenceProvider(checkSelector(selector), provider);
                },
                registerRenameProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerRenameProvider(checkSelector(selector), provider);
                },
                registerDocumentSymbolProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentSymbolProvider(checkSelector(selector), provider, extension);
                },
                registerWorkspaceSymbolProvider: function (provider) {
                    return extHostLanguageFeatures.registerWorkspaceSymbolProvider(provider);
                },
                registerDocumentFormattingEditProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentFormattingEditProvider(checkSelector(selector), provider);
                },
                registerDocumentRangeFormattingEditProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(checkSelector(selector), provider);
                },
                registerOnTypeFormattingEditProvider: function (selector, provider, firstTriggerCharacter) {
                    var moreTriggerCharacters = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        moreTriggerCharacters[_i - 3] = arguments[_i];
                    }
                    return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
                },
                registerSignatureHelpProvider: function (selector, provider, firstItem) {
                    var remaining = [];
                    for (var _i = 3; _i < arguments.length; _i++) {
                        remaining[_i - 3] = arguments[_i];
                    }
                    if (typeof firstItem === 'object') {
                        return extHostLanguageFeatures.registerSignatureHelpProvider(checkSelector(selector), provider, firstItem);
                    }
                    return extHostLanguageFeatures.registerSignatureHelpProvider(checkSelector(selector), provider, typeof firstItem === 'undefined' ? [] : [firstItem].concat(remaining));
                },
                registerCompletionItemProvider: function (selector, provider) {
                    var triggerCharacters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        triggerCharacters[_i - 2] = arguments[_i];
                    }
                    return extHostLanguageFeatures.registerCompletionItemProvider(checkSelector(selector), provider, triggerCharacters);
                },
                registerDocumentLinkProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerDocumentLinkProvider(checkSelector(selector), provider);
                },
                registerColorProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerColorProvider(checkSelector(selector), provider);
                },
                registerFoldingRangeProvider: function (selector, provider) {
                    return extHostLanguageFeatures.registerFoldingRangeProvider(checkSelector(selector), provider);
                },
                setLanguageConfiguration: function (language, configuration) {
                    return extHostLanguageFeatures.setLanguageConfiguration(language, configuration);
                }
            };
            // namespace: window
            var window = {
                get activeTextEditor() {
                    return extHostEditors.getActiveTextEditor();
                },
                get visibleTextEditors() {
                    return extHostEditors.getVisibleTextEditors();
                },
                get activeTerminal() {
                    return extHostTerminalService.activeTerminal;
                },
                get terminals() {
                    return extHostTerminalService.terminals;
                },
                showTextDocument: function (documentOrUri, columnOrOptions, preserveFocus) {
                    var documentPromise;
                    if (uri_1.URI.isUri(documentOrUri)) {
                        documentPromise = Promise.resolve(workspace.openTextDocument(documentOrUri));
                    }
                    else {
                        documentPromise = Promise.resolve(documentOrUri);
                    }
                    return documentPromise.then(function (document) {
                        return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
                    });
                },
                createTextEditorDecorationType: function (options) {
                    return extHostEditors.createTextEditorDecorationType(options);
                },
                onDidChangeActiveTextEditor: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
                },
                onDidChangeVisibleTextEditors: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
                },
                onDidChangeTextEditorSelection: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorOptions: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorVisibleRanges: function (listener, thisArgs, disposables) {
                    return extHostEditors.onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables);
                },
                onDidChangeTextEditorViewColumn: function (listener, thisArg, disposables) {
                    return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
                },
                onDidCloseTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidCloseTerminal(listener, thisArg, disposables);
                },
                onDidOpenTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidOpenTerminal(listener, thisArg, disposables);
                },
                onDidChangeActiveTerminal: function (listener, thisArg, disposables) {
                    return extHostTerminalService.onDidChangeActiveTerminal(listener, thisArg, disposables);
                },
                get state() {
                    return extHostWindow.state;
                },
                onDidChangeWindowState: function (listener, thisArg, disposables) {
                    return extHostWindow.onDidChangeWindowState(listener, thisArg, disposables);
                },
                showInformationMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, message, first, rest);
                },
                showWarningMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Warning, message, first, rest);
                },
                showErrorMessage: function (message, first) {
                    var rest = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        rest[_i - 2] = arguments[_i];
                    }
                    return extHostMessageService.showMessage(extension, severity_1.default.Error, message, first, rest);
                },
                showQuickPick: function (items, options, token) {
                    return extHostQuickOpen.showQuickPick(items, extension.enableProposedApi, options, token);
                },
                showWorkspaceFolderPick: function (options) {
                    return extHostQuickOpen.showWorkspaceFolderPick(options);
                },
                showInputBox: function (options, token) {
                    return extHostQuickOpen.showInput(options, token);
                },
                showOpenDialog: function (options) {
                    return extHostDialogs.showOpenDialog(options);
                },
                showSaveDialog: function (options) {
                    return extHostDialogs.showSaveDialog(options);
                },
                createStatusBarItem: function (position, priority) {
                    return extHostStatusBar.createStatusBarEntry(extension.id, position, priority);
                },
                setStatusBarMessage: function (text, timeoutOrThenable) {
                    return extHostStatusBar.setStatusBarMessage(text, timeoutOrThenable);
                },
                withScmProgress: function (task) {
                    console.warn("[Deprecation Warning] function 'withScmProgress' is deprecated and should no longer be used. Use 'withProgress' instead.");
                    return extHostProgress.withProgress(extension, { location: extHostTypes.ProgressLocation.SourceControl }, function (progress, token) { return task({ report: function (n) { } }); });
                },
                withProgress: function (options, task) {
                    return extHostProgress.withProgress(extension, options, task);
                },
                createOutputChannel: function (name) {
                    return extHostOutputService.createOutputChannel(name);
                },
                createWebviewPanel: function (viewType, title, showOptions, options) {
                    return extHostWebviews.createWebview(extension, viewType, title, showOptions, options);
                },
                createTerminal: function (nameOrOptions, shellPath, shellArgs) {
                    if (typeof nameOrOptions === 'object') {
                        return extHostTerminalService.createTerminalFromOptions(nameOrOptions);
                    }
                    return extHostTerminalService.createTerminal(nameOrOptions, shellPath, shellArgs);
                },
                createTerminalRenderer: proposedApiFunction(extension, function (name) {
                    return extHostTerminalService.createTerminalRenderer(name);
                }),
                registerTreeDataProvider: function (viewId, treeDataProvider) {
                    return extHostTreeViews.registerTreeDataProvider(viewId, treeDataProvider, extension);
                },
                createTreeView: function (viewId, options) {
                    return extHostTreeViews.createTreeView(viewId, options, extension);
                },
                registerWebviewPanelSerializer: function (viewType, serializer) {
                    return extHostWebviews.registerWebviewPanelSerializer(viewType, serializer);
                },
                // proposed API
                sampleFunction: proposedApiFunction(extension, function () {
                    return extHostMessageService.showMessage(extension, severity_1.default.Info, 'Hello Proposed Api!', {}, []);
                }),
                registerDecorationProvider: proposedApiFunction(extension, function (provider) {
                    return extHostDecorations.registerDecorationProvider(provider, extension.id);
                }),
                registerUriHandler: function (handler) {
                    return extHostUrls.registerUriHandler(extension.id, handler);
                },
                createQuickPick: function () {
                    return extHostQuickOpen.createQuickPick(extension.id, extension.enableProposedApi);
                },
                createInputBox: function () {
                    return extHostQuickOpen.createInputBox(extension.id);
                },
            };
            // namespace: workspace
            var workspace = {
                get rootPath() {
                    return extHostWorkspace.getPath();
                },
                set rootPath(value) {
                    throw errors.readonly();
                },
                getWorkspaceFolder: function (resource) {
                    return extHostWorkspace.getWorkspaceFolder(resource);
                },
                get workspaceFolders() {
                    return extHostWorkspace.getWorkspaceFolders();
                },
                get name() {
                    return extHostWorkspace.name;
                },
                set name(value) {
                    throw errors.readonly();
                },
                updateWorkspaceFolders: function (index, deleteCount) {
                    var workspaceFoldersToAdd = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        workspaceFoldersToAdd[_i - 2] = arguments[_i];
                    }
                    return extHostWorkspace.updateWorkspaceFolders.apply(extHostWorkspace, [extension, index, deleteCount || 0].concat(workspaceFoldersToAdd));
                },
                onDidChangeWorkspaceFolders: function (listener, thisArgs, disposables) {
                    return extHostWorkspace.onDidChangeWorkspace(listener, thisArgs, disposables);
                },
                asRelativePath: function (pathOrUri, includeWorkspace) {
                    return extHostWorkspace.getRelativePath(pathOrUri, includeWorkspace);
                },
                findFiles: function (include, exclude, maxResults, token) {
                    return extHostWorkspace.findFiles(typeConverters.GlobPattern.from(include), typeConverters.GlobPattern.from(exclude), maxResults, extension.id, token);
                },
                findTextInFiles: function (query, optionsOrCallback, callbackOrToken, token) {
                    var options;
                    var callback;
                    if (typeof optionsOrCallback === 'object') {
                        options = optionsOrCallback;
                        callback = callbackOrToken;
                    }
                    else {
                        options = {};
                        callback = optionsOrCallback;
                        token = callbackOrToken;
                    }
                    return extHostWorkspace.findTextInFiles(query, options || {}, callback, extension.id, token);
                },
                saveAll: function (includeUntitled) {
                    return extHostWorkspace.saveAll(includeUntitled);
                },
                applyEdit: function (edit) {
                    return extHostEditors.applyWorkspaceEdit(edit);
                },
                createFileSystemWatcher: function (pattern, ignoreCreate, ignoreChange, ignoreDelete) {
                    return extHostFileSystemEvent.createFileSystemWatcher(typeConverters.GlobPattern.from(pattern), ignoreCreate, ignoreChange, ignoreDelete);
                },
                get textDocuments() {
                    return extHostDocuments.getAllDocumentData().map(function (data) { return data.document; });
                },
                set textDocuments(value) {
                    throw errors.readonly();
                },
                openTextDocument: function (uriOrFileNameOrOptions) {
                    var uriPromise;
                    var options = uriOrFileNameOrOptions;
                    if (typeof uriOrFileNameOrOptions === 'string') {
                        uriPromise = Promise.resolve(uri_1.URI.file(uriOrFileNameOrOptions));
                    }
                    else if (uriOrFileNameOrOptions instanceof uri_1.URI) {
                        uriPromise = Promise.resolve(uriOrFileNameOrOptions);
                    }
                    else if (!options || typeof options === 'object') {
                        uriPromise = extHostDocuments.createDocumentData(options);
                    }
                    else {
                        throw new Error('illegal argument - uriOrFileNameOrOptions');
                    }
                    return uriPromise.then(function (uri) {
                        return extHostDocuments.ensureDocumentData(uri).then(function () {
                            var data = extHostDocuments.getDocumentData(uri);
                            return data && data.document;
                        });
                    });
                },
                onDidOpenTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidAddDocument(listener, thisArgs, disposables);
                },
                onDidCloseTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidRemoveDocument(listener, thisArgs, disposables);
                },
                onDidChangeTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidChangeDocument(listener, thisArgs, disposables);
                },
                onDidSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocuments.onDidSaveDocument(listener, thisArgs, disposables);
                },
                onWillSaveTextDocument: function (listener, thisArgs, disposables) {
                    return extHostDocumentSaveParticipant.getOnWillSaveTextDocumentEvent(extension)(listener, thisArgs, disposables);
                },
                onDidChangeConfiguration: function (listener, thisArgs, disposables) {
                    return extHostConfiguration.onDidChangeConfiguration(listener, thisArgs, disposables);
                },
                getConfiguration: function (section, resource) {
                    resource = arguments.length === 1 ? void 0 : resource;
                    return extHostConfiguration.getConfiguration(section, resource, extension.id);
                },
                registerTextDocumentContentProvider: function (scheme, provider) {
                    return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
                },
                registerTaskProvider: function (type, provider) {
                    return extHostTask.registerTaskProvider(extension, provider);
                },
                registerFileSystemProvider: function (scheme, provider, options) {
                    return extHostFileSystem.registerFileSystemProvider(scheme, provider, options);
                },
                registerFileSearchProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerFileSearchProvider(scheme, provider);
                }),
                registerSearchProvider: proposedApiFunction(extension, function () {
                    // Temp for live share in Insiders
                    return { dispose: function () { } };
                }),
                registerTextSearchProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerTextSearchProvider(scheme, provider);
                }),
                registerFileIndexProvider: proposedApiFunction(extension, function (scheme, provider) {
                    return extHostSearch.registerFileIndexProvider(scheme, provider);
                }),
                registerDocumentCommentProvider: proposedApiFunction(extension, function (provider) {
                    return exthostCommentProviders.registerDocumentCommentProvider(provider);
                }),
                registerWorkspaceCommentProvider: proposedApiFunction(extension, function (provider) {
                    return exthostCommentProviders.registerWorkspaceCommentProvider(extension.id, provider);
                }),
                onDidRenameFile: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostFileSystemEvent.onDidRenameFile(listener, thisArg, disposables);
                }),
                onWillRenameFile: proposedApiFunction(extension, function (listener, thisArg, disposables) {
                    return extHostFileSystemEvent.getOnWillRenameFileEvent(extension)(listener, thisArg, disposables);
                })
            };
            // namespace: scm
            var scm = {
                get inputBox() {
                    return extHostSCM.getLastInputBox(extension);
                },
                createSourceControl: function (id, label, rootUri) {
                    return extHostSCM.createSourceControl(extension, id, label, rootUri);
                }
            };
            // namespace: debug
            var debug = {
                get activeDebugSession() {
                    return extHostDebugService.activeDebugSession;
                },
                get activeDebugConsole() {
                    return extHostDebugService.activeDebugConsole;
                },
                get breakpoints() {
                    return extHostDebugService.breakpoints;
                },
                onDidStartDebugSession: function (listener, thisArg, disposables) {
                    return extHostDebugService.onDidStartDebugSession(listener, thisArg, disposables);
                },
                onDidTerminateDebugSession: function (listener, thisArg, disposables) {
                    return extHostDebugService.onDidTerminateDebugSession(listener, thisArg, disposables);
                },
                onDidChangeActiveDebugSession: function (listener, thisArg, disposables) {
                    return extHostDebugService.onDidChangeActiveDebugSession(listener, thisArg, disposables);
                },
                onDidReceiveDebugSessionCustomEvent: function (listener, thisArg, disposables) {
                    return extHostDebugService.onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables);
                },
                onDidChangeBreakpoints: function (listener, thisArgs, disposables) {
                    return extHostDebugService.onDidChangeBreakpoints(listener, thisArgs, disposables);
                },
                registerDebugConfigurationProvider: function (debugType, provider) {
                    return extHostDebugService.registerDebugConfigurationProvider(extension, debugType, provider);
                },
                startDebugging: function (folder, nameOrConfig) {
                    return extHostDebugService.startDebugging(folder, nameOrConfig);
                },
                addBreakpoints: function (breakpoints) {
                    return extHostDebugService.addBreakpoints(breakpoints);
                },
                removeBreakpoints: function (breakpoints) {
                    return extHostDebugService.removeBreakpoints(breakpoints);
                }
            };
            var tasks = {
                registerTaskProvider: function (type, provider) {
                    return extHostTask.registerTaskProvider(extension, provider);
                },
                fetchTasks: function (filter) {
                    return extHostTask.fetchTasks(filter);
                },
                executeTask: function (task) {
                    return extHostTask.executeTask(extension, task);
                },
                get taskExecutions() {
                    return extHostTask.taskExecutions;
                },
                onDidStartTask: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidStartTask(listeners, thisArgs, disposables);
                },
                onDidEndTask: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidEndTask(listeners, thisArgs, disposables);
                },
                onDidStartTaskProcess: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidStartTaskProcess(listeners, thisArgs, disposables);
                },
                onDidEndTaskProcess: function (listeners, thisArgs, disposables) {
                    return extHostTask.onDidEndTaskProcess(listeners, thisArgs, disposables);
                }
            };
            return {
                version: package_1.default.version,
                // namespaces
                commands: commands,
                debug: debug,
                env: env,
                extensions: extensions,
                languages: languages,
                scm: scm,
                tasks: tasks,
                window: window,
                workspace: workspace,
                // types
                Breakpoint: extHostTypes.Breakpoint,
                CancellationTokenSource: cancellation_1.CancellationTokenSource,
                CodeAction: extHostTypes.CodeAction,
                CodeActionKind: extHostTypes.CodeActionKind,
                CodeActionTrigger: extHostTypes.CodeActionTrigger,
                CodeLens: extHostTypes.CodeLens,
                Color: extHostTypes.Color,
                ColorInformation: extHostTypes.ColorInformation,
                ColorPresentation: extHostTypes.ColorPresentation,
                CommentThreadCollapsibleState: extHostTypes.CommentThreadCollapsibleState,
                CompletionItem: extHostTypes.CompletionItem,
                CompletionItemKind: extHostTypes.CompletionItemKind,
                CompletionItemInsertTextRule: extension.enableProposedApi ? extHostTypes.CompletionItemInsertTextRule : null,
                CompletionList: extHostTypes.CompletionList,
                CompletionTriggerKind: extHostTypes.CompletionTriggerKind,
                ConfigurationTarget: extHostTypes.ConfigurationTarget,
                DebugAdapterExecutable: extHostTypes.DebugAdapterExecutable,
                DebugAdapterServer: extHostTypes.DebugAdapterServer,
                DebugAdapterImplementation: extHostTypes.DebugAdapterImplementation,
                DecorationRangeBehavior: extHostTypes.DecorationRangeBehavior,
                Diagnostic: extHostTypes.Diagnostic,
                DiagnosticRelatedInformation: extHostTypes.DiagnosticRelatedInformation,
                DiagnosticSeverity: extHostTypes.DiagnosticSeverity,
                DiagnosticTag: extHostTypes.DiagnosticTag,
                Disposable: extHostTypes.Disposable,
                DocumentHighlight: extHostTypes.DocumentHighlight,
                DocumentHighlightKind: extHostTypes.DocumentHighlightKind,
                DocumentLink: extHostTypes.DocumentLink,
                DocumentSymbol: extHostTypes.DocumentSymbol,
                EndOfLine: extHostTypes.EndOfLine,
                EventEmitter: event_1.Emitter,
                FileChangeType: extHostTypes.FileChangeType,
                FileSystemError: extHostTypes.FileSystemError,
                FileType: files.FileType,
                FoldingRange: extHostTypes.FoldingRange,
                FoldingRangeKind: extHostTypes.FoldingRangeKind,
                FunctionBreakpoint: extHostTypes.FunctionBreakpoint,
                Hover: extHostTypes.Hover,
                IndentAction: languageConfiguration.IndentAction,
                Location: extHostTypes.Location,
                LogLevel: extHostTypes.LogLevel,
                MarkdownString: extHostTypes.MarkdownString,
                OverviewRulerLane: model_1.OverviewRulerLane,
                ParameterInformation: extHostTypes.ParameterInformation,
                Position: extHostTypes.Position,
                ProcessExecution: extHostTypes.ProcessExecution,
                ProgressLocation: extHostTypes.ProgressLocation,
                QuickInputButtons: extHostTypes.QuickInputButtons,
                Range: extHostTypes.Range,
                RelativePattern: extHostTypes.RelativePattern,
                Selection: extHostTypes.Selection,
                ShellExecution: extHostTypes.ShellExecution,
                ShellQuoting: extHostTypes.ShellQuoting,
                SignatureHelpTriggerReason: extHostTypes.SignatureHelpTriggerReason,
                SignatureHelp: extHostTypes.SignatureHelp,
                SignatureInformation: extHostTypes.SignatureInformation,
                SnippetString: extHostTypes.SnippetString,
                SourceBreakpoint: extHostTypes.SourceBreakpoint,
                SourceControlInputBoxValidationType: extHostTypes.SourceControlInputBoxValidationType,
                StatusBarAlignment: extHostTypes.StatusBarAlignment,
                SymbolInformation: extHostTypes.SymbolInformation,
                SymbolKind: extHostTypes.SymbolKind,
                Task: extHostTypes.Task,
                TaskGroup: extHostTypes.TaskGroup,
                TaskPanelKind: extHostTypes.TaskPanelKind,
                TaskRevealKind: extHostTypes.TaskRevealKind,
                TaskScope: extHostTypes.TaskScope,
                TextDocumentSaveReason: extHostTypes.TextDocumentSaveReason,
                TextEdit: extHostTypes.TextEdit,
                TextEditorCursorStyle: editorOptions_1.TextEditorCursorStyle,
                TextEditorLineNumbersStyle: extHostTypes.TextEditorLineNumbersStyle,
                TextEditorRevealType: extHostTypes.TextEditorRevealType,
                TextEditorSelectionChangeKind: extHostTypes.TextEditorSelectionChangeKind,
                ThemeColor: extHostTypes.ThemeColor,
                ThemeIcon: extHostTypes.ThemeIcon,
                TreeItem: extHostTypes.TreeItem,
                TreeItem2: extHostTypes.TreeItem,
                TreeItemCollapsibleState: extHostTypes.TreeItemCollapsibleState,
                Uri: uri_1.URI,
                ViewColumn: extHostTypes.ViewColumn,
                WorkspaceEdit: extHostTypes.WorkspaceEdit,
            };
        };
    }
    exports.createApiFactory = createApiFactory;
    /**
     * Returns the original fs path (using the original casing for the drive letter)
     */
    function originalFSPath(uri) {
        var result = uri.fsPath;
        if (/^[a-zA-Z]:/.test(result) && uri.path.charAt(1).toLowerCase() === result.charAt(0)) {
            // Restore original drive letter casing
            return uri.path.charAt(1) + result.substr(1);
        }
        return result;
    }
    exports.originalFSPath = originalFSPath;
    var Extension = /** @class */ (function () {
        function Extension(extensionService, description) {
            this._extensionService = extensionService;
            this.id = description.id;
            this.extensionPath = paths.normalize(originalFSPath(description.extensionLocation), true);
            this.packageJSON = description;
        }
        Object.defineProperty(Extension.prototype, "isActive", {
            get: function () {
                return this._extensionService.isActivated(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Extension.prototype, "exports", {
            get: function () {
                return this._extensionService.getExtensionExports(this.id);
            },
            enumerable: true,
            configurable: true
        });
        Extension.prototype.activate = function () {
            var _this = this;
            return this._extensionService.activateByIdWithErrors(this.id, new extHostExtensionActivator_1.ExtensionActivatedByAPI(false)).then(function () { return _this.exports; });
        };
        return Extension;
    }());
    function initializeExtensionApi(extensionService, apiFactory) {
        return extensionService.getExtensionPathIndex().then(function (trie) { return defineAPI(apiFactory, trie); });
    }
    exports.initializeExtensionApi = initializeExtensionApi;
    function defineAPI(factory, extensionPaths) {
        // each extension is meant to get its own api implementation
        var extApiImpl = new Map();
        var defaultApiImpl;
        var node_module = require.__$__nodeRequire('module');
        var original = node_module._load;
        node_module._load = function load(request, parent, isMain) {
            if (request !== 'vscode') {
                return original.apply(this, arguments);
            }
            // get extension id from filename and api for extension
            var ext = extensionPaths.findSubstr(uri_1.URI.file(parent.filename).fsPath);
            if (ext) {
                var apiImpl = extApiImpl.get(ext.id);
                if (!apiImpl) {
                    apiImpl = factory(ext);
                    extApiImpl.set(ext.id, apiImpl);
                }
                return apiImpl;
            }
            // fall back to a default implementation
            if (!defaultApiImpl) {
                var extensionPathsPretty_1 = '';
                extensionPaths.forEach(function (value, index) { return extensionPathsPretty_1 += "\t" + index + " -> " + value.id + "\n"; });
                console.warn("Could not identify extension for 'vscode' require call from " + parent.filename + ". These are the extension path mappings: \n" + extensionPathsPretty_1);
                defaultApiImpl = factory(nullExtensionDescription);
            }
            return defaultApiImpl;
        };
    }
    var nullExtensionDescription = {
        id: 'nullExtensionDescription',
        name: 'Null Extension Description',
        publisher: 'vscode',
        activationEvents: undefined,
        contributes: undefined,
        enableProposedApi: false,
        engines: undefined,
        extensionDependencies: undefined,
        extensionLocation: undefined,
        isBuiltin: false,
        isUnderDevelopment: false,
        main: undefined,
        version: undefined
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[194/*vs/workbench/api/node/extHostExtensionService*/], __M([1/*require*/,0/*exports*/,10/*path*/,11/*vs/base/common/async*/,8/*vs/base/common/lifecycle*/,22/*vs/base/common/map*/,29/*vs/base/common/severity*/,2/*vs/base/common/uri*/,47/*vs/base/node/pfs*/,193/*vs/workbench/api/node/extHost.api.impl*/,4/*vs/workbench/api/node/extHost.protocol*/,43/*vs/workbench/api/node/extHostExtensionActivator*/,165/*vs/workbench/api/node/extHostStorage*/,142/*vs/workbench/services/extensions/node/extensionDescriptionRegistry*/,182/*vs/workbench/node/proxyResolver*/]), function (require, exports, path_1, async_1, lifecycle_1, map_1, severity_1, uri_1, pfs_1, extHost_api_impl_1, extHost_protocol_1, extHostExtensionActivator_1, extHostStorage_1, extensionDescriptionRegistry_1, proxyResolver_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtensionMemento = /** @class */ (function () {
        function ExtensionMemento(id, global, storage) {
            var _this = this;
            this._id = id;
            this._shared = global;
            this._storage = storage;
            this._init = this._storage.getValue(this._shared, this._id, Object.create(null)).then(function (value) {
                _this._value = value;
                return _this;
            });
            this._storageListener = this._storage.onDidChangeStorage(function (e) {
                if (e.shared === _this._shared && e.key === _this._id) {
                    _this._value = e.value;
                }
            });
        }
        Object.defineProperty(ExtensionMemento.prototype, "whenReady", {
            get: function () {
                return this._init;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionMemento.prototype.get = function (key, defaultValue) {
            var value = this._value[key];
            if (typeof value === 'undefined') {
                value = defaultValue;
            }
            return value;
        };
        ExtensionMemento.prototype.update = function (key, value) {
            this._value[key] = value;
            return this._storage
                .setValue(this._shared, this._id, this._value)
                .then(function () { return true; });
        };
        ExtensionMemento.prototype.dispose = function () {
            this._storageListener.dispose();
        };
        return ExtensionMemento;
    }());
    var ExtensionStoragePath = /** @class */ (function () {
        function ExtensionStoragePath(workspace, environment) {
            var _this = this;
            this._workspace = workspace;
            this._environment = environment;
            this._ready = this._getOrCreateWorkspaceStoragePath().then(function (value) { return _this._value = value; });
        }
        Object.defineProperty(ExtensionStoragePath.prototype, "whenReady", {
            get: function () {
                return this._ready;
            },
            enumerable: true,
            configurable: true
        });
        ExtensionStoragePath.prototype.value = function (extension) {
            if (this._value) {
                return path_1.join(this._value, extension.id);
            }
            return undefined;
        };
        ExtensionStoragePath.prototype._getOrCreateWorkspaceStoragePath = function () {
            return __awaiter(this, void 0, void 0, function () {
                var storageName, storagePath, exists, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this._workspace) {
                                return [2 /*return*/, Promise.resolve(undefined)];
                            }
                            storageName = this._workspace.id;
                            storagePath = path_1.join(this._environment.appSettingsHome.fsPath, 'workspaceStorage', storageName);
                            return [4 /*yield*/, pfs_1.dirExists(storagePath)];
                        case 1:
                            exists = _a.sent();
                            if (exists) {
                                return [2 /*return*/, storagePath];
                            }
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 5, , 6]);
                            return [4 /*yield*/, pfs_1.mkdirp(storagePath)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, pfs_1.writeFile(path_1.join(storagePath, 'meta.json'), JSON.stringify({
                                    id: this._workspace.id,
                                    configuration: this._workspace.configuration && uri_1.URI.revive(this._workspace.configuration).toString(),
                                    name: this._workspace.name
                                }, undefined, 2))];
                        case 4:
                            _a.sent();
                            return [2 /*return*/, storagePath];
                        case 5:
                            e_1 = _a.sent();
                            console.error(e_1);
                            return [2 /*return*/, undefined];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        return ExtensionStoragePath;
    }());
    var ExtHostExtensionService = /** @class */ (function () {
        /**
         * This class is constructed manually because it is a service, so it doesn't use any ctor injection
         */
        function ExtHostExtensionService(initData, extHostContext, extHostWorkspace, extHostConfiguration, extHostLogService, mainThreadTelemetry) {
            var _this = this;
            this._barrier = new async_1.Barrier();
            this._registry = new extensionDescriptionRegistry_1.ExtensionDescriptionRegistry(initData.extensions);
            this._extHostLogService = extHostLogService;
            this._mainThreadTelemetry = mainThreadTelemetry;
            this._storage = new extHostStorage_1.ExtHostStorage(extHostContext);
            this._storagePath = new ExtensionStoragePath(initData.workspace, initData.environment);
            this._proxy = extHostContext.getProxy(extHost_protocol_1.MainContext.MainThreadExtensionService);
            this._activator = null;
            // initialize API first (i.e. do not release barrier until the API is initialized)
            var apiFactory = extHost_api_impl_1.createApiFactory(initData, extHostContext, extHostWorkspace, extHostConfiguration, this, this._extHostLogService, this._storage);
            extHost_api_impl_1.initializeExtensionApi(this, apiFactory).then(function () {
                // Do this when extension service exists, but extensions are not being activated yet.
                return proxyResolver_1.connectProxyResolver(extHostWorkspace, extHostConfiguration, _this, _this._extHostLogService, _this._mainThreadTelemetry);
            }).then(function () {
                _this._activator = new extHostExtensionActivator_1.ExtensionsActivator(_this._registry, {
                    showMessage: function (severity, message) {
                        _this._proxy.$localShowMessage(severity, message);
                        switch (severity) {
                            case severity_1.default.Error:
                                console.error(message);
                                break;
                            case severity_1.default.Warning:
                                console.warn(message);
                                break;
                            default:
                                console.log(message);
                        }
                    },
                    actualActivateExtension: function (extensionDescription, reason) {
                        return _this._activateExtension(extensionDescription, reason);
                    }
                });
                _this._barrier.open();
            });
        }
        ExtHostExtensionService.prototype.onExtensionAPIReady = function () {
            return this._barrier.wait();
        };
        ExtHostExtensionService.prototype.isActivated = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.isActivated(extensionId);
            }
            return false;
        };
        ExtHostExtensionService.prototype.activateByEvent = function (activationEvent, startup) {
            var _this = this;
            var reason = new extHostExtensionActivator_1.ExtensionActivatedByEvent(startup, activationEvent);
            if (this._barrier.isOpen()) {
                return this._activator.activateByEvent(activationEvent, reason);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateByEvent(activationEvent, reason); });
            }
        };
        ExtHostExtensionService.prototype.activateById = function (extensionId, reason) {
            var _this = this;
            if (this._barrier.isOpen()) {
                return this._activator.activateById(extensionId, reason);
            }
            else {
                return this._barrier.wait().then(function () { return _this._activator.activateById(extensionId, reason); });
            }
        };
        ExtHostExtensionService.prototype.activateByIdWithErrors = function (extensionId, reason) {
            var _this = this;
            return this.activateById(extensionId, reason).then(function () {
                var extension = _this._activator.getActivatedExtension(extensionId);
                if (extension.activationFailed) {
                    // activation failed => bubble up the error as the promise result
                    return Promise.reject(extension.activationFailedError);
                }
                return void 0;
            });
        };
        ExtHostExtensionService.prototype.getAllExtensionDescriptions = function () {
            return this._registry.getAllExtensionDescriptions();
        };
        ExtHostExtensionService.prototype.getExtensionDescription = function (extensionId) {
            return this._registry.getExtensionDescription(extensionId);
        };
        ExtHostExtensionService.prototype.getExtensionExports = function (extensionId) {
            if (this._barrier.isOpen()) {
                return this._activator.getActivatedExtension(extensionId).exports;
            }
            else {
                return null;
            }
        };
        // create trie to enable fast 'filename -> extension id' look up
        ExtHostExtensionService.prototype.getExtensionPathIndex = function () {
            if (!this._extensionPathIndex) {
                var tree_1 = map_1.TernarySearchTree.forPaths();
                var extensions = this.getAllExtensionDescriptions().map(function (ext) {
                    if (!ext.main) {
                        return undefined;
                    }
                    return pfs_1.realpath(ext.extensionLocation.fsPath).then(function (value) { return tree_1.set(uri_1.URI.file(value).fsPath, ext); });
                });
                this._extensionPathIndex = Promise.all(extensions).then(function () { return tree_1; });
            }
            return this._extensionPathIndex;
        };
        ExtHostExtensionService.prototype.deactivate = function (extensionId) {
            var result = Promise.resolve(void 0);
            if (!this._barrier.isOpen()) {
                return result;
            }
            if (!this._activator.isActivated(extensionId)) {
                return result;
            }
            var extension = this._activator.getActivatedExtension(extensionId);
            if (!extension) {
                return result;
            }
            // call deactivate if available
            try {
                if (typeof extension.module.deactivate === 'function') {
                    result = Promise.resolve(extension.module.deactivate()).then(null, function (err) {
                        // TODO: Do something with err if this is not the shutdown case
                        return Promise.resolve(void 0);
                    });
                }
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            // clean up subscriptions
            try {
                lifecycle_1.dispose(extension.subscriptions);
            }
            catch (err) {
                // TODO: Do something with err if this is not the shutdown case
            }
            return result;
        };
        ExtHostExtensionService.prototype.addMessage = function (extensionId, severity, message) {
            this._proxy.$addMessage(extensionId, severity, message);
        };
        // --- impl
        ExtHostExtensionService.prototype._activateExtension = function (extensionDescription, reason) {
            var _this = this;
            return this._doActivateExtension(extensionDescription, reason).then(function (activatedExtension) {
                var activationTimes = activatedExtension.activationTimes;
                var activationEvent = (reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent : null);
                _this._proxy.$onExtensionActivated(extensionDescription.id, activationTimes.startup, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, activationEvent);
                return activatedExtension;
            }, function (err) {
                _this._proxy.$onExtensionActivationFailed(extensionDescription.id);
                throw err;
            });
        };
        ExtHostExtensionService.prototype._doActivateExtension = function (extensionDescription, reason) {
            var _this = this;
            var event = getTelemetryActivationEvent(extensionDescription, reason);
            /* __GDPR__
                "activatePlugin" : {
                    "${include}": [
                        "${TelemetryActivationEvent}"
                    ]
                }
            */
            this._mainThreadTelemetry.$publicLog('activatePlugin', event);
            if (!extensionDescription.main) {
                // Treat the extension as being empty => NOT AN ERROR CASE
                return Promise.resolve(new extHostExtensionActivator_1.EmptyExtension(extHostExtensionActivator_1.ExtensionActivationTimes.NONE));
            }
            this._extHostLogService.info("ExtensionService#_doActivateExtension " + extensionDescription.id + " " + JSON.stringify(reason));
            var activationTimesBuilder = new extHostExtensionActivator_1.ExtensionActivationTimesBuilder(reason.startup);
            return Promise.all([
                loadCommonJSModule(this._extHostLogService, extensionDescription.main, activationTimesBuilder),
                this._loadExtensionContext(extensionDescription)
            ]).then(function (values) {
                return ExtHostExtensionService._callActivate(_this._extHostLogService, extensionDescription.id, values[0], values[1], activationTimesBuilder);
            });
        };
        ExtHostExtensionService.prototype._loadExtensionContext = function (extensionDescription) {
            var _this = this;
            var globalState = new ExtensionMemento(extensionDescription.id, true, this._storage);
            var workspaceState = new ExtensionMemento(extensionDescription.id, false, this._storage);
            this._extHostLogService.trace("ExtensionService#loadExtensionContext " + extensionDescription.id);
            return Promise.all([
                globalState.whenReady,
                workspaceState.whenReady,
                this._storagePath.whenReady
            ]).then(function () {
                var that = _this;
                return Object.freeze({
                    globalState: globalState,
                    workspaceState: workspaceState,
                    subscriptions: [],
                    get extensionPath() { return extensionDescription.extensionLocation.fsPath; },
                    storagePath: _this._storagePath.value(extensionDescription),
                    asAbsolutePath: function (relativePath) { return path_1.join(extensionDescription.extensionLocation.fsPath, relativePath); },
                    logPath: that._extHostLogService.getLogDirectory(extensionDescription.id)
                });
            });
        };
        ExtHostExtensionService._callActivate = function (logService, extensionId, extensionModule, context, activationTimesBuilder) {
            // Make sure the extension's surface is not undefined
            extensionModule = extensionModule || {
                activate: undefined,
                deactivate: undefined
            };
            return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then(function (extensionExports) {
                return new extHostExtensionActivator_1.ActivatedExtension(false, null, activationTimesBuilder.build(), extensionModule, extensionExports, context.subscriptions);
            });
        };
        ExtHostExtensionService._callActivateOptional = function (logService, extensionId, extensionModule, context, activationTimesBuilder) {
            if (typeof extensionModule.activate === 'function') {
                try {
                    activationTimesBuilder.activateCallStart();
                    logService.trace("ExtensionService#_callActivateOptional " + extensionId);
                    var activateResult = extensionModule.activate.apply(global, [context]);
                    activationTimesBuilder.activateCallStop();
                    activationTimesBuilder.activateResolveStart();
                    return Promise.resolve(activateResult).then(function (value) {
                        activationTimesBuilder.activateResolveStop();
                        return value;
                    });
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
            else {
                // No activate found => the module is the extension's exports
                return Promise.resolve(extensionModule);
            }
        };
        // -- called by main thread
        ExtHostExtensionService.prototype.$activateByEvent = function (activationEvent) {
            return this.activateByEvent(activationEvent, false);
        };
        return ExtHostExtensionService;
    }());
    exports.ExtHostExtensionService = ExtHostExtensionService;
    function loadCommonJSModule(logService, modulePath, activationTimesBuilder) {
        var r = null;
        activationTimesBuilder.codeLoadingStart();
        logService.info("ExtensionService#loadCommonJSModule " + modulePath);
        try {
            r = require.__$__nodeRequire(modulePath);
        }
        catch (e) {
            return Promise.reject(e);
        }
        finally {
            activationTimesBuilder.codeLoadingStop();
        }
        return Promise.resolve(r);
    }
    function getTelemetryActivationEvent(extensionDescription, reason) {
        var reasonStr = reason instanceof extHostExtensionActivator_1.ExtensionActivatedByEvent ? reason.activationEvent :
            reason instanceof extHostExtensionActivator_1.ExtensionActivatedByAPI ? 'api' :
                '';
        /* __GDPR__FRAGMENT__
            "TelemetryActivationEvent" : {
                "id": { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" },
                "name": { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" },
                "publisherDisplayName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "activationEvents": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "isBuiltin": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                "reason": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            }
        */
        var event = {
            id: extensionDescription.id,
            name: extensionDescription.name,
            publisherDisplayName: extensionDescription.publisher,
            activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
            isBuiltin: extensionDescription.isBuiltin,
            reason: reasonStr
        };
        return event;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[195/*vs/workbench/node/extensionHostMain*/], __M([1/*require*/,0/*exports*/,89/*vs/nls!vs/workbench/node/extensionHostMain*/,10/*path*/,11/*vs/base/common/async*/,17/*vs/base/common/cancellation*/,14/*vs/base/common/errors*/,8/*vs/base/common/lifecycle*/,133/*vs/base/common/numbers*/,2/*vs/base/common/uri*/,20/*vs/base/common/winjs.base*/,47/*vs/base/node/pfs*/,4/*vs/workbench/api/node/extHost.protocol*/,130/*vs/workbench/api/node/extHostConfiguration*/,43/*vs/workbench/api/node/extHostExtensionActivator*/,194/*vs/workbench/api/node/extHostExtensionService*/,140/*vs/workbench/api/node/extHostLogService*/,172/*vs/workbench/api/node/extHostWorkspace*/,173/*vs/workbench/services/extensions/node/rpcProtocol*/]), function (require, exports, nls, path_1, async_1, cancellation_1, errors, lifecycle_1, numbers_1, uri_1, winjs_base_1, pfs, extHost_protocol_1, extHostConfiguration_1, extHostExtensionActivator_1, extHostExtensionService_1, extHostLogService_1, extHostWorkspace_1, rpcProtocol_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // we don't (yet) throw when extensions parse
    // uris that have no scheme
    uri_1.setUriThrowOnMissingScheme(false);
    var nativeExit = process.exit.bind(process);
    function patchProcess(allowExit) {
        process.exit = function (code) {
            if (allowExit) {
                exit(code);
            }
            else {
                var err = new Error('An extension called process.exit() and this was prevented.');
                console.warn(err.stack);
            }
        };
        process.crash = function () {
            var err = new Error('An extension called process.crash() and this was prevented.');
            console.warn(err.stack);
        };
    }
    function exit(code) {
        nativeExit(code);
    }
    exports.exit = exit;
    var ExtensionHostMain = /** @class */ (function () {
        function ExtensionHostMain(protocol, initData) {
            this._isTerminating = false;
            this.disposables = [];
            var rpcProtocol = new rpcProtocol_1.RPCProtocol(protocol);
            // ensure URIs are transformed and revived
            initData = this.transform(initData, rpcProtocol);
            this._environment = initData.environment;
            this._workspace = initData.workspace;
            var allowExit = !!this._environment.extensionTestsPath; // to support other test frameworks like Jasmin that use process.exit (https://github.com/Microsoft/vscode/issues/37708)
            patchProcess(allowExit);
            // services
            this._extHostLogService = new extHostLogService_1.ExtHostLogService(initData.logLevel, initData.logsLocation.fsPath);
            this.disposables.push(this._extHostLogService);
            this._searchRequestIdProvider = new numbers_1.Counter();
            var extHostWorkspace = new extHostWorkspace_1.ExtHostWorkspace(rpcProtocol, initData.workspace, this._extHostLogService, this._searchRequestIdProvider);
            this._extHostLogService.info('extension host started');
            this._extHostLogService.trace('initData', initData);
            this._extHostConfiguration = new extHostConfiguration_1.ExtHostConfiguration(rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadConfiguration), extHostWorkspace, initData.configuration);
            var mainThreadTelemetry = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadTelemetry);
            this._extensionService = new extHostExtensionService_1.ExtHostExtensionService(initData, rpcProtocol, extHostWorkspace, this._extHostConfiguration, this._extHostLogService, mainThreadTelemetry);
            // error forwarding and stack trace scanning
            Error.stackTraceLimit = 100; // increase number of stack frames (from 10, https://github.com/v8/v8/wiki/Stack-Trace-API)
            var extensionErrors = new WeakMap();
            this._extensionService.getExtensionPathIndex().then(function (map) {
                Error.prepareStackTrace = function (error, stackTrace) {
                    var stackTraceMessage = '';
                    var extension;
                    var fileName;
                    for (var _i = 0, stackTrace_1 = stackTrace; _i < stackTrace_1.length; _i++) {
                        var call = stackTrace_1[_i];
                        stackTraceMessage += "\n\tat " + call.toString();
                        fileName = call.getFileName();
                        if (!extension && fileName) {
                            extension = map.findSubstr(fileName);
                        }
                    }
                    extensionErrors.set(error, extension);
                    return (error.name || 'Error') + ": " + (error.message || '') + stackTraceMessage;
                };
            });
            var mainThreadExtensions = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadExtensionService);
            var mainThreadErrors = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadErrors);
            errors.setUnexpectedErrorHandler(function (err) {
                var data = errors.transformErrorForSerialization(err);
                var extension = extensionErrors.get(err);
                if (extension) {
                    mainThreadExtensions.$onExtensionRuntimeError(extension.id, data);
                }
                else {
                    mainThreadErrors.$onUnexpectedError(data);
                }
            });
            this._mainThreadWorkspace = rpcProtocol.getProxy(extHost_protocol_1.MainContext.MainThreadWorkspace);
        }
        ExtensionHostMain.prototype.start = function () {
            var _this = this;
            return this._extensionService.onExtensionAPIReady()
                .then(function () { return _this.handleEagerExtensions(); })
                .then(function () { return _this.handleExtensionTests(); })
                .then(function () {
                _this._extHostLogService.info("eager extensions activated");
            });
        };
        ExtensionHostMain.prototype.terminate = function () {
            var _this = this;
            if (this._isTerminating) {
                // we are already shutting down...
                return;
            }
            this._isTerminating = true;
            this.disposables = lifecycle_1.dispose(this.disposables);
            errors.setUnexpectedErrorHandler(function (err) {
                // TODO: write to log once we have one
            });
            var allPromises = [];
            try {
                var allExtensions = this._extensionService.getAllExtensionDescriptions();
                var allExtensionsIds = allExtensions.map(function (ext) { return ext.id; });
                var activatedExtensions = allExtensionsIds.filter(function (id) { return _this._extensionService.isActivated(id); });
                allPromises = activatedExtensions.map(function (extensionId) {
                    return _this._extensionService.deactivate(extensionId);
                });
            }
            catch (err) {
                // TODO: write to log once we have one
            }
            var extensionsDeactivated = winjs_base_1.TPromise.join(allPromises).then(function () { return void 0; });
            // Give extensions 1 second to wrap up any async dispose, then exit
            setTimeout(function () {
                Promise.race([async_1.timeout(4000), extensionsDeactivated]).then(function () { return exit(); }, function () { return exit(); });
            }, 1000);
        };
        // Handle "eager" activation extensions
        ExtensionHostMain.prototype.handleEagerExtensions = function () {
            this._extensionService.activateByEvent('*', true).then(null, function (err) {
                console.error(err);
            });
            return this.handleWorkspaceContainsEagerExtensions();
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtensions = function () {
            var _this = this;
            if (!this._workspace || this._workspace.folders.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            return winjs_base_1.TPromise.join(this._extensionService.getAllExtensionDescriptions().map(function (desc) {
                return _this.handleWorkspaceContainsEagerExtension(desc);
            })).then(function () { });
        };
        ExtensionHostMain.prototype.handleWorkspaceContainsEagerExtension = function (desc) {
            var _this = this;
            var activationEvents = desc.activationEvents;
            if (!activationEvents) {
                return winjs_base_1.TPromise.as(void 0);
            }
            var fileNames = [];
            var globPatterns = [];
            for (var i = 0; i < activationEvents.length; i++) {
                if (/^workspaceContains:/.test(activationEvents[i])) {
                    var fileNameOrGlob = activationEvents[i].substr('workspaceContains:'.length);
                    if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0) {
                        globPatterns.push(fileNameOrGlob);
                    }
                    else {
                        fileNames.push(fileNameOrGlob);
                    }
                }
            }
            if (fileNames.length === 0 && globPatterns.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            var fileNamePromise = winjs_base_1.TPromise.join(fileNames.map(function (fileName) { return _this.activateIfFileName(desc.id, fileName); })).then(function () { });
            var globPatternPromise = this.activateIfGlobPatterns(desc.id, globPatterns);
            return winjs_base_1.TPromise.join([fileNamePromise, globPatternPromise]).then(function () { });
        };
        ExtensionHostMain.prototype.activateIfFileName = function (extensionId, fileName) {
            return __awaiter(this, void 0, void 0, function () {
                var _i, _a, uri;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _i = 0, _a = this._workspace.folders;
                            _b.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 4];
                            uri = _a[_i].uri;
                            return [4 /*yield*/, pfs.exists(path_1.join(uri_1.URI.revive(uri).fsPath, fileName))];
                        case 2:
                            if (_b.sent()) {
                                // the file was found
                                return [2 /*return*/, (this._extensionService.activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, "workspaceContains:" + fileName))
                                        .then(null, function (err) { return console.error(err); }))];
                            }
                            _b.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/, undefined];
                    }
                });
            });
        };
        ExtensionHostMain.prototype.activateIfGlobPatterns = function (extensionId, globPatterns) {
            return __awaiter(this, void 0, void 0, function () {
                var tokenSource, searchP, timer, exists, err_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._extHostLogService.trace("extensionHostMain#activateIfGlobPatterns: fileSearch, extension: " + extensionId + ", entryPoint: workspaceContains");
                            if (globPatterns.length === 0) {
                                return [2 /*return*/, winjs_base_1.TPromise.as(void 0)];
                            }
                            tokenSource = new cancellation_1.CancellationTokenSource();
                            searchP = this._mainThreadWorkspace.$checkExists(globPatterns, tokenSource.token);
                            timer = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    tokenSource.cancel();
                                    this._extensionService.activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, "workspaceContainsTimeout:" + globPatterns.join(',')))
                                        .then(null, function (err) { return console.error(err); });
                                    return [2 /*return*/];
                                });
                            }); }, ExtensionHostMain.WORKSPACE_CONTAINS_TIMEOUT);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, searchP];
                        case 2:
                            exists = _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            err_1 = _a.sent();
                            if (!errors.isPromiseCanceledError(err_1)) {
                                console.error(err_1);
                            }
                            return [3 /*break*/, 4];
                        case 4:
                            tokenSource.dispose();
                            clearTimeout(timer);
                            if (exists) {
                                // a file was found matching one of the glob patterns
                                return [2 /*return*/, (this._extensionService.activateById(extensionId, new extHostExtensionActivator_1.ExtensionActivatedByEvent(true, "workspaceContains:" + globPatterns.join(',')))
                                        .then(null, function (err) { return console.error(err); }))];
                            }
                            return [2 /*return*/, winjs_base_1.TPromise.as(void 0)];
                    }
                });
            });
        };
        ExtensionHostMain.prototype.handleExtensionTests = function () {
            var _this = this;
            if (!this._environment.extensionTestsPath || !this._environment.extensionDevelopmentLocationURI) {
                return winjs_base_1.TPromise.as(null);
            }
            // Require the test runner via node require from the provided path
            var testRunner;
            var requireError;
            try {
                testRunner = require.__$__nodeRequire(this._environment.extensionTestsPath);
            }
            catch (error) {
                requireError = error;
            }
            // Execute the runner if it follows our spec
            if (testRunner && typeof testRunner.run === 'function') {
                return new winjs_base_1.TPromise(function (c, e) {
                    testRunner.run(_this._environment.extensionTestsPath, function (error, failures) {
                        if (error) {
                            e(error.toString());
                        }
                        else {
                            c(null);
                        }
                        // after tests have run, we shutdown the host
                        _this.gracefulExit(failures && failures > 0 ? 1 /* ERROR */ : 0 /* OK */);
                    });
                });
            }
            // Otherwise make sure to shutdown anyway even in case of an error
            else {
                this.gracefulExit(1 /* ERROR */);
            }
            return winjs_base_1.TPromise.wrapError(new Error(requireError ? requireError.toString() : nls.localize(0, null, this._environment.extensionTestsPath)));
        };
        ExtensionHostMain.prototype.transform = function (initData, rpcProtocol) {
            initData.extensions.forEach(function (ext) { return ext.extensionLocation = uri_1.URI.revive(ext.extensionLocation); });
            initData.environment.appRoot = uri_1.URI.revive(initData.environment.appRoot);
            initData.environment.appSettingsHome = uri_1.URI.revive(initData.environment.appSettingsHome);
            initData.environment.extensionDevelopmentLocationURI = uri_1.URI.revive(initData.environment.extensionDevelopmentLocationURI);
            initData.logsLocation = uri_1.URI.revive(initData.logsLocation);
            initData.workspace = rpcProtocol.transformIncomingURIs(initData.workspace);
            return initData;
        };
        ExtensionHostMain.prototype.gracefulExit = function (code) {
            // to give the PH process a chance to flush any outstanding console
            // messages to the main process, we delay the exit() by some time
            setTimeout(function () { return exit(code); }, 500);
        };
        ExtensionHostMain.WORKSPACE_CONTAINS_TIMEOUT = 7000;
        return ExtensionHostMain;
    }());
    exports.ExtensionHostMain = ExtensionHostMain;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[205/*vs/workbench/node/extensionHostProcess*/], __M([1/*require*/,0/*exports*/,64/*net*/,14/*vs/base/common/errors*/,3/*vs/base/common/event*/,102/*vs/base/parts/ipc/node/ipc.net*/,50/*vs/platform/node/product*/,122/*vs/workbench/common/extensionHostProtocol*/,195/*vs/workbench/node/extensionHostMain*/]), function (require, exports, net_1, errors_1, event_1, ipc_net_1, product_1, extensionHostProtocol_1, extensionHostMain_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // With Electron 2.x and node.js 8.x the "natives" module
    // can cause a native crash (see https://github.com/nodejs/node/issues/19891 and
    // https://github.com/electron/electron/issues/10905). To prevent this from
    // happening we essentially blocklist this module from getting loaded in any
    // extension by patching the node require() function.
    (function () {
        var Module = require.__$__nodeRequire('module');
        var originalLoad = Module._load;
        Module._load = function (request) {
            if (request === 'natives') {
                throw new Error('Either the extension or a NPM dependency is using the "natives" node module which is unsupported as it can cause a crash of the extension host. Click [here](https://go.microsoft.com/fwlink/?linkid=871887) to find out more');
            }
            return originalLoad.apply(this, arguments);
        };
    })();
    // This calls exit directly in case the initialization is not finished and we need to exit
    // Otherwise, if initialization completed we go to extensionHostMain.terminate()
    var onTerminate = function () {
        extensionHostMain_1.exit();
    };
    function createExtHostProtocol() {
        var pipeName = process.env.VSCODE_IPC_HOOK_EXTHOST;
        return new Promise(function (resolve, reject) {
            var socket = net_1.createConnection(pipeName, function () {
                socket.removeListener('error', reject);
                resolve(new ipc_net_1.Protocol(socket));
            });
            socket.once('error', reject);
        }).then(function (protocol) {
            return new /** @class */ (function () {
                function class_1() {
                    var _this = this;
                    this._terminating = false;
                    this.onMessage = event_1.filterEvent(protocol.onMessage, function (msg) {
                        if (!extensionHostProtocol_1.isMessageOfType(msg, 2 /* Terminate */)) {
                            return true;
                        }
                        _this._terminating = true;
                        onTerminate();
                        return false;
                    });
                }
                class_1.prototype.send = function (msg) {
                    if (!this._terminating) {
                        protocol.send(msg);
                    }
                };
                return class_1;
            }());
        });
    }
    function connectToRenderer(protocol) {
        return new Promise(function (c, e) {
            // Listen init data message
            var first = protocol.onMessage(function (raw) {
                first.dispose();
                var initData = JSON.parse(raw.toString());
                var rendererCommit = initData.commit;
                var myCommit = product_1.default.commit;
                if (rendererCommit && myCommit) {
                    // Running in the built version where commits are defined
                    if (rendererCommit !== myCommit) {
                        extensionHostMain_1.exit(55);
                    }
                }
                // Print a console message when rejection isn't handled within N seconds. For details:
                // see https://nodejs.org/api/process.html#process_event_unhandledrejection
                // and https://nodejs.org/api/process.html#process_event_rejectionhandled
                var unhandledPromises = [];
                process.on('unhandledRejection', function (reason, promise) {
                    unhandledPromises.push(promise);
                    setTimeout(function () {
                        var idx = unhandledPromises.indexOf(promise);
                        if (idx >= 0) {
                            unhandledPromises.splice(idx, 1);
                            console.warn('rejected promise not handled within 1 second');
                            errors_1.onUnexpectedError(reason);
                        }
                    }, 1000);
                });
                process.on('rejectionHandled', function (promise) {
                    var idx = unhandledPromises.indexOf(promise);
                    if (idx >= 0) {
                        unhandledPromises.splice(idx, 1);
                    }
                });
                // Print a console message when an exception isn't handled.
                process.on('uncaughtException', function (err) {
                    errors_1.onUnexpectedError(err);
                });
                // Kill oneself if one's parent dies. Much drama.
                setInterval(function () {
                    try {
                        process.kill(initData.parentPid, 0); // throws an exception if the main process doesn't exist anymore.
                    }
                    catch (e) {
                        onTerminate();
                    }
                }, 1000);
                // In certain cases, the event loop can become busy and never yield
                // e.g. while-true or process.nextTick endless loops
                // So also use the native node module to do it from a separate thread
                var watchdog;
                try {
                    watchdog = require.__$__nodeRequire('native-watchdog');
                    watchdog.start(initData.parentPid);
                }
                catch (err) {
                    // no problem...
                    errors_1.onUnexpectedError(err);
                }
                // Tell the outside that we are initialized
                protocol.send(extensionHostProtocol_1.createMessageOfType(0 /* Initialized */));
                c({ protocol: protocol, initData: initData });
            });
            // Tell the outside that we are ready to receive messages
            protocol.send(extensionHostProtocol_1.createMessageOfType(1 /* Ready */));
        });
    }
    patchExecArgv();
    createExtHostProtocol().then(function (protocol) {
        // connect to main side
        return connectToRenderer(protocol);
    }).then(function (renderer) {
        // setup things
        var extensionHostMain = new extensionHostMain_1.ExtensionHostMain(renderer.protocol, renderer.initData);
        onTerminate = function () { return extensionHostMain.terminate(); };
        return extensionHostMain.start();
    }).catch(function (err) { return console.error(err); });
    function patchExecArgv() {
        // when encountering the prevent-inspect flag we delete this
        // and the prior flag
        if (process.env.VSCODE_PREVENT_FOREIGN_INSPECT) {
            for (var i = 0; i < process.execArgv.length; i++) {
                if (process.execArgv[i].match(/--inspect-brk=\d+|--inspect=\d+/)) {
                    process.execArgv.splice(i, 1);
                    break;
                }
            }
        }
    }
});

}).call(this);
//# sourceMappingURL=extensionHostProcess.js.map
