// Generated by Haxe 3.3.0
(function ($hx_exports) { "use strict";
var HxOverrides = function() { };
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
var LanguageClient = require("vscode-languageclient").LanguageClient;
var StringTools = function() { };
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var Vscode = require("vscode");
var haxe_io_Bytes = function() { };
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( e ) {
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _ ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_File = function() { };
sys_io_File.copy = function(srcPath,dstPath) {
	var src = js_node_Fs.openSync(srcPath,"r");
	var dst = js_node_Fs.openSync(dstPath,"w",js_node_Fs.fstatSync(src).mode);
	var bytesRead;
	var pos = 0;
	while(true) {
		bytesRead = js_node_Fs.readSync(src,sys_io_File.copyBuf,0,65536,pos);
		if(!(bytesRead > 0)) {
			break;
		}
		js_node_Fs.writeSync(dst,sys_io_File.copyBuf,0,bytesRead);
		pos += bytesRead;
	}
	js_node_Fs.closeSync(src);
	js_node_Fs.closeSync(dst);
};
var vscode_Range = require("vscode").Range;
var vshaxe_DisplayConfiguration = function(context) {
	this.context = context;
	this.statusBarItem = Vscode.window.createStatusBarItem(1);
	this.statusBarItem.tooltip = "Select Haxe configuration";
	this.statusBarItem.command = "haxe.selectDisplayConfiguration";
	context.subscriptions.push(this.statusBarItem);
	context.subscriptions.push(Vscode.commands.registerCommand("haxe.selectDisplayConfiguration",$bind(this,this.selectConfiguration)));
	context.subscriptions.push(Vscode.workspace.onDidChangeConfiguration($bind(this,this.onDidChangeConfiguration)));
	context.subscriptions.push(Vscode.window.onDidChangeActiveTextEditor($bind(this,this.onDidChangeActiveTextEditor)));
	this.fixIndex();
};
vshaxe_DisplayConfiguration.prototype = {
	fixIndex: function() {
		var index = this.context.workspaceState.get("haxe.displayConfigurationIndex",0);
		var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations");
		if(configs == null || index >= configs.length) {
			this.setIndex(0);
		}
	}
	,selectConfiguration: function() {
		var _gthis = this;
		var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations");
		if(configs == null || configs.length == 0) {
			Vscode.window.showErrorMessage("No Haxe display configurations are available. Please provide the haxe.displayConfigurations setting.",{ title : "Edit settings"}).then(function(button) {
				if(button == null) {
					return;
				}
				Vscode.workspace.openTextDocument(Vscode.workspace.rootPath + "/.vscode/settings.json").then(function(doc) {
					Vscode.window.showTextDocument(doc);
				});
			});
			return;
		}
		if(configs.length == 1) {
			Vscode.window.showInformationMessage("Only one Haxe display configuration found: " + configs[0].join(" "));
			return;
		}
		var items = [];
		var _g1 = 0;
		var _g = configs.length;
		while(_g1 < _g) {
			var index = _g1++;
			items.push({ label : "" + index, description : configs[index].join(" "), index : index});
		}
		Vscode.window.showQuickPick(items,{ placeHolder : "Select haxe display configuration"}).then(function(choice) {
			if(choice == null || choice.index == _gthis.context.workspaceState.get("haxe.displayConfigurationIndex",0)) {
				return;
			}
			_gthis.setIndex(choice.index);
		});
	}
	,onDidChangeConfiguration: function(_) {
		this.fixIndex();
		this.updateStatusBarItem();
	}
	,onDidChangeActiveTextEditor: function(_) {
		this.updateStatusBarItem();
	}
	,updateStatusBarItem: function() {
		if(Vscode.window.activeTextEditor == null) {
			this.statusBarItem.hide();
			return;
		}
		if(Vscode.languages.match({ language : "haxe", scheme : "file"},Vscode.window.activeTextEditor.document) > 0) {
			var configs = Vscode.workspace.getConfiguration("haxe").get("displayConfigurations");
			if(configs != null && configs.length >= 2) {
				var index = this.context.workspaceState.get("haxe.displayConfigurationIndex",0);
				this.statusBarItem.text = "$(gear) Haxe: " + index + " (" + configs[index].join(" ") + ")";
				this.statusBarItem.show();
				return;
			}
		}
		this.statusBarItem.hide();
	}
	,setIndex: function(index) {
		this.context.workspaceState.update("haxe.displayConfigurationIndex",index);
		this.updateStatusBarItem();
		this.onDidChangeIndex(index);
	}
	,onDidChangeIndex: function(index) {
	}
};
var vshaxe_InitProject = function(context) {
	this.context = context;
	context.subscriptions.push(Vscode.commands.registerCommand("haxe.initProject",$bind(this,this.initProject)));
};
vshaxe_InitProject.getHxmlPath = function(item) {
	var path = item.description;
	var file = item.label;
	if(path.length == 0) {
		return file;
	} else {
		return path + "/" + file;
	}
};
vshaxe_InitProject.prototype = {
	initProject: function() {
		var workspaceRoot = Vscode.workspace.rootPath;
		if(workspaceRoot == null) {
			Vscode.window.showErrorMessage("Please open a folder to set up a Haxe project into");
			return;
		}
		if(js_node_Fs.readdirSync(workspaceRoot).length == 0) {
			this.scaffoldEmpty(workspaceRoot);
			return;
		}
		var vscodeDir = workspaceRoot + "/.vscode";
		if(sys_FileSystem.exists(vscodeDir)) {
			this.showConfigureHint();
			return;
		}
		var hxmls = this.findHxmls(workspaceRoot);
		if(hxmls.length > 0) {
			this.createWorkspaceConfiguration(vscodeDir,hxmls);
			return;
		}
		Vscode.window.showErrorMessage("To set up Haxe project, workspace must be either empty or contain HXML files to choose from");
	}
	,scaffoldEmpty: function(root) {
		this.copyRec(this.context.asAbsolutePath("./scaffold"),root);
		Vscode.window.setStatusBarMessage("Haxe project scaffolded",2000);
	}
	,showConfigureHint: function() {
		var channel = Vscode.window.createOutputChannel("Haxe scaffold");
		this.context.subscriptions.push(channel);
		var content = js_node_Fs.readFileSync(this.context.asAbsolutePath("./configureHint.txt"),{ encoding : "utf8"});
		content = StringTools.replace(content,"{{tasks}}",js_node_Fs.readFileSync(this.context.asAbsolutePath("./scaffold/.vscode/tasks.json"),{ encoding : "utf8"}));
		channel.clear();
		channel.append(content);
		channel.show();
	}
	,findHxmls: function(root) {
		var hxmls = [];
		var loop = null;
		loop = function(path) {
			var fullPath = root + "/" + path;
			if(js_node_Fs.statSync(fullPath).isDirectory()) {
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fullPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					if(StringTools.endsWith(file,".hxml")) {
						hxmls.push({ label : file, description : path});
					} else {
						loop(path.length == 0?file:path + "/" + file);
					}
				}
			}
		};
		loop("");
		return hxmls;
	}
	,createWorkspaceConfiguration: function(vscodeDir,hxmls) {
		var _gthis = this;
		Vscode.window.showQuickPick(hxmls,{ placeHolder : "Choose HXML file to use"}).then(function(s) {
			if(s == null) {
				return;
			}
			var hxmlPath = vshaxe_InitProject.getHxmlPath(s);
			_gthis.copyRec(_gthis.context.asAbsolutePath("./scaffold/.vscode"),vscodeDir);
			var tasksPath = vscodeDir + "/tasks.json";
			js_node_Fs.writeFileSync(tasksPath,StringTools.replace(js_node_Fs.readFileSync(tasksPath,{ encoding : "utf8"}),"\"build.hxml\"","\"" + hxmlPath + "\""));
			var settingsPath = vscodeDir + "/settings.json";
			var content = js_node_Fs.readFileSync(settingsPath,{ encoding : "utf8"});
			content = StringTools.replace(content,"\"build.hxml\"","\"" + hxmlPath + "\"");
			if(hxmls.length > 1) {
				HxOverrides.remove(hxmls,s);
				var _g = [];
				var _g1 = 0;
				while(_g1 < hxmls.length) {
					var hxml = hxmls[_g1];
					++_g1;
					_g.push("        [\"" + vshaxe_InitProject.getHxmlPath(hxml) + "\"]");
				}
				content = StringTools.replace(content,"        //[\"build-cpp.hxml\"]",_g.join(",\n"));
			}
			js_node_Fs.writeFileSync(settingsPath,content);
			Vscode.workspace.openTextDocument(vscodeDir + "/settings.json").then(function(doc) {
				Vscode.window.showTextDocument(doc);
				Vscode.window.showInformationMessage("Please check if " + hxmlPath + " is suitable for completion and modify haxe.displayConfigurations if needed.");
			});
		});
	}
	,copyRec: function(from,to) {
		var loop = null;
		loop = function(src,dst) {
			var fromPath = from + src;
			var toPath = to + dst;
			if(js_node_Fs.statSync(fromPath).isDirectory()) {
				sys_FileSystem.createDirectory(toPath);
				var _g = 0;
				var _g1 = js_node_Fs.readdirSync(fromPath);
				while(_g < _g1.length) {
					var file = _g1[_g];
					++_g;
					loop(src + "/" + file,dst + "/" + file);
				}
			} else {
				sys_io_File.copy(fromPath,toPath);
			}
		};
		loop("","");
	}
};
var vshaxe_Main = function(ctx) {
	this.context = ctx;
	this.displayConfig = new vshaxe_DisplayConfiguration(ctx);
	new vshaxe_InitProject(ctx);
	this.vshaxeChannel = Vscode.window.createOutputChannel("vshaxe");
	this.context.subscriptions.push(this.vshaxeChannel);
	this.context.subscriptions.push(Vscode.commands.registerCommand("haxe.restartLanguageServer",$bind(this,this.restartLanguageServer)));
	this.context.subscriptions.push(Vscode.commands.registerCommand("haxe.applyFixes",$bind(this,this.applyFixes)));
	if(!js_node_Fs.existsSync(js_node_Path.join(Vscode.workspace.rootPath,"build","project-debug-html5.hxml"))) {
		Vscode.extensions.getExtension("ktx.kha").exports.compile("debug-html5");
	}
	this.startLanguageServer();
};
vshaxe_Main.findKha = function() {
	return Vscode.extensions.getExtension("ktx.kha").exports.findKha();
};
vshaxe_Main.main = $hx_exports["activate"] = function(context) {
	new vshaxe_Main(context);
};
vshaxe_Main.prototype = {
	log: function(message) {
		this.vshaxeChannel.append(message);
	}
	,applyFixes: function(uri,version,edits) {
		var editor = Vscode.window.activeTextEditor;
		if(editor == null || editor.document.uri.toString() != uri) {
			return;
		}
		editor.edit(function(mutator) {
			var _g = 0;
			while(_g < edits.length) {
				var edit = edits[_g];
				++_g;
				mutator.replace(new vscode_Range(edit.range.start.line,edit.range.start.character,edit.range.end.line,edit.range.end.character),edit.newText);
			}
		});
	}
	,startLanguageServer: function() {
		var _gthis = this;
		var serverModule = this.context.asAbsolutePath("./server_wrapper.js");
		var client = new LanguageClient("Haxe",{ run : { module : serverModule, options : { env : process.env}}, debug : { module : serverModule, options : { env : process.env, execArgv : ["--nolazy","--debug=6004"]}}},{ documentSelector : "haxe", synchronize : { configurationSection : "haxe"}, initializationOptions : { displayConfigurationIndex : this.displayConfig.context.workspaceState.get("haxe.displayConfigurationIndex",0), kha : vshaxe_Main.findKha()}});
		client.onNotification({ method : "vshaxe/log"},$bind(this,this.log));
		client.onReady().then(function(_) {
			_gthis.vshaxeChannel.append("Haxe language server started with Kha at " + vshaxe_Main.findKha() + "\n");
			_gthis.displayConfig.onDidChangeIndex = function(index) {
				client.sendNotification({ method : "vshaxe/didChangeDisplayConfigurationIndex"},{ index : index});
			};
		});
		this.serverDisposable = client.start();
		this.context.subscriptions.push(this.serverDisposable);
	}
	,restartLanguageServer: function() {
		if(this.serverDisposable != null) {
			HxOverrides.remove(this.context.subscriptions,this.serverDisposable);
			this.serverDisposable.dispose();
		}
		this.startLanguageServer();
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
sys_io_File.copyBuf = new js_node_buffer_Buffer(65536);
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this);

//# sourceMappingURL=client.js.map