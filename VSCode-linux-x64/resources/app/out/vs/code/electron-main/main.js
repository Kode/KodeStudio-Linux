/*!--------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
(function() {
var __m = ["exports","require","vs/base/common/winjs.base","vs/base/common/platform","vs/platform/instantiation/common/instantiation","vs/base/common/event","vs/base/common/uri","vs/platform/log/common/log","electron","vs/platform/environment/common/environment","vs/nls!vs/code/electron-main/main","path","vs/nls","vs/base/common/lifecycle","vs/platform/configuration/common/configuration","vs/base/common/paths","vs/platform/node/product","vs/base/common/objects","vs/base/common/strings","vs/platform/workspaces/common/workspaces","vs/base/common/async","fs","vs/base/common/types","vs/base/common/errors","vs/base/common/arrays","vs/platform/windows/electron-main/windows","os","vs/platform/lifecycle/electron-main/lifecycleMain","vs/platform/state/common/state","vs/platform/telemetry/common/telemetry","vs/base/common/network","vs/base/common/labels","vs/base/common/resources","vs/platform/update/common/update","vs/base/node/pfs","vs/base/common/cancellation","vs/base/node/extfs","vs/platform/registry/common/platform","vs/base/common/map","vs/base/common/uuid","vs/base/common/json","vs/platform/environment/node/argv","vs/platform/request/node/request","vs/platform/configuration/common/configurationRegistry","vs/platform/history/common/history","vs/base/common/amd","vs/platform/files/common/files","vs/base/node/request","vs/platform/label/common/label","vs/platform/url/common/url","vs/platform/node/package","vs/base/parts/ipc/node/ipc.net","vs/base/common/decorators","child_process","vs/base/parts/ipc/node/ipc","vs/platform/instantiation/common/descriptors","vs/base/common/functional","vs/platform/backup/common/backup","crypto","vs/code/electron-main/theme","vs/platform/update/electron-main/abstractUpdateService","vs/platform/instantiation/common/serviceCollection","vs/base/common/keyCodes","vs/platform/launch/electron-main/launchService","vs/base/node/id","vs/platform/configuration/common/configurationModels","vs/platform/menubar/common/menubar","vs/code/node/paths","vs/base/node/config","vs/platform/windows/common/windows","vs/platform/diagnostics/electron-main/diagnosticsService","vs/code/electron-main/keyboard","vs/base/common/normalization","vs/base/common/scanCode","vs/platform/workspace/common/workspace","vs/base/common/jsonFormatter","vs/base/common/assert","vs/nls!vs/code/electron-main/menus","vs/nls!vs/code/electron-main/window","vs/nls!vs/code/electron-main/windows","vs/nls!vs/platform/configuration/common/configurationRegistry","vs/nls!vs/platform/dialogs/common/dialogs","vs/nls!vs/platform/dialogs/node/dialogService","vs/nls!vs/platform/environment/node/argv","vs/nls!vs/platform/extensions/node/extensionValidator","vs/nls!vs/platform/history/electron-main/historyMainService","vs/nls!vs/platform/issue/electron-main/issueService","vs/nls!vs/platform/label/common/label","vs/nls!vs/platform/menubar/electron-main/menubar","vs/nls!vs/platform/request/node/request","vs/nls!vs/platform/telemetry/common/telemetryService","vs/nls!vs/platform/update/node/update.config.contribution","vs/nls!vs/platform/windows/electron-main/windowsService","vs/base/node/paths","vs/platform/dialogs/node/dialogService","vs/platform/request/electron-main/requestService","vs/platform/extensionManagement/common/extensionManagementUtil","vs/base/node/proxy","url","vs/base/node/ps","vs/platform/dialogs/common/dialogs","vs/platform/driver/node/driver","vs/base/common/jsonEdit","vs/base/node/stats","vs/nls!vs/platform/workspaces/common/workspaces","vs/base/node/stream","vs/platform/instantiation/common/instantiationService","vs/platform/issue/common/issue","vs/platform/issue/node/issueIpc","vs/platform/keybinding/common/usLayoutResolvedKeybinding","vs/platform/lifecycle/common/lifecycle","vs/base/node/encoding","vs/platform/log/common/bufferLog","vs/platform/log/node/logIpc","vs/platform/log/node/spdlogService","vs/code/electron-main/app","vs/platform/menubar/node/menubarIpc","vs/platform/update/electron-main/updateService.win32","vs/platform/extensions/node/extensionValidator","vs/base/common/graph","vs/code/electron-main/logUploader","vs/base/common/glob","vs/base/common/mime","vs/platform/request/node/requestService","vs/platform/environment/node/environmentService","vs/base/parts/contextmenu/common/contextmenu","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/base/parts/contextmenu/electron-main/contextmenu","vs/base/node/crypto","vs/base/common/collections","vs/platform/configuration/node/configuration","vs/platform/configuration/node/configurationService","vs/base/parts/ipc/node/ipc.electron","vs/base/parts/ipc/electron-main/ipc.electron-main","vs/base/common/keybindingParser","vs/code/electron-main/sharedProcess","vs/platform/state/node/stateService","vs/platform/update/electron-main/updateService.linux","vs/platform/telemetry/common/telemetryService","vs/platform/telemetry/common/telemetryUtils","vs/platform/telemetry/node/commonProperties","vs/platform/telemetry/node/telemetryIpc","vs/base/node/flow","assert","vs/platform/update/electron-main/updateService.darwin","vs/platform/update/node/update.config.contribution","vs/code/code.main","vs/platform/update/node/updateIpc","vs/code/node/shellEnv","vs/platform/url/common/urlService","vs/platform/url/node/urlIpc","vs/nls!vs/base/common/keybindingLabels","vs/base/common/linkedList","vs/code/electron-main/auth","vs/base/common/date","vs/code/electron-main/windows","vs/platform/driver/electron-main/driver","vs/platform/url/electron-main/electronUrlListener","vs/platform/windows/electron-main/windowsService","vs/base/common/keybindingLabels","vs/code/node/windowsFinder","vs/platform/backup/electron-main/backupMainService","vs/nls!vs/base/common/severity","vs/platform/issue/electron-main/issueService","vs/platform/windows/node/windowsIpc","vs/base/common/severity","vs/nls!vs/code/electron-main/auth","vs/code/electron-main/menus","vs/platform/history/electron-main/historyMainService","vs/platform/menubar/electron-main/menubar","vs/platform/menubar/electron-main/menubarService","vs/platform/workspaces/node/workspaces","vs/platform/workspaces/electron-main/workspacesMainService","vs/platform/workspaces/node/workspacesIpc","vs/nls!vs/code/electron-main/logUploader","vs/code/electron-main/window","vs/platform/extensionManagement/node/extensionGalleryService","zlib","vs/base/common/performance","native-keymap","minimist","readline","net","stream","iconv-lite","vs/code/electron-main/main"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
define(__m[76/*vs/base/common/assert*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

define(__m[129/*vs/base/common/collections*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * Returns an array which contains all values that reside
     * in the given set.
     */
    function values(from) {
        var result = [];
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                result.push(from[key]);
            }
        }
        return result;
    }
    exports.values = values;
    function size(from) {
        var count = 0;
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                count += 1;
            }
        }
        return count;
    }
    exports.size = size;
    function first(from) {
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                return from[key];
            }
        }
        return undefined;
    }
    exports.first = first;
    /**
     * Iterates over each entry in the provided set. The iterator allows
     * to remove elements and will stop when the callback returns {{false}}.
     */
    function forEach(from, callback) {
        var _loop_1 = function (key) {
            if (hasOwnProperty.call(from, key)) {
                var result = callback({ key: key, value: from[key] }, function () {
                    delete from[key];
                });
                if (result === false) {
                    return { value: void 0 };
                }
            }
        };
        for (var key in from) {
            var state_1 = _loop_1(key);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    exports.forEach = forEach;
    /**
     * Removes an element from the dictionary. Returns {{false}} if the property
     * does not exists.
     */
    function remove(from, key) {
        if (!hasOwnProperty.call(from, key)) {
            return false;
        }
        delete from[key];
        return true;
    }
    exports.remove = remove;
    /**
     * Groups the collection into a dictionary based on the provided
     * group function.
     */
    function groupBy(data, groupFn) {
        var result = Object.create(null);
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var element = data_1[_i];
            var key = groupFn(element);
            var target = result[key];
            if (!target) {
                target = result[key] = [];
            }
            target.push(element);
        }
        return result;
    }
    exports.groupBy = groupBy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[52/*vs/base/common/decorators*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createDecorator(mapFn) {
        return function (target, key, descriptor) {
            var fnKey = null;
            var fn = null;
            if (typeof descriptor.value === 'function') {
                fnKey = 'value';
                fn = descriptor.value;
            }
            else if (typeof descriptor.get === 'function') {
                fnKey = 'get';
                fn = descriptor.get;
            }
            if (!fn) {
                throw new Error('not supported');
            }
            descriptor[fnKey] = mapFn(fn, key);
        };
    }
    exports.createDecorator = createDecorator;
    function memoize(target, key, descriptor) {
        var fnKey = null;
        var fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
            if (fn.length !== 0) {
                console.warn('Memoize should only be used in functions with zero parameters');
            }
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        var memoizeKey = "$memoize$" + key;
        descriptor[fnKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.hasOwnProperty(memoizeKey)) {
                Object.defineProperty(this, memoizeKey, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: fn.apply(this, args)
                });
            }
            return this[memoizeKey];
        };
    }
    exports.memoize = memoize;
    function debounce(delay, reducer, initialValueProvider) {
        return createDecorator(function (fn, key) {
            var timerKey = "$debounce$" + key;
            var resultKey = "$debounce$result$" + key;
            return function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }
                clearTimeout(this[timerKey]);
                if (reducer) {
                    this[resultKey] = reducer.apply(void 0, [this[resultKey]].concat(args));
                    args = [this[resultKey]];
                }
                this[timerKey] = setTimeout(function () {
                    fn.apply(_this, args);
                    _this[resultKey] = initialValueProvider ? initialValueProvider() : void 0;
                }, delay);
            };
        });
    }
    exports.debounce = debounce;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[56/*vs/base/common/functional*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
});

define(__m[40/*vs/base/common/json*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ScanError;
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
        ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError = exports.ScanError || (exports.ScanError = {}));
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
    })(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = 0 /* Unknown */, scanError = 0 /* None */;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = 0 /* Unknown */;
            scanError = 0 /* None */;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === 48 /* _0 */) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = 3 /* UnexpectedEndOfNumber */;
                    return text.substring(start, pos);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = 3 /* UnexpectedEndOfNumber */;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === 34 /* doubleQuote */) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = 2 /* UnexpectedEndOfString */;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 34 /* doubleQuote */:
                            result += '\"';
                            break;
                        case 92 /* backslash */:
                            result += '\\';
                            break;
                        case 47 /* slash */:
                            result += '/';
                            break;
                        case 98 /* b */:
                            result += '\b';
                            break;
                        case 102 /* f */:
                            result += '\f';
                            break;
                        case 110 /* n */:
                            result += '\n';
                            break;
                        case 114 /* r */:
                            result += '\r';
                            break;
                        case 116 /* t */:
                            result += '\t';
                            break;
                        case 117 /* u */:
                            var ch_1 = scanHexDigits(4, true);
                            if (ch_1 >= 0) {
                                result += String.fromCharCode(ch_1);
                            }
                            else {
                                scanError = 4 /* InvalidUnicode */;
                            }
                            break;
                        default:
                            scanError = 5 /* InvalidEscapeCharacter */;
                    }
                    start = pos;
                    continue;
                }
                if (ch >= 0 && ch <= 0x1f) {
                    if (isLineBreak(ch)) {
                        result += text.substring(start, pos);
                        scanError = 2 /* UnexpectedEndOfString */;
                        break;
                    }
                    else {
                        scanError = 6 /* InvalidCharacter */;
                        // mark as error but continue with string
                    }
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = 0 /* None */;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = 16 /* EOF */;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = 15 /* Trivia */;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                    pos++;
                    value += '\n';
                }
                return token = 14 /* LineBreakTrivia */;
            }
            switch (code) {
                // tokens: []{}:,
                case 123 /* openBrace */:
                    pos++;
                    return token = 1 /* OpenBraceToken */;
                case 125 /* closeBrace */:
                    pos++;
                    return token = 2 /* CloseBraceToken */;
                case 91 /* openBracket */:
                    pos++;
                    return token = 3 /* OpenBracketToken */;
                case 93 /* closeBracket */:
                    pos++;
                    return token = 4 /* CloseBracketToken */;
                case 58 /* colon */:
                    pos++;
                    return token = 6 /* ColonToken */;
                case 44 /* comma */:
                    pos++;
                    return token = 5 /* CommaToken */;
                // strings
                case 34 /* doubleQuote */:
                    pos++;
                    value = scanString();
                    return token = 10 /* StringLiteral */;
                // comments
                case 47 /* slash */:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = 12 /* LineCommentTrivia */;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = 1 /* UnexpectedEndOfComment */;
                        }
                        value = text.substring(start, pos);
                        return token = 13 /* BlockCommentTrivia */;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = 0 /* Unknown */;
                // numbers
                case 45 /* minus */:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = 0 /* Unknown */;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case 48 /* _0 */:
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    value += scanNumber();
                    return token = 11 /* NumericLiteral */;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = 8 /* TrueKeyword */;
                            case 'false': return token = 9 /* FalseKeyword */;
                            case 'null': return token = 7 /* NullKeyword */;
                        }
                        return token = 0 /* Unknown */;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = 0 /* Unknown */;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case 125 /* closeBrace */:
                case 93 /* closeBracket */:
                case 123 /* openBrace */:
                case 91 /* openBracket */:
                case 34 /* doubleQuote */:
                case 58 /* colon */:
                case 44 /* comma */:
                case 47 /* slash */:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
            ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
            ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
    }
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    var ParseErrorCode;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 0] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 1] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 2] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 3] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 4] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 5] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 6] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 7] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 8] = "EndOfFileExpected";
    })(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));
    function getLiteralNodeType(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            default: return 'null';
        }
    }
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function parse(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        return currentParent[0];
    }
    exports.parse = parse;
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function parseTree(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            return valueNode;
        }
        var visitor = {
            onObjectBegin: function (offset) {
                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: function (name, offset, length) {
                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
            },
            onObjectEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onArrayBegin: function (offset, length) {
                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
                ensurePropertyComplete(offset + length);
            },
            onLiteralValue: function (value, offset, length) {
                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
                ensurePropertyComplete(offset + length);
            },
            onSeparator: function (sep, offset, length) {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.columnOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        var result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    exports.parseTree = parseTree;
    function findNodeAtLocation(root, path) {
        if (!root) {
            return void 0;
        }
        var node = root;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var segment = path_1[_i];
            if (typeof segment === 'string') {
                if (node.type !== 'object') {
                    return void 0;
                }
                var found = false;
                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                    var propertyNode = _b[_a];
                    if (propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return void 0;
                }
            }
            else {
                var index = segment;
                if (node.type !== 'array' || index < 0 || index >= node.children.length) {
                    return void 0;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    exports.findNodeAtLocation = findNodeAtLocation;
    function getNodeValue(node) {
        if (node.type === 'array') {
            return node.children.map(getNodeValue);
        }
        else if (node.type === 'object') {
            var obj = {};
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                obj[prop.children[0].value] = getNodeValue(prop.children[1]);
            }
            return obj;
        }
        return node.value;
    }
    exports.getNodeValue = getNodeValue;
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function visit(text, visitor, options) {
        var _scanner = createScanner(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);
        var disallowComments = options && options.disallowComments;
        var disallowTrailingComma = options && options.disallowTrailingComma;
        function scanNext() {
            while (true) {
                var token = _scanner.scan();
                switch (token) {
                    case 12 /* LineCommentTrivia */:
                    case 13 /* BlockCommentTrivia */:
                        if (disallowComments) {
                            handleError(0 /* InvalidSymbol */);
                        }
                        break;
                    case 0 /* Unknown */:
                        handleError(0 /* InvalidSymbol */);
                        break;
                    case 15 /* Trivia */:
                    case 14 /* LineBreakTrivia */:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== 16 /* EOF */) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            var value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case 11 /* NumericLiteral */:
                    var value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(1 /* InvalidNumberFormat */);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(1 /* InvalidNumberFormat */);
                    }
                    onLiteralValue(value);
                    break;
                case 7 /* NullKeyword */:
                    onLiteralValue(null);
                    break;
                case 8 /* TrueKeyword */:
                    onLiteralValue(true);
                    break;
                case 9 /* FalseKeyword */:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (_scanner.getToken() !== 10 /* StringLiteral */) {
                handleError(2 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                return false;
            }
            parseString(false);
            if (_scanner.getToken() === 6 /* ColonToken */) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(3 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                }
            }
            else {
                handleError(4 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            return true;
        }
        function parseObject() {
            onObjectBegin();
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 16 /* EOF */) {
                if (_scanner.getToken() === 5 /* CommaToken */) {
                    if (!needsComma) {
                        handleError(3 /* ValueExpected */, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === 2 /* CloseBraceToken */ && !disallowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(5 /* CommaExpected */, [], []);
                }
                if (!parseProperty()) {
                    handleError(3 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
                handleError(6 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            onArrayBegin();
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 16 /* EOF */) {
                if (_scanner.getToken() === 5 /* CommaToken */) {
                    if (!needsComma) {
                        handleError(3 /* ValueExpected */, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                    if (_scanner.getToken() === 4 /* CloseBracketToken */ && !disallowTrailingComma) {
                        break;
                    }
                }
                else if (needsComma) {
                    handleError(5 /* CommaExpected */, [], []);
                }
                if (!parseValue()) {
                    handleError(3 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
                handleError(7 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            switch (_scanner.getToken()) {
                case 3 /* OpenBracketToken */:
                    return parseArray();
                case 1 /* OpenBraceToken */:
                    return parseObject();
                case 10 /* StringLiteral */:
                    return parseString(true);
                default:
                    return parseLiteral();
            }
        }
        scanNext();
        if (_scanner.getToken() === 16 /* EOF */) {
            return true;
        }
        if (!parseValue()) {
            handleError(3 /* ValueExpected */, [], []);
            return false;
        }
        if (_scanner.getToken() !== 16 /* EOF */) {
            handleError(8 /* EndOfFileExpected */, [], []);
        }
        return true;
    }
    exports.visit = visit;
});

define(__m[75/*vs/base/common/jsonFormatter*/], __M([1/*require*/,0/*exports*/,40/*vs/base/common/json*/]), function (require, exports, Json) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function applyEdit(text, edit) {
        return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
    }
    exports.applyEdit = applyEdit;
    function applyEdits(text, edits) {
        for (var i = edits.length - 1; i >= 0; i--) {
            text = applyEdit(text, edits[i]);
        }
        return text;
    }
    exports.applyEdits = applyEdits;
    function format(documentText, range, options) {
        var initialIndentLevel;
        var value;
        var rangeStart;
        var rangeEnd;
        if (range) {
            rangeStart = range.offset;
            rangeEnd = rangeStart + range.length;
            while (rangeStart > 0 && !isEOL(documentText, rangeStart - 1)) {
                rangeStart--;
            }
            var scanner_1 = Json.createScanner(documentText, true);
            scanner_1.setPosition(rangeEnd);
            scanner_1.scan();
            rangeEnd = scanner_1.getPosition();
            value = documentText.substring(rangeStart, rangeEnd);
            initialIndentLevel = computeIndentLevel(value, 0, options);
        }
        else {
            value = documentText;
            rangeStart = 0;
            rangeEnd = documentText.length;
            initialIndentLevel = 0;
        }
        var eol = getEOL(options, documentText);
        var lineBreak = false;
        var indentLevel = 0;
        var indentValue;
        if (options.insertSpaces) {
            indentValue = repeat(' ', options.tabSize);
        }
        else {
            indentValue = '\t';
        }
        var scanner = Json.createScanner(value, false);
        function newLineAndIndent() {
            return eol + repeat(indentValue, initialIndentLevel + indentLevel);
        }
        function scanNext() {
            var token = scanner.scan();
            lineBreak = false;
            while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
                lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
                token = scanner.scan();
            }
            return token;
        }
        var editOperations = [];
        function addEdit(text, startOffset, endOffset) {
            if (documentText.substring(startOffset, endOffset) !== text) {
                editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
            }
        }
        var firstToken = scanNext();
        if (firstToken !== 16 /* EOF */) {
            var firstTokenStart = scanner.getTokenOffset() + rangeStart;
            var initialIndent = repeat(indentValue, initialIndentLevel);
            addEdit(initialIndent, rangeStart, firstTokenStart);
        }
        while (firstToken !== 16 /* EOF */) {
            var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + rangeStart;
            var secondToken = scanNext();
            var replaceContent = '';
            while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                // comments on the same line: keep them on the same line, but ignore them otherwise
                var commentTokenStart = scanner.getTokenOffset() + rangeStart;
                addEdit(' ', firstTokenEnd, commentTokenStart);
                firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + rangeStart;
                replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
                secondToken = scanNext();
            }
            if (secondToken === 2 /* CloseBraceToken */) {
                if (firstToken !== 1 /* OpenBraceToken */) {
                    indentLevel--;
                    replaceContent = newLineAndIndent();
                }
            }
            else if (secondToken === 4 /* CloseBracketToken */) {
                if (firstToken !== 3 /* OpenBracketToken */) {
                    indentLevel--;
                    replaceContent = newLineAndIndent();
                }
            }
            else if (secondToken !== 16 /* EOF */) {
                switch (firstToken) {
                    case 3 /* OpenBracketToken */:
                    case 1 /* OpenBraceToken */:
                        indentLevel++;
                        replaceContent = newLineAndIndent();
                        break;
                    case 5 /* CommaToken */:
                    case 12 /* LineCommentTrivia */:
                        replaceContent = newLineAndIndent();
                        break;
                    case 13 /* BlockCommentTrivia */:
                        if (lineBreak) {
                            replaceContent = newLineAndIndent();
                        }
                        else {
                            // symbol following comment on the same line: keep on same line, separate with ' '
                            replaceContent = ' ';
                        }
                        break;
                    case 6 /* ColonToken */:
                        replaceContent = ' ';
                        break;
                    case 7 /* NullKeyword */:
                    case 8 /* TrueKeyword */:
                    case 9 /* FalseKeyword */:
                    case 11 /* NumericLiteral */:
                        if (secondToken === 7 /* NullKeyword */ || secondToken === 9 /* FalseKeyword */ || secondToken === 11 /* NumericLiteral */) {
                            replaceContent = ' ';
                        }
                        break;
                }
                if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                    replaceContent = newLineAndIndent();
                }
            }
            var secondTokenStart = scanner.getTokenOffset() + rangeStart;
            addEdit(replaceContent, firstTokenEnd, secondTokenStart);
            firstToken = secondToken;
        }
        return editOperations;
    }
    exports.format = format;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    function computeIndentLevel(content, offset, options) {
        var i = 0;
        var nChars = 0;
        var tabSize = options.tabSize || 4;
        while (i < content.length) {
            var ch = content.charAt(i);
            if (ch === ' ') {
                nChars++;
            }
            else if (ch === '\t') {
                nChars += tabSize;
            }
            else {
                break;
            }
            i++;
        }
        return Math.floor(nChars / tabSize);
    }
    function getEOL(options, text) {
        for (var i = 0; i < text.length; i++) {
            var ch = text.charAt(i);
            if (ch === '\r') {
                if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    return '\r\n';
                }
                return '\r';
            }
            else if (ch === '\n') {
                return '\n';
            }
        }
        return (options && options.eol) || '\n';
    }
    function isEOL(text, offset) {
        return '\r\n'.indexOf(text.charAt(offset)) !== -1;
    }
});

define(__m[102/*vs/base/common/jsonEdit*/], __M([1/*require*/,0/*exports*/,40/*vs/base/common/json*/,75/*vs/base/common/jsonFormatter*/]), function (require, exports, json_1, jsonFormatter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function removeProperty(text, path, formattingOptions) {
        return setProperty(text, path, void 0, formattingOptions);
    }
    exports.removeProperty = removeProperty;
    function setProperty(text, path, value, formattingOptions, getInsertionIndex) {
        var _a;
        var errors = [];
        var root = json_1.parseTree(text, errors);
        var parent = void 0;
        var lastSegment = void 0;
        while (path.length > 0) {
            lastSegment = path.pop();
            parent = json_1.findNodeAtLocation(root, path);
            if (parent === void 0 && value !== void 0) {
                if (typeof lastSegment === 'string') {
                    value = (_a = {}, _a[lastSegment] = value, _a);
                }
                else {
                    value = [value];
                }
            }
            else {
                break;
            }
        }
        if (!parent) {
            // empty document
            if (value === void 0) { // delete
                throw new Error('Can not delete in empty document');
            }
            return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);
        }
        else if (parent.type === 'object' && typeof lastSegment === 'string') {
            var existing = json_1.findNodeAtLocation(parent, [lastSegment]);
            if (existing !== void 0) {
                if (value === void 0) { // delete
                    var propertyIndex = parent.children.indexOf(existing.parent);
                    var removeBegin = void 0;
                    var removeEnd = existing.parent.offset + existing.parent.length;
                    if (propertyIndex > 0) {
                        // remove the comma of the previous node
                        var previous = parent.children[propertyIndex - 1];
                        removeBegin = previous.offset + previous.length;
                    }
                    else {
                        removeBegin = parent.offset + 1;
                        if (parent.children.length > 1) {
                            // remove the comma of the next node
                            var next = parent.children[1];
                            removeEnd = next.offset;
                        }
                    }
                    return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);
                }
                else {
                    // set value of existing property
                    return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);
                }
            }
            else {
                if (value === void 0) { // delete
                    return []; // property does not exist, nothing to do
                }
                var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
                var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
                var edit = void 0;
                if (index > 0) {
                    var previous = parent.children[index - 1];
                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
                }
                else if (parent.children.length === 0) {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };
                }
                else {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
                }
                return withFormatting(text, edit, formattingOptions);
            }
        }
        else if (parent.type === 'array' && typeof lastSegment === 'number') {
            var insertIndex = lastSegment;
            if (insertIndex === -1) {
                // Insert
                var newProperty = "" + JSON.stringify(value);
                var edit = void 0;
                if (parent.children.length === 0) {
                    edit = { offset: parent.offset + 1, length: 0, content: newProperty };
                }
                else {
                    var previous = parent.children[parent.children.length - 1];
                    edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
                }
                return withFormatting(text, edit, formattingOptions);
            }
            else {
                if (value === void 0 && parent.children.length >= 0) {
                    //Removal
                    var removalIndex = lastSegment;
                    var toRemove = parent.children[removalIndex];
                    var edit = void 0;
                    if (parent.children.length === 1) {
                        // only item
                        edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
                    }
                    else if (parent.children.length - 1 === removalIndex) {
                        // last item
                        var previous = parent.children[removalIndex - 1];
                        var offset = previous.offset + previous.length;
                        var parentEndOffset = parent.offset + parent.length;
                        edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
                    }
                    else {
                        edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
                    }
                    return withFormatting(text, edit, formattingOptions);
                }
                else {
                    throw new Error('Array modification not supported yet');
                }
            }
        }
        else {
            throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
        }
    }
    exports.setProperty = setProperty;
    function withFormatting(text, edit, formattingOptions) {
        // apply the edit
        var newText = jsonFormatter_1.applyEdit(text, edit);
        // format the new text
        var begin = edit.offset;
        var end = edit.offset + edit.content.length;
        var edits = jsonFormatter_1.format(newText, { offset: begin, length: end - begin }, formattingOptions);
        // apply the formatting edits and track the begin and end offsets of the changes
        for (var i = edits.length - 1; i >= 0; i--) {
            var edit_1 = edits[i];
            newText = jsonFormatter_1.applyEdit(newText, edit_1);
            begin = Math.min(begin, edit_1.offset);
            end = Math.max(end, edit_1.offset + edit_1.length);
            end += edit_1.content.length - edit_1.length;
        }
        // create a single edit with all changes
        var editLength = text.length - (newText.length - end) - begin;
        return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[62/*vs/base/common/keyCodes*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
     * But these are "more general", as they should work across browsers & OS`s.
     */
    var KeyCode;
    (function (KeyCode) {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
        KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
        KeyCode[KeyCode["Tab"] = 2] = "Tab";
        KeyCode[KeyCode["Enter"] = 3] = "Enter";
        KeyCode[KeyCode["Shift"] = 4] = "Shift";
        KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
        KeyCode[KeyCode["Alt"] = 6] = "Alt";
        KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
        KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
        KeyCode[KeyCode["Escape"] = 9] = "Escape";
        KeyCode[KeyCode["Space"] = 10] = "Space";
        KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
        KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
        KeyCode[KeyCode["End"] = 13] = "End";
        KeyCode[KeyCode["Home"] = 14] = "Home";
        KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
        KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
        KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
        KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
        KeyCode[KeyCode["Insert"] = 19] = "Insert";
        KeyCode[KeyCode["Delete"] = 20] = "Delete";
        KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
        KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
        KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
        KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
        KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
        KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
        KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
        KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
        KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
        KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
        KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
        KeyCode[KeyCode["Meta"] = 57] = "Meta";
        KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
        KeyCode[KeyCode["F1"] = 59] = "F1";
        KeyCode[KeyCode["F2"] = 60] = "F2";
        KeyCode[KeyCode["F3"] = 61] = "F3";
        KeyCode[KeyCode["F4"] = 62] = "F4";
        KeyCode[KeyCode["F5"] = 63] = "F5";
        KeyCode[KeyCode["F6"] = 64] = "F6";
        KeyCode[KeyCode["F7"] = 65] = "F7";
        KeyCode[KeyCode["F8"] = 66] = "F8";
        KeyCode[KeyCode["F9"] = 67] = "F9";
        KeyCode[KeyCode["F10"] = 68] = "F10";
        KeyCode[KeyCode["F11"] = 69] = "F11";
        KeyCode[KeyCode["F12"] = 70] = "F12";
        KeyCode[KeyCode["F13"] = 71] = "F13";
        KeyCode[KeyCode["F14"] = 72] = "F14";
        KeyCode[KeyCode["F15"] = 73] = "F15";
        KeyCode[KeyCode["F16"] = 74] = "F16";
        KeyCode[KeyCode["F17"] = 75] = "F17";
        KeyCode[KeyCode["F18"] = 76] = "F18";
        KeyCode[KeyCode["F19"] = 77] = "F19";
        KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
        KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
        KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
        KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
        KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
        KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
        KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
        KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
        KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
        KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
        KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
        KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
        KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
        KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
        KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
        KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
        KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
        /**
         * Cover all key codes when IME is processing input.
         */
        KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
        KeyCode[KeyCode["ABNT_C1"] = 110] = "ABNT_C1";
        KeyCode[KeyCode["ABNT_C2"] = 111] = "ABNT_C2";
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        KeyCode[KeyCode["MAX_VALUE"] = 112] = "MAX_VALUE";
    })(KeyCode = exports.KeyCode || (exports.KeyCode = {}));
    var KeyCodeStrMap = /** @class */ (function () {
        function KeyCodeStrMap() {
            this._keyCodeToStr = [];
            this._strToKeyCode = Object.create(null);
        }
        KeyCodeStrMap.prototype.define = function (keyCode, str) {
            this._keyCodeToStr[keyCode] = str;
            this._strToKeyCode[str.toLowerCase()] = keyCode;
        };
        KeyCodeStrMap.prototype.keyCodeToStr = function (keyCode) {
            return this._keyCodeToStr[keyCode];
        };
        KeyCodeStrMap.prototype.strToKeyCode = function (str) {
            return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;
        };
        return KeyCodeStrMap;
    }());
    var uiMap = new KeyCodeStrMap();
    var userSettingsUSMap = new KeyCodeStrMap();
    var userSettingsGeneralMap = new KeyCodeStrMap();
    (function () {
        function define(keyCode, uiLabel, usUserSettingsLabel, generalUserSettingsLabel) {
            if (usUserSettingsLabel === void 0) { usUserSettingsLabel = uiLabel; }
            if (generalUserSettingsLabel === void 0) { generalUserSettingsLabel = usUserSettingsLabel; }
            uiMap.define(keyCode, uiLabel);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);
        }
        define(0 /* Unknown */, 'unknown');
        define(1 /* Backspace */, 'Backspace');
        define(2 /* Tab */, 'Tab');
        define(3 /* Enter */, 'Enter');
        define(4 /* Shift */, 'Shift');
        define(5 /* Ctrl */, 'Ctrl');
        define(6 /* Alt */, 'Alt');
        define(7 /* PauseBreak */, 'PauseBreak');
        define(8 /* CapsLock */, 'CapsLock');
        define(9 /* Escape */, 'Escape');
        define(10 /* Space */, 'Space');
        define(11 /* PageUp */, 'PageUp');
        define(12 /* PageDown */, 'PageDown');
        define(13 /* End */, 'End');
        define(14 /* Home */, 'Home');
        define(15 /* LeftArrow */, 'LeftArrow', 'Left');
        define(16 /* UpArrow */, 'UpArrow', 'Up');
        define(17 /* RightArrow */, 'RightArrow', 'Right');
        define(18 /* DownArrow */, 'DownArrow', 'Down');
        define(19 /* Insert */, 'Insert');
        define(20 /* Delete */, 'Delete');
        define(21 /* KEY_0 */, '0');
        define(22 /* KEY_1 */, '1');
        define(23 /* KEY_2 */, '2');
        define(24 /* KEY_3 */, '3');
        define(25 /* KEY_4 */, '4');
        define(26 /* KEY_5 */, '5');
        define(27 /* KEY_6 */, '6');
        define(28 /* KEY_7 */, '7');
        define(29 /* KEY_8 */, '8');
        define(30 /* KEY_9 */, '9');
        define(31 /* KEY_A */, 'A');
        define(32 /* KEY_B */, 'B');
        define(33 /* KEY_C */, 'C');
        define(34 /* KEY_D */, 'D');
        define(35 /* KEY_E */, 'E');
        define(36 /* KEY_F */, 'F');
        define(37 /* KEY_G */, 'G');
        define(38 /* KEY_H */, 'H');
        define(39 /* KEY_I */, 'I');
        define(40 /* KEY_J */, 'J');
        define(41 /* KEY_K */, 'K');
        define(42 /* KEY_L */, 'L');
        define(43 /* KEY_M */, 'M');
        define(44 /* KEY_N */, 'N');
        define(45 /* KEY_O */, 'O');
        define(46 /* KEY_P */, 'P');
        define(47 /* KEY_Q */, 'Q');
        define(48 /* KEY_R */, 'R');
        define(49 /* KEY_S */, 'S');
        define(50 /* KEY_T */, 'T');
        define(51 /* KEY_U */, 'U');
        define(52 /* KEY_V */, 'V');
        define(53 /* KEY_W */, 'W');
        define(54 /* KEY_X */, 'X');
        define(55 /* KEY_Y */, 'Y');
        define(56 /* KEY_Z */, 'Z');
        define(57 /* Meta */, 'Meta');
        define(58 /* ContextMenu */, 'ContextMenu');
        define(59 /* F1 */, 'F1');
        define(60 /* F2 */, 'F2');
        define(61 /* F3 */, 'F3');
        define(62 /* F4 */, 'F4');
        define(63 /* F5 */, 'F5');
        define(64 /* F6 */, 'F6');
        define(65 /* F7 */, 'F7');
        define(66 /* F8 */, 'F8');
        define(67 /* F9 */, 'F9');
        define(68 /* F10 */, 'F10');
        define(69 /* F11 */, 'F11');
        define(70 /* F12 */, 'F12');
        define(71 /* F13 */, 'F13');
        define(72 /* F14 */, 'F14');
        define(73 /* F15 */, 'F15');
        define(74 /* F16 */, 'F16');
        define(75 /* F17 */, 'F17');
        define(76 /* F18 */, 'F18');
        define(77 /* F19 */, 'F19');
        define(78 /* NumLock */, 'NumLock');
        define(79 /* ScrollLock */, 'ScrollLock');
        define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');
        define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');
        define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');
        define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');
        define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');
        define(85 /* US_SLASH */, '/', '/', 'OEM_2');
        define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');
        define(110 /* ABNT_C1 */, 'ABNT_C1');
        define(111 /* ABNT_C2 */, 'ABNT_C2');
        define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');
        define(88 /* US_BACKSLASH */, '\\', '\\', 'OEM_5');
        define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');
        define(90 /* US_QUOTE */, '\'', '\'', 'OEM_7');
        define(91 /* OEM_8 */, 'OEM_8');
        define(92 /* OEM_102 */, 'OEM_102');
        define(93 /* NUMPAD_0 */, 'NumPad0');
        define(94 /* NUMPAD_1 */, 'NumPad1');
        define(95 /* NUMPAD_2 */, 'NumPad2');
        define(96 /* NUMPAD_3 */, 'NumPad3');
        define(97 /* NUMPAD_4 */, 'NumPad4');
        define(98 /* NUMPAD_5 */, 'NumPad5');
        define(99 /* NUMPAD_6 */, 'NumPad6');
        define(100 /* NUMPAD_7 */, 'NumPad7');
        define(101 /* NUMPAD_8 */, 'NumPad8');
        define(102 /* NUMPAD_9 */, 'NumPad9');
        define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');
        define(104 /* NUMPAD_ADD */, 'NumPad_Add');
        define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');
        define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');
        define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');
        define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');
    })();
    var KeyCodeUtils;
    (function (KeyCodeUtils) {
        function toString(keyCode) {
            return uiMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils.toString = toString;
        function fromString(key) {
            return uiMap.strToKeyCode(key);
        }
        KeyCodeUtils.fromString = fromString;
        function toUserSettingsUS(keyCode) {
            return userSettingsUSMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;
        function toUserSettingsGeneral(keyCode) {
            return userSettingsGeneralMap.keyCodeToStr(keyCode);
        }
        KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;
        function fromUserSettings(key) {
            return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
        }
        KeyCodeUtils.fromUserSettings = fromUserSettings;
    })(KeyCodeUtils = exports.KeyCodeUtils || (exports.KeyCodeUtils = {}));
    /**
     * Binary encoding strategy:
     * ```
     *    1111 11
     *    5432 1098 7654 3210
     *    ---- CSAW KKKK KKKK
     *  C = bit 11 = ctrlCmd flag
     *  S = bit 10 = shift flag
     *  A = bit 9 = alt flag
     *  W = bit 8 = winCtrl flag
     *  K = bits 0-7 = key code
     * ```
     */
    var BinaryKeybindingsMask;
    (function (BinaryKeybindingsMask) {
        BinaryKeybindingsMask[BinaryKeybindingsMask["CtrlCmd"] = 2048] = "CtrlCmd";
        BinaryKeybindingsMask[BinaryKeybindingsMask["Shift"] = 1024] = "Shift";
        BinaryKeybindingsMask[BinaryKeybindingsMask["Alt"] = 512] = "Alt";
        BinaryKeybindingsMask[BinaryKeybindingsMask["WinCtrl"] = 256] = "WinCtrl";
        BinaryKeybindingsMask[BinaryKeybindingsMask["KeyCode"] = 255] = "KeyCode";
    })(BinaryKeybindingsMask || (BinaryKeybindingsMask = {}));
    var KeyMod;
    (function (KeyMod) {
        KeyMod[KeyMod["CtrlCmd"] = 2048] = "CtrlCmd";
        KeyMod[KeyMod["Shift"] = 1024] = "Shift";
        KeyMod[KeyMod["Alt"] = 512] = "Alt";
        KeyMod[KeyMod["WinCtrl"] = 256] = "WinCtrl";
    })(KeyMod = exports.KeyMod || (exports.KeyMod = {}));
    function KeyChord(firstPart, secondPart) {
        var chordPart = ((secondPart & 0x0000ffff) << 16) >>> 0;
        return (firstPart | chordPart) >>> 0;
    }
    exports.KeyChord = KeyChord;
    function createKeybinding(keybinding, OS) {
        if (keybinding === 0) {
            return null;
        }
        var firstPart = (keybinding & 0x0000ffff) >>> 0;
        var chordPart = (keybinding & 0xffff0000) >>> 16;
        if (chordPart !== 0) {
            return new ChordKeybinding(createSimpleKeybinding(firstPart, OS), createSimpleKeybinding(chordPart, OS));
        }
        return createSimpleKeybinding(firstPart, OS);
    }
    exports.createKeybinding = createKeybinding;
    function createSimpleKeybinding(keybinding, OS) {
        var ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);
        var winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);
        var ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);
        var shiftKey = (keybinding & 1024 /* Shift */ ? true : false);
        var altKey = (keybinding & 512 /* Alt */ ? true : false);
        var metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);
        var keyCode = (keybinding & 255 /* KeyCode */);
        return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
    }
    exports.createSimpleKeybinding = createSimpleKeybinding;
    var KeybindingType;
    (function (KeybindingType) {
        KeybindingType[KeybindingType["Simple"] = 1] = "Simple";
        KeybindingType[KeybindingType["Chord"] = 2] = "Chord";
    })(KeybindingType = exports.KeybindingType || (exports.KeybindingType = {}));
    var SimpleKeybinding = /** @class */ (function () {
        function SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
            this.type = 1 /* Simple */;
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
            this.metaKey = metaKey;
            this.keyCode = keyCode;
        }
        SimpleKeybinding.prototype.equals = function (other) {
            if (other.type !== 1 /* Simple */) {
                return false;
            }
            return (this.ctrlKey === other.ctrlKey
                && this.shiftKey === other.shiftKey
                && this.altKey === other.altKey
                && this.metaKey === other.metaKey
                && this.keyCode === other.keyCode);
        };
        SimpleKeybinding.prototype.getHashCode = function () {
            var ctrl = this.ctrlKey ? '1' : '0';
            var shift = this.shiftKey ? '1' : '0';
            var alt = this.altKey ? '1' : '0';
            var meta = this.metaKey ? '1' : '0';
            return "" + ctrl + shift + alt + meta + this.keyCode;
        };
        SimpleKeybinding.prototype.isModifierKey = function () {
            return (this.keyCode === 0 /* Unknown */
                || this.keyCode === 5 /* Ctrl */
                || this.keyCode === 57 /* Meta */
                || this.keyCode === 6 /* Alt */
                || this.keyCode === 4 /* Shift */);
        };
        /**
         * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
         */
        SimpleKeybinding.prototype.isDuplicateModifierCase = function () {
            return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)
                || (this.shiftKey && this.keyCode === 4 /* Shift */)
                || (this.altKey && this.keyCode === 6 /* Alt */)
                || (this.metaKey && this.keyCode === 57 /* Meta */));
        };
        return SimpleKeybinding;
    }());
    exports.SimpleKeybinding = SimpleKeybinding;
    var ChordKeybinding = /** @class */ (function () {
        function ChordKeybinding(firstPart, chordPart) {
            this.type = 2 /* Chord */;
            this.firstPart = firstPart;
            this.chordPart = chordPart;
        }
        ChordKeybinding.prototype.getHashCode = function () {
            return this.firstPart.getHashCode() + ";" + this.chordPart.getHashCode();
        };
        return ChordKeybinding;
    }());
    exports.ChordKeybinding = ChordKeybinding;
    var ResolvedKeybindingPart = /** @class */ (function () {
        function ResolvedKeybindingPart(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
            this.metaKey = metaKey;
            this.keyLabel = kbLabel;
            this.keyAriaLabel = kbAriaLabel;
        }
        return ResolvedKeybindingPart;
    }());
    exports.ResolvedKeybindingPart = ResolvedKeybindingPart;
    /**
     * A resolved keybinding. Can be a simple keybinding or a chord keybinding.
     */
    var ResolvedKeybinding = /** @class */ (function () {
        function ResolvedKeybinding() {
        }
        return ResolvedKeybinding;
    }());
    exports.ResolvedKeybinding = ResolvedKeybinding;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[13/*vs/base/common/lifecycle*/], __M([1/*require*/,0/*exports*/,56/*vs/base/common/functional*/]), function (require, exports, functional_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isDisposable(thing) {
        return typeof thing.dispose === 'function'
            && thing.dispose.length === 0;
    }
    exports.isDisposable = isDisposable;
    function dispose(first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (Array.isArray(first)) {
            first.forEach(function (d) { return d && d.dispose(); });
            return [];
        }
        else if (rest.length === 0) {
            if (first) {
                first.dispose();
                return first;
            }
            return undefined;
        }
        else {
            dispose(first);
            dispose(rest);
            return [];
        }
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable(fn) {
        return { dispose: function () { fn(); } };
    }
    exports.toDisposable = toDisposable;
    var Disposable = /** @class */ (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Object.defineProperty(Disposable.prototype, "toDispose", {
            get: function () { return this._toDispose; },
            enumerable: true,
            configurable: true
        });
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        Disposable.None = Object.freeze({ dispose: function () { } });
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var ReferenceCollection = /** @class */ (function () {
        function ReferenceCollection() {
            this.references = Object.create(null);
        }
        ReferenceCollection.prototype.acquire = function (key) {
            var _this = this;
            var reference = this.references[key];
            if (!reference) {
                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };
            }
            var object = reference.object;
            var dispose = functional_1.once(function () {
                if (--reference.counter === 0) {
                    _this.destroyReferencedObject(reference.object);
                    delete _this.references[key];
                }
            });
            reference.counter++;
            return { object: object, dispose: dispose };
        };
        return ReferenceCollection;
    }());
    exports.ReferenceCollection = ReferenceCollection;
    var ImmortalReference = /** @class */ (function () {
        function ImmortalReference(object) {
            this.object = object;
        }
        ImmortalReference.prototype.dispose = function () { };
        return ImmortalReference;
    }());
    exports.ImmortalReference = ImmortalReference;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[152/*vs/base/common/linkedList*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Node = /** @class */ (function () {
        function Node(element) {
            this.element = element;
        }
        return Node;
    }());
    var LinkedList = /** @class */ (function () {
        function LinkedList() {
        }
        LinkedList.prototype.isEmpty = function () {
            return !this._first;
        };
        LinkedList.prototype.clear = function () {
            this._first = undefined;
            this._last = undefined;
        };
        LinkedList.prototype.unshift = function (element) {
            return this.insert(element, false);
        };
        LinkedList.prototype.push = function (element) {
            return this.insert(element, true);
        };
        LinkedList.prototype.insert = function (element, atTheEnd) {
            var _this = this;
            var newNode = new Node(element);
            if (!this._first) {
                this._first = newNode;
                this._last = newNode;
            }
            else if (atTheEnd) {
                // push
                var oldLast = this._last;
                this._last = newNode;
                newNode.prev = oldLast;
                oldLast.next = newNode;
            }
            else {
                // unshift
                var oldFirst = this._first;
                this._first = newNode;
                newNode.next = oldFirst;
                oldFirst.prev = newNode;
            }
            return function () {
                for (var candidate = _this._first; candidate instanceof Node; candidate = candidate.next) {
                    if (candidate !== newNode) {
                        continue;
                    }
                    if (candidate.prev && candidate.next) {
                        // middle
                        var anchor = candidate.prev;
                        anchor.next = candidate.next;
                        candidate.next.prev = anchor;
                    }
                    else if (!candidate.prev && !candidate.next) {
                        // only node
                        _this._first = undefined;
                        _this._last = undefined;
                    }
                    else if (!candidate.next) {
                        // last
                        _this._last = _this._last.prev;
                        _this._last.next = undefined;
                    }
                    else if (!candidate.prev) {
                        // first
                        _this._first = _this._first.next;
                        _this._first.prev = undefined;
                    }
                    // done
                    break;
                }
            };
        };
        LinkedList.prototype.iterator = function () {
            var element = {
                done: undefined,
                value: undefined,
            };
            var node = this._first;
            return {
                next: function () {
                    if (!node) {
                        element.done = true;
                        element.value = undefined;
                    }
                    else {
                        element.done = false;
                        element.value = node.element;
                        node = node.next;
                    }
                    return element;
                }
            };
        };
        LinkedList.prototype.toArray = function () {
            var result = [];
            for (var node = this._first; node instanceof Node; node = node.next) {
                result.push(node.element);
            }
            return result;
        };
        return LinkedList;
    }());
    exports.LinkedList = LinkedList;
});

define(__m[30/*vs/base/common/network*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        /**
         * A walk-through document.
         */
        Schemas.walkThrough = 'walkThrough';
        /**
         * An embedded code snippet.
         */
        Schemas.walkThroughSnippet = 'walkThroughSnippet';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
        Schemas.mailto = 'mailto';
        Schemas.untitled = 'untitled';
        Schemas.data = 'data';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

'use strict';

/*global define*/

// This module can be loaded in an amd and commonjs-context.
// Because we want both instances to use the same perf-data
// we store them globally
// stores data as 'type','name','startTime','duration'

if (typeof define !== "function" && typeof module === "object" && typeof module.exports === "object") {
	// this is commonjs, fake amd
	global.define = function (dep, callback) {
		module.exports = callback();
		global.define = undefined;
	};
}

define("vs/base/common/performance", [], function () {

	var _global = this;
	if (typeof global !== 'undefined') {
		_global = global;
	}
	_global._performanceEntries = _global._performanceEntries || [];

	// const _now = global.performance && performance.now ? performance.now : Date.now
	const _now = Date.now;

	function importEntries(entries) {
		global._performanceEntries.splice(0, 0, ...entries);
	}

	function exportEntries() {
		return global._performanceEntries.slice(0);
	}

	function getEntries(type, name) {
		const result = [];
		const entries = global._performanceEntries;
		for (let i = 0; i < entries.length; i += 5) {
			if (entries[i] === type && (name === void 0 || entries[i + 1] === name)) {
				result.push({
					type: entries[i],
					name: entries[i + 1],
					startTime: entries[i + 2],
					duration: entries[i + 3],
					seq: entries[i + 4],
				});
			}
		}

		return result.sort((a, b) => {
			return a.startTime - b.startTime || a.seq - b.seq;
		});
	}

	function getEntry(type, name) {
		const entries = global._performanceEntries;
		for (let i = 0; i < entries.length; i += 5) {
			if (entries[i] === type && entries[i + 1] === name) {
				return {
					type: entries[i],
					name: entries[i + 1],
					startTime: entries[i + 2],
					duration: entries[i + 3],
					seq: entries[i + 4],
				};
			}
		}
	}

	function getDuration(from, to) {
		const entries = global._performanceEntries;
		let target = to;
		let endTime = 0;
		for (let i = entries.length - 1; i >= 0; i -= 5) {
			if (entries[i - 3] === target) {
				if (target === to) {
					// found `to` (end of interval)
					endTime = entries[i - 2];
					target = from;
				} else {
					return endTime - entries[i - 2];
				}
			}
		}
		return 0;
	}

	let seq = 0;

	function mark(name) {
		global._performanceEntries.push('mark', name, _now(), 0, seq++);
		if (typeof console.timeStamp === 'function') {
			console.timeStamp(name);
		}
	}

	function measure(name, from, to) {

		let startTime;
		let duration;
		let now = _now();

		if (!from) {
			startTime = now;
		} else {
			startTime = _getLastStartTime(from);
		}

		if (!to) {
			duration = now - startTime;
		} else {
			duration = _getLastStartTime(to) - startTime;
		}

		global._performanceEntries.push('measure', name, startTime, duration);
	}

	function _getLastStartTime(name) {
		const entries = global._performanceEntries;
		for (let i = entries.length - 1; i >= 0; i -= 5) {
			if (entries[i - 3] === name) {
				return entries[i - 2];
			}
		}

		throw new Error(name + ' not found');
	}

	var exports = {
		mark: mark,
		measure: measure,
		getEntries: getEntries,
		getEntry: getEntry,
		getDuration: getDuration,
		importEntries: importEntries,
		exportEntries: exportEntries
	};

	return exports;
});

define(__m[3/*vs/base/common/platform*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isNative = false;
    var _isWeb = false;
    var _locale = undefined;
    var _language = undefined;
    var _translationsConfigFile = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    // OS detection
    if (typeof process === 'object' && typeof process.nextTick === 'function' && typeof process.platform === 'string') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _locale = exports.LANGUAGE_DEFAULT;
        _language = exports.LANGUAGE_DEFAULT;
        var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
        if (rawNlsConfig) {
            try {
                var nlsConfig = JSON.parse(rawNlsConfig);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
                _translationsConfigFile = nlsConfig._translationsConfigFile;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
    }
    var Platform;
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(Platform = exports.Platform || (exports.Platform = {}));
    function PlatformToString(platform) {
        switch (platform) {
            case 0 /* Web */: return 'Web';
            case 1 /* Mac */: return 'Mac';
            case 2 /* Linux */: return 'Linux';
            case 3 /* Windows */: return 'Windows';
        }
    }
    exports.PlatformToString = PlatformToString;
    var _platform = 0 /* Web */;
    if (_isNative) {
        if (_isMacintosh) {
            _platform = 1 /* Mac */;
        }
        else if (_isWindows) {
            _platform = 3 /* Windows */;
        }
        else if (_isLinux) {
            _platform = 2 /* Linux */;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.platform = _platform;
    function isRootUser() {
        return _isNative && !_isWindows && (process.getuid() === 0);
    }
    exports.isRootUser = isRootUser;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    /**
     * The translatios that are available through language packs.
     */
    exports.translationsConfigFile = _translationsConfigFile;
    var _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
    exports.globals = _globals;
    var _setImmediate = null;
    function setImmediate(callback) {
        if (_setImmediate === null) {
            if (exports.globals.setImmediate) {
                _setImmediate = exports.globals.setImmediate.bind(exports.globals);
            }
            else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                _setImmediate = process.nextTick.bind(process);
            }
            else {
                _setImmediate = exports.globals.setTimeout.bind(exports.globals);
            }
        }
        return _setImmediate(callback);
    }
    exports.setImmediate = setImmediate;
    var OperatingSystem;
    (function (OperatingSystem) {
        OperatingSystem[OperatingSystem["Windows"] = 1] = "Windows";
        OperatingSystem[OperatingSystem["Macintosh"] = 2] = "Macintosh";
        OperatingSystem[OperatingSystem["Linux"] = 3] = "Linux";
    })(OperatingSystem = exports.OperatingSystem || (exports.OperatingSystem = {}));
    exports.OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));
    var AccessibilitySupport;
    (function (AccessibilitySupport) {
        /**
         * This should be the browser case where it is not known if a screen reader is attached or no.
         */
        AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
        AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
        AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
    })(AccessibilitySupport = exports.AccessibilitySupport || (exports.AccessibilitySupport = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[73/*vs/base/common/scanCode*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * keyboardEvent.code
     */
    var ScanCode;
    (function (ScanCode) {
        ScanCode[ScanCode["None"] = 0] = "None";
        ScanCode[ScanCode["Hyper"] = 1] = "Hyper";
        ScanCode[ScanCode["Super"] = 2] = "Super";
        ScanCode[ScanCode["Fn"] = 3] = "Fn";
        ScanCode[ScanCode["FnLock"] = 4] = "FnLock";
        ScanCode[ScanCode["Suspend"] = 5] = "Suspend";
        ScanCode[ScanCode["Resume"] = 6] = "Resume";
        ScanCode[ScanCode["Turbo"] = 7] = "Turbo";
        ScanCode[ScanCode["Sleep"] = 8] = "Sleep";
        ScanCode[ScanCode["WakeUp"] = 9] = "WakeUp";
        ScanCode[ScanCode["KeyA"] = 10] = "KeyA";
        ScanCode[ScanCode["KeyB"] = 11] = "KeyB";
        ScanCode[ScanCode["KeyC"] = 12] = "KeyC";
        ScanCode[ScanCode["KeyD"] = 13] = "KeyD";
        ScanCode[ScanCode["KeyE"] = 14] = "KeyE";
        ScanCode[ScanCode["KeyF"] = 15] = "KeyF";
        ScanCode[ScanCode["KeyG"] = 16] = "KeyG";
        ScanCode[ScanCode["KeyH"] = 17] = "KeyH";
        ScanCode[ScanCode["KeyI"] = 18] = "KeyI";
        ScanCode[ScanCode["KeyJ"] = 19] = "KeyJ";
        ScanCode[ScanCode["KeyK"] = 20] = "KeyK";
        ScanCode[ScanCode["KeyL"] = 21] = "KeyL";
        ScanCode[ScanCode["KeyM"] = 22] = "KeyM";
        ScanCode[ScanCode["KeyN"] = 23] = "KeyN";
        ScanCode[ScanCode["KeyO"] = 24] = "KeyO";
        ScanCode[ScanCode["KeyP"] = 25] = "KeyP";
        ScanCode[ScanCode["KeyQ"] = 26] = "KeyQ";
        ScanCode[ScanCode["KeyR"] = 27] = "KeyR";
        ScanCode[ScanCode["KeyS"] = 28] = "KeyS";
        ScanCode[ScanCode["KeyT"] = 29] = "KeyT";
        ScanCode[ScanCode["KeyU"] = 30] = "KeyU";
        ScanCode[ScanCode["KeyV"] = 31] = "KeyV";
        ScanCode[ScanCode["KeyW"] = 32] = "KeyW";
        ScanCode[ScanCode["KeyX"] = 33] = "KeyX";
        ScanCode[ScanCode["KeyY"] = 34] = "KeyY";
        ScanCode[ScanCode["KeyZ"] = 35] = "KeyZ";
        ScanCode[ScanCode["Digit1"] = 36] = "Digit1";
        ScanCode[ScanCode["Digit2"] = 37] = "Digit2";
        ScanCode[ScanCode["Digit3"] = 38] = "Digit3";
        ScanCode[ScanCode["Digit4"] = 39] = "Digit4";
        ScanCode[ScanCode["Digit5"] = 40] = "Digit5";
        ScanCode[ScanCode["Digit6"] = 41] = "Digit6";
        ScanCode[ScanCode["Digit7"] = 42] = "Digit7";
        ScanCode[ScanCode["Digit8"] = 43] = "Digit8";
        ScanCode[ScanCode["Digit9"] = 44] = "Digit9";
        ScanCode[ScanCode["Digit0"] = 45] = "Digit0";
        ScanCode[ScanCode["Enter"] = 46] = "Enter";
        ScanCode[ScanCode["Escape"] = 47] = "Escape";
        ScanCode[ScanCode["Backspace"] = 48] = "Backspace";
        ScanCode[ScanCode["Tab"] = 49] = "Tab";
        ScanCode[ScanCode["Space"] = 50] = "Space";
        ScanCode[ScanCode["Minus"] = 51] = "Minus";
        ScanCode[ScanCode["Equal"] = 52] = "Equal";
        ScanCode[ScanCode["BracketLeft"] = 53] = "BracketLeft";
        ScanCode[ScanCode["BracketRight"] = 54] = "BracketRight";
        ScanCode[ScanCode["Backslash"] = 55] = "Backslash";
        ScanCode[ScanCode["IntlHash"] = 56] = "IntlHash";
        ScanCode[ScanCode["Semicolon"] = 57] = "Semicolon";
        ScanCode[ScanCode["Quote"] = 58] = "Quote";
        ScanCode[ScanCode["Backquote"] = 59] = "Backquote";
        ScanCode[ScanCode["Comma"] = 60] = "Comma";
        ScanCode[ScanCode["Period"] = 61] = "Period";
        ScanCode[ScanCode["Slash"] = 62] = "Slash";
        ScanCode[ScanCode["CapsLock"] = 63] = "CapsLock";
        ScanCode[ScanCode["F1"] = 64] = "F1";
        ScanCode[ScanCode["F2"] = 65] = "F2";
        ScanCode[ScanCode["F3"] = 66] = "F3";
        ScanCode[ScanCode["F4"] = 67] = "F4";
        ScanCode[ScanCode["F5"] = 68] = "F5";
        ScanCode[ScanCode["F6"] = 69] = "F6";
        ScanCode[ScanCode["F7"] = 70] = "F7";
        ScanCode[ScanCode["F8"] = 71] = "F8";
        ScanCode[ScanCode["F9"] = 72] = "F9";
        ScanCode[ScanCode["F10"] = 73] = "F10";
        ScanCode[ScanCode["F11"] = 74] = "F11";
        ScanCode[ScanCode["F12"] = 75] = "F12";
        ScanCode[ScanCode["PrintScreen"] = 76] = "PrintScreen";
        ScanCode[ScanCode["ScrollLock"] = 77] = "ScrollLock";
        ScanCode[ScanCode["Pause"] = 78] = "Pause";
        ScanCode[ScanCode["Insert"] = 79] = "Insert";
        ScanCode[ScanCode["Home"] = 80] = "Home";
        ScanCode[ScanCode["PageUp"] = 81] = "PageUp";
        ScanCode[ScanCode["Delete"] = 82] = "Delete";
        ScanCode[ScanCode["End"] = 83] = "End";
        ScanCode[ScanCode["PageDown"] = 84] = "PageDown";
        ScanCode[ScanCode["ArrowRight"] = 85] = "ArrowRight";
        ScanCode[ScanCode["ArrowLeft"] = 86] = "ArrowLeft";
        ScanCode[ScanCode["ArrowDown"] = 87] = "ArrowDown";
        ScanCode[ScanCode["ArrowUp"] = 88] = "ArrowUp";
        ScanCode[ScanCode["NumLock"] = 89] = "NumLock";
        ScanCode[ScanCode["NumpadDivide"] = 90] = "NumpadDivide";
        ScanCode[ScanCode["NumpadMultiply"] = 91] = "NumpadMultiply";
        ScanCode[ScanCode["NumpadSubtract"] = 92] = "NumpadSubtract";
        ScanCode[ScanCode["NumpadAdd"] = 93] = "NumpadAdd";
        ScanCode[ScanCode["NumpadEnter"] = 94] = "NumpadEnter";
        ScanCode[ScanCode["Numpad1"] = 95] = "Numpad1";
        ScanCode[ScanCode["Numpad2"] = 96] = "Numpad2";
        ScanCode[ScanCode["Numpad3"] = 97] = "Numpad3";
        ScanCode[ScanCode["Numpad4"] = 98] = "Numpad4";
        ScanCode[ScanCode["Numpad5"] = 99] = "Numpad5";
        ScanCode[ScanCode["Numpad6"] = 100] = "Numpad6";
        ScanCode[ScanCode["Numpad7"] = 101] = "Numpad7";
        ScanCode[ScanCode["Numpad8"] = 102] = "Numpad8";
        ScanCode[ScanCode["Numpad9"] = 103] = "Numpad9";
        ScanCode[ScanCode["Numpad0"] = 104] = "Numpad0";
        ScanCode[ScanCode["NumpadDecimal"] = 105] = "NumpadDecimal";
        ScanCode[ScanCode["IntlBackslash"] = 106] = "IntlBackslash";
        ScanCode[ScanCode["ContextMenu"] = 107] = "ContextMenu";
        ScanCode[ScanCode["Power"] = 108] = "Power";
        ScanCode[ScanCode["NumpadEqual"] = 109] = "NumpadEqual";
        ScanCode[ScanCode["F13"] = 110] = "F13";
        ScanCode[ScanCode["F14"] = 111] = "F14";
        ScanCode[ScanCode["F15"] = 112] = "F15";
        ScanCode[ScanCode["F16"] = 113] = "F16";
        ScanCode[ScanCode["F17"] = 114] = "F17";
        ScanCode[ScanCode["F18"] = 115] = "F18";
        ScanCode[ScanCode["F19"] = 116] = "F19";
        ScanCode[ScanCode["F20"] = 117] = "F20";
        ScanCode[ScanCode["F21"] = 118] = "F21";
        ScanCode[ScanCode["F22"] = 119] = "F22";
        ScanCode[ScanCode["F23"] = 120] = "F23";
        ScanCode[ScanCode["F24"] = 121] = "F24";
        ScanCode[ScanCode["Open"] = 122] = "Open";
        ScanCode[ScanCode["Help"] = 123] = "Help";
        ScanCode[ScanCode["Select"] = 124] = "Select";
        ScanCode[ScanCode["Again"] = 125] = "Again";
        ScanCode[ScanCode["Undo"] = 126] = "Undo";
        ScanCode[ScanCode["Cut"] = 127] = "Cut";
        ScanCode[ScanCode["Copy"] = 128] = "Copy";
        ScanCode[ScanCode["Paste"] = 129] = "Paste";
        ScanCode[ScanCode["Find"] = 130] = "Find";
        ScanCode[ScanCode["AudioVolumeMute"] = 131] = "AudioVolumeMute";
        ScanCode[ScanCode["AudioVolumeUp"] = 132] = "AudioVolumeUp";
        ScanCode[ScanCode["AudioVolumeDown"] = 133] = "AudioVolumeDown";
        ScanCode[ScanCode["NumpadComma"] = 134] = "NumpadComma";
        ScanCode[ScanCode["IntlRo"] = 135] = "IntlRo";
        ScanCode[ScanCode["KanaMode"] = 136] = "KanaMode";
        ScanCode[ScanCode["IntlYen"] = 137] = "IntlYen";
        ScanCode[ScanCode["Convert"] = 138] = "Convert";
        ScanCode[ScanCode["NonConvert"] = 139] = "NonConvert";
        ScanCode[ScanCode["Lang1"] = 140] = "Lang1";
        ScanCode[ScanCode["Lang2"] = 141] = "Lang2";
        ScanCode[ScanCode["Lang3"] = 142] = "Lang3";
        ScanCode[ScanCode["Lang4"] = 143] = "Lang4";
        ScanCode[ScanCode["Lang5"] = 144] = "Lang5";
        ScanCode[ScanCode["Abort"] = 145] = "Abort";
        ScanCode[ScanCode["Props"] = 146] = "Props";
        ScanCode[ScanCode["NumpadParenLeft"] = 147] = "NumpadParenLeft";
        ScanCode[ScanCode["NumpadParenRight"] = 148] = "NumpadParenRight";
        ScanCode[ScanCode["NumpadBackspace"] = 149] = "NumpadBackspace";
        ScanCode[ScanCode["NumpadMemoryStore"] = 150] = "NumpadMemoryStore";
        ScanCode[ScanCode["NumpadMemoryRecall"] = 151] = "NumpadMemoryRecall";
        ScanCode[ScanCode["NumpadMemoryClear"] = 152] = "NumpadMemoryClear";
        ScanCode[ScanCode["NumpadMemoryAdd"] = 153] = "NumpadMemoryAdd";
        ScanCode[ScanCode["NumpadMemorySubtract"] = 154] = "NumpadMemorySubtract";
        ScanCode[ScanCode["NumpadClear"] = 155] = "NumpadClear";
        ScanCode[ScanCode["NumpadClearEntry"] = 156] = "NumpadClearEntry";
        ScanCode[ScanCode["ControlLeft"] = 157] = "ControlLeft";
        ScanCode[ScanCode["ShiftLeft"] = 158] = "ShiftLeft";
        ScanCode[ScanCode["AltLeft"] = 159] = "AltLeft";
        ScanCode[ScanCode["MetaLeft"] = 160] = "MetaLeft";
        ScanCode[ScanCode["ControlRight"] = 161] = "ControlRight";
        ScanCode[ScanCode["ShiftRight"] = 162] = "ShiftRight";
        ScanCode[ScanCode["AltRight"] = 163] = "AltRight";
        ScanCode[ScanCode["MetaRight"] = 164] = "MetaRight";
        ScanCode[ScanCode["BrightnessUp"] = 165] = "BrightnessUp";
        ScanCode[ScanCode["BrightnessDown"] = 166] = "BrightnessDown";
        ScanCode[ScanCode["MediaPlay"] = 167] = "MediaPlay";
        ScanCode[ScanCode["MediaRecord"] = 168] = "MediaRecord";
        ScanCode[ScanCode["MediaFastForward"] = 169] = "MediaFastForward";
        ScanCode[ScanCode["MediaRewind"] = 170] = "MediaRewind";
        ScanCode[ScanCode["MediaTrackNext"] = 171] = "MediaTrackNext";
        ScanCode[ScanCode["MediaTrackPrevious"] = 172] = "MediaTrackPrevious";
        ScanCode[ScanCode["MediaStop"] = 173] = "MediaStop";
        ScanCode[ScanCode["Eject"] = 174] = "Eject";
        ScanCode[ScanCode["MediaPlayPause"] = 175] = "MediaPlayPause";
        ScanCode[ScanCode["MediaSelect"] = 176] = "MediaSelect";
        ScanCode[ScanCode["LaunchMail"] = 177] = "LaunchMail";
        ScanCode[ScanCode["LaunchApp2"] = 178] = "LaunchApp2";
        ScanCode[ScanCode["LaunchApp1"] = 179] = "LaunchApp1";
        ScanCode[ScanCode["SelectTask"] = 180] = "SelectTask";
        ScanCode[ScanCode["LaunchScreenSaver"] = 181] = "LaunchScreenSaver";
        ScanCode[ScanCode["BrowserSearch"] = 182] = "BrowserSearch";
        ScanCode[ScanCode["BrowserHome"] = 183] = "BrowserHome";
        ScanCode[ScanCode["BrowserBack"] = 184] = "BrowserBack";
        ScanCode[ScanCode["BrowserForward"] = 185] = "BrowserForward";
        ScanCode[ScanCode["BrowserStop"] = 186] = "BrowserStop";
        ScanCode[ScanCode["BrowserRefresh"] = 187] = "BrowserRefresh";
        ScanCode[ScanCode["BrowserFavorites"] = 188] = "BrowserFavorites";
        ScanCode[ScanCode["ZoomToggle"] = 189] = "ZoomToggle";
        ScanCode[ScanCode["MailReply"] = 190] = "MailReply";
        ScanCode[ScanCode["MailForward"] = 191] = "MailForward";
        ScanCode[ScanCode["MailSend"] = 192] = "MailSend";
        ScanCode[ScanCode["MAX_VALUE"] = 193] = "MAX_VALUE";
    })(ScanCode = exports.ScanCode || (exports.ScanCode = {}));
    var scanCodeIntToStr = [];
    var scanCodeStrToInt = Object.create(null);
    var scanCodeLowerCaseStrToInt = Object.create(null);
    exports.ScanCodeUtils = {
        lowerCaseToEnum: function (scanCode) { return scanCodeLowerCaseStrToInt[scanCode] || 0 /* None */; },
        toEnum: function (scanCode) { return scanCodeStrToInt[scanCode] || 0 /* None */; },
        toString: function (scanCode) { return scanCodeIntToStr[scanCode] || 'None'; }
    };
    /**
     * -1 if a ScanCode => KeyCode mapping depends on kb layout.
     */
    exports.IMMUTABLE_CODE_TO_KEY_CODE = [];
    /**
     * -1 if a KeyCode => ScanCode mapping depends on kb layout.
     */
    exports.IMMUTABLE_KEY_CODE_TO_CODE = [];
    var ScanCodeBinding = /** @class */ (function () {
        function ScanCodeBinding(ctrlKey, shiftKey, altKey, metaKey, scanCode) {
            this.ctrlKey = ctrlKey;
            this.shiftKey = shiftKey;
            this.altKey = altKey;
            this.metaKey = metaKey;
            this.scanCode = scanCode;
        }
        ScanCodeBinding.prototype.equals = function (other) {
            return (this.ctrlKey === other.ctrlKey
                && this.shiftKey === other.shiftKey
                && this.altKey === other.altKey
                && this.metaKey === other.metaKey
                && this.scanCode === other.scanCode);
        };
        /**
         * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
         */
        ScanCodeBinding.prototype.isDuplicateModifierCase = function () {
            return ((this.ctrlKey && (this.scanCode === 157 /* ControlLeft */ || this.scanCode === 161 /* ControlRight */))
                || (this.shiftKey && (this.scanCode === 158 /* ShiftLeft */ || this.scanCode === 162 /* ShiftRight */))
                || (this.altKey && (this.scanCode === 159 /* AltLeft */ || this.scanCode === 163 /* AltRight */))
                || (this.metaKey && (this.scanCode === 160 /* MetaLeft */ || this.scanCode === 164 /* MetaRight */)));
        };
        return ScanCodeBinding;
    }());
    exports.ScanCodeBinding = ScanCodeBinding;
    (function () {
        function d(intScanCode, strScanCode) {
            scanCodeIntToStr[intScanCode] = strScanCode;
            scanCodeStrToInt[strScanCode] = intScanCode;
            scanCodeLowerCaseStrToInt[strScanCode.toLowerCase()] = intScanCode;
        }
        d(0 /* None */, 'None');
        d(1 /* Hyper */, 'Hyper');
        d(2 /* Super */, 'Super');
        d(3 /* Fn */, 'Fn');
        d(4 /* FnLock */, 'FnLock');
        d(5 /* Suspend */, 'Suspend');
        d(6 /* Resume */, 'Resume');
        d(7 /* Turbo */, 'Turbo');
        d(8 /* Sleep */, 'Sleep');
        d(9 /* WakeUp */, 'WakeUp');
        d(10 /* KeyA */, 'KeyA');
        d(11 /* KeyB */, 'KeyB');
        d(12 /* KeyC */, 'KeyC');
        d(13 /* KeyD */, 'KeyD');
        d(14 /* KeyE */, 'KeyE');
        d(15 /* KeyF */, 'KeyF');
        d(16 /* KeyG */, 'KeyG');
        d(17 /* KeyH */, 'KeyH');
        d(18 /* KeyI */, 'KeyI');
        d(19 /* KeyJ */, 'KeyJ');
        d(20 /* KeyK */, 'KeyK');
        d(21 /* KeyL */, 'KeyL');
        d(22 /* KeyM */, 'KeyM');
        d(23 /* KeyN */, 'KeyN');
        d(24 /* KeyO */, 'KeyO');
        d(25 /* KeyP */, 'KeyP');
        d(26 /* KeyQ */, 'KeyQ');
        d(27 /* KeyR */, 'KeyR');
        d(28 /* KeyS */, 'KeyS');
        d(29 /* KeyT */, 'KeyT');
        d(30 /* KeyU */, 'KeyU');
        d(31 /* KeyV */, 'KeyV');
        d(32 /* KeyW */, 'KeyW');
        d(33 /* KeyX */, 'KeyX');
        d(34 /* KeyY */, 'KeyY');
        d(35 /* KeyZ */, 'KeyZ');
        d(36 /* Digit1 */, 'Digit1');
        d(37 /* Digit2 */, 'Digit2');
        d(38 /* Digit3 */, 'Digit3');
        d(39 /* Digit4 */, 'Digit4');
        d(40 /* Digit5 */, 'Digit5');
        d(41 /* Digit6 */, 'Digit6');
        d(42 /* Digit7 */, 'Digit7');
        d(43 /* Digit8 */, 'Digit8');
        d(44 /* Digit9 */, 'Digit9');
        d(45 /* Digit0 */, 'Digit0');
        d(46 /* Enter */, 'Enter');
        d(47 /* Escape */, 'Escape');
        d(48 /* Backspace */, 'Backspace');
        d(49 /* Tab */, 'Tab');
        d(50 /* Space */, 'Space');
        d(51 /* Minus */, 'Minus');
        d(52 /* Equal */, 'Equal');
        d(53 /* BracketLeft */, 'BracketLeft');
        d(54 /* BracketRight */, 'BracketRight');
        d(55 /* Backslash */, 'Backslash');
        d(56 /* IntlHash */, 'IntlHash');
        d(57 /* Semicolon */, 'Semicolon');
        d(58 /* Quote */, 'Quote');
        d(59 /* Backquote */, 'Backquote');
        d(60 /* Comma */, 'Comma');
        d(61 /* Period */, 'Period');
        d(62 /* Slash */, 'Slash');
        d(63 /* CapsLock */, 'CapsLock');
        d(64 /* F1 */, 'F1');
        d(65 /* F2 */, 'F2');
        d(66 /* F3 */, 'F3');
        d(67 /* F4 */, 'F4');
        d(68 /* F5 */, 'F5');
        d(69 /* F6 */, 'F6');
        d(70 /* F7 */, 'F7');
        d(71 /* F8 */, 'F8');
        d(72 /* F9 */, 'F9');
        d(73 /* F10 */, 'F10');
        d(74 /* F11 */, 'F11');
        d(75 /* F12 */, 'F12');
        d(76 /* PrintScreen */, 'PrintScreen');
        d(77 /* ScrollLock */, 'ScrollLock');
        d(78 /* Pause */, 'Pause');
        d(79 /* Insert */, 'Insert');
        d(80 /* Home */, 'Home');
        d(81 /* PageUp */, 'PageUp');
        d(82 /* Delete */, 'Delete');
        d(83 /* End */, 'End');
        d(84 /* PageDown */, 'PageDown');
        d(85 /* ArrowRight */, 'ArrowRight');
        d(86 /* ArrowLeft */, 'ArrowLeft');
        d(87 /* ArrowDown */, 'ArrowDown');
        d(88 /* ArrowUp */, 'ArrowUp');
        d(89 /* NumLock */, 'NumLock');
        d(90 /* NumpadDivide */, 'NumpadDivide');
        d(91 /* NumpadMultiply */, 'NumpadMultiply');
        d(92 /* NumpadSubtract */, 'NumpadSubtract');
        d(93 /* NumpadAdd */, 'NumpadAdd');
        d(94 /* NumpadEnter */, 'NumpadEnter');
        d(95 /* Numpad1 */, 'Numpad1');
        d(96 /* Numpad2 */, 'Numpad2');
        d(97 /* Numpad3 */, 'Numpad3');
        d(98 /* Numpad4 */, 'Numpad4');
        d(99 /* Numpad5 */, 'Numpad5');
        d(100 /* Numpad6 */, 'Numpad6');
        d(101 /* Numpad7 */, 'Numpad7');
        d(102 /* Numpad8 */, 'Numpad8');
        d(103 /* Numpad9 */, 'Numpad9');
        d(104 /* Numpad0 */, 'Numpad0');
        d(105 /* NumpadDecimal */, 'NumpadDecimal');
        d(106 /* IntlBackslash */, 'IntlBackslash');
        d(107 /* ContextMenu */, 'ContextMenu');
        d(108 /* Power */, 'Power');
        d(109 /* NumpadEqual */, 'NumpadEqual');
        d(110 /* F13 */, 'F13');
        d(111 /* F14 */, 'F14');
        d(112 /* F15 */, 'F15');
        d(113 /* F16 */, 'F16');
        d(114 /* F17 */, 'F17');
        d(115 /* F18 */, 'F18');
        d(116 /* F19 */, 'F19');
        d(117 /* F20 */, 'F20');
        d(118 /* F21 */, 'F21');
        d(119 /* F22 */, 'F22');
        d(120 /* F23 */, 'F23');
        d(121 /* F24 */, 'F24');
        d(122 /* Open */, 'Open');
        d(123 /* Help */, 'Help');
        d(124 /* Select */, 'Select');
        d(125 /* Again */, 'Again');
        d(126 /* Undo */, 'Undo');
        d(127 /* Cut */, 'Cut');
        d(128 /* Copy */, 'Copy');
        d(129 /* Paste */, 'Paste');
        d(130 /* Find */, 'Find');
        d(131 /* AudioVolumeMute */, 'AudioVolumeMute');
        d(132 /* AudioVolumeUp */, 'AudioVolumeUp');
        d(133 /* AudioVolumeDown */, 'AudioVolumeDown');
        d(134 /* NumpadComma */, 'NumpadComma');
        d(135 /* IntlRo */, 'IntlRo');
        d(136 /* KanaMode */, 'KanaMode');
        d(137 /* IntlYen */, 'IntlYen');
        d(138 /* Convert */, 'Convert');
        d(139 /* NonConvert */, 'NonConvert');
        d(140 /* Lang1 */, 'Lang1');
        d(141 /* Lang2 */, 'Lang2');
        d(142 /* Lang3 */, 'Lang3');
        d(143 /* Lang4 */, 'Lang4');
        d(144 /* Lang5 */, 'Lang5');
        d(145 /* Abort */, 'Abort');
        d(146 /* Props */, 'Props');
        d(147 /* NumpadParenLeft */, 'NumpadParenLeft');
        d(148 /* NumpadParenRight */, 'NumpadParenRight');
        d(149 /* NumpadBackspace */, 'NumpadBackspace');
        d(150 /* NumpadMemoryStore */, 'NumpadMemoryStore');
        d(151 /* NumpadMemoryRecall */, 'NumpadMemoryRecall');
        d(152 /* NumpadMemoryClear */, 'NumpadMemoryClear');
        d(153 /* NumpadMemoryAdd */, 'NumpadMemoryAdd');
        d(154 /* NumpadMemorySubtract */, 'NumpadMemorySubtract');
        d(155 /* NumpadClear */, 'NumpadClear');
        d(156 /* NumpadClearEntry */, 'NumpadClearEntry');
        d(157 /* ControlLeft */, 'ControlLeft');
        d(158 /* ShiftLeft */, 'ShiftLeft');
        d(159 /* AltLeft */, 'AltLeft');
        d(160 /* MetaLeft */, 'MetaLeft');
        d(161 /* ControlRight */, 'ControlRight');
        d(162 /* ShiftRight */, 'ShiftRight');
        d(163 /* AltRight */, 'AltRight');
        d(164 /* MetaRight */, 'MetaRight');
        d(165 /* BrightnessUp */, 'BrightnessUp');
        d(166 /* BrightnessDown */, 'BrightnessDown');
        d(167 /* MediaPlay */, 'MediaPlay');
        d(168 /* MediaRecord */, 'MediaRecord');
        d(169 /* MediaFastForward */, 'MediaFastForward');
        d(170 /* MediaRewind */, 'MediaRewind');
        d(171 /* MediaTrackNext */, 'MediaTrackNext');
        d(172 /* MediaTrackPrevious */, 'MediaTrackPrevious');
        d(173 /* MediaStop */, 'MediaStop');
        d(174 /* Eject */, 'Eject');
        d(175 /* MediaPlayPause */, 'MediaPlayPause');
        d(176 /* MediaSelect */, 'MediaSelect');
        d(177 /* LaunchMail */, 'LaunchMail');
        d(178 /* LaunchApp2 */, 'LaunchApp2');
        d(179 /* LaunchApp1 */, 'LaunchApp1');
        d(180 /* SelectTask */, 'SelectTask');
        d(181 /* LaunchScreenSaver */, 'LaunchScreenSaver');
        d(182 /* BrowserSearch */, 'BrowserSearch');
        d(183 /* BrowserHome */, 'BrowserHome');
        d(184 /* BrowserBack */, 'BrowserBack');
        d(185 /* BrowserForward */, 'BrowserForward');
        d(186 /* BrowserStop */, 'BrowserStop');
        d(187 /* BrowserRefresh */, 'BrowserRefresh');
        d(188 /* BrowserFavorites */, 'BrowserFavorites');
        d(189 /* ZoomToggle */, 'ZoomToggle');
        d(190 /* MailReply */, 'MailReply');
        d(191 /* MailForward */, 'MailForward');
        d(192 /* MailSend */, 'MailSend');
    })();
    (function () {
        for (var i = 0; i <= 193 /* MAX_VALUE */; i++) {
            exports.IMMUTABLE_CODE_TO_KEY_CODE[i] = -1;
        }
        for (var i = 0; i <= 112 /* MAX_VALUE */; i++) {
            exports.IMMUTABLE_KEY_CODE_TO_CODE[i] = -1;
        }
        function define(code, keyCode) {
            exports.IMMUTABLE_CODE_TO_KEY_CODE[code] = keyCode;
            if ((keyCode !== 0 /* Unknown */)
                && (keyCode !== 3 /* Enter */)
                && (keyCode !== 5 /* Ctrl */)
                && (keyCode !== 4 /* Shift */)
                && (keyCode !== 6 /* Alt */)
                && (keyCode !== 57 /* Meta */)) {
                exports.IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = code;
            }
        }
        // Manually added due to the exclusion above (due to duplication with NumpadEnter)
        exports.IMMUTABLE_KEY_CODE_TO_CODE[3 /* Enter */] = 46 /* Enter */;
        define(0 /* None */, 0 /* Unknown */);
        define(1 /* Hyper */, 0 /* Unknown */);
        define(2 /* Super */, 0 /* Unknown */);
        define(3 /* Fn */, 0 /* Unknown */);
        define(4 /* FnLock */, 0 /* Unknown */);
        define(5 /* Suspend */, 0 /* Unknown */);
        define(6 /* Resume */, 0 /* Unknown */);
        define(7 /* Turbo */, 0 /* Unknown */);
        define(8 /* Sleep */, 0 /* Unknown */);
        define(9 /* WakeUp */, 0 /* Unknown */);
        // define(ScanCode.KeyA, KeyCode.Unknown);
        // define(ScanCode.KeyB, KeyCode.Unknown);
        // define(ScanCode.KeyC, KeyCode.Unknown);
        // define(ScanCode.KeyD, KeyCode.Unknown);
        // define(ScanCode.KeyE, KeyCode.Unknown);
        // define(ScanCode.KeyF, KeyCode.Unknown);
        // define(ScanCode.KeyG, KeyCode.Unknown);
        // define(ScanCode.KeyH, KeyCode.Unknown);
        // define(ScanCode.KeyI, KeyCode.Unknown);
        // define(ScanCode.KeyJ, KeyCode.Unknown);
        // define(ScanCode.KeyK, KeyCode.Unknown);
        // define(ScanCode.KeyL, KeyCode.Unknown);
        // define(ScanCode.KeyM, KeyCode.Unknown);
        // define(ScanCode.KeyN, KeyCode.Unknown);
        // define(ScanCode.KeyO, KeyCode.Unknown);
        // define(ScanCode.KeyP, KeyCode.Unknown);
        // define(ScanCode.KeyQ, KeyCode.Unknown);
        // define(ScanCode.KeyR, KeyCode.Unknown);
        // define(ScanCode.KeyS, KeyCode.Unknown);
        // define(ScanCode.KeyT, KeyCode.Unknown);
        // define(ScanCode.KeyU, KeyCode.Unknown);
        // define(ScanCode.KeyV, KeyCode.Unknown);
        // define(ScanCode.KeyW, KeyCode.Unknown);
        // define(ScanCode.KeyX, KeyCode.Unknown);
        // define(ScanCode.KeyY, KeyCode.Unknown);
        // define(ScanCode.KeyZ, KeyCode.Unknown);
        // define(ScanCode.Digit1, KeyCode.Unknown);
        // define(ScanCode.Digit2, KeyCode.Unknown);
        // define(ScanCode.Digit3, KeyCode.Unknown);
        // define(ScanCode.Digit4, KeyCode.Unknown);
        // define(ScanCode.Digit5, KeyCode.Unknown);
        // define(ScanCode.Digit6, KeyCode.Unknown);
        // define(ScanCode.Digit7, KeyCode.Unknown);
        // define(ScanCode.Digit8, KeyCode.Unknown);
        // define(ScanCode.Digit9, KeyCode.Unknown);
        // define(ScanCode.Digit0, KeyCode.Unknown);
        define(46 /* Enter */, 3 /* Enter */);
        define(47 /* Escape */, 9 /* Escape */);
        define(48 /* Backspace */, 1 /* Backspace */);
        define(49 /* Tab */, 2 /* Tab */);
        define(50 /* Space */, 10 /* Space */);
        // define(ScanCode.Minus, KeyCode.Unknown);
        // define(ScanCode.Equal, KeyCode.Unknown);
        // define(ScanCode.BracketLeft, KeyCode.Unknown);
        // define(ScanCode.BracketRight, KeyCode.Unknown);
        // define(ScanCode.Backslash, KeyCode.Unknown);
        // define(ScanCode.IntlHash, KeyCode.Unknown);
        // define(ScanCode.Semicolon, KeyCode.Unknown);
        // define(ScanCode.Quote, KeyCode.Unknown);
        // define(ScanCode.Backquote, KeyCode.Unknown);
        // define(ScanCode.Comma, KeyCode.Unknown);
        // define(ScanCode.Period, KeyCode.Unknown);
        // define(ScanCode.Slash, KeyCode.Unknown);
        define(63 /* CapsLock */, 8 /* CapsLock */);
        define(64 /* F1 */, 59 /* F1 */);
        define(65 /* F2 */, 60 /* F2 */);
        define(66 /* F3 */, 61 /* F3 */);
        define(67 /* F4 */, 62 /* F4 */);
        define(68 /* F5 */, 63 /* F5 */);
        define(69 /* F6 */, 64 /* F6 */);
        define(70 /* F7 */, 65 /* F7 */);
        define(71 /* F8 */, 66 /* F8 */);
        define(72 /* F9 */, 67 /* F9 */);
        define(73 /* F10 */, 68 /* F10 */);
        define(74 /* F11 */, 69 /* F11 */);
        define(75 /* F12 */, 70 /* F12 */);
        define(76 /* PrintScreen */, 0 /* Unknown */);
        define(77 /* ScrollLock */, 79 /* ScrollLock */);
        define(78 /* Pause */, 7 /* PauseBreak */);
        define(79 /* Insert */, 19 /* Insert */);
        define(80 /* Home */, 14 /* Home */);
        define(81 /* PageUp */, 11 /* PageUp */);
        define(82 /* Delete */, 20 /* Delete */);
        define(83 /* End */, 13 /* End */);
        define(84 /* PageDown */, 12 /* PageDown */);
        define(85 /* ArrowRight */, 17 /* RightArrow */);
        define(86 /* ArrowLeft */, 15 /* LeftArrow */);
        define(87 /* ArrowDown */, 18 /* DownArrow */);
        define(88 /* ArrowUp */, 16 /* UpArrow */);
        define(89 /* NumLock */, 78 /* NumLock */);
        define(90 /* NumpadDivide */, 108 /* NUMPAD_DIVIDE */);
        define(91 /* NumpadMultiply */, 103 /* NUMPAD_MULTIPLY */);
        define(92 /* NumpadSubtract */, 106 /* NUMPAD_SUBTRACT */);
        define(93 /* NumpadAdd */, 104 /* NUMPAD_ADD */);
        define(94 /* NumpadEnter */, 3 /* Enter */); // Duplicate
        define(95 /* Numpad1 */, 94 /* NUMPAD_1 */);
        define(96 /* Numpad2 */, 95 /* NUMPAD_2 */);
        define(97 /* Numpad3 */, 96 /* NUMPAD_3 */);
        define(98 /* Numpad4 */, 97 /* NUMPAD_4 */);
        define(99 /* Numpad5 */, 98 /* NUMPAD_5 */);
        define(100 /* Numpad6 */, 99 /* NUMPAD_6 */);
        define(101 /* Numpad7 */, 100 /* NUMPAD_7 */);
        define(102 /* Numpad8 */, 101 /* NUMPAD_8 */);
        define(103 /* Numpad9 */, 102 /* NUMPAD_9 */);
        define(104 /* Numpad0 */, 93 /* NUMPAD_0 */);
        define(105 /* NumpadDecimal */, 107 /* NUMPAD_DECIMAL */);
        // define(ScanCode.IntlBackslash, KeyCode.Unknown);
        define(107 /* ContextMenu */, 58 /* ContextMenu */);
        define(108 /* Power */, 0 /* Unknown */);
        define(109 /* NumpadEqual */, 0 /* Unknown */);
        define(110 /* F13 */, 71 /* F13 */);
        define(111 /* F14 */, 72 /* F14 */);
        define(112 /* F15 */, 73 /* F15 */);
        define(113 /* F16 */, 74 /* F16 */);
        define(114 /* F17 */, 75 /* F17 */);
        define(115 /* F18 */, 76 /* F18 */);
        define(116 /* F19 */, 77 /* F19 */);
        define(117 /* F20 */, 0 /* Unknown */);
        define(118 /* F21 */, 0 /* Unknown */);
        define(119 /* F22 */, 0 /* Unknown */);
        define(120 /* F23 */, 0 /* Unknown */);
        define(121 /* F24 */, 0 /* Unknown */);
        define(122 /* Open */, 0 /* Unknown */);
        define(123 /* Help */, 0 /* Unknown */);
        define(124 /* Select */, 0 /* Unknown */);
        define(125 /* Again */, 0 /* Unknown */);
        define(126 /* Undo */, 0 /* Unknown */);
        define(127 /* Cut */, 0 /* Unknown */);
        define(128 /* Copy */, 0 /* Unknown */);
        define(129 /* Paste */, 0 /* Unknown */);
        define(130 /* Find */, 0 /* Unknown */);
        define(131 /* AudioVolumeMute */, 0 /* Unknown */);
        define(132 /* AudioVolumeUp */, 0 /* Unknown */);
        define(133 /* AudioVolumeDown */, 0 /* Unknown */);
        define(134 /* NumpadComma */, 105 /* NUMPAD_SEPARATOR */);
        // define(ScanCode.IntlRo, KeyCode.Unknown);
        define(136 /* KanaMode */, 0 /* Unknown */);
        // define(ScanCode.IntlYen, KeyCode.Unknown);
        define(138 /* Convert */, 0 /* Unknown */);
        define(139 /* NonConvert */, 0 /* Unknown */);
        define(140 /* Lang1 */, 0 /* Unknown */);
        define(141 /* Lang2 */, 0 /* Unknown */);
        define(142 /* Lang3 */, 0 /* Unknown */);
        define(143 /* Lang4 */, 0 /* Unknown */);
        define(144 /* Lang5 */, 0 /* Unknown */);
        define(145 /* Abort */, 0 /* Unknown */);
        define(146 /* Props */, 0 /* Unknown */);
        define(147 /* NumpadParenLeft */, 0 /* Unknown */);
        define(148 /* NumpadParenRight */, 0 /* Unknown */);
        define(149 /* NumpadBackspace */, 0 /* Unknown */);
        define(150 /* NumpadMemoryStore */, 0 /* Unknown */);
        define(151 /* NumpadMemoryRecall */, 0 /* Unknown */);
        define(152 /* NumpadMemoryClear */, 0 /* Unknown */);
        define(153 /* NumpadMemoryAdd */, 0 /* Unknown */);
        define(154 /* NumpadMemorySubtract */, 0 /* Unknown */);
        define(155 /* NumpadClear */, 0 /* Unknown */);
        define(156 /* NumpadClearEntry */, 0 /* Unknown */);
        define(157 /* ControlLeft */, 5 /* Ctrl */); // Duplicate
        define(158 /* ShiftLeft */, 4 /* Shift */); // Duplicate
        define(159 /* AltLeft */, 6 /* Alt */); // Duplicate
        define(160 /* MetaLeft */, 57 /* Meta */); // Duplicate
        define(161 /* ControlRight */, 5 /* Ctrl */); // Duplicate
        define(162 /* ShiftRight */, 4 /* Shift */); // Duplicate
        define(163 /* AltRight */, 6 /* Alt */); // Duplicate
        define(164 /* MetaRight */, 57 /* Meta */); // Duplicate
        define(165 /* BrightnessUp */, 0 /* Unknown */);
        define(166 /* BrightnessDown */, 0 /* Unknown */);
        define(167 /* MediaPlay */, 0 /* Unknown */);
        define(168 /* MediaRecord */, 0 /* Unknown */);
        define(169 /* MediaFastForward */, 0 /* Unknown */);
        define(170 /* MediaRewind */, 0 /* Unknown */);
        define(171 /* MediaTrackNext */, 0 /* Unknown */);
        define(172 /* MediaTrackPrevious */, 0 /* Unknown */);
        define(173 /* MediaStop */, 0 /* Unknown */);
        define(174 /* Eject */, 0 /* Unknown */);
        define(175 /* MediaPlayPause */, 0 /* Unknown */);
        define(176 /* MediaSelect */, 0 /* Unknown */);
        define(177 /* LaunchMail */, 0 /* Unknown */);
        define(178 /* LaunchApp2 */, 0 /* Unknown */);
        define(179 /* LaunchApp1 */, 0 /* Unknown */);
        define(180 /* SelectTask */, 0 /* Unknown */);
        define(181 /* LaunchScreenSaver */, 0 /* Unknown */);
        define(182 /* BrowserSearch */, 0 /* Unknown */);
        define(183 /* BrowserHome */, 0 /* Unknown */);
        define(184 /* BrowserBack */, 0 /* Unknown */);
        define(185 /* BrowserForward */, 0 /* Unknown */);
        define(186 /* BrowserStop */, 0 /* Unknown */);
        define(187 /* BrowserRefresh */, 0 /* Unknown */);
        define(188 /* BrowserFavorites */, 0 /* Unknown */);
        define(189 /* ZoomToggle */, 0 /* Unknown */);
        define(190 /* MailReply */, 0 /* Unknown */);
        define(191 /* MailForward */, 0 /* Unknown */);
        define(192 /* MailSend */, 0 /* Unknown */);
    })();
});

define(__m[134/*vs/base/common/keybindingParser*/], __M([1/*require*/,0/*exports*/,62/*vs/base/common/keyCodes*/,73/*vs/base/common/scanCode*/]), function (require, exports, keyCodes_1, scanCode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeybindingParser = /** @class */ (function () {
        function KeybindingParser() {
        }
        KeybindingParser._readModifiers = function (input) {
            input = input.toLowerCase().trim();
            var ctrl = false;
            var shift = false;
            var alt = false;
            var meta = false;
            var matchedModifier;
            do {
                matchedModifier = false;
                if (/^ctrl(\+|\-)/.test(input)) {
                    ctrl = true;
                    input = input.substr('ctrl-'.length);
                    matchedModifier = true;
                }
                if (/^shift(\+|\-)/.test(input)) {
                    shift = true;
                    input = input.substr('shift-'.length);
                    matchedModifier = true;
                }
                if (/^alt(\+|\-)/.test(input)) {
                    alt = true;
                    input = input.substr('alt-'.length);
                    matchedModifier = true;
                }
                if (/^meta(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('meta-'.length);
                    matchedModifier = true;
                }
                if (/^win(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('win-'.length);
                    matchedModifier = true;
                }
                if (/^cmd(\+|\-)/.test(input)) {
                    meta = true;
                    input = input.substr('cmd-'.length);
                    matchedModifier = true;
                }
            } while (matchedModifier);
            var key;
            var firstSpaceIdx = input.indexOf(' ');
            if (firstSpaceIdx > 0) {
                key = input.substring(0, firstSpaceIdx);
                input = input.substring(firstSpaceIdx);
            }
            else {
                key = input;
                input = '';
            }
            return {
                remains: input,
                ctrl: ctrl,
                shift: shift,
                alt: alt,
                meta: meta,
                key: key
            };
        };
        KeybindingParser.parseSimpleKeybinding = function (input) {
            var mods = this._readModifiers(input);
            var keyCode = keyCodes_1.KeyCodeUtils.fromUserSettings(mods.key);
            return [new keyCodes_1.SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode), mods.remains];
        };
        KeybindingParser.parseKeybinding = function (input, OS) {
            if (!input) {
                return null;
            }
            var _a = this.parseSimpleKeybinding(input), firstPart = _a[0], remains = _a[1];
            var chordPart = null;
            if (remains.length > 0) {
                chordPart = this.parseSimpleKeybinding(remains)[0];
            }
            if (chordPart) {
                return new keyCodes_1.ChordKeybinding(firstPart, chordPart);
            }
            return firstPart;
        };
        KeybindingParser.parseSimpleUserBinding = function (input) {
            var mods = this._readModifiers(input);
            var scanCodeMatch = mods.key.match(/^\[([^\]]+)\]$/);
            if (scanCodeMatch) {
                var strScanCode = scanCodeMatch[1];
                var scanCode = scanCode_1.ScanCodeUtils.lowerCaseToEnum(strScanCode);
                return [new scanCode_1.ScanCodeBinding(mods.ctrl, mods.shift, mods.alt, mods.meta, scanCode), mods.remains];
            }
            var keyCode = keyCodes_1.KeyCodeUtils.fromUserSettings(mods.key);
            return [new keyCodes_1.SimpleKeybinding(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode), mods.remains];
        };
        KeybindingParser.parseUserBinding = function (input) {
            if (!input) {
                return [null, null];
            }
            var _a = this.parseSimpleUserBinding(input), firstPart = _a[0], remains = _a[1];
            var chordPart = null;
            if (remains.length > 0) {
                chordPart = this.parseSimpleUserBinding(remains)[0];
            }
            return [firstPart, chordPart];
        };
        return KeybindingParser;
    }());
    exports.KeybindingParser = KeybindingParser;
});

define(__m[18/*vs/base/common/strings*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The empty string.
     */
    exports.empty = '';
    function isFalsyOrWhitespace(str) {
        if (!str || typeof str !== 'string') {
            return true;
        }
        return str.trim().length === 0;
    }
    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\[\]\(\)\#]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        if (haystack === needle) {
            return true;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.indexOf(needle, diff) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, options) {
        if (options === void 0) { options = {}; }
        if (!searchString) {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = escapeRegExpCharacters(searchString);
        }
        if (options.wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (options.global) {
            modifiers += 'g';
        }
        if (!options.matchCase) {
            modifiers += 'i';
        }
        if (options.multiline) {
            modifiers += 'm';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    function regExpContainsBackreference(regexpValue) {
        return !!regexpValue.match(/([^\\]|^)(\\\\)*\\\d+/);
    }
    exports.regExpContainsBackreference = regExpContainsBackreference;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = str.length; }
        for (var i = start; i < end; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return str.substring(start, i);
            }
        }
        return str.substring(start, end);
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compare = compare;
    function compareIgnoreCase(a, b) {
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                // equal
                continue;
            }
            if (isUpperAsciiLetter(codeA)) {
                codeA += 32;
            }
            if (isUpperAsciiLetter(codeB)) {
                codeB += 32;
            }
            var diff = codeA - codeB;
            if (diff === 0) {
                // equal -> ignoreCase
                continue;
            }
            else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
                //
                return diff;
            }
            else {
                return compare(a.toLowerCase(), b.toLowerCase());
            }
        }
        if (a.length < b.length) {
            return -1;
        }
        else if (a.length > b.length) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compareIgnoreCase = compareIgnoreCase;
    function isLowerAsciiLetter(code) {
        return code >= 97 /* a */ && code <= 122 /* z */;
    }
    exports.isLowerAsciiLetter = isLowerAsciiLetter;
    function isUpperAsciiLetter(code) {
        return code >= 65 /* A */ && code <= 90 /* Z */;
    }
    exports.isUpperAsciiLetter = isUpperAsciiLetter;
    function isAsciiLetter(code) {
        return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a ? a.length : 0;
        var len2 = b ? b.length : 0;
        if (len1 !== len2) {
            return false;
        }
        return doEqualsIgnoreCase(a, b);
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    function doEqualsIgnoreCase(a, b, stopAt) {
        if (stopAt === void 0) { stopAt = a.length; }
        if (typeof a !== 'string' || typeof b !== 'string') {
            return false;
        }
        for (var i = 0; i < stopAt; i++) {
            var codeA = a.charCodeAt(i);
            var codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            // a-z A-Z
            if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            // Any other charcode
            else {
                if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    function startsWithIgnoreCase(str, candidate) {
        var candidateLength = candidate.length;
        if (candidate.length > str.length) {
            return false;
        }
        return doEqualsIgnoreCase(str, candidate, candidateLength);
    }
    exports.startsWithIgnoreCase = startsWithIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    function substrEquals(a, aStart, aEnd, b, bStart, bEnd) {
        while (aStart < aEnd && bStart < bEnd) {
            if (a[aStart] !== b[bStart]) {
                return false;
            }
            aStart += 1;
            bStart += 1;
        }
        return true;
    }
    /**
     * Return the overlap between the suffix of `a` and the prefix of `b`.
     * For instance `overlap("foobar", "arr, I'm a pirate") === 2`.
     */
    function overlap(a, b) {
        var aEnd = a.length;
        var bEnd = b.length;
        var aStart = aEnd - bEnd;
        if (aStart === 0) {
            return a === b ? aEnd : 0;
        }
        else if (aStart < 0) {
            bEnd += aStart;
            aStart = 0;
        }
        while (aStart < aEnd && bEnd > 0) {
            if (substrEquals(a, aStart, aEnd, b, 0, bEnd)) {
                return bEnd;
            }
            bEnd -= 1;
            aStart += 1;
        }
        return 0;
    }
    exports.overlap = overlap;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    exports.isLowSurrogate = isLowSurrogate;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
     */
    var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
    /**
     * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
     */
    function containsRTL(str) {
        return CONTAINS_RTL.test(str);
    }
    exports.containsRTL = containsRTL;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
     */
    var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEF8]|\uD83E[\uDD00-\uDDE6])/;
    function containsEmoji(str) {
        return CONTAINS_EMOJI.test(str);
    }
    exports.containsEmoji = containsEmoji;
    var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    /**
     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
     */
    function isBasicASCII(str) {
        return IS_BASIC_ASCII.test(str);
    }
    exports.isBasicASCII = isBasicASCII;
    function containsFullWidthCharacter(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (isFullWidthCharacter(str.charCodeAt(i))) {
                return true;
            }
        }
        return false;
    }
    exports.containsFullWidthCharacter = containsFullWidthCharacter;
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80  2EFF   CJK Radicals Supplement
        //          2F00  2FDF   Kangxi Radicals
        //          2FF0  2FFF   Ideographic Description Characters
        //          3000  303F   CJK Symbols and Punctuation
        //          3040  309F   Hiragana
        //          30A0  30FF   Katakana
        //          3100  312F   Bopomofo
        //          3130  318F   Hangul Compatibility Jamo
        //          3190  319F   Kanbun
        //          31A0  31BF   Bopomofo Extended
        //          31F0  31FF   Katakana Phonetic Extensions
        //          3200  32FF   Enclosed CJK Letters and Months
        //          3300  33FF   CJK Compatibility
        //          3400  4DBF   CJK Unified Ideographs Extension A
        //          4DC0  4DFF   Yijing Hexagram Symbols
        //          4E00  9FFF   CJK Unified Ideographs
        //          A000  A48F   Yi Syllables
        //          A490  A4CF   Yi Radicals
        //          AC00  D7AF   Hangul Syllables
        // [IGNORE] D800  DB7F   High Surrogates
        // [IGNORE] DB80  DBFF   High Private Use Surrogates
        // [IGNORE] DC00  DFFF   Low Surrogates
        // [IGNORE] E000  F8FF   Private Use Area
        //          F900  FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00  FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50  FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00  FE0F   Variation Selectors
        // [IGNORE] FE20  FE2F   Combining Half Marks
        // [IGNORE] FE30  FE4F   CJK Compatibility Forms
        // [IGNORE] FE50  FE6F   Small Form Variants
        // [IGNORE] FE70  FEFF   Arabic Presentation Forms-B
        //          FF00  FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0  FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var re = /\b/g;
        var i = 0;
        while (re.test(text)) {
            if (text.length - re.lastIndex < n) {
                break;
            }
            i = re.lastIndex;
            re.lastIndex += 1;
        }
        return text.substring(i).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    function stripUTF8BOM(str) {
        return startsWithUTF8BOM(str) ? str.substr(1) : str;
    }
    exports.stripUTF8BOM = stripUTF8BOM;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
    /**
     * Checks if the characters of the provided query string are included in the
     * target string. The characters do not have to be contiguous within the string.
     */
    function fuzzyContains(target, query) {
        if (!target || !query) {
            return false; // return early if target or query are undefined
        }
        if (target.length < query.length) {
            return false; // impossible for query to be contained in target
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(query[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.fuzzyContains = fuzzyContains;
    function containsUppercaseCharacter(target, ignoreEscapedChars) {
        if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }
        if (!target) {
            return false;
        }
        if (ignoreEscapedChars) {
            target = target.replace(/\\./g, '');
        }
        return target.toLowerCase() !== target;
    }
    exports.containsUppercaseCharacter = containsUppercaseCharacter;
    function uppercaseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    exports.uppercaseFirstLetter = uppercaseFirstLetter;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[154/*vs/base/common/date*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/strings*/]), function (require, exports, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function toLocalISOString(date) {
        return date.getFullYear() +
            '-' + strings_1.pad(date.getMonth() + 1, 2) +
            '-' + strings_1.pad(date.getDate(), 2) +
            'T' + strings_1.pad(date.getHours(), 2) +
            ':' + strings_1.pad(date.getMinutes(), 2) +
            ':' + strings_1.pad(date.getSeconds(), 2) +
            '.' + (date.getMilliseconds() / 1000).toFixed(3).slice(2, 5) +
            'Z';
    }
    exports.toLocalISOString = toLocalISOString;
});

define(__m[15/*vs/base/common/paths*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/platform*/,18/*vs/base/common/strings*/]), function (require, exports, platform_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    /**
     * @param path the path to get the dirname from
     * @param separator the separator to use
     * @returns the directory name of a path.
     *
     */
    function dirname(path, separator) {
        if (separator === void 0) { separator = exports.nativeSep; }
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else if (~idx === path.length - 1) {
            return dirname(path.substring(0, path.length - 1));
        }
        else {
            var res = path.substring(0, ~idx);
            if (platform_1.isWindows && res[res.length - 1] === ':') {
                res += separator; // make sure drive letters end with backslash
            }
            return res;
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns `.far` from `boo.far` or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = platform_1.isWindows && toOSPath;
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            code = path.charCodeAt(1);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === 58 /* Colon */) {
                code = path.charCodeAt(2);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        // Not using a function with var-args because of how TS compiles
        // them to JS - it would result in 2*n runtime cost instead
        // of 1*n, where n is parts.length.
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                    var next = part.charCodeAt(0);
                    if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === 92 /* Backslash */) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === 92 /* Backslash */) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    function isEqual(pathA, pathB, ignoreCase) {
        var identityEquals = (pathA === pathB);
        if (!ignoreCase || identityEquals) {
            return identityEquals;
        }
        if (!pathA || !pathB) {
            return false;
        }
        return strings_1.equalsIgnoreCase(pathA, pathB);
    }
    exports.isEqual = isEqual;
    function isEqualOrParent(path, candidate, ignoreCase, separator) {
        if (separator === void 0) { separator = exports.nativeSep; }
        if (path === candidate) {
            return true;
        }
        if (!path || !candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (ignoreCase) {
            var beginsWith = strings_1.startsWithIgnoreCase(path, candidate);
            if (!beginsWith) {
                return false;
            }
            if (candidate.length === path.length) {
                return true; // same path, different casing
            }
            var sepOffset = candidate.length;
            if (candidate.charAt(candidate.length - 1) === separator) {
                sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character
            }
            return path.charAt(sepOffset) === separator;
        }
        if (candidate.charAt(candidate.length - 1) !== separator) {
            candidate += separator;
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isEqualOrParent = isEqualOrParent;
    /**
     * Adapted from Node's path.isAbsolute functions
     */
    function isAbsolute(path) {
        return platform_1.isWindows ?
            isAbsolute_win32(path) :
            isAbsolute_posix(path);
    }
    exports.isAbsolute = isAbsolute;
    function isAbsolute_win32(path) {
        if (!path) {
            return false;
        }
        var char0 = path.charCodeAt(0);
        if (char0 === 47 /* Slash */ || char0 === 92 /* Backslash */) {
            return true;
        }
        else if ((char0 >= 65 /* A */ && char0 <= 90 /* Z */) || (char0 >= 97 /* a */ && char0 <= 122 /* z */)) {
            if (path.length > 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var char2 = path.charCodeAt(2);
                if (char2 === 47 /* Slash */ || char2 === 92 /* Backslash */) {
                    return true;
                }
            }
        }
        return false;
    }
    exports.isAbsolute_win32 = isAbsolute_win32;
    function isAbsolute_posix(path) {
        return path && path.charCodeAt(0) === 47 /* Slash */;
    }
    exports.isAbsolute_posix = isAbsolute_posix;
});

define(__m[22/*vs/base/common/types*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        // The method can't do a type cast since there are type (like strings) which
        // are subclasses of any put not positvely matched by the function. Hence type
        // narrowing results in wrong results.
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

define(__m[119/*vs/base/common/graph*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/types*/,129/*vs/base/common/collections*/]), function (require, exports, types_1, collections_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function newNode(data) {
        return {
            data: data,
            incoming: Object.create(null),
            outgoing: Object.create(null)
        };
    }
    var Graph = /** @class */ (function () {
        function Graph(_hashFn) {
            this._hashFn = _hashFn;
            this._nodes = Object.create(null);
            // empty
        }
        Graph.prototype.roots = function () {
            var ret = [];
            collections_1.forEach(this._nodes, function (entry) {
                if (types_1.isEmptyObject(entry.value.outgoing)) {
                    ret.push(entry.value);
                }
            });
            return ret;
        };
        Graph.prototype.traverse = function (start, inwards, callback) {
            var startNode = this.lookup(start);
            if (!startNode) {
                return;
            }
            this._traverse(startNode, inwards, Object.create(null), callback);
        };
        Graph.prototype._traverse = function (node, inwards, seen, callback) {
            var _this = this;
            var key = this._hashFn(node.data);
            if (seen[key]) {
                return;
            }
            seen[key] = true;
            callback(node.data);
            var nodes = inwards ? node.outgoing : node.incoming;
            collections_1.forEach(nodes, function (entry) { return _this._traverse(entry.value, inwards, seen, callback); });
        };
        Graph.prototype.insertEdge = function (from, to) {
            var fromNode = this.lookupOrInsertNode(from), toNode = this.lookupOrInsertNode(to);
            fromNode.outgoing[this._hashFn(to)] = toNode;
            toNode.incoming[this._hashFn(from)] = fromNode;
        };
        Graph.prototype.removeNode = function (data) {
            var key = this._hashFn(data);
            delete this._nodes[key];
            collections_1.forEach(this._nodes, function (entry) {
                delete entry.value.outgoing[key];
                delete entry.value.incoming[key];
            });
        };
        Graph.prototype.lookupOrInsertNode = function (data) {
            var key = this._hashFn(data);
            var node = this._nodes[key];
            if (!node) {
                node = newNode(data);
                this._nodes[key] = node;
            }
            return node;
        };
        Graph.prototype.lookup = function (data) {
            return this._nodes[this._hashFn(data)];
        };
        Object.defineProperty(Graph.prototype, "length", {
            get: function () {
                return Object.keys(this._nodes).length;
            },
            enumerable: true,
            configurable: true
        });
        Graph.prototype.toString = function () {
            var data = [];
            collections_1.forEach(this._nodes, function (entry) {
                data.push(entry.key + ", (incoming)[" + Object.keys(entry.value.incoming).join(', ') + "], (outgoing)[" + Object.keys(entry.value.outgoing).join(',') + "]");
            });
            return data.join('\n');
        };
        return Graph;
    }());
    exports.Graph = Graph;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[17/*vs/base/common/objects*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/types*/]), function (require, exports, types_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            // See https://github.com/Microsoft/TypeScript/issues/10990
            return obj;
        }
        var result = Array.isArray(obj) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    function deepFreeze(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var stack = [obj];
        while (stack.length > 0) {
            var obj_1 = stack.shift();
            Object.freeze(obj_1);
            for (var key in obj_1) {
                if (_hasOwnProperty.call(obj_1, key)) {
                    var prop = obj_1[key];
                    if (typeof prop === 'object' && !Object.isFrozen(prop)) {
                        stack.push(prop);
                    }
                }
            }
        }
        return obj;
    }
    exports.deepFreeze = deepFreeze;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (types_1.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (types_1.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (types_1.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (_hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!types_1.isObject(destination)) {
            return source;
        }
        if (types_1.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (types_1.isObject(destination[key]) && types_1.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i;
        var key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
    /**
     * Returns an object that has keys for each value that is different in the base object. Keys
     * that do not exist in the target but in the base object are not considered.
     *
     * Note: This is not a deep-diffing method, so the values are strictly taken into the resulting
     * object if they differ.
     *
     * @param base the object to diff against
     * @param obj the object to use for diffing
     */
    function distinct(base, target) {
        var result = Object.create(null);
        if (!base || !target) {
            return result;
        }
        var targetKeys = Object.keys(target);
        targetKeys.forEach(function (k) {
            var baseValue = base[k];
            var targetValue = target[k];
            if (!equals(baseValue, targetValue)) {
                result[k] = targetValue;
            }
        });
        return result;
    }
    exports.distinct = distinct;
});

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
define(__m[6/*vs/base/common/uri*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var _a;
    var _schemePattern = /^\w[\w\d+.-]*$/;
    var _singleSlashStart = /^\//;
    var _doubleSlashStart = /^\/\//;
    function _validateUri(ret) {
        // scheme, must be set
        if (!ret.scheme) {
            // throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${ret.authority}", path: "${ret.path}", query: "${ret.query}", fragment: "${ret.fragment}"}`);
            console.warn("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
        }
        // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
        // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
        if (ret.scheme && !_schemePattern.test(ret.scheme)) {
            throw new Error('[UriError]: Scheme contains illegal characters.');
        }
        // path, http://tools.ietf.org/html/rfc3986#section-3.3
        // If a URI contains an authority component, then the path component
        // must either be empty or begin with a slash ("/") character.  If a URI
        // does not contain an authority component, then the path cannot begin
        // with two slash characters ("//").
        if (ret.path) {
            if (ret.authority) {
                if (!_singleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                }
            }
            else {
                if (_doubleSlashStart.test(ret.path)) {
                    throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                }
            }
        }
    }
    // implements a bit of https://tools.ietf.org/html/rfc3986#section-5
    function _referenceResolution(scheme, path) {
        // the slash-character is our 'default base' as we don't
        // support constructing URIs relative to other URIs. This
        // also means that we alter and potentially break paths.
        // see https://tools.ietf.org/html/rfc3986#section-5.1.4
        switch (scheme) {
            case 'https':
            case 'http':
            case 'file':
                if (!path) {
                    path = _slash;
                }
                else if (path[0] !== _slash) {
                    path = _slash + path;
                }
                break;
        }
        return path;
    }
    var _empty = '';
    var _slash = '/';
    var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component parts
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     */
    var URI = /** @class */ (function () {
        /**
         * @internal
         */
        function URI(schemeOrData, authority, path, query, fragment) {
            if (typeof schemeOrData === 'object') {
                this.scheme = schemeOrData.scheme || _empty;
                this.authority = schemeOrData.authority || _empty;
                this.path = schemeOrData.path || _empty;
                this.query = schemeOrData.query || _empty;
                this.fragment = schemeOrData.fragment || _empty;
                // no validation because it's this URI
                // that creates uri components.
                // _validateUri(this);
            }
            else {
                this.scheme = schemeOrData || _empty;
                this.authority = authority || _empty;
                this.path = _referenceResolution(this.scheme, path || _empty);
                this.query = query || _empty;
                this.fragment = fragment || _empty;
                _validateUri(this);
            }
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string';
        };
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
             * platform specific path separator.
             *
             * * Will *not* validate the path for invalid characters and semantics.
             * * Will *not* look at the scheme of this URI.
             * * The result shall *not* be used for display purposes but for accessing a file on disk.
             *
             *
             * The *difference* to `URI#path` is the use of the platform specific separator and the handling
             * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
             *
             * ```ts
                const u = URI.parse('file://server/c$/folder/file.txt')
                u.authority === 'server'
                u.path === '/shares/c$/file.txt'
                u.fsPath === '\\server\c$\folder\file.txt'
            ```
             *
             * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
             * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
             * with URIs that represent files on disk (`file` scheme).
             */
            get: function () {
                // if (this.scheme !== 'file') {
                // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
                // }
                return _makeFsPath(this);
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === void 0) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = _empty;
            }
            if (authority === void 0) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = _empty;
            }
            if (path === void 0) {
                path = this.path;
            }
            else if (path === null) {
                path = _empty;
            }
            if (query === void 0) {
                query = this.query;
            }
            else if (query === null) {
                query = _empty;
            }
            if (fragment === void 0) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = _empty;
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            return new _URI(scheme, authority, path, query, fragment);
        };
        // ---- parse & validate ------------------------
        /**
         * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
         * `file:///usr/home`, or `scheme:with/path`.
         *
         * @param value A string which represents an URI (see `URI#toString`).
         */
        URI.parse = function (value) {
            var match = _regexp.exec(value);
            if (!match) {
                return new _URI(_empty, _empty, _empty, _empty, _empty);
            }
            return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty));
        };
        /**
         * Creates a new URI from a file system path, e.g. `c:\my\files`,
         * `/usr/home`, or `\\server\share\some\path`.
         *
         * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
         * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
         * `URI.parse('file://' + path)` because the path might contain characters that are
         * interpreted (# and ?). See the following sample:
         * ```ts
        const good = URI.file('/coding/c#/project1');
        good.scheme === 'file';
        good.path === '/coding/c#/project1';
        good.fragment === '';
        const bad = URI.parse('file://' + '/coding/c#/project1');
        bad.scheme === 'file';
        bad.path === '/coding/c'; // path is now broken
        bad.fragment === '/project1';
        ```
         *
         * @param path A file system path (see `URI#fsPath`)
         */
        URI.file = function (path) {
            var authority = _empty;
            // normalize to fwd-slashes on windows,
            // on other systems bwd-slashes are valid
            // filename character, eg /f\oo/ba\r.txt
            if (platform_1.isWindows) {
                path = path.replace(/\\/g, _slash);
            }
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === _slash && path[1] === _slash) {
                var idx = path.indexOf(_slash, 2);
                if (idx === -1) {
                    authority = path.substring(2);
                    path = _slash;
                }
                else {
                    authority = path.substring(2, idx);
                    path = path.substring(idx) || _slash;
                }
            }
            return new _URI('file', authority, path, _empty, _empty);
        };
        URI.from = function (components) {
            return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
        };
        // ---- printing/externalize ---------------------------
        /**
         * Creates a string presentation for this URI. It's guardeed that calling
         * `URI.parse` with the result of this function creates an URI which is equal
         * to this URI.
         *
         * * The result shall *not* be used for display purposes but for externalization or transport.
         * * The result will be encoded using the percentage encoding and encoding happens mostly
         * ignore the scheme-specific encoding rules.
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            return _asFormatted(this, skipEncoding);
        };
        URI.prototype.toJSON = function () {
            return this;
        };
        URI.revive = function (data) {
            if (!data) {
                return data;
            }
            else if (data instanceof URI) {
                return data;
            }
            else {
                var result = new _URI(data);
                result._fsPath = data.fsPath;
                result._formatted = data.external;
                return result;
            }
        };
        return URI;
    }());
    exports.URI = URI;
    // tslint:disable-next-line:class-name
    var _URI = /** @class */ (function (_super) {
        __extends(_URI, _super);
        function _URI() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._formatted = null;
            _this._fsPath = null;
            return _this;
        }
        Object.defineProperty(_URI.prototype, "fsPath", {
            get: function () {
                if (!this._fsPath) {
                    this._fsPath = _makeFsPath(this);
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        _URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = _asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return _asFormatted(this, true);
            }
        };
        _URI.prototype.toJSON = function () {
            var res = {
                $mid: 1
            };
            // cached state
            if (this._fsPath) {
                res.fsPath = this._fsPath;
            }
            if (this._formatted) {
                res.external = this._formatted;
            }
            // uri components
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        return _URI;
    }(URI));
    // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
    var encodeTable = (_a = {},
        _a[58 /* Colon */] = '%3A',
        _a[47 /* Slash */] = '%2F',
        _a[63 /* QuestionMark */] = '%3F',
        _a[35 /* Hash */] = '%23',
        _a[91 /* OpenSquareBracket */] = '%5B',
        _a[93 /* CloseSquareBracket */] = '%5D',
        _a[64 /* AtSign */] = '%40',
        _a[33 /* ExclamationMark */] = '%21',
        _a[36 /* DollarSign */] = '%24',
        _a[38 /* Ampersand */] = '%26',
        _a[39 /* SingleQuote */] = '%27',
        _a[40 /* OpenParen */] = '%28',
        _a[41 /* CloseParen */] = '%29',
        _a[42 /* Asterisk */] = '%2A',
        _a[43 /* Plus */] = '%2B',
        _a[44 /* Comma */] = '%2C',
        _a[59 /* Semicolon */] = '%3B',
        _a[61 /* Equals */] = '%3D',
        _a[32 /* Space */] = '%20',
        _a);
    function encodeURIComponentFast(uriComponent, allowSlash) {
        var res = undefined;
        var nativeEncodePos = -1;
        for (var pos = 0; pos < uriComponent.length; pos++) {
            var code = uriComponent.charCodeAt(pos);
            // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
            if ((code >= 97 /* a */ && code <= 122 /* z */)
                || (code >= 65 /* A */ && code <= 90 /* Z */)
                || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
                || code === 45 /* Dash */
                || code === 46 /* Period */
                || code === 95 /* Underline */
                || code === 126 /* Tilde */
                || (allowSlash && code === 47 /* Slash */)) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // check if we write into a new string (by default we try to return the param)
                if (res !== undefined) {
                    res += uriComponent.charAt(pos);
                }
            }
            else {
                // encoding needed, we need to allocate a new string
                if (res === undefined) {
                    res = uriComponent.substr(0, pos);
                }
                // check with default table first
                var escaped = encodeTable[code];
                if (escaped !== undefined) {
                    // check if we are delaying native encode
                    if (nativeEncodePos !== -1) {
                        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                        nativeEncodePos = -1;
                    }
                    // append escaped variant to result
                    res += escaped;
                }
                else if (nativeEncodePos === -1) {
                    // use native encode only when needed
                    nativeEncodePos = pos;
                }
            }
        }
        if (nativeEncodePos !== -1) {
            res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
        }
        return res !== undefined ? res : uriComponent;
    }
    function encodeURIComponentMinimal(path) {
        var res = undefined;
        for (var pos = 0; pos < path.length; pos++) {
            var code = path.charCodeAt(pos);
            if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
                if (res === undefined) {
                    res = path.substr(0, pos);
                }
                res += encodeTable[code];
            }
            else {
                if (res !== undefined) {
                    res += path[pos];
                }
            }
        }
        return res !== undefined ? res : path;
    }
    /**
     * Compute `fsPath` for the given uri
     * @param uri
     */
    function _makeFsPath(uri) {
        var value;
        if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + uri.authority + uri.path;
        }
        else if (uri.path.charCodeAt(0) === 47 /* Slash */
            && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
            && uri.path.charCodeAt(2) === 58 /* Colon */) {
            // windows drive letter: file:///c:/far/boo
            value = uri.path[1].toLowerCase() + uri.path.substr(2);
        }
        else {
            // other path
            value = uri.path;
        }
        if (platform_1.isWindows) {
            value = value.replace(/\//g, '\\');
        }
        return value;
    }
    /**
     * Create the external version of a uri
     */
    function _asFormatted(uri, skipEncoding) {
        var encoder = !skipEncoding
            ? encodeURIComponentFast
            : encodeURIComponentMinimal;
        var res = '';
        var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
        if (scheme) {
            res += scheme;
            res += ':';
        }
        if (authority || scheme === 'file') {
            res += _slash;
            res += _slash;
        }
        if (authority) {
            var idx = authority.indexOf('@');
            if (idx !== -1) {
                // <user>@<auth>
                var userinfo = authority.substr(0, idx);
                authority = authority.substr(idx + 1);
                idx = userinfo.indexOf(':');
                if (idx === -1) {
                    res += encoder(userinfo, false);
                }
                else {
                    // <user>:<pass>@<auth>
                    res += encoder(userinfo.substr(0, idx), false);
                    res += ':';
                    res += encoder(userinfo.substr(idx + 1), false);
                }
                res += '@';
            }
            authority = authority.toLowerCase();
            idx = authority.indexOf(':');
            if (idx === -1) {
                res += encoder(authority, false);
            }
            else {
                // <auth>:<port>
                res += encoder(authority.substr(0, idx), false);
                res += authority.substr(idx);
            }
        }
        if (path) {
            // lower-case windows drive letters in /C:/fff or C:/fff
            if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
                var code = path.charCodeAt(1);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
                }
            }
            else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
                var code = path.charCodeAt(0);
                if (code >= 65 /* A */ && code <= 90 /* Z */) {
                    path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
                }
            }
            // encode the rest of the path
            res += encoder(path, true);
        }
        if (query) {
            res += '?';
            res += encoder(query, false);
        }
        if (fragment) {
            res += '#';
            res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
        }
        return res;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[45/*vs/base/common/amd*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getPathFromAmdModule(requirefn, relativePath) {
        return uri_1.URI.parse(requirefn.toUrl(relativePath)).fsPath;
    }
    exports.getPathFromAmdModule = getPathFromAmdModule;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[38/*vs/base/common/map*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function values(forEachable) {
        var result = [];
        forEachable.forEach(function (value) { return result.push(value); });
        return result;
    }
    exports.values = values;
    function keys(map) {
        var result = [];
        map.forEach(function (value, key) { return result.push(key); });
        return result;
    }
    exports.keys = keys;
    function getOrSet(map, key, value) {
        var result = map.get(key);
        if (result === void 0) {
            result = value;
            map.set(key, result);
        }
        return result;
    }
    exports.getOrSet = getOrSet;
    var StringIterator = /** @class */ (function () {
        function StringIterator() {
            this._value = '';
            this._pos = 0;
        }
        StringIterator.prototype.reset = function (key) {
            this._value = key;
            this._pos = 0;
            return this;
        };
        StringIterator.prototype.next = function () {
            this._pos += 1;
            return this;
        };
        StringIterator.prototype.hasNext = function () {
            return this._pos < this._value.length - 1;
        };
        StringIterator.prototype.cmp = function (a) {
            var aCode = a.charCodeAt(0);
            var thisCode = this._value.charCodeAt(this._pos);
            return aCode - thisCode;
        };
        StringIterator.prototype.value = function () {
            return this._value[this._pos];
        };
        return StringIterator;
    }());
    exports.StringIterator = StringIterator;
    var PathIterator = /** @class */ (function () {
        function PathIterator() {
        }
        PathIterator.prototype.reset = function (key) {
            this._value = key.replace(/\\$|\/$/, '');
            this._from = 0;
            this._to = 0;
            return this.next();
        };
        PathIterator.prototype.hasNext = function () {
            return this._to < this._value.length;
        };
        PathIterator.prototype.next = function () {
            // this._data = key.split(/[\\/]/).filter(s => !!s);
            this._from = this._to;
            var justSeps = true;
            for (; this._to < this._value.length; this._to++) {
                var ch = this._value.charCodeAt(this._to);
                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                    if (justSeps) {
                        this._from++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    justSeps = false;
                }
            }
            return this;
        };
        PathIterator.prototype.cmp = function (a) {
            var aPos = 0;
            var aLen = a.length;
            var thisPos = this._from;
            while (aPos < aLen && thisPos < this._to) {
                var cmp = a.charCodeAt(aPos) - this._value.charCodeAt(thisPos);
                if (cmp !== 0) {
                    return cmp;
                }
                aPos += 1;
                thisPos += 1;
            }
            if (aLen === this._to - this._from) {
                return 0;
            }
            else if (aPos < aLen) {
                return -1;
            }
            else {
                return 1;
            }
        };
        PathIterator.prototype.value = function () {
            return this._value.substring(this._from, this._to);
        };
        return PathIterator;
    }());
    exports.PathIterator = PathIterator;
    var TernarySearchTreeNode = /** @class */ (function () {
        function TernarySearchTreeNode() {
        }
        TernarySearchTreeNode.prototype.isEmpty = function () {
            return !this.left && !this.mid && !this.right && !this.value;
        };
        return TernarySearchTreeNode;
    }());
    var TernarySearchTree = /** @class */ (function () {
        function TernarySearchTree(segments) {
            this._iter = segments;
        }
        TernarySearchTree.forPaths = function () {
            return new TernarySearchTree(new PathIterator());
        };
        TernarySearchTree.forStrings = function () {
            return new TernarySearchTree(new StringIterator());
        };
        TernarySearchTree.prototype.clear = function () {
            this._root = undefined;
        };
        TernarySearchTree.prototype.set = function (key, element) {
            var iter = this._iter.reset(key);
            var node;
            if (!this._root) {
                this._root = new TernarySearchTreeNode();
                this._root.segment = iter.value();
            }
            node = this._root;
            while (true) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    if (!node.left) {
                        node.left = new TernarySearchTreeNode();
                        node.left.segment = iter.value();
                    }
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    if (!node.right) {
                        node.right = new TernarySearchTreeNode();
                        node.right.segment = iter.value();
                    }
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    if (!node.mid) {
                        node.mid = new TernarySearchTreeNode();
                        node.mid.segment = iter.value();
                    }
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            var oldElement = node.value;
            node.value = element;
            node.key = key;
            return oldElement;
        };
        TernarySearchTree.prototype.get = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node ? node.value : undefined;
        };
        TernarySearchTree.prototype.delete = function (key) {
            var iter = this._iter.reset(key);
            var stack = [];
            var node = this._root;
            // find and unset node
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    stack.push([1, node]);
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    stack.push([-1, node]);
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    stack.push([0, node]);
                    node = node.mid;
                }
                else {
                    // remove element
                    node.value = undefined;
                    // clean up empty nodes
                    while (stack.length > 0 && node.isEmpty()) {
                        var _a = stack.pop(), dir = _a[0], parent_1 = _a[1];
                        switch (dir) {
                            case 1:
                                parent_1.left = undefined;
                                break;
                            case 0:
                                parent_1.mid = undefined;
                                break;
                            case -1:
                                parent_1.right = undefined;
                                break;
                        }
                        node = parent_1;
                    }
                    break;
                }
            }
        };
        TernarySearchTree.prototype.findSubstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            var candidate;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    candidate = node.value || candidate;
                    node = node.mid;
                }
                else {
                    break;
                }
            }
            return node && node.value || candidate;
        };
        TernarySearchTree.prototype.findSuperstr = function (key) {
            var iter = this._iter.reset(key);
            var node = this._root;
            while (node) {
                var val = iter.cmp(node.segment);
                if (val > 0) {
                    // left
                    node = node.left;
                }
                else if (val < 0) {
                    // right
                    node = node.right;
                }
                else if (iter.hasNext()) {
                    // mid
                    iter.next();
                    node = node.mid;
                }
                else {
                    // collect
                    if (!node.mid) {
                        return undefined;
                    }
                    else {
                        return this._nodeIterator(node.mid);
                    }
                }
            }
            return undefined;
        };
        TernarySearchTree.prototype._nodeIterator = function (node) {
            var _this = this;
            var res = {
                done: false,
                value: undefined
            };
            var idx;
            var data;
            var next = function () {
                if (!data) {
                    // lazy till first invocation
                    data = [];
                    idx = 0;
                    _this._forEach(node, function (value) { return data.push(value); });
                }
                if (idx >= data.length) {
                    res.done = true;
                    res.value = undefined;
                }
                else {
                    res.done = false;
                    res.value = data[idx++];
                }
                return res;
            };
            return { next: next };
        };
        TernarySearchTree.prototype.forEach = function (callback) {
            this._forEach(this._root, callback);
        };
        TernarySearchTree.prototype._forEach = function (node, callback) {
            if (node) {
                // left
                this._forEach(node.left, callback);
                // node
                if (node.value) {
                    // callback(node.value, this._iter.join(parts));
                    callback(node.value, node.key);
                }
                // mid
                this._forEach(node.mid, callback);
                // right
                this._forEach(node.right, callback);
            }
        };
        return TernarySearchTree;
    }());
    exports.TernarySearchTree = TernarySearchTree;
    var ResourceMap = /** @class */ (function () {
        function ResourceMap() {
            this.map = new Map();
            this.ignoreCase = false; // in the future this should be an uri-comparator
        }
        ResourceMap.prototype.set = function (resource, value) {
            this.map.set(this.toKey(resource), value);
        };
        ResourceMap.prototype.get = function (resource) {
            return this.map.get(this.toKey(resource));
        };
        ResourceMap.prototype.has = function (resource) {
            return this.map.has(this.toKey(resource));
        };
        Object.defineProperty(ResourceMap.prototype, "size", {
            get: function () {
                return this.map.size;
            },
            enumerable: true,
            configurable: true
        });
        ResourceMap.prototype.clear = function () {
            this.map.clear();
        };
        ResourceMap.prototype.delete = function (resource) {
            return this.map.delete(this.toKey(resource));
        };
        ResourceMap.prototype.forEach = function (clb) {
            this.map.forEach(clb);
        };
        ResourceMap.prototype.values = function () {
            return values(this.map);
        };
        ResourceMap.prototype.toKey = function (resource) {
            var key = resource.toString();
            if (this.ignoreCase) {
                key = key.toLowerCase();
            }
            return key;
        };
        ResourceMap.prototype.keys = function () {
            return keys(this.map).map(uri_1.URI.parse);
        };
        ResourceMap.prototype.clone = function () {
            var resourceMap = new ResourceMap();
            this.map.forEach(function (value, key) { return resourceMap.map.set(key, value); });
            return resourceMap;
        };
        return ResourceMap;
    }());
    exports.ResourceMap = ResourceMap;
    var Touch;
    (function (Touch) {
        Touch[Touch["None"] = 0] = "None";
        Touch[Touch["AsOld"] = 1] = "AsOld";
        Touch[Touch["AsNew"] = 2] = "AsNew";
    })(Touch = exports.Touch || (exports.Touch = {}));
    var LinkedMap = /** @class */ (function () {
        function LinkedMap() {
            this._map = new Map();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        }
        LinkedMap.prototype.clear = function () {
            this._map.clear();
            this._head = undefined;
            this._tail = undefined;
            this._size = 0;
        };
        LinkedMap.prototype.isEmpty = function () {
            return !this._head && !this._tail;
        };
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.has = function (key) {
            return this._map.has(key);
        };
        LinkedMap.prototype.get = function (key, touch) {
            if (touch === void 0) { touch = 0 /* None */; }
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            if (touch !== 0 /* None */) {
                this.touch(item, touch);
            }
            return item.value;
        };
        LinkedMap.prototype.set = function (key, value, touch) {
            if (touch === void 0) { touch = 0 /* None */; }
            var item = this._map.get(key);
            if (item) {
                item.value = value;
                if (touch !== 0 /* None */) {
                    this.touch(item, touch);
                }
            }
            else {
                item = { key: key, value: value, next: undefined, previous: undefined };
                switch (touch) {
                    case 0 /* None */:
                        this.addItemLast(item);
                        break;
                    case 1 /* AsOld */:
                        this.addItemFirst(item);
                        break;
                    case 2 /* AsNew */:
                        this.addItemLast(item);
                        break;
                    default:
                        this.addItemLast(item);
                        break;
                }
                this._map.set(key, item);
                this._size++;
            }
        };
        LinkedMap.prototype.delete = function (key) {
            return !!this.remove(key);
        };
        LinkedMap.prototype.remove = function (key) {
            var item = this._map.get(key);
            if (!item) {
                return undefined;
            }
            this._map.delete(key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.shift = function () {
            if (!this._head && !this._tail) {
                return undefined;
            }
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            var item = this._head;
            this._map.delete(item.key);
            this.removeItem(item);
            this._size--;
            return item.value;
        };
        LinkedMap.prototype.forEach = function (callbackfn, thisArg) {
            var current = this._head;
            while (current) {
                if (thisArg) {
                    callbackfn.bind(thisArg)(current.value, current.key, this);
                }
                else {
                    callbackfn(current.value, current.key, this);
                }
                current = current.next;
            }
        };
        LinkedMap.prototype.values = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.value);
                current = current.next;
            }
            return result;
        };
        LinkedMap.prototype.keys = function () {
            var result = [];
            var current = this._head;
            while (current) {
                result.push(current.key);
                current = current.next;
            }
            return result;
        };
        /* VS Code / Monaco editor runs on es5 which has no Symbol.iterator
        public keys(): IterableIterator<K> {
            let current = this._head;
            let iterator: IterableIterator<K> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<K> {
                    if (current) {
                        let result = { value: current.key, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
    
        public values(): IterableIterator<V> {
            let current = this._head;
            let iterator: IterableIterator<V> = {
                [Symbol.iterator]() {
                    return iterator;
                },
                next():IteratorResult<V> {
                    if (current) {
                        let result = { value: current.value, done: false };
                        current = current.next;
                        return result;
                    } else {
                        return { value: undefined, done: true };
                    }
                }
            };
            return iterator;
        }
        */
        LinkedMap.prototype.trimOld = function (newSize) {
            if (newSize >= this.size) {
                return;
            }
            if (newSize === 0) {
                this.clear();
                return;
            }
            var current = this._head;
            var currentSize = this.size;
            while (current && currentSize > newSize) {
                this._map.delete(current.key);
                current = current.next;
                currentSize--;
            }
            this._head = current;
            this._size = currentSize;
            current.previous = void 0;
        };
        LinkedMap.prototype.addItemFirst = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._tail = item;
            }
            else if (!this._head) {
                throw new Error('Invalid list');
            }
            else {
                item.next = this._head;
                this._head.previous = item;
            }
            this._head = item;
        };
        LinkedMap.prototype.addItemLast = function (item) {
            // First time Insert
            if (!this._head && !this._tail) {
                this._head = item;
            }
            else if (!this._tail) {
                throw new Error('Invalid list');
            }
            else {
                item.previous = this._tail;
                this._tail.next = item;
            }
            this._tail = item;
        };
        LinkedMap.prototype.removeItem = function (item) {
            if (item === this._head && item === this._tail) {
                this._head = void 0;
                this._tail = void 0;
            }
            else if (item === this._head) {
                this._head = item.next;
            }
            else if (item === this._tail) {
                this._tail = item.previous;
            }
            else {
                var next = item.next;
                var previous = item.previous;
                if (!next || !previous) {
                    throw new Error('Invalid list');
                }
                next.previous = previous;
                previous.next = next;
            }
        };
        LinkedMap.prototype.touch = function (item, touch) {
            if (!this._head || !this._tail) {
                throw new Error('Invalid list');
            }
            if ((touch !== 1 /* AsOld */ && touch !== 2 /* AsNew */)) {
                return;
            }
            if (touch === 1 /* AsOld */) {
                if (item === this._head) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item
                if (item === this._tail) {
                    // previous must be defined since item was not head but is tail
                    // So there are more than on item in the map
                    previous.next = void 0;
                    this._tail = previous;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                // Insert the node at head
                item.previous = void 0;
                item.next = this._head;
                this._head.previous = item;
                this._head = item;
            }
            else if (touch === 2 /* AsNew */) {
                if (item === this._tail) {
                    return;
                }
                var next = item.next;
                var previous = item.previous;
                // Unlink the item.
                if (item === this._head) {
                    // next must be defined since item was not tail but is head
                    // So there are more than on item in the map
                    next.previous = void 0;
                    this._head = next;
                }
                else {
                    // Both next and previous are not undefined since item was neither head nor tail.
                    next.previous = previous;
                    previous.next = next;
                }
                item.next = void 0;
                item.previous = this._tail;
                this._tail.next = item;
                this._tail = item;
            }
        };
        LinkedMap.prototype.toJSON = function () {
            var data = [];
            this.forEach(function (value, key) {
                data.push([key, value]);
            });
            return data;
        };
        LinkedMap.prototype.fromJSON = function (data) {
            this.clear();
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var _a = data_1[_i], key = _a[0], value = _a[1];
                this.set(key, value);
            }
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
    var LRUCache = /** @class */ (function (_super) {
        __extends(LRUCache, _super);
        function LRUCache(limit, ratio) {
            if (ratio === void 0) { ratio = 1; }
            var _this = _super.call(this) || this;
            _this._limit = limit;
            _this._ratio = Math.min(Math.max(0, ratio), 1);
            return _this;
        }
        Object.defineProperty(LRUCache.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LRUCache.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            set: function (ratio) {
                this._ratio = Math.min(Math.max(0, ratio), 1);
                this.checkTrim();
            },
            enumerable: true,
            configurable: true
        });
        LRUCache.prototype.get = function (key) {
            return _super.prototype.get.call(this, key, 2 /* AsNew */);
        };
        LRUCache.prototype.peek = function (key) {
            return _super.prototype.get.call(this, key, 0 /* None */);
        };
        LRUCache.prototype.set = function (key, value) {
            _super.prototype.set.call(this, key, value, 2 /* AsNew */);
            this.checkTrim();
        };
        LRUCache.prototype.checkTrim = function () {
            if (this.size > this._limit) {
                this.trimOld(Math.round(this._limit * this._ratio));
            }
        };
        return LRUCache;
    }(LinkedMap));
    exports.LRUCache = LRUCache;
});

define(__m[72/*vs/base/common/normalization*/], __M([1/*require*/,0/*exports*/,38/*vs/base/common/map*/]), function (require, exports, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nfcCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        return normalize(str, 'NFC', nfcCache);
    }
    exports.normalizeNFC = normalizeNFC;
    var nfdCache = new map_1.LRUCache(10000); // bounded to 10000 elements
    function normalizeNFD(str) {
        return normalize(str, 'NFD', nfdCache);
    }
    exports.normalizeNFD = normalizeNFD;
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    function normalize(str, form, normalizedCache) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize(form);
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
});

define(__m[32/*vs/base/common/resources*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/paths*/,6/*vs/base/common/uri*/,18/*vs/base/common/strings*/,30/*vs/base/common/network*/,3/*vs/base/common/platform*/]), function (require, exports, paths, uri_1, strings_1, network_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getComparisonKey(resource) {
        return hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();
    }
    exports.getComparisonKey = getComparisonKey;
    function hasToIgnoreCase(resource) {
        // A file scheme resource is in the same platform as code, so ignore case for non linux platforms
        // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider
        return resource && resource.scheme === network_1.Schemas.file ? !platform_1.isLinux : true;
    }
    exports.hasToIgnoreCase = hasToIgnoreCase;
    function basenameOrAuthority(resource) {
        return basename(resource) || resource.authority;
    }
    exports.basenameOrAuthority = basenameOrAuthority;
    /**
     * Tests wheter a `candidate` URI is a parent or equal of a given `base` URI.
     * @param base A uri which is "longer"
     * @param parentCandidate A uri which is "shorter" then `base`
     */
    function isEqualOrParent(base, parentCandidate, ignoreCase) {
        if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(base); }
        if (base.scheme === parentCandidate.scheme) {
            if (base.scheme === network_1.Schemas.file) {
                return paths.isEqualOrParent(fsPath(base), fsPath(parentCandidate), ignoreCase);
            }
            if (isEqualAuthority(base.authority, parentCandidate.authority, ignoreCase)) {
                return paths.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');
            }
        }
        return false;
    }
    exports.isEqualOrParent = isEqualOrParent;
    function isEqualAuthority(a1, a2, ignoreCase) {
        return a1 === a2 || ignoreCase && a1 && a2 && strings_1.equalsIgnoreCase(a1, a2);
    }
    function isEqual(first, second, ignoreCase) {
        if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(first); }
        var identityEquals = (first === second);
        if (identityEquals) {
            return true;
        }
        if (!first || !second) {
            return false;
        }
        if (ignoreCase) {
            return strings_1.equalsIgnoreCase(first.toString(), second.toString());
        }
        return first.toString() === second.toString();
    }
    exports.isEqual = isEqual;
    function basename(resource) {
        return paths.basename(resource.path);
    }
    exports.basename = basename;
    /**
     * Return a URI representing the directory of a URI path.
     *
     * @param resource The input URI.
     * @returns The URI representing the directory of the input URI.
     */
    function dirname(resource) {
        var dirname = paths.dirname(resource.path, '/');
        if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {
            return null; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash ("/") character
        }
        return resource.with({
            path: dirname
        });
    }
    exports.dirname = dirname;
    /**
     * Join a URI path with a path fragment and normalizes the resulting path.
     *
     * @param resource The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    function joinPath(resource, pathFragment) {
        var joinedPath;
        if (resource.scheme === network_1.Schemas.file) {
            joinedPath = uri_1.URI.file(paths.join(fsPath(resource), pathFragment)).path;
        }
        else {
            joinedPath = paths.join(resource.path, pathFragment);
        }
        return resource.with({
            path: joinedPath
        });
    }
    exports.joinPath = joinPath;
    /**
     * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.
     *
     * @param resource The URI to normalize the path.
     * @returns The URI with the normalized path.
     */
    function normalizePath(resource) {
        var normalizedPath;
        if (resource.scheme === network_1.Schemas.file) {
            normalizedPath = uri_1.URI.file(paths.normalize(fsPath(resource))).path;
        }
        else {
            normalizedPath = paths.normalize(resource.path);
        }
        return resource.with({
            path: normalizedPath
        });
    }
    exports.normalizePath = normalizePath;
    /**
     * Returns the fsPath of an URI where the drive letter is not normalized.
     * See #56403.
     */
    function fsPath(uri) {
        var value;
        if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
            // unc path: file://shares/c$/far/boo
            value = "//" + uri.authority + uri.path;
        }
        else if (platform_1.isWindows
            && uri.path.charCodeAt(0) === 47 /* Slash */
            && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
            && uri.path.charCodeAt(2) === 58 /* Colon */) {
            value = uri.path.substr(1);
        }
        else {
            // other path
            value = uri.path;
        }
        if (platform_1.isWindows) {
            value = value.replace(/\//g, '\\');
        }
        return value;
    }
    /**
     * Returns true if the URI path is absolute.
     */
    function isAbsolutePath(resource) {
        return paths.isAbsolute(resource.path);
    }
    exports.isAbsolutePath = isAbsolutePath;
    function distinctParents(items, resourceAccessor) {
        var distinctParents = [];
        var _loop_1 = function (i) {
            var candidateResource = resourceAccessor(items[i]);
            if (items.some(function (otherItem, index) {
                if (index === i) {
                    return false;
                }
                return isEqualOrParent(candidateResource, resourceAccessor(otherItem));
            })) {
                return "continue";
            }
            distinctParents.push(items[i]);
        };
        for (var i = 0; i < items.length; i++) {
            _loop_1(i);
        }
        return distinctParents;
    }
    exports.distinctParents = distinctParents;
    /**
     * Tests wheter the given URL is a file URI created by `URI.parse` instead of `URI.file`.
     * Such URI have no scheme or scheme that consist of a single letter (windows drive letter)
     * @param candidate The URI to test
     * @returns A corrected, real file URI if the input seems to be malformed.
     * Undefined is returned if the input URI looks fine.
     */
    function isMalformedFileUri(candidate) {
        if (!candidate.scheme || platform_1.isWindows && candidate.scheme.match(/^[a-zA-Z]$/)) {
            return uri_1.URI.file((candidate.scheme ? candidate.scheme + ':' : '') + candidate.path);
        }
        return void 0;
    }
    exports.isMalformedFileUri = isMalformedFileUri;
});

define(__m[31/*vs/base/common/labels*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,15/*vs/base/common/paths*/,18/*vs/base/common/strings*/,30/*vs/base/common/network*/,3/*vs/base/common/platform*/,32/*vs/base/common/resources*/]), function (require, exports, uri_1, paths_1, strings_1, network_1, platform_1, resources_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @deprecated use LabelService instead
     */
    function getPathLabel(resource, userHomeProvider, rootProvider) {
        if (!resource) {
            return null;
        }
        if (typeof resource === 'string') {
            resource = uri_1.URI.file(resource);
        }
        // return early if we can resolve a relative path label from the root
        var baseResource = rootProvider ? rootProvider.getWorkspaceFolder(resource) : null;
        if (baseResource) {
            var hasMultipleRoots = rootProvider.getWorkspace().folders.length > 1;
            var pathLabel = void 0;
            if (resources_1.isEqual(baseResource.uri, resource, !platform_1.isLinux)) {
                pathLabel = ''; // no label if paths are identical
            }
            else {
                pathLabel = paths_1.normalize(strings_1.ltrim(resource.path.substr(baseResource.uri.path.length), paths_1.sep), true);
            }
            if (hasMultipleRoots) {
                var rootName = (baseResource && baseResource.name) ? baseResource.name : paths_1.basename(baseResource.uri.fsPath);
                pathLabel = pathLabel ? (rootName + '  ' + pathLabel) : rootName; // always show root basename if there are multiple
            }
            return pathLabel;
        }
        // return if the resource is neither file:// nor untitled:// and no baseResource was provided
        if (resource.scheme !== network_1.Schemas.file && resource.scheme !== network_1.Schemas.untitled) {
            return resource.with({ query: null, fragment: null }).toString(true);
        }
        // convert c:\something => C:\something
        if (hasDriveLetter(resource.fsPath)) {
            return paths_1.normalize(normalizeDriveLetter(resource.fsPath), true);
        }
        // normalize and tildify (macOS, Linux only)
        var res = paths_1.normalize(resource.fsPath, true);
        if (!platform_1.isWindows && userHomeProvider) {
            res = tildify(res, userHomeProvider.userHome);
        }
        return res;
    }
    exports.getPathLabel = getPathLabel;
    function getBaseLabel(resource) {
        if (!resource) {
            return null;
        }
        if (typeof resource === 'string') {
            resource = uri_1.URI.file(resource);
        }
        var base = paths_1.basename(resource.path) || (resource.scheme === network_1.Schemas.file ? resource.fsPath : resource.path) /* can be empty string if '/' is passed in */;
        // convert c: => C:
        if (hasDriveLetter(base)) {
            return normalizeDriveLetter(base);
        }
        return base;
    }
    exports.getBaseLabel = getBaseLabel;
    function hasDriveLetter(path) {
        return platform_1.isWindows && path && path[1] === ':';
    }
    function normalizeDriveLetter(path) {
        if (hasDriveLetter(path)) {
            return path.charAt(0).toUpperCase() + path.slice(1);
        }
        return path;
    }
    exports.normalizeDriveLetter = normalizeDriveLetter;
    var normalizedUserHomeCached = Object.create(null);
    function tildify(path, userHome) {
        if (platform_1.isWindows || !path || !userHome) {
            return path; // unsupported
        }
        // Keep a normalized user home path as cache to prevent accumulated string creation
        var normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : void 0;
        if (!normalizedUserHome) {
            normalizedUserHome = "" + strings_1.rtrim(userHome, paths_1.sep) + paths_1.sep;
            normalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };
        }
        // Linux: case sensitive, macOS: case insensitive
        if (platform_1.isLinux ? strings_1.startsWith(path, normalizedUserHome) : strings_1.startsWithIgnoreCase(path, normalizedUserHome)) {
            path = "~/" + path.substr(normalizedUserHome.length);
        }
        return path;
    }
    exports.tildify = tildify;
    function untildify(path, userHome) {
        return path.replace(/^~($|\/|\\)/, userHome + "$1");
    }
    exports.untildify = untildify;
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     *
     * Algorithm for shortening paths is as follows:
     * 1. For every path in list, find unique substring of that path.
     * 2. Unique substring along with ellipsis is shortened path of that path.
     * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string
     *    and if present segment is not substring to any other paths then present segment is unique path,
     *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,
     *    if it is true take present segment as unique path.
     * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.
     *
     * Example 1
     * 1. consider 2 paths i.e. ['a\\b\\c\\d', 'a\\f\\b\\c\\d']
     * 2. find unique path of first path,
     * 	a. 'd' is present in path2 and is suffix of path2, hence not unique of present path.
     * 	b. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.
     * 	c. 'd\\c' is suffix of path2.
     *  d. 'b\\c' is not suffix of present path.
     *  e. 'a\\b' is not present in path2, hence unique path is 'a\\b...'.
     * 3. for path2, 'f' is not present in path1 hence unique is '...\\f\\...'.
     *
     * Example 2
     * 1. consider 2 paths i.e. ['a\\b', 'a\\b\\c'].
     * 	a. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\b'.
     * 2. for path2, 'c' is not present in path1 hence unique path is '..\\c'.
     */
    var ellipsis = '\u2026';
    var unc = '\\\\';
    var home = '~';
    function shorten(paths) {
        var shortenedPaths = new Array(paths.length);
        // for every path
        var match = false;
        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            var path = paths[pathIndex];
            if (path === '') {
                shortenedPaths[pathIndex] = "." + paths_1.nativeSep;
                continue;
            }
            if (!path) {
                shortenedPaths[pathIndex] = path;
                continue;
            }
            match = true;
            // trim for now and concatenate unc path (e.g. \\network) or root path (/etc, ~/etc) later
            var prefix = '';
            if (path.indexOf(unc) === 0) {
                prefix = path.substr(0, path.indexOf(unc) + unc.length);
                path = path.substr(path.indexOf(unc) + unc.length);
            }
            else if (path.indexOf(paths_1.nativeSep) === 0) {
                prefix = path.substr(0, path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
                path = path.substr(path.indexOf(paths_1.nativeSep) + paths_1.nativeSep.length);
            }
            else if (path.indexOf(home) === 0) {
                prefix = path.substr(0, path.indexOf(home) + home.length);
                path = path.substr(path.indexOf(home) + home.length);
            }
            // pick the first shortest subpath found
            var segments = path.split(paths_1.nativeSep);
            for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                    match = false;
                    var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                    // that is unique to any other path
                    for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                        // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                        if (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {
                            var isSubpathEnding = (start + subpathLength === segments.length);
                            // Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.
                            // prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.
                            var subpathWithSep = (start > 0 && paths[otherPathIndex].indexOf(paths_1.nativeSep) > -1) ? paths_1.nativeSep + subpath : subpath;
                            var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpathWithSep);
                            match = !isSubpathEnding || isOtherPathEnding;
                        }
                    }
                    // found unique subpath
                    if (!match) {
                        var result = '';
                        // preserve disk drive or root prefix
                        if (strings_1.endsWith(segments[0], ':') || prefix !== '') {
                            if (start === 1) {
                                // extend subpath to include disk drive prefix
                                start = 0;
                                subpathLength++;
                                subpath = segments[0] + paths_1.nativeSep + subpath;
                            }
                            if (start > 0) {
                                result = segments[0] + paths_1.nativeSep;
                            }
                            result = prefix + result;
                        }
                        // add ellipsis at the beginning if neeeded
                        if (start > 0) {
                            result = result + ellipsis + paths_1.nativeSep;
                        }
                        result = result + subpath;
                        // add ellipsis at the end if needed
                        if (start + subpathLength < segments.length) {
                            result = result + paths_1.nativeSep + ellipsis;
                        }
                        shortenedPaths[pathIndex] = result;
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    exports.shorten = shorten;
    var Type;
    (function (Type) {
        Type[Type["TEXT"] = 0] = "TEXT";
        Type[Type["VARIABLE"] = 1] = "VARIABLE";
        Type[Type["SEPARATOR"] = 2] = "SEPARATOR";
    })(Type || (Type = {}));
    /**
     * Helper to insert values for specific template variables into the string. E.g. "this $(is) a $(template)" can be
     * passed to this function together with an object that maps "is" and "template" to strings to have them replaced.
     * @param value string to which templating is applied
     * @param values the values of the templates to use
     */
    function template(template, values) {
        if (values === void 0) { values = Object.create(null); }
        var segments = [];
        var inVariable = false;
        var char;
        var curVal = '';
        for (var i = 0; i < template.length; i++) {
            char = template[i];
            // Beginning of variable
            if (char === '$' || (inVariable && char === '{')) {
                if (curVal) {
                    segments.push({ value: curVal, type: Type.TEXT });
                }
                curVal = '';
                inVariable = true;
            }
            // End of variable
            else if (char === '}' && inVariable) {
                var resolved = values[curVal];
                // Variable
                if (typeof resolved === 'string') {
                    if (resolved.length) {
                        segments.push({ value: resolved, type: Type.VARIABLE });
                    }
                }
                // Separator
                else if (resolved) {
                    var prevSegment = segments[segments.length - 1];
                    if (!prevSegment || prevSegment.type !== Type.SEPARATOR) {
                        segments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators
                    }
                }
                curVal = '';
                inVariable = false;
            }
            // Text or Variable Name
            else {
                curVal += char;
            }
        }
        // Tail
        if (curVal && !inVariable) {
            segments.push({ value: curVal, type: Type.TEXT });
        }
        return segments.filter(function (segment, index) {
            // Only keep separator if we have values to the left and right
            if (segment.type === Type.SEPARATOR) {
                var left = segments[index - 1];
                var right = segments[index + 1];
                return [left, right].every(function (segment) { return segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0; });
            }
            // accept any TEXT and VARIABLE
            return true;
        }).map(function (segment) { return segment.value; }).join('');
    }
    exports.template = template;
    /**
     * Handles mnemonics for menu items. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via & character (replace && with &)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicMenuLabel(label, forceDisableMnemonics) {
        if (platform_1.isMacintosh || forceDisableMnemonics) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, '&');
    }
    exports.mnemonicMenuLabel = mnemonicMenuLabel;
    /**
     * Handles mnemonics for buttons. Depending on OS:
     * - Windows: Supported via & character (replace && with &)
     * -   Linux: Supported via _ character (replace && with _)
     * -   macOS: Unsupported (replace && with empty string)
     */
    function mnemonicButtonLabel(label) {
        if (platform_1.isMacintosh) {
            return label.replace(/\(&&\w\)|&&/g, '');
        }
        return label.replace(/&&/g, platform_1.isWindows ? '&' : '_');
    }
    exports.mnemonicButtonLabel = mnemonicButtonLabel;
    function unmnemonicLabel(label) {
        return label.replace(/&/g, '&&');
    }
    exports.unmnemonicLabel = unmnemonicLabel;
});














define(__m[39/*vs/base/common/uuid*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = /** @class */ (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        return ValueUUID;
    }());
    var V4UUID = /** @class */ (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            return _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join('')) || this;
        }
        V4UUID._oneOf = function (array) {
            return array[Math.floor(array.length * Math.random())];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
        return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!isUUID(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the MIT License.
 */
var __winjs_exports;

(function() {

var _modules = Object.create(null);//{};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    var actualSetImmediate = null;

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: function (callback) {
            // BEGIN monaco change
            if (actualSetImmediate === null) {
                if (_Global.setImmediate) {
                    actualSetImmediate = _Global.setImmediate.bind(_Global);
                } else if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
                    actualSetImmediate = process.nextTick.bind(process);
                } else {
                    actualSetImmediate = _Global.setTimeout.bind(_Global);
                }
            }
            actualSetImmediate(callback);
            // END monaco change
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            // BEGIN monaco change
            if (this.then !== Promise_then) {
                this.then(onComplete, onError, onProgress);
                return;
            }
            // END monaco change
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

__winjs_exports = _modules["WinJS/Core/_WinJS"];
__winjs_exports.TPromise = __winjs_exports.Promise;
__winjs_exports.PPromise = __winjs_exports.Promise;

// ESM-comment-begin
if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base", [], __winjs_exports);
} else {
    module.exports = __winjs_exports;
}
// ESM-comment-end

})();

// ESM-uncomment-begin
// export var Promise = __winjs_exports.Promise;
// export var TPromise = __winjs_exports.TPromise;
// export var PPromise = __winjs_exports.PPromise;
// ESM-uncomment-end

define(__m[23/*vs/base/common/errors*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ BEGIN Hook up error listeners to winjs promises
    var outstandingPromiseErrors = {};
    function promiseErrorHandler(e) {
        //
        // e.detail looks like: { exception, error, promise, handler, id, parent }
        //
        var details = e.detail;
        var id = details.id;
        // If the error has a parent promise then this is not the origination of the
        //  error so we check if it has a handler, and if so we mark that the error
        //  was handled by removing it from outstandingPromiseErrors
        //
        if (details.parent) {
            if (details.handler && outstandingPromiseErrors) {
                delete outstandingPromiseErrors[id];
            }
            return;
        }
        // Indicate that this error was originated and needs to be handled
        outstandingPromiseErrors[id] = details;
        // The first time the queue fills up this iteration, schedule a timeout to
        // check if any errors are still unhandled.
        if (Object.keys(outstandingPromiseErrors).length === 1) {
            setTimeout(function () {
                var errors = outstandingPromiseErrors;
                outstandingPromiseErrors = {};
                Object.keys(errors).forEach(function (errorId) {
                    var error = errors[errorId];
                    if (error.exception) {
                        onUnexpectedError(error.exception);
                    }
                    else if (error.error) {
                        onUnexpectedError(error.error);
                    }
                    console.log('WARNING: Promise with no error callback:' + error.id);
                    console.log(error);
                    if (error.exception) {
                        console.log(error.exception.stack);
                    }
                });
            }, 0);
        }
    }
    winjs_base_1.TPromise.addEventListener('error', promiseErrorHandler);
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = /** @class */ (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        // For external errors, we don't want the listeners to be called
        ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
            this.unexpectedErrorHandler(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
        return undefined;
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedExternalError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedExternalError(e);
        }
        return undefined;
    }
    exports.onUnexpectedExternalError = onUnexpectedExternalError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    function illegalArgument(name) {
        if (name) {
            return new Error("Illegal argument: " + name);
        }
        else {
            return new Error('Illegal argument');
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error("Illegal state: " + name);
        }
        else {
            return new Error('Illegal state');
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function disposed(what) {
        var result = new Error(what + " has been disposed");
        result.name = 'DISPOSED';
        return result;
    }
    exports.disposed = disposed;
    function isErrorWithActions(obj) {
        return obj instanceof Error && Array.isArray(obj.actions);
    }
    exports.isErrorWithActions = isErrorWithActions;
    function create(message, options) {
        if (options === void 0) { options = Object.create(null); }
        var result = new Error(message);
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
    function getErrorMessage(err) {
        if (!err) {
            return 'Error';
        }
        if (err.message) {
            return err.message;
        }
        if (err.stack) {
            return err.stack.split('\n')[0];
        }
        return String(err);
    }
    exports.getErrorMessage = getErrorMessage;
});

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
define(__m[24/*vs/base/common/arrays*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/errors*/,2/*vs/base/common/winjs.base*/]), function (require, exports, errors_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default is zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    function tail2(arr) {
        if (arr.length === 0) {
            throw new Error('Invalid tail call');
        }
        return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
    }
    exports.tail2 = tail2;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one === other) {
            return true;
        }
        if (!one || !other) {
            return false;
        }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirstInSorted(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirstInSorted = findFirstInSorted;
    /**
     * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
     * so only use this when actually needing stable sort.
     */
    function mergeSort(data, compare) {
        _sort(data, compare, 0, data.length - 1, []);
        return data;
    }
    exports.mergeSort = mergeSort;
    function _merge(a, compare, lo, mid, hi, aux) {
        var leftIdx = lo, rightIdx = mid + 1;
        for (var i = lo; i <= hi; i++) {
            aux[i] = a[i];
        }
        for (var i = lo; i <= hi; i++) {
            if (leftIdx > mid) {
                // left side consumed
                a[i] = aux[rightIdx++];
            }
            else if (rightIdx > hi) {
                // right side consumed
                a[i] = aux[leftIdx++];
            }
            else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {
                // right element is less -> comes first
                a[i] = aux[rightIdx++];
            }
            else {
                // left element comes first (less or equal)
                a[i] = aux[leftIdx++];
            }
        }
    }
    function _sort(a, compare, lo, hi, aux) {
        if (hi <= lo) {
            return;
        }
        var mid = lo + ((hi - lo) / 2) | 0;
        _sort(a, compare, lo, mid, aux);
        _sort(a, compare, mid + 1, hi, aux);
        if (compare(a[mid], a[mid + 1]) <= 0) {
            // left and right are sorted and if the last-left element is less
            // or equals than the first-right element there is nothing else
            // to do
            return;
        }
        _merge(a, compare, lo, mid, hi, aux);
    }
    function groupBy(data, compare) {
        var result = [];
        var currentGroup;
        for (var _i = 0, _a = mergeSort(data.slice(0), compare); _i < _a.length; _i++) {
            var element = _a[_i];
            if (!currentGroup || compare(currentGroup[0], element) !== 0) {
                currentGroup = [element];
                result.push(currentGroup);
            }
            else {
                currentGroup.push(element);
            }
        }
        return result;
    }
    exports.groupBy = groupBy;
    /**
     * Diffs two *sorted* arrays and computes the splices which apply the diff.
     */
    function sortedDiff(before, after, compare) {
        var result = [];
        function pushSplice(start, deleteCount, toInsert) {
            var _a;
            if (deleteCount === 0 && toInsert.length === 0) {
                return;
            }
            var latest = result[result.length - 1];
            if (latest && latest.start + latest.deleteCount === start) {
                latest.deleteCount += deleteCount;
                (_a = latest.toInsert).push.apply(_a, toInsert);
            }
            else {
                result.push({ start: start, deleteCount: deleteCount, toInsert: toInsert });
            }
        }
        var beforeIdx = 0;
        var afterIdx = 0;
        while (true) {
            if (beforeIdx === before.length) {
                pushSplice(beforeIdx, 0, after.slice(afterIdx));
                break;
            }
            if (afterIdx === after.length) {
                pushSplice(beforeIdx, before.length - beforeIdx, []);
                break;
            }
            var beforeElement = before[beforeIdx];
            var afterElement = after[afterIdx];
            var n = compare(beforeElement, afterElement);
            if (n === 0) {
                // equal
                beforeIdx += 1;
                afterIdx += 1;
            }
            else if (n < 0) {
                // beforeElement is smaller -> before element removed
                pushSplice(beforeIdx, 1, []);
                beforeIdx += 1;
            }
            else if (n > 0) {
                // beforeElement is greater -> after element added
                pushSplice(beforeIdx, 0, [afterElement]);
                afterIdx += 1;
            }
        }
        return result;
    }
    exports.sortedDiff = sortedDiff;
    /**
     * Takes two *sorted* arrays and computes their delta (removed, added elements).
     * Finishes in `Math.min(before.length, after.length)` steps.
     * @param before
     * @param after
     * @param compare
     */
    function delta(before, after, compare) {
        var splices = sortedDiff(before, after, compare);
        var removed = [];
        var added = [];
        for (var _i = 0, splices_1 = splices; _i < splices_1.length; _i++) {
            var splice = splices_1[_i];
            removed.push.apply(removed, before.slice(splice.start, splice.start + splice.deleteCount));
            added.push.apply(added, splice.toInsert);
        }
        return { removed: removed, added: added };
    }
    exports.delta = delta;
    /**
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @return The first n elemnts from array when sorted with compare.
     */
    function top(array, compare, n) {
        if (n === 0) {
            return [];
        }
        var result = array.slice(0, n).sort(compare);
        topStep(array, compare, result, n, array.length);
        return result;
    }
    exports.top = top;
    /**
     * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.
     *
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @param batch The number of elements to examine before yielding to the event loop.
     * @return The first n elemnts from array when sorted with compare.
     */
    function topAsync(array, compare, n, batch, token) {
        var _this = this;
        if (n === 0) {
            return winjs_base_1.TPromise.as([]);
        }
        return new winjs_base_1.TPromise(function (resolve, reject) {
            (function () { return __awaiter(_this, void 0, void 0, function () {
                var o, result, i, m;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            o = array.length;
                            result = array.slice(0, n).sort(compare);
                            i = n, m = Math.min(n + batch, o);
                            _a.label = 1;
                        case 1:
                            if (!(i < o)) return [3 /*break*/, 5];
                            if (!(i > n)) return [3 /*break*/, 3];
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve); })];
                        case 2:
                            _a.sent(); // nextTick() would starve I/O.
                            _a.label = 3;
                        case 3:
                            if (token && token.isCancellationRequested) {
                                throw errors_1.canceled();
                            }
                            topStep(array, compare, result, i, m);
                            _a.label = 4;
                        case 4:
                            i = m, m = Math.min(m + batch, o);
                            return [3 /*break*/, 1];
                        case 5: return [2 /*return*/, result];
                    }
                });
            }); })()
                .then(resolve, reject);
        });
    }
    exports.topAsync = topAsync;
    function topStep(array, compare, result, i, m) {
        var _loop_1 = function (n) {
            var element = array[i];
            if (compare(element, result[n - 1]) < 0) {
                result.pop();
                var j = findFirstInSorted(result, function (e) { return compare(element, e) < 0; });
                result.splice(j, 0, element);
            }
        };
        for (var n = result.length; i < m; i++) {
            _loop_1(n);
        }
    }
    function coalesce(array, inplace) {
        if (!array) {
            if (!inplace) {
                return array;
            }
        }
        if (!inplace) {
            return array.filter(function (e) { return !!e; });
        }
        else {
            var to = 0;
            for (var i = 0; i < array.length; i++) {
                if (!!array[i]) {
                    array[to] = array[i];
                    to += 1;
                }
            }
            array.length = to;
        }
    }
    exports.coalesce = coalesce;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return [].concat.apply([], arr);
    }
    exports.flatten = flatten;
    function range(arg, to) {
        var from = typeof to === 'number' ? arg : 0;
        if (typeof to === 'number') {
            from = arg;
        }
        else {
            from = 0;
            to = arg;
        }
        var result = [];
        if (from <= to) {
            for (var i = from; i < to; i++) {
                result.push(i);
            }
        }
        else {
            for (var i = from; i > to; i--) {
                result.push(i);
            }
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer, merger) {
        if (merger === void 0) { merger = function (t) { return t; }; }
        return array.reduce(function (r, t) {
            var key = indexer(t);
            r[key] = merger(t, r[key]);
            return r;
        }, Object.create(null));
    }
    exports.index = index;
    /**
     * Inserts an element into an array. Returns a function which, when
     * called, will remove that element from the array.
     */
    function insert(array, element) {
        array.push(element);
        return function () {
            var index = array.indexOf(element);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
    }
    exports.insert = insert;
    /**
     * Insert `insertArr` inside `target` at `insertIndex`.
     * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
     */
    function arrayInsert(target, insertIndex, insertArr) {
        var before = target.slice(0, insertIndex);
        var after = target.slice(insertIndex);
        return before.concat(insertArr, after);
    }
    exports.arrayInsert = arrayInsert;
    /**
     * Uses Fisher-Yates shuffle to shuffle the given array
     * @param array
     */
    function shuffle(array, seed) {
        // Seeded random number generator in JS. Modified from:
        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
        var random = function () {
            var x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias
            return x - Math.floor(x);
        };
        var rand = typeof seed === 'number' ? random : Math.random;
        for (var i = array.length - 1; i > 0; i -= 1) {
            var j = Math.floor(rand() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }
    exports.shuffle = shuffle;
    /**
     * Pushes an element to the start of the array, if found.
     */
    function pushToStart(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.unshift(value);
        }
    }
    exports.pushToStart = pushToStart;
    /**
     * Pushes an element to the end of the array, if found.
     */
    function pushToEnd(arr, value) {
        var index = arr.indexOf(value);
        if (index > -1) {
            arr.splice(index, 1);
            arr.push(value);
        }
    }
    exports.pushToEnd = pushToEnd;
    function find(arr, predicate) {
        for (var i = 0; i < arr.length; i++) {
            var element = arr[i];
            if (predicate(element, i, arr)) {
                return element;
            }
        }
        return undefined;
    }
    exports.find = find;
});

















































define(__m[5/*vs/base/common/event*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/errors*/,56/*vs/base/common/functional*/,13/*vs/base/common/lifecycle*/,152/*vs/base/common/linkedList*/,2/*vs/base/common/winjs.base*/]), function (require, exports, errors_1, functional_1, lifecycle_1, linkedList_1, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event = exports.Event || (exports.Event = {}));
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = /** @class */ (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._listeners) {
                            _this._listeners = new linkedList_1.LinkedList();
                        }
                        var firstListener = _this._listeners.isEmpty();
                        if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                        if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                            _this._options.onFirstListenerDidAdd(_this);
                        }
                        if (_this._options && _this._options.onListenerDidAdd) {
                            _this._options.onListenerDidAdd(_this, listener, thisArgs);
                        }
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    remove();
                                    if (_this._options && _this._options.onLastListenerRemove && _this._listeners.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._listeners) {
                // put all [listener,event]-pairs into delivery queue
                // then emit all event. an inner/nested event might be
                // the driver of this
                if (!this._deliveryQueue) {
                    this._deliveryQueue = [];
                }
                for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                    this._deliveryQueue.push([e.value, event]);
                }
                while (this._deliveryQueue.length > 0) {
                    var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];
                    try {
                        if (typeof listener === 'function') {
                            listener.call(undefined, event_1);
                        }
                        else {
                            listener[0].call(listener[1], event_1);
                        }
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                }
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._listeners) {
                this._listeners = undefined;
            }
            if (this._deliveryQueue) {
                this._deliveryQueue.length = 0;
            }
            this._disposed = true;
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    var AsyncEmitter = /** @class */ (function (_super) {
        __extends(AsyncEmitter, _super);
        function AsyncEmitter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AsyncEmitter.prototype.fireAsync = function (eventFn) {
            return __awaiter(this, void 0, void 0, function () {
                var iter, e, thenables, _a, listener, event_2, thenables;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this._listeners) {
                                return [2 /*return*/];
                            }
                            // put all [listener,event]-pairs into delivery queue
                            // then emit all event. an inner/nested event might be
                            // the driver of this
                            if (!this._asyncDeliveryQueue) {
                                this._asyncDeliveryQueue = [];
                            }
                            for (iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                                thenables = [];
                                this._asyncDeliveryQueue.push([e.value, eventFn(thenables, typeof e.value === 'function' ? e.value : e.value[0]), thenables]);
                            }
                            _b.label = 1;
                        case 1:
                            if (!(this._asyncDeliveryQueue.length > 0)) return [3 /*break*/, 3];
                            _a = this._asyncDeliveryQueue.shift(), listener = _a[0], event_2 = _a[1], thenables = _a[2];
                            try {
                                if (typeof listener === 'function') {
                                    listener.call(undefined, event_2);
                                }
                                else {
                                    listener[0].call(listener[1], event_2);
                                }
                            }
                            catch (e) {
                                errors_1.onUnexpectedError(e);
                                return [3 /*break*/, 1];
                            }
                            // freeze thenables-collection to enforce sync-calls to
                            // wait until and then wait for all thenables to resolve
                            Object.freeze(thenables);
                            return [4 /*yield*/, Promise.all(thenables)];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        return AsyncEmitter;
    }(Emitter));
    exports.AsyncEmitter = AsyncEmitter;
    var EventMultiplexer = /** @class */ (function () {
        function EventMultiplexer() {
            var _this = this;
            this.hasListeners = false;
            this.events = [];
            this.emitter = new Emitter({
                onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
                onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
            });
        }
        Object.defineProperty(EventMultiplexer.prototype, "event", {
            get: function () {
                return this.emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        EventMultiplexer.prototype.add = function (event) {
            var _this = this;
            var e = { event: event, listener: null };
            this.events.push(e);
            if (this.hasListeners) {
                this.hook(e);
            }
            var dispose = function () {
                if (_this.hasListeners) {
                    _this.unhook(e);
                }
                var idx = _this.events.indexOf(e);
                _this.events.splice(idx, 1);
            };
            return lifecycle_1.toDisposable(functional_1.once(dispose));
        };
        EventMultiplexer.prototype.onFirstListenerAdd = function () {
            var _this = this;
            this.hasListeners = true;
            this.events.forEach(function (e) { return _this.hook(e); });
        };
        EventMultiplexer.prototype.onLastListenerRemove = function () {
            var _this = this;
            this.hasListeners = false;
            this.events.forEach(function (e) { return _this.unhook(e); });
        };
        EventMultiplexer.prototype.hook = function (e) {
            var _this = this;
            e.listener = e.event(function (r) { return _this.emitter.fire(r); });
        };
        EventMultiplexer.prototype.unhook = function (e) {
            e.listener.dispose();
            e.listener = null;
        };
        EventMultiplexer.prototype.dispose = function () {
            this.emitter.dispose();
        };
        return EventMultiplexer;
    }());
    exports.EventMultiplexer = EventMultiplexer;
    function fromCallback(fn) {
        var listener;
        var emitter = new Emitter({
            onFirstListenerAdd: function () { return listener = fn(function (e) { return emitter.fire(e); }); },
            onLastListenerRemove: function () { return listener.dispose(); }
        });
        return emitter.event;
    }
    exports.fromCallback = fromCallback;
    function fromPromise(promise) {
        var emitter = new Emitter();
        var shouldEmit = false;
        promise
            .then(null, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(); }, 0);
            }
            else {
                emitter.fire();
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    exports.fromPromise = fromPromise;
    function toPromise(event) {
        return new winjs_base_1.TPromise(function (c) { return once(event)(c); });
    }
    exports.toPromise = toPromise;
    function toNativePromise(event) {
        return new Promise(function (c) { return once(event)(c); });
    }
    exports.toNativePromise = toNativePromise;
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            // we need this, in case the event fires during the listener call
            var didFire = false;
            var result = event(function (e) {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    exports.once = once;
    function anyEvent() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return lifecycle_1.combinedDisposable(events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));
        };
    }
    exports.anyEvent = anyEvent;
    function debounceEvent(event, merger, delay, leading) {
        if (delay === void 0) { delay = 100; }
        if (leading === void 0) { leading = false; }
        var subscription;
        var output = undefined;
        var handle = undefined;
        var numDebouncedCalls = 0;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    numDebouncedCalls++;
                    output = merger(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                    }
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.wrapEvent(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.bufferEvents(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = /** @class */ (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function forEach(event, each) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);
        };
    }
    exports.forEach = forEach;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    var ChainableEvent = /** @class */ (function () {
        function ChainableEvent(_event) {
            this._event = _event;
        }
        Object.defineProperty(ChainableEvent.prototype, "event", {
            get: function () { return this._event; },
            enumerable: true,
            configurable: true
        });
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(mapEvent(this._event, fn));
        };
        ChainableEvent.prototype.forEach = function (fn) {
            return new ChainableEvent(forEach(this._event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filterEvent(this._event, fn));
        };
        ChainableEvent.prototype.latch = function () {
            return new ChainableEvent(latch(this._event));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this._event(listener, thisArgs, disposables);
        };
        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {
            return once(this._event)(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    exports.chain = chain;
    function stopwatch(event) {
        var start = new Date().getTime();
        return mapEvent(once(event), function (_) { return new Date().getTime() - start; });
    }
    exports.stopwatch = stopwatch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            buffer.forEach(function (e) { return emitter.fire(e); });
            buffer = null;
        };
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                listener.dispose();
                listener = null;
            }
        });
        return emitter.event;
    }
    exports.buffer = buffer;
    /**
     * Similar to `buffer` but it buffers indefinitely and repeats
     * the buffered events to every new listener.
     */
    function echo(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        event(function (e) {
            buffer.push(e);
            emitter.fire(e);
        });
        var flush = function (listener, thisArgs) { return buffer.forEach(function (e) { return listener.call(thisArgs, e); }); };
        var emitter = new Emitter({
            onListenerDidAdd: function (emitter, listener, thisArgs) {
                if (nextTick) {
                    setTimeout(function () { return flush(listener, thisArgs); });
                }
                else {
                    flush(listener, thisArgs);
                }
            }
        });
        return emitter.event;
    }
    exports.echo = echo;
    var Relay = /** @class */ (function () {
        function Relay() {
            var _this = this;
            this.listening = false;
            this.inputEvent = Event.None;
            this.inputEventListener = lifecycle_1.Disposable.None;
            this.emitter = new Emitter({
                onFirstListenerDidAdd: function () {
                    _this.listening = true;
                    _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);
                },
                onLastListenerRemove: function () {
                    _this.listening = false;
                    _this.inputEventListener.dispose();
                }
            });
            this.event = this.emitter.event;
        }
        Object.defineProperty(Relay.prototype, "input", {
            set: function (event) {
                this.inputEvent = event;
                if (this.listening) {
                    this.inputEventListener.dispose();
                    this.inputEventListener = event(this.emitter.fire, this.emitter);
                }
            },
            enumerable: true,
            configurable: true
        });
        Relay.prototype.dispose = function () {
            this.inputEventListener.dispose();
            this.emitter.dispose();
        };
        return Relay;
    }());
    exports.Relay = Relay;
    function fromNodeEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };
        var result = new Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    exports.fromNodeEventEmitter = fromNodeEventEmitter;
    function latch(event) {
        var firstCall = true;
        var cache;
        return filterEvent(event, function (value) {
            var shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    exports.latch = latch;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[35/*vs/base/common/cancellation*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/event*/]), function (require, exports, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var CancellationToken;
    (function (CancellationToken) {
        function isCancellationToken(thing) {
            if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
                return true;
            }
            if (thing instanceof MutableToken) {
                return true;
            }
            if (!thing || typeof thing !== 'object') {
                return false;
            }
            return typeof thing.isCancellationRequested === 'boolean'
                && typeof thing.onCancellationRequested === 'function';
        }
        CancellationToken.isCancellationToken = isCancellationToken;
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.Event.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: shortcutEvent
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var MutableToken = /** @class */ (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this.dispose();
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        MutableToken.prototype.dispose = function () {
            if (this._emitter) {
                this._emitter.dispose();
                this._emitter = undefined;
            }
        };
        return MutableToken;
    }());
    var CancellationTokenSource = /** @class */ (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else if (this._token instanceof MutableToken) {
                // actually cancel
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            if (!this._token) {
                // ensure to initialize with an empty token if we had none
                this._token = CancellationToken.None;
            }
            else if (this._token instanceof MutableToken) {
                // actually dispose
                this._token.dispose();
            }
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[20/*vs/base/common/async*/], __M([1/*require*/,0/*exports*/,35/*vs/base/common/cancellation*/,23/*vs/base/common/errors*/,5/*vs/base/common/event*/,13/*vs/base/common/lifecycle*/,2/*vs/base/common/winjs.base*/]), function (require, exports, cancellation_1, errors, event_1, lifecycle_1, winjs_base_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    exports.isThenable = isThenable;
    function toThenable(arg) {
        if (isThenable(arg)) {
            return arg;
        }
        else {
            return winjs_base_1.TPromise.as(arg);
        }
    }
    exports.toThenable = toThenable;
    function createCancelablePromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        var thenable = callback(source.token);
        var promise = new Promise(function (resolve, reject) {
            source.token.onCancellationRequested(function () {
                reject(errors.canceled());
            });
            Promise.resolve(thenable).then(function (value) {
                source.dispose();
                resolve(value);
            }, function (err) {
                source.dispose();
                reject(err);
            });
        });
        return new /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.cancel = function () {
                source.cancel();
            };
            class_1.prototype.then = function (resolve, reject) {
                return promise.then(resolve, reject);
            };
            class_1.prototype.catch = function (reject) {
                return this.then(undefined, reject);
            };
            return class_1;
        }());
    }
    exports.createCancelablePromise = createCancelablePromise;
    function asThenable(callback) {
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var item = callback();
            if (item instanceof winjs_base_1.TPromise) {
                item.then(resolve, reject);
            }
            else if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        });
    }
    exports.asThenable = asThenable;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = /** @class */ (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.TPromise(function (c) {
                        _this.activePromise.then(onComplete_1, onComplete_1).then(c);
                    });
                }
                return new winjs_base_1.TPromise(function (c, e) {
                    _this.queuedPromise.then(c, e);
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.TPromise(function (c, e) {
                _this.activePromise.then(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                });
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = /** @class */ (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.wrap(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = /** @class */ (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.doResolve = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.TPromise(function (c, e) {
                    _this.doResolve = c;
                    _this.doReject = e;
                }).then(function () {
                    _this.completionPromise = null;
                    _this.doResolve = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.doResolve(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.doReject(errors.canceled());
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail men's strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = /** @class */ (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            var _this = _super.call(this, defaultDelay) || this;
            _this.throttler = new Throttler();
            return _this;
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * A barrier that is initially closed and then becomes opened permanently.
     */
    var Barrier = /** @class */ (function () {
        function Barrier() {
            var _this = this;
            this._isOpen = false;
            this._promise = new winjs_base_1.TPromise(function (c, e) {
                _this._completePromise = c;
            });
        }
        Barrier.prototype.isOpen = function () {
            return this._isOpen;
        };
        Barrier.prototype.open = function () {
            this._isOpen = true;
            this._completePromise(true);
        };
        Barrier.prototype.wait = function () {
            return this._promise;
        };
        return Barrier;
    }());
    exports.Barrier = Barrier;
    function timeout(millis, token) {
        if (!token) {
            return createCancelablePromise(function (token) { return timeout(millis, token); });
        }
        return new Promise(function (resolve, reject) {
            var handle = setTimeout(resolve, millis);
            token.onCancellationRequested(function () {
                clearTimeout(handle);
                reject(errors.canceled());
            });
        });
    }
    exports.timeout = timeout;
    function always(winjsPromiseOrThenable, callback) {
        function safeCallback() {
            try {
                callback();
            }
            catch (err) {
                errors.onUnexpectedError(err);
            }
        }
        winjsPromiseOrThenable.then(function (_) { return safeCallback(); }, function (_) { return safeCallback(); });
        return winjsPromiseOrThenable;
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactories) {
        var results = [];
        var index = 0;
        var len = promiseFactories.length;
        function next() {
            return index < len ? promiseFactories[index++]() : null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function first2(promiseFactories, shouldStop, defaultValue) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        if (defaultValue === void 0) { defaultValue = null; }
        var index = 0;
        var len = promiseFactories.length;
        var loop = function () {
            if (index >= len) {
                return Promise.resolve(defaultValue);
            }
            var factory = promiseFactories[index++];
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return Promise.resolve(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first2 = first2;
    function first(promiseFactories, shouldStop, defaultValue) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        if (defaultValue === void 0) { defaultValue = null; }
        var index = 0;
        var len = promiseFactories.length;
        var loop = function () {
            if (index >= len) {
                return winjs_base_1.TPromise.as(defaultValue);
            }
            var factory = promiseFactories[index++];
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return winjs_base_1.TPromise.as(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first = first;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = /** @class */ (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
            this._onFinished = new event_1.Emitter();
        }
        Object.defineProperty(Limiter.prototype, "onFinished", {
            get: function () {
                return this._onFinished.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Limiter.prototype, "size", {
            get: function () {
                return this.runningPromises + this.outstandingPromises.length;
            },
            enumerable: true,
            configurable: true
        });
        Limiter.prototype.queue = function (factory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                _this.outstandingPromises.push({ factory: factory, c: c, e: e });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.then(iLimitedTask.c, iLimitedTask.e);
                promise.then(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            if (this.outstandingPromises.length > 0) {
                this.consume();
            }
            else {
                this._onFinished.fire();
            }
        };
        Limiter.prototype.dispose = function () {
            this._onFinished.dispose();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    var Queue = /** @class */ (function (_super) {
        __extends(Queue, _super);
        function Queue() {
            return _super.call(this, 1) || this;
        }
        return Queue;
    }(Limiter));
    exports.Queue = Queue;
    /**
     * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource
     * by disposing them once the queue is empty.
     */
    var ResourceQueue = /** @class */ (function () {
        function ResourceQueue() {
            this.queues = Object.create(null);
        }
        ResourceQueue.prototype.queueFor = function (resource) {
            var _this = this;
            var key = resource.toString();
            if (!this.queues[key]) {
                var queue_1 = new Queue();
                queue_1.onFinished(function () {
                    queue_1.dispose();
                    delete _this.queues[key];
                });
                this.queues[key] = queue_1;
            }
            return this.queues[key];
        };
        return ResourceQueue;
    }());
    exports.ResourceQueue = ResourceQueue;
    var TimeoutTimer = /** @class */ (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer(runner, timeout) {
            var _this = _super.call(this) || this;
            _this._token = -1;
            if (typeof runner === 'function' && typeof timeout === 'number') {
                _this.setIfNotSet(runner, timeout);
            }
            return _this;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = /** @class */ (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = /** @class */ (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.doRun();
            }
        };
        RunOnceScheduler.prototype.doRun = function () {
            this.runner();
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    var RunOnceWorker = /** @class */ (function (_super) {
        __extends(RunOnceWorker, _super);
        function RunOnceWorker(runner, timeout) {
            var _this = _super.call(this, runner, timeout) || this;
            _this.units = [];
            return _this;
        }
        RunOnceWorker.prototype.work = function (unit) {
            this.units.push(unit);
            if (!this.isScheduled()) {
                this.schedule();
            }
        };
        RunOnceWorker.prototype.doRun = function () {
            var units = this.units;
            this.units = [];
            this.runner(units);
        };
        RunOnceWorker.prototype.dispose = function () {
            this.units = [];
            _super.prototype.dispose.call(this);
        };
        return RunOnceWorker;
    }(RunOnceScheduler));
    exports.RunOnceWorker = RunOnceWorker;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.TPromise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.ninvoke = ninvoke;
});

define(__m[121/*vs/base/common/glob*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/arrays*/,18/*vs/base/common/strings*/,15/*vs/base/common/paths*/,38/*vs/base/common/map*/,2/*vs/base/common/winjs.base*/,20/*vs/base/common/async*/]), function (require, exports, arrays, strings, paths, map_1, winjs_base_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getEmptyExpression() {
        return Object.create(null);
    }
    exports.getEmptyExpression = getEmptyExpression;
    var GLOBSTAR = '**';
    var GLOB_SPLIT = '/';
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    var ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, GLOB_SPLIT);
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === GLOBSTAR; })) {
            regEx = '.*';
        }
        // Build regex over segments
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === GLOBSTAR) {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {
                        var res = void 0;
                        // range operator
                        if (char === '-') {
                            res = char;
                        }
                        // negation operator (only valid on first index in bracket)
                        else if ((char === '^' || char === '!') && !bracketVal) {
                            res = '^';
                        }
                        // glob split matching is not allowed within character ranges
                        // see http://man7.org/linux/man-pages/man7/glob.7.html
                        else if (char === GLOB_SPLIT) {
                            res = '';
                        }
                        // anything else gets escaped
                        else {
                            res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar
                // For example if pattern: some/**/*.js we want the "/" after some to be included in the RegEx to prevent
                // a folder called "something" to match as well.
                // However, if pattern: some/**, we tolerate that we also match on "something" because our globstar behaviour
                // is to match 0-N segments.
                if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    var CACHE = new map_1.LRUCache(10000); // bounded to 10000 elements
    var FALSE = function () {
        return false;
    };
    var NULL = function () {
        return null;
    };
    function parsePattern(arg1, options) {
        if (!arg1) {
            return NULL;
        }
        // Handle IRelativePattern
        var pattern;
        if (typeof arg1 !== 'string') {
            pattern = arg1.pattern;
        }
        else {
            pattern = arg1;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var patternKey = pattern + "_" + !!options.trimForExclusions;
        var parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return wrapRelativePattern(parsedPattern, arg1);
        }
        // Check for Trivias
        var match;
        if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check
            var base_1 = pattern.substr(4); // '**/*'.length === 4
            parsedPattern = function (path, basename) {
                return path && strings.endsWith(path, base_1) ? pattern : null;
            };
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        // Otherwise convert to pattern
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return wrapRelativePattern(parsedPattern, arg1);
    }
    function wrapRelativePattern(parsedPattern, arg2) {
        if (typeof arg2 === 'string') {
            return parsedPattern;
        }
        return function (path, basename) {
            if (!paths.isEqualOrParent(path, arg2.base)) {
                return null;
            }
            return parsedPattern(arg2.pathToRelative(arg2.base, path), basename);
        };
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, originalPattern) {
        var slashBase = "/" + base;
        var backslashBase = "\\" + base;
        var parsedPattern = function (path, basename) {
            if (!path) {
                return null;
            }
            if (basename) {
                return basename === base ? originalPattern : null;
            }
            return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
        };
        var basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [originalPattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
            .map(function (pattern) { return parsePattern(pattern, options); })
            .filter(function (pattern) { return pattern !== NULL; }), pattern);
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (n === 1) {
            return parsedPatterns[0];
        }
        var parsedPattern = function (path, basename) {
            for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(path, pattern, matchPathEnds) {
        var nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
        var nativePathEnd = paths.nativeSep + nativePath;
        var parsedPattern = matchPathEnds ? function (path, basename) {
            return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        } : function (path, basename) {
            return path && path === nativePath ? pattern : null;
        };
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
            return function (path, basename) {
                regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return path && regExp_1.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function match(arg1, path, hasSibling) {
        if (!arg1 || !path) {
            return false;
        }
        return parse(arg1)(path, undefined, hasSibling);
    }
    exports.match = match;
    function parse(arg1, options) {
        if (options === void 0) { options = {}; }
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string' || isRelativePattern(arg1)) {
            var parsedPattern_1 = parsePattern(arg1, options);
            if (parsedPattern_1 === NULL) {
                return FALSE;
            }
            var resultPattern = function (path, basename) {
                return !!parsedPattern_1(path, basename);
            };
            if (parsedPattern_1.allBasenames) {
                resultPattern.allBasenames = parsedPattern_1.allBasenames;
            }
            if (parsedPattern_1.allPaths) {
                resultPattern.allPaths = parsedPattern_1.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    exports.parse = parse;
    function hasSiblingPromiseFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                siblings = (siblingsFn() || winjs_base_1.TPromise.as([]))
                    .then(function (list) { return list ? listToMap(list) : {}; });
            }
            return siblings.then(function (map) { return !!map[name]; });
        };
    }
    exports.hasSiblingPromiseFn = hasSiblingPromiseFn;
    function hasSiblingFn(siblingsFn) {
        if (!siblingsFn) {
            return undefined;
        }
        var siblings;
        return function (name) {
            if (!siblings) {
                var list = siblingsFn();
                siblings = list ? listToMap(list) : {};
            }
            return !!siblings[name];
        };
    }
    exports.hasSiblingFn = hasSiblingFn;
    function listToMap(list) {
        var map = {};
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var key = list_1[_i];
            map[key] = true;
        }
        return map;
    }
    function isRelativePattern(obj) {
        var rp = obj;
        return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string' && typeof rp.pathToRelative === 'function';
    }
    exports.isRelativePattern = isRelativePattern;
    /**
     * Same as `parse`, but the ParsedExpression is guaranteed to return a Promise
     */
    function parseToAsync(expression, options) {
        var parsedExpression = parse(expression, options);
        return function (path, basename, hasSibling) {
            var result = parsedExpression(path, basename, hasSibling);
            return result instanceof winjs_base_1.TPromise ? result : winjs_base_1.TPromise.as(result);
        };
    }
    exports.parseToAsync = parseToAsync;
    function getBasenameTerms(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    exports.getBasenameTerms = getBasenameTerms;
    function getPathTerms(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    exports.getPathTerms = getPathTerms;
    function parsedExpression(expression, options) {
        var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
            .filter(function (pattern) { return pattern !== NULL; }));
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (!parsedPatterns.some(function (parsedPattern) { return parsedPattern.requiresSiblings; })) {
            if (n === 1) {
                return parsedPatterns[0];
            }
            var resultExpression_1 = function (path, basename) {
                for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                    // Pattern matches path
                    var result = parsedPatterns[i](path, basename);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
            if (withBasenames_1) {
                resultExpression_1.allBasenames = withBasenames_1.allBasenames;
            }
            var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
            if (allPaths_1.length) {
                resultExpression_1.allPaths = allPaths_1;
            }
            return resultExpression_1;
        }
        var resultExpression = function (path, basename, hasSibling) {
            var name;
            for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
                // Pattern matches path
                var parsedPattern = parsedPatterns[i];
                if (parsedPattern.requiresSiblings && hasSibling) {
                    if (!basename) {
                        basename = paths.basename(path);
                    }
                    if (!name) {
                        name = basename.substr(0, basename.length - paths.extname(path).length);
                    }
                }
                var result = parsedPattern(path, basename, name, hasSibling);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        var parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            var when_1 = value.when;
            if (typeof when_1 === 'string') {
                var result = function (path, basename, name, hasSibling) {
                    if (!hasSibling || !parsedPattern(path, basename)) {
                        return null;
                    }
                    var clausePattern = when_1.replace('$(basename)', name);
                    var matched = hasSibling(clausePattern);
                    return async_1.isThenable(matched) ?
                        matched.then(function (m) { return m ? pattern : null; }) :
                        matched ? pattern : null;
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is Anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        var basenames = basenamePatterns.reduce(function (all, current) { return all.concat(current.basenames); }, []);
        var patterns;
        if (result) {
            patterns = [];
            for (var i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce(function (all, current) { return all.concat(current.patterns); }, []);
        }
        var aggregate = function (path, basename) {
            if (!path) {
                return null;
            }
            if (!basename) {
                var i = void 0;
                for (i = path.length; i > 0; i--) {
                    var ch = path.charCodeAt(i - 1);
                    if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            var index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
});

define(__m[122/*vs/base/common/mime*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/paths*/,18/*vs/base/common/strings*/,121/*vs/base/common/glob*/]), function (require, exports, paths, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    var nonUserRegisteredAssociations = [];
    var userRegisteredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association, warnOnOverwrite) {
        if (warnOnOverwrite === void 0) { warnOnOverwrite = false; }
        // Register
        var associationItem = toTextMimeAssociationItem(association);
        registeredAssociations.push(associationItem);
        if (!associationItem.userConfigured) {
            nonUserRegisteredAssociations.push(associationItem);
        }
        else {
            userRegisteredAssociations.push(associationItem);
        }
        // Check for conflicts unless this is a user configured association
        if (warnOnOverwrite && !associationItem.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === associationItem.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (associationItem.extension && a.extension === associationItem.extension) {
                    console.warn("Overwriting extension <<" + associationItem.extension + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filename && a.filename === associationItem.filename) {
                    console.warn("Overwriting filename <<" + associationItem.filename + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                    console.warn("Overwriting filepattern <<" + associationItem.filepattern + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.firstline && a.firstline === associationItem.firstline) {
                    console.warn("Overwriting firstline <<" + associationItem.firstline + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    function toTextMimeAssociationItem(association) {
        return {
            id: association.id,
            mime: association.mime,
            filename: association.filename,
            extension: association.extension,
            filepattern: association.filepattern,
            firstline: association.firstline,
            userConfigured: association.userConfigured,
            filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
            extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
            filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
            filepatternOnPath: association.filepattern ? association.filepattern.indexOf(paths.sep) >= 0 : false
        };
    }
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
            nonUserRegisteredAssociations = [];
            userRegisteredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
            userRegisteredAssociations = [];
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        var filename = paths.basename(path);
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, filename, associations) {
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        // We want to prioritize associations based on the order they are registered so that the last registered
        // association wins over all other. This is for https://github.com/Microsoft/vscode/issues/20074
        for (var i = associations.length - 1; i >= 0; i--) {
            var association = associations[i];
            // First exact name match
            if (filename === association.filenameLowercase) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                    var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
                    if (glob_1.match(association.filepatternLowercase, target)) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                    if (strings.endsWith(filename, association.extensionLowercase)) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    /**
     * Returns a suggestion for the filename by the following logic:
     * 1. If a relevant extension exists and is an actual filename extension (starting with a dot), suggest the prefix appended by the first one.
     * 2. Otherwise, if there are other extensions, suggest the first one.
     * 3. Otherwise, suggest the prefix.
     */
    function suggestFilename(langId, prefix) {
        var extensions = registeredAssociations
            .filter(function (assoc) { return !assoc.userConfigured && assoc.extension && assoc.id === langId; })
            .map(function (assoc) { return assoc.extension; });
        var extensionsWithDotFirst = extensions
            .filter(function (assoc) { return strings.startsWith(assoc, '.'); });
        if (extensionsWithDotFirst.length > 0) {
            return prefix + extensionsWithDotFirst[0];
        }
        return extensions[0] || prefix;
    }
    exports.suggestFilename = suggestFilename;
    // Known media mimes that we can handle
    var mapExtToMediaMimes = {
        '.bmp': 'image/bmp',
        '.gif': 'image/gif',
        '.jpg': 'image/jpg',
        '.jpeg': 'image/jpg',
        '.jpe': 'image/jpg',
        '.png': 'image/png',
        '.tiff': 'image/tiff',
        '.tif': 'image/tiff',
        '.ico': 'image/x-icon',
        '.tga': 'image/x-tga',
        '.psd': 'image/vnd.adobe.photoshop',
        '.webp': 'image/webp',
        '.mid': 'audio/midi',
        '.midi': 'audio/midi',
        '.mp4a': 'audio/mp4',
        '.mpga': 'audio/mpeg',
        '.mp2': 'audio/mpeg',
        '.mp2a': 'audio/mpeg',
        '.mp3': 'audio/mpeg',
        '.m2a': 'audio/mpeg',
        '.m3a': 'audio/mpeg',
        '.oga': 'audio/ogg',
        '.ogg': 'audio/ogg',
        '.spx': 'audio/ogg',
        '.aac': 'audio/x-aac',
        '.wav': 'audio/x-wav',
        '.wma': 'audio/x-ms-wma',
        '.mp4': 'video/mp4',
        '.mp4v': 'video/mp4',
        '.mpg4': 'video/mp4',
        '.mpeg': 'video/mpeg',
        '.mpg': 'video/mpeg',
        '.mpe': 'video/mpeg',
        '.m1v': 'video/mpeg',
        '.m2v': 'video/mpeg',
        '.ogv': 'video/ogg',
        '.qt': 'video/quicktime',
        '.mov': 'video/quicktime',
        '.webm': 'video/webm',
        '.mkv': 'video/x-matroska',
        '.mk3d': 'video/x-matroska',
        '.mks': 'video/x-matroska',
        '.wmv': 'video/x-ms-wmv',
        '.flv': 'video/x-flv',
        '.avi': 'video/x-msvideo',
        '.movie': 'video/x-sgi-movie'
    };
    function getMediaMime(path) {
        var ext = paths.extname(path);
        return mapExtToMediaMimes[ext.toLowerCase()];
    }
    exports.getMediaMime = getMediaMime;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[128/*vs/base/node/crypto*/], __M([1/*require*/,0/*exports*/,21/*fs*/,58/*crypto*/,2/*vs/base/common/winjs.base*/,56/*vs/base/common/functional*/]), function (require, exports, fs, crypto, winjs_base_1, functional_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function checksum(path, sha1hash) {
        var promise = new winjs_base_1.TPromise(function (c, e) {
            var input = fs.createReadStream(path);
            var hash = crypto.createHash('sha1');
            var hashStream = hash;
            input.pipe(hashStream);
            var done = functional_1.once(function (err, result) {
                input.removeAllListeners();
                hashStream.removeAllListeners();
                if (err) {
                    e(err);
                }
                else {
                    c(result);
                }
            });
            input.once('error', done);
            input.once('end', done);
            hashStream.once('error', done);
            hashStream.once('data', function (data) { return done(null, data.toString('hex')); });
        });
        return promise.then(function (hash) {
            if (hash !== sha1hash) {
                return winjs_base_1.TPromise.wrapError(new Error('Hash mismatch'));
            }
            return winjs_base_1.TPromise.as(null);
        });
    }
    exports.checksum = checksum;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[142/*vs/base/node/flow*/], __M([1/*require*/,0/*exports*/,143/*assert*/]), function (require, exports, assert) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Executes the given function (fn) over the given array of items (list) in parallel and returns the resulting errors and results as
     * array to the callback (callback). The resulting errors and results are evaluated by calling the provided callback function.
     */
    function parallel(list, fn, callback) {
        var results = new Array(list.length);
        var errors = new Array(list.length);
        var didErrorOccur = false;
        var doneCount = 0;
        if (list.length === 0) {
            return callback(null, []);
        }
        list.forEach(function (item, index) {
            fn(item, function (error, result) {
                if (error) {
                    didErrorOccur = true;
                    results[index] = null;
                    errors[index] = error;
                }
                else {
                    results[index] = result;
                    errors[index] = null;
                }
                if (++doneCount === list.length) {
                    return callback(didErrorOccur ? errors : null, results);
                }
            });
        });
    }
    exports.parallel = parallel;
    function loop(param, fn, callback) {
        // Assert
        assert.ok(param, 'Missing first parameter');
        assert.ok(typeof (fn) === 'function', 'Second parameter must be a function that is called for each element');
        assert.ok(typeof (callback) === 'function', 'Third parameter must be a function that is called on error and success');
        // Param is function, execute to retrieve array
        if (typeof (param) === 'function') {
            try {
                param(function (error, result) {
                    if (error) {
                        callback(error, null);
                    }
                    else {
                        loop(result, fn, callback);
                    }
                });
            }
            catch (error) {
                callback(error, null);
            }
        }
        // Expect the param to be an array and loop over it
        else {
            var results_1 = [];
            var looper_1 = function (i) {
                // Still work to do
                if (i < param.length) {
                    // Execute function on array element
                    try {
                        fn(param[i], function (error, result) {
                            // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                            if (error === true || error === false) {
                                result = error;
                                error = null;
                            }
                            // Quit looping on error
                            if (error) {
                                callback(error, null);
                            }
                            // Otherwise push result on stack and continue looping
                            else {
                                if (result) { //Could be that provided function is not returning a result
                                    results_1.push(result);
                                }
                                process.nextTick(function () {
                                    looper_1(i + 1);
                                });
                            }
                        }, i, param.length);
                    }
                    catch (error) {
                        callback(error, null);
                    }
                }
                // Done looping, pass back results too callback function
                else {
                    callback(null, results_1);
                }
            };
            // Start looping with first element in array
            looper_1(0);
        }
    }
    exports.loop = loop;
    function Sequence(sequences) {
        // Assert
        assert.ok(sequences.length > 1, 'Need at least one error handler and one function to process sequence');
        sequences.forEach(function (sequence) {
            assert.ok(typeof (sequence) === 'function');
        });
        // Execute in Loop
        var errorHandler = sequences.splice(0, 1)[0]; //Remove error handler
        var sequenceResult = null;
        loop(sequences, function (sequence, clb) {
            var sequenceFunction = function (error, result) {
                // A method might only send a boolean value as return value (e.g. fs.exists), support this case gracefully
                if (error === true || error === false) {
                    result = error;
                    error = null;
                }
                // Handle Error and Result
                if (error) {
                    clb(error, null);
                }
                else {
                    sequenceResult = result; //Remember result of sequence
                    clb(null, null); //Don't pass on result to Looper as we are not aggregating it
                }
            };
            // We call the sequence function setting "this" to be the callback we define here
            // and we pass in the "sequenceResult" as first argument. Doing all this avoids having
            // to pass in a callback to the sequence because the callback is already "this".
            try {
                sequence.call(sequenceFunction, sequenceResult);
            }
            catch (error) {
                clb(error, null);
            }
        }, function (error, result) {
            if (error) {
                errorHandler(error);
            }
        });
    }
    function sequence(sequences) {
        Sequence((Array.isArray(sequences)) ? sequences : Array.prototype.slice.call(arguments));
    }
    exports.sequence = sequence;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[64/*vs/base/node/id*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,23/*vs/base/common/errors*/,39/*vs/base/common/uuid*/,26/*os*/,38/*vs/base/common/map*/]), function (require, exports, winjs_base_1, errors, uuid, os_1, map_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // http://www.techrepublic.com/blog/data-center/mac-address-scorecard-for-common-virtual-machine-platforms/
    // VMware ESX 3, Server, Workstation, Player	00-50-56, 00-0C-29, 00-05-69
    // Microsoft Hyper-V, Virtual Server, Virtual PC	00-03-FF
    // Parallells Desktop, Workstation, Server, Virtuozzo	00-1C-42
    // Virtual Iron 4	00-0F-4B
    // Red Hat Xen	00-16-3E
    // Oracle VM	00-16-3E
    // XenSource	00-16-3E
    // Novell Xen	00-16-3E
    // Sun xVM VirtualBox	08-00-27
    exports.virtualMachineHint = new /** @class */ (function () {
        function class_1() {
        }
        class_1.prototype._isVirtualMachineMacAdress = function (mac) {
            if (!this._virtualMachineOUIs) {
                this._virtualMachineOUIs = map_1.TernarySearchTree.forStrings();
                // dash-separated
                this._virtualMachineOUIs.set('00-50-56', true);
                this._virtualMachineOUIs.set('00-0C-29', true);
                this._virtualMachineOUIs.set('00-05-69', true);
                this._virtualMachineOUIs.set('00-03-FF', true);
                this._virtualMachineOUIs.set('00-1C-42', true);
                this._virtualMachineOUIs.set('00-16-3E', true);
                this._virtualMachineOUIs.set('08-00-27', true);
                // colon-separated
                this._virtualMachineOUIs.set('00:50:56', true);
                this._virtualMachineOUIs.set('00:0C:29', true);
                this._virtualMachineOUIs.set('00:05:69', true);
                this._virtualMachineOUIs.set('00:03:FF', true);
                this._virtualMachineOUIs.set('00:1C:42', true);
                this._virtualMachineOUIs.set('00:16:3E', true);
                this._virtualMachineOUIs.set('08:00:27', true);
            }
            return this._virtualMachineOUIs.findSubstr(mac);
        };
        class_1.prototype.value = function () {
            if (this._value === undefined) {
                var vmOui = 0;
                var interfaceCount = 0;
                var interfaces = os_1.networkInterfaces();
                for (var name_1 in interfaces) {
                    if (Object.prototype.hasOwnProperty.call(interfaces, name_1)) {
                        for (var _i = 0, _a = interfaces[name_1]; _i < _a.length; _i++) {
                            var _b = _a[_i], mac = _b.mac, internal = _b.internal;
                            if (!internal) {
                                interfaceCount += 1;
                                if (this._isVirtualMachineMacAdress(mac.toUpperCase())) {
                                    vmOui += 1;
                                }
                            }
                        }
                    }
                }
                this._value = interfaceCount > 0
                    ? vmOui / interfaceCount
                    : 0;
            }
            return this._value;
        };
        return class_1;
    }());
    var machineId;
    function getMachineId() {
        return machineId || (machineId = getMacMachineId()
            .then(function (id) { return id || uuid.generateUuid(); })); // fallback, generate a UUID
    }
    exports.getMachineId = getMachineId;
    function getMacMachineId() {
        return new winjs_base_1.TPromise(function (resolve) {
            winjs_base_1.TPromise.join([new Promise(function (resolve_1, reject_1) { require(['crypto'], resolve_1, reject_1); }), new Promise(function (resolve_2, reject_2) { require(['getmac'], resolve_2, reject_2); })]).then(function (_a) {
                var crypto = _a[0], getmac = _a[1];
                try {
                    getmac.getMac(function (error, macAddress) {
                        if (!error) {
                            resolve(crypto.createHash('sha256').update(macAddress, 'utf8').digest('hex'));
                        }
                        else {
                            resolve(undefined);
                        }
                    });
                }
                catch (err) {
                    errors.onUnexpectedError(err);
                    resolve(undefined);
                }
            }, function (err) {
                errors.onUnexpectedError(err);
                resolve(undefined);
            });
        });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[93/*vs/base/node/paths*/], __M([1/*require*/,0/*exports*/,45/*vs/base/common/amd*/]), function (require, exports, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pathsPath = amd_1.getPathFromAmdModule(require, 'paths');
    var paths = require.__$__nodeRequire(pathsPath);
    exports.getAppDataPath = paths.getAppDataPath;
    exports.getDefaultUserDataPath = paths.getDefaultUserDataPath;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[97/*vs/base/node/proxy*/], __M([1/*require*/,0/*exports*/,98/*url*/,22/*vs/base/common/types*/]), function (require, exports, url_1, types_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getSystemProxyURI(requestURL) {
        if (requestURL.protocol === 'http:') {
            return process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        else if (requestURL.protocol === 'https:') {
            return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
        }
        return null;
    }
    function getProxyAgent(rawRequestURL, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var requestURL, proxyURL, proxyEndpoint, opts, Ctor, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        requestURL = url_1.parse(rawRequestURL);
                        proxyURL = options.proxyUrl || getSystemProxyURI(requestURL);
                        if (!proxyURL) {
                            return [2 /*return*/, null];
                        }
                        proxyEndpoint = url_1.parse(proxyURL);
                        if (!/^https?:$/.test(proxyEndpoint.protocol)) {
                            return [2 /*return*/, null];
                        }
                        opts = {
                            host: proxyEndpoint.hostname,
                            port: Number(proxyEndpoint.port),
                            auth: proxyEndpoint.auth,
                            rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true
                        };
                        if (!(requestURL.protocol === 'http:')) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolve_1, reject_1) { require(['http-proxy-agent'], resolve_1, reject_1); })];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Promise(function (resolve_2, reject_2) { require(['https-proxy-agent'], resolve_2, reject_2); })];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        Ctor = _a;
                        return [2 /*return*/, new Ctor(opts)];
                }
            });
        });
    }
    exports.getProxyAgent = getProxyAgent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[99/*vs/base/node/ps*/], __M([1/*require*/,0/*exports*/,53/*child_process*/,45/*vs/base/common/amd*/]), function (require, exports, child_process_1, amd_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function listProcesses(rootPid) {
        return new Promise(function (resolve, reject) {
            var rootItem;
            var map = new Map();
            function addToTree(pid, ppid, cmd, load, mem) {
                var parent = map.get(ppid);
                if (pid === rootPid || parent) {
                    var item = {
                        name: findName(cmd),
                        cmd: cmd,
                        pid: pid,
                        ppid: ppid,
                        load: load,
                        mem: mem
                    };
                    map.set(pid, item);
                    if (pid === rootPid) {
                        rootItem = item;
                    }
                    if (parent) {
                        if (!parent.children) {
                            parent.children = [];
                        }
                        parent.children.push(item);
                        if (parent.children.length > 1) {
                            parent.children = parent.children.sort(function (a, b) { return a.pid - b.pid; });
                        }
                    }
                }
            }
            function findName(cmd) {
                var SHARED_PROCESS_HINT = /--disable-blink-features=Auxclick/;
                var WINDOWS_WATCHER_HINT = /\\watcher\\win32\\CodeHelper\.exe/;
                var WINDOWS_CRASH_REPORTER = /--crashes-directory/;
                var WINDOWS_PTY = /\\pipe\\winpty-control/;
                var WINDOWS_CONSOLE_HOST = /conhost\.exe/;
                var TYPE = /--type=([a-zA-Z-]+)/;
                // find windows file watcher
                if (WINDOWS_WATCHER_HINT.exec(cmd)) {
                    return 'watcherService ';
                }
                // find windows crash reporter
                if (WINDOWS_CRASH_REPORTER.exec(cmd)) {
                    return 'electron-crash-reporter';
                }
                // find windows pty process
                if (WINDOWS_PTY.exec(cmd)) {
                    return 'winpty-process';
                }
                //find windows console host process
                if (WINDOWS_CONSOLE_HOST.exec(cmd)) {
                    return 'console-window-host (Windows internal process)';
                }
                // find "--type=xxxx"
                var matches = TYPE.exec(cmd);
                if (matches && matches.length === 2) {
                    if (matches[1] === 'renderer') {
                        if (SHARED_PROCESS_HINT.exec(cmd)) {
                            return 'shared-process';
                        }
                        return "window";
                    }
                    return matches[1];
                }
                // find all xxxx.js
                var JS = /[a-zA-Z-]+\.js/g;
                var result = '';
                do {
                    matches = JS.exec(cmd);
                    if (matches) {
                        result += matches + ' ';
                    }
                } while (matches);
                if (result) {
                    if (cmd.indexOf('node ') !== 0) {
                        return "electron_node " + result;
                    }
                }
                return cmd;
            }
            if (process.platform === 'win32') {
                var cleanUNCPrefix_1 = function (value) {
                    if (value.indexOf('\\\\?\\') === 0) {
                        return value.substr(4);
                    }
                    else if (value.indexOf('\\??\\') === 0) {
                        return value.substr(4);
                    }
                    else if (value.indexOf('"\\\\?\\') === 0) {
                        return '"' + value.substr(5);
                    }
                    else if (value.indexOf('"\\??\\') === 0) {
                        return '"' + value.substr(5);
                    }
                    else {
                        return value;
                    }
                };
                (new Promise(function (resolve_1, reject_1) { require(['windows-process-tree'], resolve_1, reject_1); })).then(function (windowsProcessTree) {
                    windowsProcessTree.getProcessList(rootPid, function (processList) {
                        windowsProcessTree.getProcessCpuUsage(processList, function (completeProcessList) {
                            var processItems = new Map();
                            completeProcessList.forEach(function (process) {
                                var commandLine = cleanUNCPrefix_1(process.commandLine);
                                processItems.set(process.pid, {
                                    name: findName(commandLine),
                                    cmd: commandLine,
                                    pid: process.pid,
                                    ppid: process.ppid,
                                    load: process.cpu,
                                    mem: process.memory
                                });
                            });
                            rootItem = processItems.get(rootPid);
                            if (rootItem) {
                                processItems.forEach(function (item) {
                                    var parent = processItems.get(item.ppid);
                                    if (parent) {
                                        if (!parent.children) {
                                            parent.children = [];
                                        }
                                        parent.children.push(item);
                                    }
                                });
                                processItems.forEach(function (item) {
                                    if (item.children) {
                                        item.children = item.children.sort(function (a, b) { return a.pid - b.pid; });
                                    }
                                });
                                resolve(rootItem);
                            }
                            else {
                                reject(new Error("Root process " + rootPid + " not found"));
                            }
                        });
                    }, windowsProcessTree.ProcessDataFlag.CommandLine | windowsProcessTree.ProcessDataFlag.Memory);
                });
            }
            else { // OS X & Linux
                var CMD = '/bin/ps -ax -o pid=,ppid=,pcpu=,pmem=,command=';
                var PID_CMD_1 = /^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+\.[0-9]+)\s+([0-9]+\.[0-9]+)\s+(.+)$/;
                child_process_1.exec(CMD, { maxBuffer: 1000 * 1024 }, function (err, stdout, stderr) {
                    if (err || stderr) {
                        reject(err || stderr.toString());
                    }
                    else {
                        var lines = stdout.toString().split('\n');
                        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                            var line = lines_1[_i];
                            var matches = PID_CMD_1.exec(line.trim());
                            if (matches && matches.length === 6) {
                                addToTree(parseInt(matches[1]), parseInt(matches[2]), matches[5], parseFloat(matches[3]), parseFloat(matches[4]));
                            }
                        }
                        if (process.platform === 'linux') {
                            // Flatten rootItem to get a list of all VSCode processes
                            var processes = [rootItem];
                            var pids_1 = [];
                            while (processes.length) {
                                var process_1 = processes.shift();
                                pids_1.push(process_1.pid);
                                if (process_1.children) {
                                    processes = processes.concat(process_1.children);
                                }
                            }
                            // The cpu usage value reported on Linux is the average over the process lifetime,
                            // recalculate the usage over a one second interval
                            // JSON.stringify is needed to escape spaces, https://github.com/nodejs/node/issues/6803
                            var cmd = JSON.stringify(amd_1.getPathFromAmdModule(require, 'vs/base/node/cpuUsage.sh'));
                            cmd += ' ' + pids_1.join(' ');
                            child_process_1.exec(cmd, {}, function (err, stdout, stderr) {
                                if (err || stderr) {
                                    reject(err || stderr.toString());
                                }
                                else {
                                    var cpuUsage = stdout.toString().split('\n');
                                    for (var i = 0; i < pids_1.length; i++) {
                                        var processInfo = map.get(pids_1[i]);
                                        processInfo.load = parseFloat(cpuUsage[i]);
                                    }
                                    resolve(rootItem);
                                }
                            });
                        }
                        else {
                            resolve(rootItem);
                        }
                    }
                });
            }
        });
    }
    exports.listProcesses = listProcesses;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[103/*vs/base/node/stats*/], __M([1/*require*/,0/*exports*/,21/*fs*/,11/*path*/,40/*vs/base/common/json*/]), function (require, exports, fs_1, path_1, json_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function asSortedItems(map) {
        var a = [];
        map.forEach(function (value, index) { return a.push({ name: index, count: value }); });
        return a.sort(function (a, b) { return b.count - a.count; });
    }
    function collectLaunchConfigs(folder) {
        var launchConfigs = new Map();
        var launchConfig = path_1.join(folder, '.vscode', 'launch.json');
        return new Promise(function (resolve, reject) {
            fs_1.exists(launchConfig, function (doesExist) {
                if (doesExist) {
                    fs_1.readFile(launchConfig, function (err, contents) {
                        if (err) {
                            return resolve([]);
                        }
                        var errors = [];
                        var json = json_1.parse(contents.toString(), errors);
                        if (errors.length) {
                            console.log("Unable to parse " + launchConfig);
                            return resolve([]);
                        }
                        if (json['configurations']) {
                            for (var _i = 0, _a = json['configurations']; _i < _a.length; _i++) {
                                var each = _a[_i];
                                var type = each['type'];
                                if (type) {
                                    if (launchConfigs.has(type)) {
                                        launchConfigs.set(type, launchConfigs.get(type) + 1);
                                    }
                                    else {
                                        launchConfigs.set(type, 1);
                                    }
                                }
                            }
                        }
                        return resolve(asSortedItems(launchConfigs));
                    });
                }
                else {
                    return resolve([]);
                }
            });
        });
    }
    exports.collectLaunchConfigs = collectLaunchConfigs;
    function collectWorkspaceStats(folder, filter) {
        var configFilePatterns = [
            { 'tag': 'grunt.js', 'pattern': /^gruntfile\.js$/i },
            { 'tag': 'gulp.js', 'pattern': /^gulpfile\.js$/i },
            { 'tag': 'tsconfig.json', 'pattern': /^tsconfig\.json$/i },
            { 'tag': 'package.json', 'pattern': /^package\.json$/i },
            { 'tag': 'jsconfig.json', 'pattern': /^jsconfig\.json$/i },
            { 'tag': 'tslint.json', 'pattern': /^tslint\.json$/i },
            { 'tag': 'eslint.json', 'pattern': /^eslint\.json$/i },
            { 'tag': 'tasks.json', 'pattern': /^tasks\.json$/i },
            { 'tag': 'launch.json', 'pattern': /^launch\.json$/i },
            { 'tag': 'settings.json', 'pattern': /^settings\.json$/i },
            { 'tag': 'webpack.config.js', 'pattern': /^webpack\.config\.js$/i },
            { 'tag': 'project.json', 'pattern': /^project\.json$/i },
            { 'tag': 'makefile', 'pattern': /^makefile$/i },
            { 'tag': 'sln', 'pattern': /^.+\.sln$/i },
            { 'tag': 'csproj', 'pattern': /^.+\.csproj$/i },
            { 'tag': 'cmake', 'pattern': /^.+\.cmake$/i }
        ];
        var fileTypes = new Map();
        var configFiles = new Map();
        var MAX_FILES = 20000;
        function walk(dir, filter, token, done) {
            var _this = this;
            var results = [];
            fs_1.readdir(dir, function (err, files) { return __awaiter(_this, void 0, void 0, function () {
                var pending, _loop_1, _i, files_1, file, state_1;
                return __generator(this, function (_a) {
                    // Ignore folders that can't be read
                    if (err) {
                        return [2 /*return*/, done(results)];
                    }
                    pending = files.length;
                    if (pending === 0) {
                        return [2 /*return*/, done(results)];
                    }
                    _loop_1 = function (file) {
                        if (token.maxReached) {
                            return { value: done(results) };
                        }
                        fs_1.stat(path_1.join(dir, file), function (err, stats) {
                            // Ignore files that can't be read
                            if (err) {
                                if (--pending === 0) {
                                    return done(results);
                                }
                            }
                            else {
                                if (stats.isDirectory()) {
                                    if (filter.indexOf(file) === -1) {
                                        walk(path_1.join(dir, file), filter, token, function (res) {
                                            results = results.concat(res);
                                            if (--pending === 0) {
                                                return done(results);
                                            }
                                        });
                                    }
                                    else {
                                        if (--pending === 0) {
                                            done(results);
                                        }
                                    }
                                }
                                else {
                                    if (token.count >= MAX_FILES) {
                                        token.maxReached = true;
                                    }
                                    token.count++;
                                    results.push(file);
                                    if (--pending === 0) {
                                        done(results);
                                    }
                                }
                            }
                        });
                    };
                    for (_i = 0, files_1 = files; _i < files_1.length; _i++) {
                        file = files_1[_i];
                        state_1 = _loop_1(file);
                        if (typeof state_1 === "object")
                            return [2 /*return*/, state_1.value];
                    }
                    return [2 /*return*/];
                });
            }); });
        }
        var addFileType = function (fileType) {
            if (fileTypes.has(fileType)) {
                fileTypes.set(fileType, fileTypes.get(fileType) + 1);
            }
            else {
                fileTypes.set(fileType, 1);
            }
        };
        var addConfigFiles = function (fileName) {
            for (var _i = 0, configFilePatterns_1 = configFilePatterns; _i < configFilePatterns_1.length; _i++) {
                var each = configFilePatterns_1[_i];
                if (each.pattern.test(fileName)) {
                    if (configFiles.has(each.tag)) {
                        configFiles.set(each.tag, configFiles.get(each.tag) + 1);
                    }
                    else {
                        configFiles.set(each.tag, 1);
                    }
                }
            }
        };
        var acceptFile = function (name) {
            if (name.lastIndexOf('.') >= 0) {
                var suffix = name.split('.').pop();
                if (suffix) {
                    addFileType(suffix);
                }
            }
            addConfigFiles(name);
        };
        var token = { count: 0, maxReached: false };
        return new Promise(function (resolve, reject) {
            walk(folder, filter, token, function (files) {
                files.forEach(acceptFile);
                resolve({
                    configFiles: asSortedItems(configFiles),
                    fileTypes: asSortedItems(fileTypes),
                    fileCount: token.count,
                    maxFilesReached: token.maxReached
                });
            });
        });
    }
    exports.collectWorkspaceStats = collectWorkspaceStats;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[105/*vs/base/node/stream*/], __M([1/*require*/,0/*exports*/,21/*fs*/,2/*vs/base/common/winjs.base*/]), function (require, exports, fs, winjs_base_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Reads totalBytes from the provided file.
     */
    function readExactlyByFile(file, totalBytes) {
        return new winjs_base_1.TPromise(function (complete, error) {
            fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return error(err);
                }
                function end(err, resultBuffer, bytesRead) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return error(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return error(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return complete({ buffer: resultBuffer, bytesRead: bytesRead });
                    });
                }
                var buffer = Buffer.allocUnsafe(totalBytes);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, totalBytes - offset, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null, 0);
                        }
                        if (bytesRead === 0) {
                            return end(null, buffer, offset);
                        }
                        offset += bytesRead;
                        if (offset === totalBytes) {
                            return end(null, buffer, offset);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readExactlyByFile = readExactlyByFile;
    /**
     * Reads a file until a matching string is found.
     *
     * @param file The file to read.
     * @param matchingString The string to search for.
     * @param chunkBytes The number of bytes to read each iteration.
     * @param maximumBytesToRead The maximum number of bytes to read before giving up.
     * @param callback The finished callback.
     */
    function readToMatchingString(file, matchingString, chunkBytes, maximumBytesToRead) {
        return new winjs_base_1.TPromise(function (complete, error) {
            return fs.open(file, 'r', null, function (err, fd) {
                if (err) {
                    return error(err);
                }
                function end(err, result) {
                    fs.close(fd, function (closeError) {
                        if (closeError) {
                            return error(closeError);
                        }
                        if (err && err.code === 'EISDIR') {
                            return error(err); // we want to bubble this error up (file is actually a folder)
                        }
                        return complete(result);
                    });
                }
                var buffer = Buffer.allocUnsafe(maximumBytesToRead);
                var offset = 0;
                function readChunk() {
                    fs.read(fd, buffer, offset, chunkBytes, null, function (err, bytesRead) {
                        if (err) {
                            return end(err, null);
                        }
                        if (bytesRead === 0) {
                            return end(null, null);
                        }
                        offset += bytesRead;
                        var newLineIndex = buffer.indexOf(matchingString);
                        if (newLineIndex >= 0) {
                            return end(null, buffer.toString('utf8').substr(0, newLineIndex));
                        }
                        if (offset >= maximumBytesToRead) {
                            return end(new Error("Could not find " + matchingString + " in first " + maximumBytesToRead + " bytes of " + file), null);
                        }
                        return readChunk();
                    });
                }
                readChunk();
            });
        });
    }
    exports.readToMatchingString = readToMatchingString;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[111/*vs/base/node/encoding*/], __M([1/*require*/,0/*exports*/,105/*vs/base/node/stream*/,184/*iconv-lite*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/platform*/,53/*child_process*/,183/*stream*/]), function (require, exports, stream, iconv, winjs_base_1, platform_1, child_process_1, stream_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UTF8 = 'utf8';
    exports.UTF8_with_bom = 'utf8bom';
    exports.UTF16be = 'utf16be';
    exports.UTF16le = 'utf16le';
    function toDecodeStream(readable, options) {
        if (!options.minBytesRequiredForDetection) {
            options.minBytesRequiredForDetection = options.guessEncoding ? AUTO_GUESS_BUFFER_MAX_LEN : NO_GUESS_BUFFER_MAX_LEN;
        }
        if (!options.overwriteEncoding) {
            options.overwriteEncoding = function (detected) { return detected || exports.UTF8; };
        }
        return new winjs_base_1.TPromise(function (resolve, reject) {
            readable.pipe(new /** @class */ (function (_super) {
                __extends(class_1, _super);
                function class_1(opts) {
                    var _this = _super.call(this, opts) || this;
                    _this._buffer = [];
                    _this._bytesBuffered = 0;
                    _this.once('finish', function () { return _this._finish(); });
                    return _this;
                }
                class_1.prototype._write = function (chunk, encoding, callback) {
                    if (!Buffer.isBuffer(chunk)) {
                        callback(new Error('data must be a buffer'));
                    }
                    if (this._decodeStream) {
                        // just a forwarder now
                        this._decodeStream.write(chunk, callback);
                        return;
                    }
                    this._buffer.push(chunk);
                    this._bytesBuffered += chunk.length;
                    if (this._decodeStreamConstruction) {
                        // waiting for the decoder to be ready
                        this._decodeStreamConstruction.then(function (_) { return callback(); }, function (err) { return callback(err); });
                    }
                    else if (this._bytesBuffered >= options.minBytesRequiredForDetection) {
                        // buffered enough data, create stream and forward data
                        this._startDecodeStream(callback);
                    }
                    else {
                        // only buffering
                        callback();
                    }
                };
                class_1.prototype._startDecodeStream = function (callback) {
                    var _this = this;
                    this._decodeStreamConstruction = winjs_base_1.TPromise.as(detectEncodingFromBuffer({
                        buffer: Buffer.concat(this._buffer), bytesRead: this._bytesBuffered
                    }, options.guessEncoding)).then(function (detected) {
                        detected.encoding = options.overwriteEncoding(detected.encoding);
                        _this._decodeStream = decodeStream(detected.encoding);
                        for (var _i = 0, _a = _this._buffer; _i < _a.length; _i++) {
                            var buffer = _a[_i];
                            _this._decodeStream.write(buffer);
                        }
                        callback();
                        resolve({ detected: detected, stream: _this._decodeStream });
                    }, function (err) {
                        _this.emit('error', err);
                        callback(err);
                    });
                };
                class_1.prototype._finish = function () {
                    var _this = this;
                    if (this._decodeStream) {
                        // normal finish
                        this._decodeStream.end();
                    }
                    else {
                        // we were still waiting for data...
                        this._startDecodeStream(function () { return _this._decodeStream.end(); });
                    }
                };
                return class_1;
            }(stream_1.Writable)));
        });
    }
    exports.toDecodeStream = toDecodeStream;
    function bomLength(encoding) {
        switch (encoding) {
            case exports.UTF8:
                return 3;
            case exports.UTF16be:
            case exports.UTF16le:
                return 2;
        }
        return 0;
    }
    exports.bomLength = bomLength;
    function decode(buffer, encoding) {
        return iconv.decode(buffer, toNodeEncoding(encoding));
    }
    exports.decode = decode;
    function encode(content, encoding, options) {
        return iconv.encode(content, toNodeEncoding(encoding), options);
    }
    exports.encode = encode;
    function encodingExists(encoding) {
        return iconv.encodingExists(toNodeEncoding(encoding));
    }
    exports.encodingExists = encodingExists;
    function decodeStream(encoding) {
        return iconv.decodeStream(toNodeEncoding(encoding));
    }
    exports.decodeStream = decodeStream;
    function encodeStream(encoding, options) {
        return iconv.encodeStream(toNodeEncoding(encoding), options);
    }
    exports.encodeStream = encodeStream;
    function toNodeEncoding(enc) {
        if (enc === exports.UTF8_with_bom) {
            return exports.UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it
        }
        return enc;
    }
    function detectEncodingByBOMFromBuffer(buffer, bytesRead) {
        if (!buffer || bytesRead < 2) {
            return null;
        }
        var b0 = buffer.readUInt8(0);
        var b1 = buffer.readUInt8(1);
        // UTF-16 BE
        if (b0 === 0xFE && b1 === 0xFF) {
            return exports.UTF16be;
        }
        // UTF-16 LE
        if (b0 === 0xFF && b1 === 0xFE) {
            return exports.UTF16le;
        }
        if (bytesRead < 3) {
            return null;
        }
        var b2 = buffer.readUInt8(2);
        // UTF-8
        if (b0 === 0xEF && b1 === 0xBB && b2 === 0xBF) {
            return exports.UTF8;
        }
        return null;
    }
    exports.detectEncodingByBOMFromBuffer = detectEncodingByBOMFromBuffer;
    /**
     * Detects the Byte Order Mark in a given file.
     * If no BOM is detected, null will be passed to callback.
     */
    function detectEncodingByBOM(file) {
        return stream.readExactlyByFile(file, 3).then(function (_a) {
            var buffer = _a.buffer, bytesRead = _a.bytesRead;
            return detectEncodingByBOMFromBuffer(buffer, bytesRead);
        });
    }
    exports.detectEncodingByBOM = detectEncodingByBOM;
    var MINIMUM_THRESHOLD = 0.2;
    var IGNORE_ENCODINGS = ['ascii', 'utf-8', 'utf-16', 'utf-32'];
    /**
     * Guesses the encoding from buffer.
     */
    function guessEncodingByBuffer(buffer) {
        return winjs_base_1.TPromise.wrap(new Promise(function (resolve_1, reject_1) { require(['jschardet'], resolve_1, reject_1); })).then(function (jschardet) {
            jschardet.Constants.MINIMUM_THRESHOLD = MINIMUM_THRESHOLD;
            var guessed = jschardet.detect(buffer);
            if (!guessed || !guessed.encoding) {
                return null;
            }
            var enc = guessed.encoding.toLowerCase();
            // Ignore encodings that cannot guess correctly
            // (http://chardet.readthedocs.io/en/latest/supported-encodings.html)
            if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {
                return null;
            }
            return toIconvLiteEncoding(guessed.encoding);
        });
    }
    exports.guessEncodingByBuffer = guessEncodingByBuffer;
    var JSCHARDET_TO_ICONV_ENCODINGS = {
        'ibm866': 'cp866',
        'big5': 'cp950'
    };
    function toIconvLiteEncoding(encodingName) {
        var normalizedEncodingName = encodingName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        var mapped = JSCHARDET_TO_ICONV_ENCODINGS[normalizedEncodingName];
        return mapped || normalizedEncodingName;
    }
    /**
     * The encodings that are allowed in a settings file don't match the canonical encoding labels specified by WHATWG.
     * See https://encoding.spec.whatwg.org/#names-and-labels
     * Iconv-lite strips all non-alphanumeric characters, but ripgrep doesn't. For backcompat, allow these labels.
     */
    function toCanonicalName(enc) {
        switch (enc) {
            case 'shiftjis':
                return 'shift-jis';
            case 'utf16le':
                return 'utf-16le';
            case 'utf16be':
                return 'utf-16be';
            case 'big5hkscs':
                return 'big5-hkscs';
            case 'eucjp':
                return 'euc-jp';
            case 'euckr':
                return 'euc-kr';
            case 'koi8r':
                return 'koi8-r';
            case 'koi8u':
                return 'koi8-u';
            case 'macroman':
                return 'x-mac-roman';
            case 'utf8bom':
                return 'utf8';
            default:
                var m = enc.match(/windows(\d+)/);
                if (m) {
                    return 'windows-' + m[1];
                }
                return enc;
        }
    }
    exports.toCanonicalName = toCanonicalName;
    var ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512; // number of bytes to look at to decide about a file being binary or not
    var NO_GUESS_BUFFER_MAX_LEN = 512; // when not auto guessing the encoding, small number of bytes are enough
    var AUTO_GUESS_BUFFER_MAX_LEN = 512 * 8; // with auto guessing we want a lot more content to be read for guessing
    function detectEncodingFromBuffer(_a, autoGuessEncoding) {
        var buffer = _a.buffer, bytesRead = _a.bytesRead;
        // Always first check for BOM to find out about encoding
        var encoding = detectEncodingByBOMFromBuffer(buffer, bytesRead);
        // Detect 0 bytes to see if file is binary or UTF-16 LE/BE
        // unless we already know that this file has a UTF-16 encoding
        var seemsBinary = false;
        if (encoding !== exports.UTF16be && encoding !== exports.UTF16le) {
            var couldBeUTF16LE = true; // e.g. 0xAA 0x00
            var couldBeUTF16BE = true; // e.g. 0x00 0xAA
            var containsZeroByte = false;
            // This is a simplified guess to detect UTF-16 BE or LE by just checking if
            // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE
            // this would be the odd byte index and for UTF-16 BE the even one.
            // Note: this can produce false positives (a binary file that uses a 2-byte
            // encoding of the same format as UTF-16) and false negatives (a UTF-16 file
            // that is using 4 bytes to encode a character).
            for (var i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {
                var isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16
                var isZeroByte = (buffer.readInt8(i) === 0);
                if (isZeroByte) {
                    containsZeroByte = true;
                }
                // UTF-16 LE: expect e.g. 0xAA 0x00
                if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {
                    couldBeUTF16LE = false;
                }
                // UTF-16 BE: expect e.g. 0x00 0xAA
                if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {
                    couldBeUTF16BE = false;
                }
                // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary
                if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {
                    break;
                }
            }
            // Handle case of 0-byte included
            if (containsZeroByte) {
                if (couldBeUTF16LE) {
                    encoding = exports.UTF16le;
                }
                else if (couldBeUTF16BE) {
                    encoding = exports.UTF16be;
                }
                else {
                    seemsBinary = true;
                }
            }
        }
        // Auto guess encoding if configured
        if (autoGuessEncoding && !seemsBinary && !encoding) {
            return guessEncodingByBuffer(buffer.slice(0, bytesRead)).then(function (encoding) {
                return {
                    seemsBinary: false,
                    encoding: encoding
                };
            });
        }
        return { seemsBinary: seemsBinary, encoding: encoding };
    }
    exports.detectEncodingFromBuffer = detectEncodingFromBuffer;
    // https://ss64.com/nt/chcp.html
    var windowsTerminalEncodings = {
        '437': 'cp437',
        '850': 'cp850',
        '852': 'cp852',
        '855': 'cp855',
        '857': 'cp857',
        '860': 'cp860',
        '861': 'cp861',
        '863': 'cp863',
        '865': 'cp865',
        '866': 'cp866',
        '869': 'cp869',
        '936': 'cp936',
        '1252': 'cp1252' // West European Latin
    };
    function resolveTerminalEncoding(verbose) {
        var rawEncodingPromise;
        // Support a global environment variable to win over other mechanics
        var cliEncodingEnv = process.env['VSCODE_CLI_ENCODING'];
        if (cliEncodingEnv) {
            if (verbose) {
                console.log("Found VSCODE_CLI_ENCODING variable: " + cliEncodingEnv);
            }
            rawEncodingPromise = winjs_base_1.TPromise.as(cliEncodingEnv);
        }
        // Linux/Mac: use "locale charmap" command
        else if (platform_1.isLinux || platform_1.isMacintosh) {
            rawEncodingPromise = new winjs_base_1.TPromise(function (c) {
                if (verbose) {
                    console.log('Running "locale charmap" to detect terminal encoding...');
                }
                child_process_1.exec('locale charmap', function (err, stdout, stderr) { return c(stdout); });
            });
        }
        // Windows: educated guess
        else {
            rawEncodingPromise = new winjs_base_1.TPromise(function (c) {
                if (verbose) {
                    console.log('Running "chcp" to detect terminal encoding...');
                }
                child_process_1.exec('chcp', function (err, stdout, stderr) {
                    if (stdout) {
                        var windowsTerminalEncodingKeys = Object.keys(windowsTerminalEncodings);
                        for (var i = 0; i < windowsTerminalEncodingKeys.length; i++) {
                            var key = windowsTerminalEncodingKeys[i];
                            if (stdout.indexOf(key) >= 0) {
                                return c(windowsTerminalEncodings[key]);
                            }
                        }
                    }
                    return c(void 0);
                });
            });
        }
        return rawEncodingPromise.then(function (rawEncoding) {
            if (verbose) {
                console.log("Detected raw terminal encoding: " + rawEncoding);
            }
            if (!rawEncoding || rawEncoding.toLowerCase() === 'utf-8' || rawEncoding.toLowerCase() === exports.UTF8) {
                return exports.UTF8;
            }
            var iconvEncoding = toIconvLiteEncoding(rawEncoding);
            if (iconv.encodingExists(iconvEncoding)) {
                return iconvEncoding;
            }
            if (verbose) {
                console.log('Unsupported terminal encoding, falling back to UTF-8.');
            }
            return exports.UTF8;
        });
    }
    exports.resolveTerminalEncoding = resolveTerminalEncoding;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[36/*vs/base/node/extfs*/], __M([1/*require*/,0/*exports*/,21/*fs*/,11/*path*/,20/*vs/base/common/async*/,72/*vs/base/common/normalization*/,3/*vs/base/common/platform*/,18/*vs/base/common/strings*/,39/*vs/base/common/uuid*/,2/*vs/base/common/winjs.base*/,111/*vs/base/node/encoding*/,142/*vs/base/node/flow*/,13/*vs/base/common/lifecycle*/]), function (require, exports, fs, paths, async_1, normalization_1, platform, strings, uuid, winjs_base_1, encoding_1, flow, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var loop = flow.loop;
    function readdirSync(path) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdirSync(path).map(function (c) { return normalization_1.normalizeNFC(c); });
        }
        return fs.readdirSync(path);
    }
    exports.readdirSync = readdirSync;
    function readdir(path, callback) {
        // Mac: uses NFD unicode form on disk, but we want NFC
        // See also https://github.com/nodejs/node/issues/2165
        if (platform.isMacintosh) {
            return fs.readdir(path, function (error, children) {
                if (error) {
                    return callback(error, null);
                }
                return callback(null, children.map(function (c) { return normalization_1.normalizeNFC(c); }));
            });
        }
        return fs.readdir(path, callback);
    }
    exports.readdir = readdir;
    function statLink(path, callback) {
        fs.lstat(path, function (error, lstat) {
            if (error || lstat.isSymbolicLink()) {
                fs.stat(path, function (error, stat) {
                    if (error) {
                        return callback(error, null);
                    }
                    callback(null, { stat: stat, isSymbolicLink: lstat && lstat.isSymbolicLink() });
                });
            }
            else {
                callback(null, { stat: lstat, isSymbolicLink: false });
            }
        });
    }
    exports.statLink = statLink;
    function copy(source, target, callback, copiedSources) {
        if (!copiedSources) {
            copiedSources = Object.create(null);
        }
        fs.stat(source, function (error, stat) {
            if (error) {
                return callback(error);
            }
            if (!stat.isDirectory()) {
                return doCopyFile(source, target, stat.mode & 511, callback);
            }
            if (copiedSources[source]) {
                return callback(null); // escape when there are cycles (can happen with symlinks)
            }
            copiedSources[source] = true; // remember as copied
            var proceed = function () {
                readdir(source, function (err, files) {
                    loop(files, function (file, clb) {
                        copy(paths.join(source, file), paths.join(target, file), function (error) { return clb(error, void 0); }, copiedSources);
                    }, callback);
                });
            };
            mkdirp(target, stat.mode & 511).then(proceed, proceed);
        });
    }
    exports.copy = copy;
    function doCopyFile(source, target, mode, callback) {
        var reader = fs.createReadStream(source);
        var writer = fs.createWriteStream(target, { mode: mode });
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases, pass to callback
                if (error) {
                    callback(error);
                }
                // we need to explicitly chmod because of https://github.com/nodejs/node/issues/1104
                else {
                    fs.chmod(target, mode, callback);
                }
            }
        };
        // handle errors properly
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // we are done (underlying fd has been closed)
        writer.once('close', function () { return finish(); });
        // start piping
        reader.pipe(writer);
    }
    function mkdirp(path, mode, token) {
        var mkdir = function () {
            return async_1.nfcall(fs.mkdir, path, mode).then(null, function (mkdirErr) {
                // ENOENT: a parent folder does not exist yet
                if (mkdirErr.code === 'ENOENT') {
                    return winjs_base_1.TPromise.wrapError(mkdirErr);
                }
                // Any other error: check if folder exists and
                // return normally in that case if its a folder
                return async_1.nfcall(fs.stat, path).then(function (stat) {
                    if (!stat.isDirectory()) {
                        return winjs_base_1.TPromise.wrapError(new Error("'" + path + "' exists and is not a directory."));
                    }
                    return null;
                }, function (statErr) {
                    return winjs_base_1.TPromise.wrapError(mkdirErr); // bubble up original mkdir error
                });
            });
        };
        // stop at root
        if (path === paths.dirname(path)) {
            return winjs_base_1.TPromise.as(true);
        }
        // recursively mkdir
        return mkdir().then(null, function (err) {
            // Respect cancellation
            if (token && token.isCancellationRequested) {
                return winjs_base_1.TPromise.as(false);
            }
            // ENOENT: a parent folder does not exist yet, continue
            // to create the parent folder and then try again.
            if (err.code === 'ENOENT') {
                return mkdirp(paths.dirname(path), mode).then(mkdir);
            }
            // Any other error
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.mkdirp = mkdirp;
    // Deletes the given path by first moving it out of the workspace. This has two benefits. For one, the operation can return fast because
    // after the rename, the contents are out of the workspace although not yet deleted. The greater benefit however is that this operation
    // will fail in case any file is used by another process. fs.unlink() in node will not bail if a file unlinked is used by another process.
    // However, the consequences are bad as outlined in all the related bugs from https://github.com/joyent/node/issues/7164
    function del(path, tmpFolder, callback, done) {
        fs.exists(path, function (exists) {
            if (!exists) {
                return callback(null);
            }
            fs.stat(path, function (err, stat) {
                if (err || !stat) {
                    return callback(err);
                }
                // Special windows workaround: A file or folder that ends with a "." cannot be moved to another place
                // because it is not a valid file name. In this case, we really have to do the deletion without prior move.
                if (path[path.length - 1] === '.' || strings.endsWith(path, './') || strings.endsWith(path, '.\\')) {
                    return rmRecursive(path, callback);
                }
                var pathInTemp = paths.join(tmpFolder, uuid.generateUuid());
                fs.rename(path, pathInTemp, function (error) {
                    if (error) {
                        return rmRecursive(path, callback); // if rename fails, delete without tmp dir
                    }
                    // Return early since the move succeeded
                    callback(null);
                    // do the heavy deletion outside the callers callback
                    rmRecursive(pathInTemp, function (error) {
                        if (error) {
                            console.error(error);
                        }
                        if (done) {
                            done(error);
                        }
                    });
                });
            });
        });
    }
    exports.del = del;
    function rmRecursive(path, callback) {
        if (path === '\\' || path === '/') {
            return callback(new Error('Will not delete root!'));
        }
        fs.exists(path, function (exists) {
            if (!exists) {
                callback(null);
            }
            else {
                fs.lstat(path, function (err, stat) {
                    if (err || !stat) {
                        callback(err);
                    }
                    else if (!stat.isDirectory() || stat.isSymbolicLink() /* !!! never recurse into links when deleting !!! */) {
                        var mode = stat.mode;
                        if (!(mode & 128)) { // 128 === 0200
                            fs.chmod(path, mode | 128, function (err) {
                                if (err) {
                                    callback(err);
                                }
                                else {
                                    fs.unlink(path, callback);
                                }
                            });
                        }
                        else {
                            fs.unlink(path, callback);
                        }
                    }
                    else {
                        readdir(path, function (err, children) {
                            if (err || !children) {
                                callback(err);
                            }
                            else if (children.length === 0) {
                                fs.rmdir(path, callback);
                            }
                            else {
                                var firstError_1 = null;
                                var childrenLeft_1 = children.length;
                                children.forEach(function (child) {
                                    rmRecursive(paths.join(path, child), function (err) {
                                        childrenLeft_1--;
                                        if (err) {
                                            firstError_1 = firstError_1 || err;
                                        }
                                        if (childrenLeft_1 === 0) {
                                            if (firstError_1) {
                                                callback(firstError_1);
                                            }
                                            else {
                                                fs.rmdir(path, callback);
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    }
                });
            }
        });
    }
    function delSync(path) {
        try {
            var stat = fs.lstatSync(path);
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                readdirSync(path).forEach(function (child) { return delSync(paths.join(path, child)); });
                fs.rmdirSync(path);
            }
            else {
                fs.unlinkSync(path);
            }
        }
        catch (err) {
            if (err.code === 'ENOENT') {
                return; // not found
            }
            throw err;
        }
    }
    exports.delSync = delSync;
    function mv(source, target, callback) {
        if (source === target) {
            return callback(null);
        }
        function updateMtime(err) {
            if (err) {
                return callback(err);
            }
            fs.stat(target, function (error, stat) {
                if (error) {
                    return callback(error);
                }
                if (stat.isDirectory()) {
                    return callback(null);
                }
                fs.open(target, 'a', null, function (err, fd) {
                    if (err) {
                        return callback(err);
                    }
                    fs.futimes(fd, stat.atime, new Date(), function (err) {
                        if (err) {
                            return callback(err);
                        }
                        fs.close(fd, callback);
                    });
                });
            });
        }
        // Try native rename()
        fs.rename(source, target, function (err) {
            if (!err) {
                return updateMtime(null);
            }
            // In two cases we fallback to classic copy and delete:
            //
            // 1.) The EXDEV error indicates that source and target are on different devices
            // In this case, fallback to using a copy() operation as there is no way to
            // rename() between different devices.
            //
            // 2.) The user tries to rename a file/folder that ends with a dot. This is not
            // really possible to move then, at least on UNC devices.
            if (err && source.toLowerCase() !== target.toLowerCase() && (err.code === 'EXDEV') || strings.endsWith(source, '.')) {
                return copy(source, target, function (err) {
                    if (err) {
                        return callback(err);
                    }
                    rmRecursive(source, updateMtime);
                });
            }
            return callback(err);
        });
    }
    exports.mv = mv;
    var canFlush = true;
    function writeFileAndFlush(path, data, options, callback) {
        options = ensureOptions(options);
        if (typeof data === 'string' || Buffer.isBuffer(data)) {
            doWriteFileAndFlush(path, data, options, callback);
        }
        else {
            doWriteFileStreamAndFlush(path, data, options, callback);
        }
    }
    exports.writeFileAndFlush = writeFileAndFlush;
    function doWriteFileStreamAndFlush(path, reader, options, callback) {
        // finish only once
        var finished = false;
        var finish = function (error) {
            if (!finished) {
                finished = true;
                // in error cases we need to manually close streams
                // if the write stream was successfully opened
                if (error) {
                    if (isOpen) {
                        writer.once('close', function () { return callback(error); });
                        writer.close();
                    }
                    else {
                        callback(error);
                    }
                }
                // otherwise just return without error
                else {
                    callback();
                }
            }
        };
        // create writer to target. we set autoClose: false because we want to use the streams
        // file descriptor to call fs.fdatasync to ensure the data is flushed to disk
        var writer = fs.createWriteStream(path, { mode: options.mode, flags: options.flag, autoClose: false });
        // Event: 'open'
        // Purpose: save the fd for later use and start piping
        // Notes: will not be called when there is an error opening the file descriptor!
        var fd;
        var isOpen;
        writer.once('open', function (descriptor) {
            fd = descriptor;
            isOpen = true;
            // if an encoding is provided, we need to pipe the stream through
            // an encoder stream and forward the encoding related options
            if (options.encoding) {
                reader = reader.pipe(encoding_1.encodeStream(options.encoding.charset, { addBOM: options.encoding.addBOM }));
            }
            // start data piping only when we got a successful open. this ensures that we do
            // not consume the stream when an error happens and helps to fix this issue:
            // https://github.com/Microsoft/vscode/issues/42542
            reader.pipe(writer);
        });
        // Event: 'error'
        // Purpose: to return the error to the outside and to close the write stream (does not happen automatically)
        reader.once('error', function (error) { return finish(error); });
        writer.once('error', function (error) { return finish(error); });
        // Event: 'finish'
        // Purpose: use fs.fdatasync to flush the contents to disk
        // Notes: event is called when the writer has finished writing to the underlying resource. we must call writer.close()
        // because we have created the WriteStream with autoClose: false
        writer.once('finish', function () {
            // flush to disk
            if (canFlush && isOpen) {
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    writer.close();
                });
            }
            else {
                writer.close();
            }
        });
        // Event: 'close'
        // Purpose: signal we are done to the outside
        // Notes: event is called when the writer's filedescriptor is closed
        writer.once('close', function () { return finish(); });
    }
    // Calls fs.writeFile() followed by a fs.sync() call to flush the changes to disk
    // We do this in cases where we want to make sure the data is really on disk and
    // not in some cache.
    //
    // See https://github.com/nodejs/node/blob/v5.10.0/lib/fs.js#L1194
    function doWriteFileAndFlush(path, data, options, callback) {
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);
        }
        // Open the file with same flags and mode as fs.writeFile()
        fs.open(path, options.flag, options.mode, function (openError, fd) {
            if (openError) {
                return callback(openError);
            }
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFile(fd, data, function (writeError) {
                if (writeError) {
                    return fs.close(fd, function () { return callback(writeError); }); // still need to close the handle on error!
                }
                // Flush contents (not metadata) of the file to disk
                fs.fdatasync(fd, function (syncError) {
                    // In some exotic setups it is well possible that node fails to sync
                    // In that case we disable flushing and warn to the console
                    if (syncError) {
                        console.warn('[node.js fs] fdatasync is now disabled for this session because it failed: ', syncError);
                        canFlush = false;
                    }
                    return fs.close(fd, function (closeError) { return callback(closeError); });
                });
            });
        });
    }
    function writeFileAndFlushSync(path, data, options) {
        options = ensureOptions(options);
        if (options.encoding) {
            data = encoding_1.encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });
        }
        if (!canFlush) {
            return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });
        }
        // Open the file with same flags and mode as fs.writeFile()
        var fd = fs.openSync(path, options.flag, options.mode);
        try {
            // It is valid to pass a fd handle to fs.writeFile() and this will keep the handle open!
            fs.writeFileSync(fd, data);
            // Flush contents (not metadata) of the file to disk
            try {
                fs.fdatasyncSync(fd);
            }
            catch (syncError) {
                console.warn('[node.js fs] fdatasyncSync is now disabled for this session because it failed: ', syncError);
                canFlush = false;
            }
        }
        finally {
            fs.closeSync(fd);
        }
    }
    exports.writeFileAndFlushSync = writeFileAndFlushSync;
    function ensureOptions(options) {
        if (!options) {
            return { mode: 438, flag: 'w' };
        }
        var ensuredOptions = { mode: options.mode, flag: options.flag, encoding: options.encoding };
        if (typeof ensuredOptions.mode !== 'number') {
            ensuredOptions.mode = 438;
        }
        if (typeof ensuredOptions.flag !== 'string') {
            ensuredOptions.flag = 'w';
        }
        return ensuredOptions;
    }
    /**
     * Copied from: https://github.com/Microsoft/vscode-node-debug/blob/master/src/node/pathUtilities.ts#L83
     *
     * Given an absolute, normalized, and existing file path 'realcase' returns the exact path that the file has on disk.
     * On a case insensitive file system, the returned path might differ from the original path by character casing.
     * On a case sensitive file system, the returned path will always be identical to the original path.
     * In case of errors, null is returned. But you cannot use this function to verify that a path exists.
     * realcaseSync does not handle '..' or '.' path segments and it does not take the locale into account.
     */
    function realcaseSync(path) {
        var dir = paths.dirname(path);
        if (path === dir) { // end recursion
            return path;
        }
        var name = (paths.basename(path) /* can be '' for windows drive letters */ || path).toLowerCase();
        try {
            var entries = readdirSync(dir);
            var found = entries.filter(function (e) { return e.toLowerCase() === name; }); // use a case insensitive search
            if (found.length === 1) {
                // on a case sensitive filesystem we cannot determine here, whether the file exists or not, hence we need the 'file exists' precondition
                var prefix = realcaseSync(dir); // recurse
                if (prefix) {
                    return paths.join(prefix, found[0]);
                }
            }
            else if (found.length > 1) {
                // must be a case sensitive $filesystem
                var ix = found.indexOf(name);
                if (ix >= 0) { // case sensitive
                    var prefix = realcaseSync(dir); // recurse
                    if (prefix) {
                        return paths.join(prefix, found[ix]);
                    }
                }
            }
        }
        catch (error) {
            // silently ignore error
        }
        return null;
    }
    exports.realcaseSync = realcaseSync;
    function realpathSync(path) {
        try {
            return fs.realpathSync(path);
        }
        catch (error) {
            // We hit an error calling fs.realpathSync(). Since fs.realpathSync() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            fs.accessSync(normalizedPath, fs.constants.R_OK); // throws in case of an error
            return normalizedPath;
        }
    }
    exports.realpathSync = realpathSync;
    function realpath(path, callback) {
        return fs.realpath(path, function (error, realpath) {
            if (!error) {
                return callback(null, realpath);
            }
            // We hit an error calling fs.realpath(). Since fs.realpath() is doing some path normalization
            // we now do a similar normalization and then try again if we can access the path with read
            // permissions at least. If that succeeds, we return that path.
            // fs.realpath() is resolving symlinks and that can fail in certain cases. The workaround is
            // to not resolve links but to simply see if the path is read accessible or not.
            var normalizedPath = normalizePath(path);
            return fs.access(normalizedPath, fs.constants.R_OK, function (error) {
                return callback(error, normalizedPath);
            });
        });
    }
    exports.realpath = realpath;
    function normalizePath(path) {
        return strings.rtrim(paths.normalize(path), paths.sep);
    }
    function watch(path, onChange, onError) {
        try {
            var watcher_1 = fs.watch(path);
            watcher_1.on('change', function (type, raw) {
                var file = null;
                if (raw) { // https://github.com/Microsoft/vscode/issues/38191
                    file = raw.toString();
                    if (platform.isMacintosh) {
                        // Mac: uses NFD unicode form on disk, but we want NFC
                        // See also https://github.com/nodejs/node/issues/2165
                        file = normalization_1.normalizeNFC(file);
                    }
                }
                onChange(type, file);
            });
            watcher_1.on('error', function (code, signal) { return onError("Failed to watch " + path + " for changes (" + code + ", " + signal + ")"); });
            return lifecycle_1.toDisposable(function () {
                watcher_1.removeAllListeners();
                watcher_1.close();
            });
        }
        catch (error) {
            fs.exists(path, function (exists) {
                if (exists) {
                    onError("Failed to watch " + path + " for changes (" + error.toString() + ")");
                }
            });
        }
        return lifecycle_1.Disposable.None;
    }
    exports.watch = watch;
    function sanitizeFilePath(candidate, cwd) {
        // Special case: allow to open a drive letter without trailing backslash
        if (platform.isWindows && strings.endsWith(candidate, ':')) {
            candidate += paths.sep;
        }
        // Ensure absolute
        if (!paths.isAbsolute(candidate)) {
            candidate = paths.join(cwd, candidate);
        }
        // Ensure normalized
        candidate = paths.normalize(candidate);
        // Ensure no trailing slash/backslash
        if (platform.isWindows) {
            candidate = strings.rtrim(candidate, paths.sep);
            // Special case: allow to open drive root ('C:\')
            if (strings.endsWith(candidate, ':')) {
                candidate += paths.sep;
            }
        }
        else {
            candidate = strings.rtrim(candidate, paths.sep);
            // Special case: allow to open root ('/')
            if (!candidate) {
                candidate = paths.sep;
            }
        }
        return candidate;
    }
    exports.sanitizeFilePath = sanitizeFilePath;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[68/*vs/base/node/config*/], __M([1/*require*/,0/*exports*/,21/*fs*/,11/*path*/,17/*vs/base/common/objects*/,13/*vs/base/common/lifecycle*/,5/*vs/base/common/event*/,40/*vs/base/common/json*/,36/*vs/base/node/extfs*/,3/*vs/base/common/platform*/]), function (require, exports, fs, path_1, objects, lifecycle_1, event_1, json, extfs, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * A simple helper to watch a configured file for changes and process its contents as JSON object.
     * Supports:
     * - comments in JSON files and errors
     * - symlinks for the config file itself
     * - delayed processing of changes to accomodate for lots of changes
     * - configurable defaults
     */
    var ConfigWatcher = /** @class */ (function () {
        function ConfigWatcher(_path, options) {
            if (options === void 0) { options = { changeBufferDelay: 0, defaultConfig: Object.create(null), onError: function (error) { return console.error(error); } }; }
            this._path = _path;
            this.options = options;
            this.disposables = [];
            this.configName = path_1.basename(this._path);
            this._onDidUpdateConfiguration = new event_1.Emitter();
            this.disposables.push(this._onDidUpdateConfiguration);
            this.registerWatcher();
            this.initAsync();
        }
        Object.defineProperty(ConfigWatcher.prototype, "path", {
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigWatcher.prototype, "hasParseErrors", {
            get: function () {
                return this.parseErrors && this.parseErrors.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigWatcher.prototype, "onDidUpdateConfiguration", {
            get: function () {
                return this._onDidUpdateConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ConfigWatcher.prototype.initAsync = function () {
            var _this = this;
            this.loadAsync(function (config) {
                if (!_this.loaded) {
                    _this.updateCache(config); // prevent race condition if config was loaded sync already
                }
                if (_this.options.initCallback) {
                    _this.options.initCallback(_this.getConfig());
                }
            });
        };
        ConfigWatcher.prototype.updateCache = function (value) {
            this.cache = value;
            this.loaded = true;
        };
        ConfigWatcher.prototype.loadSync = function () {
            try {
                return this.parse(fs.readFileSync(this._path).toString());
            }
            catch (error) {
                return this.options.defaultConfig;
            }
        };
        ConfigWatcher.prototype.loadAsync = function (callback) {
            var _this = this;
            fs.readFile(this._path, function (error, raw) {
                if (error) {
                    return callback(_this.options.defaultConfig);
                }
                return callback(_this.parse(raw.toString()));
            });
        };
        ConfigWatcher.prototype.parse = function (raw) {
            var res;
            try {
                this.parseErrors = [];
                res = this.options.parse ? this.options.parse(raw, this.parseErrors) : json.parse(raw, this.parseErrors);
            }
            catch (error) {
                // Ignore parsing errors
            }
            return res || this.options.defaultConfig;
        };
        ConfigWatcher.prototype.registerWatcher = function () {
            var _this = this;
            // Watch the parent of the path so that we detect ADD and DELETES
            var parentFolder = path_1.dirname(this._path);
            this.watch(parentFolder, true);
            // Check if the path is a symlink and watch its target if so
            fs.lstat(this._path, function (err, stat) {
                if (err || stat.isDirectory()) {
                    return; // path is not a valid file
                }
                // We found a symlink
                if (stat.isSymbolicLink()) {
                    fs.readlink(_this._path, function (err, realPath) {
                        if (err) {
                            return; // path is not a valid symlink
                        }
                        _this.watch(realPath, false);
                    });
                }
            });
        };
        ConfigWatcher.prototype.watch = function (path, isParentFolder) {
            var _this = this;
            if (this.disposed) {
                return; // avoid watchers that will never get disposed by checking for being disposed
            }
            this.disposables.push(extfs.watch(path, function (type, file) { return _this.onConfigFileChange(type, file, isParentFolder); }, function (error) { return _this.options.onError(error); }));
        };
        ConfigWatcher.prototype.onConfigFileChange = function (eventType, filename, isParentFolder) {
            var _this = this;
            if (isParentFolder) {
                // Windows: in some cases the filename contains artifacts from the absolute path
                // see https://github.com/nodejs/node/issues/19170
                // As such, we have to ensure that the filename basename is used for comparison.
                if (platform_1.isWindows && filename && filename !== this.configName) {
                    filename = path_1.basename(filename);
                }
                if (filename !== this.configName) {
                    return; // a change to a sibling file that is not our config file
                }
            }
            if (this.timeoutHandle) {
                global.clearTimeout(this.timeoutHandle);
                this.timeoutHandle = null;
            }
            // we can get multiple change events for one change, so we buffer through a timeout
            this.timeoutHandle = global.setTimeout(function () { return _this.reload(); }, this.options.changeBufferDelay);
        };
        ConfigWatcher.prototype.reload = function (callback) {
            var _this = this;
            this.loadAsync(function (currentConfig) {
                if (!objects.equals(currentConfig, _this.cache)) {
                    _this.updateCache(currentConfig);
                    _this._onDidUpdateConfiguration.fire({ config: _this.cache });
                }
                if (callback) {
                    return callback(currentConfig);
                }
            });
        };
        ConfigWatcher.prototype.getConfig = function () {
            this.ensureLoaded();
            return this.cache;
        };
        ConfigWatcher.prototype.getValue = function (key, fallback) {
            this.ensureLoaded();
            if (!key) {
                return fallback;
            }
            var value = this.cache ? this.cache[key] : void 0;
            return typeof value !== 'undefined' ? value : fallback;
        };
        ConfigWatcher.prototype.ensureLoaded = function () {
            if (!this.loaded) {
                this.updateCache(this.loadSync());
            }
        };
        ConfigWatcher.prototype.dispose = function () {
            this.disposed = true;
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return ConfigWatcher;
    }());
    exports.ConfigWatcher = ConfigWatcher;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[34/*vs/base/node/pfs*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,36/*vs/base/node/extfs*/,11/*path*/,20/*vs/base/common/async*/,21/*fs*/,26/*os*/,3/*vs/base/common/platform*/,5/*vs/base/common/event*/]), function (require, exports, winjs_base_1, extfs, path_1, async_1, fs, os, platform, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function readdir(path) {
        return async_1.nfcall(extfs.readdir, path);
    }
    exports.readdir = readdir;
    function exists(path) {
        return new winjs_base_1.TPromise(function (c) { return fs.exists(path, c); });
    }
    exports.exists = exists;
    function chmod(path, mode) {
        return async_1.nfcall(fs.chmod, path, mode);
    }
    exports.chmod = chmod;
    exports.mkdirp = extfs.mkdirp;
    function rimraf(path) {
        return lstat(path).then(function (stat) {
            if (stat.isDirectory() && !stat.isSymbolicLink()) {
                return readdir(path)
                    .then(function (children) { return winjs_base_1.TPromise.join(children.map(function (child) { return rimraf(path_1.join(path, child)); })); })
                    .then(function () { return rmdir(path); });
            }
            else {
                return unlink(path);
            }
        }, function (err) {
            if (err.code === 'ENOENT') {
                return void 0;
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    }
    exports.rimraf = rimraf;
    function realpath(path) {
        return async_1.nfcall(extfs.realpath, path);
    }
    exports.realpath = realpath;
    function stat(path) {
        return async_1.nfcall(fs.stat, path);
    }
    exports.stat = stat;
    function statLink(path) {
        return async_1.nfcall(extfs.statLink, path);
    }
    exports.statLink = statLink;
    function lstat(path) {
        return async_1.nfcall(fs.lstat, path);
    }
    exports.lstat = lstat;
    function rename(oldPath, newPath) {
        return async_1.nfcall(fs.rename, oldPath, newPath);
    }
    exports.rename = rename;
    function rmdir(path) {
        return async_1.nfcall(fs.rmdir, path);
    }
    exports.rmdir = rmdir;
    function unlink(path) {
        return async_1.nfcall(fs.unlink, path);
    }
    exports.unlink = unlink;
    function symlink(target, path, type) {
        return async_1.nfcall(fs.symlink, target, path, type);
    }
    exports.symlink = symlink;
    function readlink(path) {
        return async_1.nfcall(fs.readlink, path);
    }
    exports.readlink = readlink;
    function truncate(path, len) {
        return async_1.nfcall(fs.truncate, path, len);
    }
    exports.truncate = truncate;
    function readFile(path, encoding) {
        return async_1.nfcall(fs.readFile, path, encoding);
    }
    exports.readFile = readFile;
    // According to node.js docs (https://nodejs.org/docs/v6.5.0/api/fs.html#fs_fs_writefile_file_data_options_callback)
    // it is not safe to call writeFile() on the same path multiple times without waiting for the callback to return.
    // Therefor we use a Queue on the path that is given to us to sequentialize calls to the same path properly.
    var writeFilePathQueue = Object.create(null);
    function writeFile(path, data, options) {
        var queueKey = toQueueKey(path);
        return ensureWriteFileQueue(queueKey).queue(function () { return async_1.nfcall(extfs.writeFileAndFlush, path, data, options); });
    }
    exports.writeFile = writeFile;
    function toQueueKey(path) {
        var queueKey = path;
        if (platform.isWindows || platform.isMacintosh) {
            queueKey = queueKey.toLowerCase(); // accomodate for case insensitive file systems
        }
        return queueKey;
    }
    function ensureWriteFileQueue(queueKey) {
        var writeFileQueue = writeFilePathQueue[queueKey];
        if (!writeFileQueue) {
            writeFileQueue = new async_1.Queue();
            writeFilePathQueue[queueKey] = writeFileQueue;
            var onFinish = event_1.once(writeFileQueue.onFinished);
            onFinish(function () {
                delete writeFilePathQueue[queueKey];
                writeFileQueue.dispose();
            });
        }
        return writeFileQueue;
    }
    /**
    * Read a dir and return only subfolders
    */
    function readDirsInDir(dirPath) {
        return readdir(dirPath).then(function (children) {
            return winjs_base_1.TPromise.join(children.map(function (c) { return dirExists(path_1.join(dirPath, c)); })).then(function (exists) {
                return children.filter(function (_, i) { return exists[i]; });
            });
        });
    }
    exports.readDirsInDir = readDirsInDir;
    /**
    * `path` exists and is a directory
    */
    function dirExists(path) {
        return stat(path).then(function (stat) { return stat.isDirectory(); }, function () { return false; });
    }
    exports.dirExists = dirExists;
    /**
    * `path` exists and is a file.
    */
    function fileExists(path) {
        return stat(path).then(function (stat) { return stat.isFile(); }, function () { return false; });
    }
    exports.fileExists = fileExists;
    /**
     * Deletes a path from disk.
     */
    var _tmpDir = null;
    function getTmpDir() {
        if (!_tmpDir) {
            _tmpDir = os.tmpdir();
        }
        return _tmpDir;
    }
    function del(path, tmp) {
        if (tmp === void 0) { tmp = getTmpDir(); }
        return async_1.nfcall(extfs.del, path, tmp);
    }
    exports.del = del;
    function whenDeleted(path) {
        // Complete when wait marker file is deleted
        return new winjs_base_1.TPromise(function (c) {
            var running = false;
            var interval = setInterval(function () {
                if (!running) {
                    running = true;
                    fs.exists(path, function (exists) {
                        running = false;
                        if (!exists) {
                            clearInterval(interval);
                            c(null);
                        }
                    });
                }
            }, 1000);
        });
    }
    exports.whenDeleted = whenDeleted;
    function copy(source, target) {
        return async_1.nfcall(extfs.copy, source, target);
    }
    exports.copy = copy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[125/*vs/base/parts/contextmenu/common/contextmenu*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CONTEXT_MENU_CHANNEL = 'vscode:contextmenu';
    exports.CONTEXT_MENU_CLOSE_CHANNEL = 'vscode:onCloseContextMenu';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[127/*vs/base/parts/contextmenu/electron-main/contextmenu*/], __M([1/*require*/,0/*exports*/,8/*electron*/,125/*vs/base/parts/contextmenu/common/contextmenu*/]), function (require, exports, electron_1, contextmenu_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function registerContextMenuListener() {
        electron_1.ipcMain.on(contextmenu_1.CONTEXT_MENU_CHANNEL, function (event, items, onClickChannel, options) {
            var menu = createMenu(event, onClickChannel, items);
            menu.popup({
                window: electron_1.BrowserWindow.fromWebContents(event.sender),
                x: options ? options.x : void 0,
                y: options ? options.y : void 0,
                positioningItem: options ? options.positioningItem : void 0,
                callback: function () {
                    event.sender.send(contextmenu_1.CONTEXT_MENU_CLOSE_CHANNEL);
                }
            });
        });
    }
    exports.registerContextMenuListener = registerContextMenuListener;
    function createMenu(event, onClickChannel, items) {
        var menu = new electron_1.Menu();
        items.forEach(function (item) {
            var menuitem;
            // Separator
            if (item.type === 'separator') {
                menuitem = new electron_1.MenuItem({
                    type: item.type,
                });
            }
            // Sub Menu
            else if (Array.isArray(item.submenu)) {
                menuitem = new electron_1.MenuItem({
                    submenu: createMenu(event, onClickChannel, item.submenu),
                    label: item.label
                });
            }
            // Normal Menu Item
            else {
                menuitem = new electron_1.MenuItem({
                    label: item.label,
                    type: item.type,
                    accelerator: item.accelerator,
                    checked: item.checked,
                    enabled: item.enabled,
                    visible: item.visible,
                    click: function (menuItem, win, contextmenuEvent) { return event.sender.send(onClickChannel, item.id, contextmenuEvent); }
                });
            }
            menu.append(menuitem);
        });
        return menu;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[54/*vs/base/parts/ipc/node/ipc*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/lifecycle*/,5/*vs/base/common/event*/,20/*vs/base/common/async*/,35/*vs/base/common/cancellation*/,23/*vs/base/common/errors*/]), function (require, exports, lifecycle_1, event_1, async_1, cancellation_1, errors) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RequestType;
    (function (RequestType) {
        RequestType[RequestType["Promise"] = 100] = "Promise";
        RequestType[RequestType["PromiseCancel"] = 101] = "PromiseCancel";
        RequestType[RequestType["EventListen"] = 102] = "EventListen";
        RequestType[RequestType["EventDispose"] = 103] = "EventDispose";
    })(RequestType = exports.RequestType || (exports.RequestType = {}));
    var ResponseType;
    (function (ResponseType) {
        ResponseType[ResponseType["Initialize"] = 200] = "Initialize";
        ResponseType[ResponseType["PromiseSuccess"] = 201] = "PromiseSuccess";
        ResponseType[ResponseType["PromiseError"] = 202] = "PromiseError";
        ResponseType[ResponseType["PromiseErrorObj"] = 203] = "PromiseErrorObj";
        ResponseType[ResponseType["EventFire"] = 204] = "EventFire";
    })(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
    var State;
    (function (State) {
        State[State["Uninitialized"] = 0] = "Uninitialized";
        State[State["Idle"] = 1] = "Idle";
    })(State || (State = {}));
    var BodyType;
    (function (BodyType) {
        BodyType[BodyType["Undefined"] = 0] = "Undefined";
        BodyType[BodyType["String"] = 1] = "String";
        BodyType[BodyType["Buffer"] = 2] = "Buffer";
        BodyType[BodyType["Object"] = 3] = "Object";
    })(BodyType || (BodyType = {}));
    var empty = Buffer.allocUnsafe(0);
    function serializeBody(body) {
        if (typeof body === 'undefined') {
            return { buffer: empty, type: BodyType.Undefined };
        }
        else if (typeof body === 'string') {
            return { buffer: Buffer.from(body), type: BodyType.String };
        }
        else if (Buffer.isBuffer(body)) {
            return { buffer: body, type: BodyType.Buffer };
        }
        else {
            return { buffer: Buffer.from(JSON.stringify(body)), type: BodyType.Object };
        }
    }
    function serialize(header, body) {
        if (body === void 0) { body = undefined; }
        var headerSizeBuffer = Buffer.allocUnsafe(4);
        var _a = serializeBody(body), bodyBuffer = _a.buffer, bodyType = _a.type;
        var headerBuffer = Buffer.from(JSON.stringify([header, bodyType]));
        headerSizeBuffer.writeUInt32BE(headerBuffer.byteLength, 0);
        return Buffer.concat([headerSizeBuffer, headerBuffer, bodyBuffer]);
    }
    function deserializeBody(bodyBuffer, bodyType) {
        switch (bodyType) {
            case BodyType.Undefined: return undefined;
            case BodyType.String: return bodyBuffer.toString();
            case BodyType.Buffer: return bodyBuffer;
            case BodyType.Object: return JSON.parse(bodyBuffer.toString());
        }
    }
    function deserialize(buffer) {
        var headerSize = buffer.readUInt32BE(0);
        var headerBuffer = buffer.slice(4, 4 + headerSize);
        var bodyBuffer = buffer.slice(4 + headerSize);
        var _a = JSON.parse(headerBuffer.toString()), header = _a[0], bodyType = _a[1];
        var body = deserializeBody(bodyBuffer, bodyType);
        return { header: header, body: body };
    }
    var ChannelServer = /** @class */ (function () {
        function ChannelServer(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.channels = new Map();
            this.activeRequests = new Map();
            this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onRawMessage(msg); });
            this.sendResponse({ type: 200 /* Initialize */ });
        }
        ChannelServer.prototype.registerChannel = function (channelName, channel) {
            this.channels.set(channelName, channel);
        };
        ChannelServer.prototype.sendResponse = function (response) {
            switch (response.type) {
                case 200 /* Initialize */:
                    return this.sendBuffer(serialize([response.type]));
                case 201 /* PromiseSuccess */:
                case 202 /* PromiseError */:
                case 204 /* EventFire */:
                case 203 /* PromiseErrorObj */:
                    return this.sendBuffer(serialize([response.type, response.id], response.data));
            }
        };
        ChannelServer.prototype.sendBuffer = function (message) {
            try {
                this.protocol.send(message);
            }
            catch (err) {
                // noop
            }
        };
        ChannelServer.prototype.onRawMessage = function (message) {
            var _a = deserialize(message), header = _a.header, body = _a.body;
            var type = header[0];
            switch (type) {
                case 100 /* Promise */:
                    return this.onPromise({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });
                case 102 /* EventListen */:
                    return this.onEventListen({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });
                case 101 /* PromiseCancel */:
                    return this.disposeActiveRequest({ type: type, id: header[1] });
                case 103 /* EventDispose */:
                    return this.disposeActiveRequest({ type: type, id: header[1] });
            }
        };
        ChannelServer.prototype.onPromise = function (request) {
            var _this = this;
            var channel = this.channels.get(request.channelName);
            var cancellationTokenSource = new cancellation_1.CancellationTokenSource();
            var promise;
            try {
                promise = channel.call(request.name, request.arg, cancellationTokenSource.token);
            }
            catch (err) {
                promise = Promise.reject(err);
            }
            var id = request.id;
            promise.then(function (data) {
                _this.sendResponse({ id: id, data: data, type: 201 /* PromiseSuccess */ });
                _this.activeRequests.delete(request.id);
            }, function (err) {
                if (err instanceof Error) {
                    _this.sendResponse({
                        id: id, data: {
                            message: err.message,
                            name: err.name,
                            stack: err.stack ? (err.stack.split ? err.stack.split('\n') : err.stack) : void 0
                        }, type: 202 /* PromiseError */
                    });
                }
                else {
                    _this.sendResponse({ id: id, data: err, type: 203 /* PromiseErrorObj */ });
                }
                _this.activeRequests.delete(request.id);
            });
            var disposable = lifecycle_1.toDisposable(function () { return cancellationTokenSource.cancel(); });
            this.activeRequests.set(request.id, disposable);
        };
        ChannelServer.prototype.onEventListen = function (request) {
            var _this = this;
            var channel = this.channels.get(request.channelName);
            var id = request.id;
            var event = channel.listen(request.name, request.arg);
            var disposable = event(function (data) { return _this.sendResponse({ id: id, data: data, type: 204 /* EventFire */ }); });
            this.activeRequests.set(request.id, disposable);
        };
        ChannelServer.prototype.disposeActiveRequest = function (request) {
            var disposable = this.activeRequests.get(request.id);
            if (disposable) {
                disposable.dispose();
                this.activeRequests.delete(request.id);
            }
        };
        ChannelServer.prototype.dispose = function () {
            this.protocolListener.dispose();
            this.protocolListener = null;
            this.activeRequests.forEach(function (d) { return d.dispose(); });
            this.activeRequests.clear();
        };
        return ChannelServer;
    }());
    exports.ChannelServer = ChannelServer;
    var ChannelClient = /** @class */ (function () {
        function ChannelClient(protocol) {
            var _this = this;
            this.protocol = protocol;
            this.state = State.Uninitialized;
            this.activeRequests = new Set();
            this.handlers = new Map();
            this.lastRequestId = 0;
            this._onDidInitialize = new event_1.Emitter();
            this.onDidInitialize = this._onDidInitialize.event;
            this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onBuffer(msg); });
        }
        ChannelClient.prototype.getChannel = function (channelName) {
            var that = this;
            return {
                call: function (command, arg, cancellationToken) {
                    return that.requestPromise(channelName, command, arg, cancellationToken);
                },
                listen: function (event, arg) {
                    return that.requestEvent(channelName, event, arg);
                }
            };
        };
        ChannelClient.prototype.requestPromise = function (channelName, name, arg, cancellationToken) {
            var _this = this;
            if (cancellationToken === void 0) { cancellationToken = cancellation_1.CancellationToken.None; }
            var id = this.lastRequestId++;
            var type = 100 /* Promise */;
            var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };
            if (cancellationToken.isCancellationRequested) {
                return Promise.reject(errors.canceled());
            }
            var disposable;
            var result = new Promise(function (c, e) {
                if (cancellationToken.isCancellationRequested) {
                    return e(errors.canceled());
                }
                var uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });
                uninitializedPromise.then(function () {
                    uninitializedPromise = null;
                    var handler = function (response) {
                        switch (response.type) {
                            case 201 /* PromiseSuccess */:
                                _this.handlers.delete(id);
                                c(response.data);
                                break;
                            case 202 /* PromiseError */:
                                _this.handlers.delete(id);
                                var error = new Error(response.data.message);
                                error.stack = response.data.stack;
                                error.name = response.data.name;
                                e(error);
                                break;
                            case 203 /* PromiseErrorObj */:
                                _this.handlers.delete(id);
                                e(response.data);
                                break;
                        }
                    };
                    _this.handlers.set(id, handler);
                    _this.sendRequest(request);
                });
                var cancel = function () {
                    if (uninitializedPromise) {
                        uninitializedPromise.cancel();
                        uninitializedPromise = null;
                    }
                    else {
                        _this.sendRequest({ id: id, type: 101 /* PromiseCancel */ });
                    }
                    e(errors.canceled());
                };
                var cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);
                disposable = lifecycle_1.combinedDisposable([lifecycle_1.toDisposable(cancel), cancellationTokenListener]);
            });
            this.activeRequests.add(disposable);
            async_1.always(result, function () { return _this.activeRequests.delete(disposable); });
            return result;
        };
        ChannelClient.prototype.requestEvent = function (channelName, name, arg) {
            var _this = this;
            var id = this.lastRequestId++;
            var type = 102 /* EventListen */;
            var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };
            var uninitializedPromise = null;
            var emitter = new event_1.Emitter({
                onFirstListenerAdd: function () {
                    uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });
                    uninitializedPromise.then(function () {
                        uninitializedPromise = null;
                        _this.activeRequests.add(emitter);
                        _this.sendRequest(request);
                    });
                },
                onLastListenerRemove: function () {
                    if (uninitializedPromise) {
                        uninitializedPromise.cancel();
                        uninitializedPromise = null;
                    }
                    else {
                        _this.activeRequests.delete(emitter);
                        _this.sendRequest({ id: id, type: 103 /* EventDispose */ });
                    }
                }
            });
            var handler = function (res) { return emitter.fire(res.data); };
            this.handlers.set(id, handler);
            return emitter.event;
        };
        ChannelClient.prototype.sendRequest = function (request) {
            switch (request.type) {
                case 100 /* Promise */:
                case 102 /* EventListen */:
                    return this.sendBuffer(serialize([request.type, request.id, request.channelName, request.name], request.arg));
                case 101 /* PromiseCancel */:
                case 103 /* EventDispose */:
                    return this.sendBuffer(serialize([request.type, request.id]));
            }
        };
        ChannelClient.prototype.sendBuffer = function (message) {
            try {
                this.protocol.send(message);
            }
            catch (err) {
                // noop
            }
        };
        ChannelClient.prototype.onBuffer = function (message) {
            var _a = deserialize(message), header = _a.header, body = _a.body;
            var type = header[0];
            switch (type) {
                case 200 /* Initialize */:
                    return this.onResponse({ type: header[0] });
                case 201 /* PromiseSuccess */:
                case 202 /* PromiseError */:
                case 204 /* EventFire */:
                case 203 /* PromiseErrorObj */:
                    return this.onResponse({ type: header[0], id: header[1], data: body });
            }
        };
        ChannelClient.prototype.onResponse = function (response) {
            if (response.type === 200 /* Initialize */) {
                this.state = State.Idle;
                this._onDidInitialize.fire();
                return;
            }
            var handler = this.handlers.get(response.id);
            if (handler) {
                handler(response);
            }
        };
        ChannelClient.prototype.whenInitialized = function () {
            if (this.state === State.Idle) {
                return Promise.resolve(null);
            }
            else {
                return event_1.toNativePromise(this.onDidInitialize);
            }
        };
        ChannelClient.prototype.dispose = function () {
            this.protocolListener.dispose();
            this.protocolListener = null;
            this.activeRequests.forEach(function (p) { return p.dispose(); });
            this.activeRequests.clear();
        };
        return ChannelClient;
    }());
    exports.ChannelClient = ChannelClient;
    /**
     * An `IPCServer` is both a channel server and a routing channel
     * client.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCServer = /** @class */ (function () {
        function IPCServer(onDidClientConnect) {
            var _this = this;
            this.channels = new Map();
            this.channelClients = new Map();
            this.onClientAdded = new event_1.Emitter();
            onDidClientConnect(function (_a) {
                var protocol = _a.protocol, onDidClientDisconnect = _a.onDidClientDisconnect;
                var onFirstMessage = event_1.once(protocol.onMessage);
                onFirstMessage(function (rawId) {
                    var channelServer = new ChannelServer(protocol);
                    var channelClient = new ChannelClient(protocol);
                    _this.channels.forEach(function (channel, name) { return channelServer.registerChannel(name, channel); });
                    var id = rawId.toString();
                    _this.channelClients.set(id, channelClient);
                    _this.onClientAdded.fire(id);
                    onDidClientDisconnect(function () {
                        channelServer.dispose();
                        channelClient.dispose();
                        _this.channelClients.delete(id);
                    });
                });
            });
        }
        IPCServer.prototype.getChannel = function (channelName, router) {
            var that = this;
            return {
                call: function (command, arg, cancellationToken) {
                    var channelPromise = router.routeCall(command, arg)
                        .then(function (id) { return that.getClient(id); })
                        .then(function (client) { return client.getChannel(channelName); });
                    return getDelayedChannel(channelPromise)
                        .call(command, arg, cancellationToken);
                },
                listen: function (event, arg) {
                    var channelPromise = router.routeEvent(event, arg)
                        .then(function (id) { return that.getClient(id); })
                        .then(function (client) { return client.getChannel(channelName); });
                    return getDelayedChannel(channelPromise)
                        .listen(event, arg);
                }
            };
        };
        IPCServer.prototype.registerChannel = function (channelName, channel) {
            this.channels.set(channelName, channel);
        };
        IPCServer.prototype.getClient = function (clientId) {
            var _this = this;
            if (!clientId) {
                return Promise.reject(new Error('Client id should be provided'));
            }
            var client = this.channelClients.get(clientId);
            if (client) {
                return Promise.resolve(client);
            }
            return new Promise(function (c) {
                var onClient = event_1.once(event_1.filterEvent(_this.onClientAdded.event, function (id) { return id === clientId; }));
                onClient(function () { return c(_this.channelClients.get(clientId)); });
            });
        };
        IPCServer.prototype.dispose = function () {
            this.channels.clear();
            this.channelClients.clear();
            this.onClientAdded.dispose();
        };
        return IPCServer;
    }());
    exports.IPCServer = IPCServer;
    /**
     * An `IPCClient` is both a channel client and a channel server.
     *
     * As the owner of a protocol, you should extend both this
     * and the `IPCClient` classes to get IPC implementations
     * for your protocol.
     */
    var IPCClient = /** @class */ (function () {
        function IPCClient(protocol, id) {
            protocol.send(Buffer.from(id));
            this.channelClient = new ChannelClient(protocol);
            this.channelServer = new ChannelServer(protocol);
        }
        IPCClient.prototype.getChannel = function (channelName) {
            return this.channelClient.getChannel(channelName);
        };
        IPCClient.prototype.registerChannel = function (channelName, channel) {
            this.channelServer.registerChannel(channelName, channel);
        };
        IPCClient.prototype.dispose = function () {
            this.channelClient.dispose();
            this.channelClient = null;
            this.channelServer.dispose();
            this.channelServer = null;
        };
        return IPCClient;
    }());
    exports.IPCClient = IPCClient;
    function getDelayedChannel(promise) {
        return {
            call: function (command, arg, cancellationToken) {
                return promise.then(function (c) { return c.call(command, arg, cancellationToken); });
            },
            listen: function (event, arg) {
                var relay = new event_1.Relay();
                promise.then(function (c) { return relay.input = c.listen(event, arg); });
                return relay.event;
            }
        };
    }
    exports.getDelayedChannel = getDelayedChannel;
    function getNextTickChannel(channel) {
        var didTick = false;
        return {
            call: function (command, arg, cancellationToken) {
                if (didTick) {
                    return channel.call(command, arg, cancellationToken);
                }
                return async_1.timeout(0)
                    .then(function () { return didTick = true; })
                    .then(function () { return channel.call(command, arg, cancellationToken); });
            },
            listen: function (event, arg) {
                if (didTick) {
                    return channel.listen(event, arg);
                }
                var relay = new event_1.Relay();
                async_1.timeout(0)
                    .then(function () { return didTick = true; })
                    .then(function () { return relay.input = channel.listen(event, arg); });
                return relay.event;
            }
        };
    }
    exports.getNextTickChannel = getNextTickChannel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[132/*vs/base/parts/ipc/node/ipc.electron*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/lifecycle*/,5/*vs/base/common/event*/]), function (require, exports, lifecycle_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Protocol = /** @class */ (function () {
        function Protocol(sender, onMessageEvent) {
            var _this = this;
            this.sender = sender;
            this._onMessage = new event_1.Emitter();
            onMessageEvent(function (msg) { return _this._onMessage.fire(Buffer.from(msg, 'base64')); });
        }
        Object.defineProperty(Protocol.prototype, "onMessage", {
            get: function () { return this._onMessage.event; },
            enumerable: true,
            configurable: true
        });
        Protocol.prototype.send = function (message) {
            try {
                this.sender.send('ipc:message', message.toString('base64'));
            }
            catch (e) {
                // systems are going down
            }
        };
        Protocol.prototype.dispose = function () {
            this.listener = lifecycle_1.dispose(this.listener);
        };
        return Protocol;
    }());
    exports.Protocol = Protocol;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[133/*vs/base/parts/ipc/electron-main/ipc.electron-main*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/event*/,54/*vs/base/parts/ipc/node/ipc*/,132/*vs/base/parts/ipc/node/ipc.electron*/,8/*electron*/]), function (require, exports, event_1, ipc_1, ipc_electron_1, electron_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createScopedOnMessageEvent(senderId) {
        var onMessage = event_1.fromNodeEventEmitter(electron_1.ipcMain, 'ipc:message', function (event, message) { return ({ event: event, message: message }); });
        var onMessageFromSender = event_1.filterEvent(onMessage, function (_a) {
            var event = _a.event;
            return event.sender.getId() === senderId;
        });
        return event_1.mapEvent(onMessageFromSender, function (_a) {
            var message = _a.message;
            return message;
        });
    }
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server() {
            return _super.call(this, Server.getOnDidClientConnect()) || this;
        }
        Server.getOnDidClientConnect = function () {
            var onHello = event_1.fromNodeEventEmitter(electron_1.ipcMain, 'ipc:hello', function (_a) {
                var sender = _a.sender;
                return sender;
            });
            return event_1.mapEvent(onHello, function (webContents) {
                var onMessage = createScopedOnMessageEvent(webContents.getId());
                var protocol = new ipc_electron_1.Protocol(webContents, onMessage);
                var onDidClientDisconnect = event_1.fromNodeEventEmitter(webContents, 'destroyed');
                return { protocol: protocol, onDidClientDisconnect: onDidClientDisconnect };
            });
        };
        return Server;
    }(ipc_1.IPCServer));
    exports.Server = Server;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[51/*vs/base/parts/ipc/node/ipc.net*/], __M([1/*require*/,0/*exports*/,182/*net*/,5/*vs/base/common/event*/,54/*vs/base/parts/ipc/node/ipc*/,11/*path*/,26/*os*/,39/*vs/base/common/uuid*/,20/*vs/base/common/async*/]), function (require, exports, net_1, event_1, ipc_1, path_1, os_1, uuid_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function generateRandomPipeName() {
        var randomSuffix = uuid_1.generateUuid();
        if (process.platform === 'win32') {
            return "\\\\.\\pipe\\vscode-ipc-" + randomSuffix + "-sock";
        }
        else {
            // Mac/Unix: use socket file
            return path_1.join(os_1.tmpdir(), "vscode-ipc-" + randomSuffix + ".sock");
        }
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    /**
     * A message has the following format:
     *
     * 		[bodyLen|message]
     * 		[header^|data^^^]
     * 		[u32be^^|buffer^]
     */
    var Protocol = /** @class */ (function () {
        function Protocol(_socket, firstDataChunk) {
            var _this = this;
            this._socket = _socket;
            this._onMessage = new event_1.Emitter();
            this.onMessage = this._onMessage.event;
            this._onClose = new event_1.Emitter();
            this.onClose = this._onClose.event;
            this._writeBuffer = new /** @class */ (function () {
                function class_1() {
                    this._data = [];
                    this._totalLength = 0;
                }
                class_1.prototype.add = function (head, body) {
                    var wasEmpty = this._totalLength === 0;
                    this._data.push(head, body);
                    this._totalLength += head.length + body.length;
                    return wasEmpty;
                };
                class_1.prototype.take = function () {
                    var ret = Buffer.concat(this._data, this._totalLength);
                    this._data.length = 0;
                    this._totalLength = 0;
                    return ret;
                };
                return class_1;
            }());
            this._isDisposed = false;
            this._chunks = [];
            var totalLength = 0;
            var state = {
                readHead: true,
                bodyLen: -1,
            };
            var acceptChunk = function (data) {
                _this._chunks.push(data);
                totalLength += data.length;
                while (totalLength > 0) {
                    if (state.readHead) {
                        // expecting header -> read 5bytes for header
                        // information: `bodyIsJson` and `bodyLen`
                        if (totalLength >= Protocol._headerLen) {
                            var all = Buffer.concat(_this._chunks);
                            state.bodyLen = all.readUInt32BE(0);
                            state.readHead = false;
                            var rest = all.slice(Protocol._headerLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                        }
                        else {
                            break;
                        }
                    }
                    if (!state.readHead) {
                        // expecting body -> read bodyLen-bytes for
                        // the actual message or wait for more data
                        if (totalLength >= state.bodyLen) {
                            var all = Buffer.concat(_this._chunks);
                            var buffer = all.slice(0, state.bodyLen);
                            // ensure the getBuffer returns a valid value if invoked from the event listeners
                            var rest = all.slice(state.bodyLen);
                            totalLength = rest.length;
                            _this._chunks = [rest];
                            state.bodyLen = -1;
                            state.readHead = true;
                            _this._onMessage.fire(buffer);
                            if (_this._isDisposed) {
                                // check if an event listener lead to our disposal
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
            };
            var acceptFirstDataChunk = function () {
                if (firstDataChunk && firstDataChunk.length > 0) {
                    var tmp = firstDataChunk;
                    firstDataChunk = null;
                    acceptChunk(tmp);
                }
            };
            // Make sure to always handle the firstDataChunk if no more `data` event comes in
            this._firstChunkTimer = new async_1.TimeoutTimer();
            this._firstChunkTimer.setIfNotSet(function () {
                acceptFirstDataChunk();
            }, 0);
            this._socketDataListener = function (data) {
                acceptFirstDataChunk();
                acceptChunk(data);
            };
            _socket.on('data', this._socketDataListener);
            this._socketEndListener = function () {
                acceptFirstDataChunk();
            };
            _socket.on('end', this._socketEndListener);
            this._socketCloseListener = function () {
                _this._onClose.fire();
            };
            _socket.once('close', this._socketCloseListener);
        }
        Protocol.prototype.dispose = function () {
            this._isDisposed = true;
            this._firstChunkTimer.dispose();
            this._socket.removeListener('data', this._socketDataListener);
            this._socket.removeListener('end', this._socketEndListener);
            this._socket.removeListener('close', this._socketCloseListener);
        };
        Protocol.prototype.end = function () {
            this._socket.end();
        };
        Protocol.prototype.getBuffer = function () {
            return Buffer.concat(this._chunks);
        };
        Protocol.prototype.send = function (buffer) {
            var header = Buffer.allocUnsafe(Protocol._headerLen);
            header.writeUInt32BE(buffer.length, 0, true);
            this._writeSoon(header, buffer);
        };
        Protocol.prototype._writeSoon = function (header, data) {
            var _this = this;
            if (this._writeBuffer.add(header, data)) {
                setImmediate(function () {
                    // return early if socket has been destroyed in the meantime
                    if (_this._socket.destroyed) {
                        return;
                    }
                    // we ignore the returned value from `write` because we would have to cached the data
                    // anyways and nodejs is already doing that for us:
                    // > https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
                    // > However, the false return value is only advisory and the writable stream will unconditionally
                    // > accept and buffer chunk even if it has not not been allowed to drain.
                    _this._socket.write(_this._writeBuffer.take());
                });
            }
        };
        Protocol._headerLen = 4;
        return Protocol;
    }());
    exports.Protocol = Protocol;
    var Server = /** @class */ (function (_super) {
        __extends(Server, _super);
        function Server(server) {
            var _this = _super.call(this, Server.toClientConnectionEvent(server)) || this;
            _this.server = server;
            return _this;
        }
        Server.toClientConnectionEvent = function (server) {
            var onConnection = event_1.fromNodeEventEmitter(server, 'connection');
            return event_1.mapEvent(onConnection, function (socket) { return ({
                protocol: new Protocol(socket),
                onDidClientDisconnect: event_1.once(event_1.fromNodeEventEmitter(socket, 'close'))
            }); });
        };
        Server.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.server.close();
            this.server = null;
        };
        return Server;
    }(ipc_1.IPCServer));
    exports.Server = Server;
    var Client = /** @class */ (function (_super) {
        __extends(Client, _super);
        function Client(protocol, id) {
            var _this = _super.call(this, protocol, id) || this;
            _this.protocol = protocol;
            return _this;
        }
        Client.fromSocket = function (socket, id) {
            return new Client(new Protocol(socket), id);
        };
        Object.defineProperty(Client.prototype, "onClose", {
            get: function () { return this.protocol.onClose; },
            enumerable: true,
            configurable: true
        });
        Client.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.protocol.end();
        };
        return Client;
    }(ipc_1.IPCClient));
    exports.Client = Client;
    function serve(hook) {
        return new Promise(function (c, e) {
            var server = net_1.createServer();
            server.on('error', e);
            server.listen(hook, function () {
                server.removeListener('error', e);
                c(new Server(server));
            });
        });
    }
    exports.serve = serve;
    function connect(hook, clientId) {
        return new Promise(function (c, e) {
            var socket = net_1.createConnection(hook, function () {
                socket.removeListener('error', e);
                c(Client.fromSocket(socket, clientId));
            });
            socket.once('error', e);
        });
    }
    exports.connect = connect;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[59/*vs/code/electron-main/theme*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/platform*/,8/*electron*/]), function (require, exports, platform_1, electron_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_BG_LIGHT = '#FFFFFF';
    exports.DEFAULT_BG_DARK = '#1E1E1E';
    exports.DEFAULT_BG_HC_BLACK = '#000000';
    exports.THEME_STORAGE_KEY = 'theme';
    exports.THEME_BG_STORAGE_KEY = 'themeBackground';
    function getBackgroundColor(stateService) {
        if (platform_1.isWindows && electron_1.systemPreferences.isInvertedColorScheme()) {
            return exports.DEFAULT_BG_HC_BLACK;
        }
        var background = stateService.getItem(exports.THEME_BG_STORAGE_KEY, null);
        if (!background) {
            var baseTheme = void 0;
            if (platform_1.isWindows && electron_1.systemPreferences.isInvertedColorScheme()) {
                baseTheme = 'hc-black';
            }
            else {
                baseTheme = stateService.getItem(exports.THEME_STORAGE_KEY, 'vs-dark').split(' ')[0];
            }
            background = (baseTheme === 'hc-black') ? exports.DEFAULT_BG_HC_BLACK : (baseTheme === 'vs' ? exports.DEFAULT_BG_LIGHT : exports.DEFAULT_BG_DARK);
        }
        if (platform_1.isMacintosh && background.toUpperCase() === exports.DEFAULT_BG_DARK) {
            background = '#171717'; // https://github.com/electron/electron/issues/5150
        }
        return background;
    }
    exports.getBackgroundColor = getBackgroundColor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[67/*vs/code/node/paths*/], __M([1/*require*/,0/*exports*/,11/*path*/,24/*vs/base/common/arrays*/,18/*vs/base/common/strings*/,15/*vs/base/common/paths*/,3/*vs/base/common/platform*/,22/*vs/base/common/types*/,36/*vs/base/node/extfs*/]), function (require, exports, path, arrays, strings, paths, platform, types, extfs_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function validatePaths(args) {
        // Track URLs if they're going to be used
        if (args['open-url']) {
            args._urls = args._;
            args._ = [];
        }
        // Normalize paths and watch out for goto line mode
        var paths = doValidatePaths(args._, args.goto);
        // Update environment
        args._ = paths;
        args.diff = args.diff && paths.length === 2;
        return args;
    }
    exports.validatePaths = validatePaths;
    function doValidatePaths(args, gotoLineMode) {
        var cwd = process.env['VSCODE_CWD'] || process.cwd();
        var result = args.map(function (arg) {
            var pathCandidate = String(arg);
            var parsedPath;
            if (gotoLineMode) {
                parsedPath = parseLineAndColumnAware(pathCandidate);
                pathCandidate = parsedPath.path;
            }
            if (pathCandidate) {
                pathCandidate = preparePath(cwd, pathCandidate);
            }
            var sanitizedFilePath = extfs_1.sanitizeFilePath(pathCandidate, cwd);
            var basename = path.basename(sanitizedFilePath);
            if (basename /* can be empty if code is opened on root */ && !paths.isValidBasename(basename)) {
                return null; // do not allow invalid file names
            }
            if (gotoLineMode) {
                parsedPath.path = sanitizedFilePath;
                return toPath(parsedPath);
            }
            return sanitizedFilePath;
        });
        var caseInsensitive = platform.isWindows || platform.isMacintosh;
        var distinct = arrays.distinct(result, function (e) { return e && caseInsensitive ? e.toLowerCase() : e; });
        return arrays.coalesce(distinct);
    }
    function preparePath(cwd, p) {
        // Trim trailing quotes
        if (platform.isWindows) {
            p = strings.rtrim(p, '"'); // https://github.com/Microsoft/vscode/issues/1498
        }
        // Trim whitespaces
        p = strings.trim(strings.trim(p, ' '), '\t');
        if (platform.isWindows) {
            // Resolve the path against cwd if it is relative
            p = path.resolve(cwd, p);
            // Trim trailing '.' chars on Windows to prevent invalid file names
            p = strings.rtrim(p, '.');
        }
        return p;
    }
    function parseLineAndColumnAware(rawPath) {
        var segments = rawPath.split(':'); // C:\file.txt:<line>:<column>
        var path;
        var line = null;
        var column = null;
        segments.forEach(function (segment) {
            var segmentAsNumber = Number(segment);
            if (!types.isNumber(segmentAsNumber)) {
                path = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\...)
            }
            else if (line === null) {
                line = segmentAsNumber;
            }
            else if (column === null) {
                column = segmentAsNumber;
            }
        });
        if (!path) {
            throw new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');
        }
        return {
            path: path,
            line: line !== null ? line : void 0,
            column: column !== null ? column : line !== null ? 1 : void 0 // if we have a line, make sure column is also set
        };
    }
    exports.parseLineAndColumnAware = parseLineAndColumnAware;
    function toPath(p) {
        var segments = [p.path];
        if (types.isNumber(p.line)) {
            segments.push(String(p.line));
        }
        if (types.isNumber(p.column)) {
            segments.push(String(p.column));
        }
        return segments.join(':');
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[148/*vs/code/node/shellEnv*/], __M([1/*require*/,0/*exports*/,53/*child_process*/,17/*vs/base/common/objects*/,39/*vs/base/common/uuid*/,2/*vs/base/common/winjs.base*/,3/*vs/base/common/platform*/]), function (require, exports, cp, objects_1, uuid_1, winjs_base_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getUnixShellEnvironment() {
        var promise = new winjs_base_1.TPromise(function (c, e) {
            var runAsNode = process.env['ELECTRON_RUN_AS_NODE'];
            var noAttach = process.env['ELECTRON_NO_ATTACH_CONSOLE'];
            var mark = uuid_1.generateUuid().replace(/-/g, '').substr(0, 12);
            var regex = new RegExp(mark + '(.*)' + mark);
            var env = objects_1.assign({}, process.env, {
                ELECTRON_RUN_AS_NODE: '1',
                ELECTRON_NO_ATTACH_CONSOLE: '1'
            });
            var command = "'" + process.execPath + "' -p '\"" + mark + "\" + JSON.stringify(process.env) + \"" + mark + "\"'";
            var child = cp.spawn(process.env.SHELL, ['-ilc', command], {
                detached: true,
                stdio: ['ignore', 'pipe', process.stderr],
                env: env
            });
            var buffers = [];
            child.on('error', function () { return c({}); });
            child.stdout.on('data', function (b) { return buffers.push(b); });
            child.on('close', function (code, signal) {
                if (code !== 0) {
                    return e(new Error('Failed to get environment'));
                }
                var raw = Buffer.concat(buffers).toString('utf8');
                var match = regex.exec(raw);
                var rawStripped = match ? match[1] : '{}';
                try {
                    var env_1 = JSON.parse(rawStripped);
                    if (runAsNode) {
                        env_1['ELECTRON_RUN_AS_NODE'] = runAsNode;
                    }
                    else {
                        delete env_1['ELECTRON_RUN_AS_NODE'];
                    }
                    if (noAttach) {
                        env_1['ELECTRON_NO_ATTACH_CONSOLE'] = noAttach;
                    }
                    else {
                        delete env_1['ELECTRON_NO_ATTACH_CONSOLE'];
                    }
                    // https://github.com/Microsoft/vscode/issues/22593#issuecomment-336050758
                    delete env_1['XDG_RUNTIME_DIR'];
                    c(env_1);
                }
                catch (err) {
                    e(err);
                }
            });
        });
        // swallow errors
        return promise.then(null, function () { return ({}); });
    }
    var _shellEnv;
    /**
     * We need to get the environment from a user's shell.
     * This should only be done when Code itself is not launched
     * from within a shell.
     */
    function getShellEnvironment() {
        if (_shellEnv === undefined) {
            if (platform_1.isWindows) {
                _shellEnv = winjs_base_1.TPromise.as({});
            }
            else if (process.env['VSCODE_CLI'] === '1') {
                _shellEnv = winjs_base_1.TPromise.as({});
            }
            else {
                _shellEnv = getUnixShellEnvironment();
            }
        }
        return _shellEnv;
    }
    exports.getShellEnvironment = getShellEnvironment;
});

define(__m[151/*vs/nls!vs/base/common/keybindingLabels*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/base/common/keybindingLabels", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[159/*vs/base/common/keybindingLabels*/], __M([1/*require*/,0/*exports*/,151/*vs/nls!vs/base/common/keybindingLabels*/]), function (require, exports, nls) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ModifierLabelProvider = /** @class */ (function () {
        function ModifierLabelProvider(mac, windows, linux) {
            if (linux === void 0) { linux = windows; }
            this.modifierLabels = [null];
            this.modifierLabels[2 /* Macintosh */] = mac;
            this.modifierLabels[1 /* Windows */] = windows;
            this.modifierLabels[3 /* Linux */] = linux;
        }
        ModifierLabelProvider.prototype.toLabel = function (firstPartMod, firstPartKey, chordPartMod, chordPartKey, OS) {
            if (firstPartKey === null && chordPartKey === null) {
                return null;
            }
            return _asString(firstPartMod, firstPartKey, chordPartMod, chordPartKey, this.modifierLabels[OS]);
        };
        return ModifierLabelProvider;
    }());
    exports.ModifierLabelProvider = ModifierLabelProvider;
    /**
     * A label provider that prints modifiers in a suitable format for displaying in the UI.
     */
    exports.UILabelProvider = new ModifierLabelProvider({
        ctrlKey: '',
        shiftKey: '',
        altKey: '',
        metaKey: '',
        separator: '',
    }, {
        ctrlKey: nls.localize(0, null),
        shiftKey: nls.localize(1, null),
        altKey: nls.localize(2, null),
        metaKey: nls.localize(3, null),
        separator: '+',
    }, {
        ctrlKey: nls.localize(4, null),
        shiftKey: nls.localize(5, null),
        altKey: nls.localize(6, null),
        metaKey: nls.localize(7, null),
        separator: '+',
    });
    /**
     * A label provider that prints modifiers in a suitable format for ARIA.
     */
    exports.AriaLabelProvider = new ModifierLabelProvider({
        ctrlKey: nls.localize(8, null),
        shiftKey: nls.localize(9, null),
        altKey: nls.localize(10, null),
        metaKey: nls.localize(11, null),
        separator: '+',
    }, {
        ctrlKey: nls.localize(12, null),
        shiftKey: nls.localize(13, null),
        altKey: nls.localize(14, null),
        metaKey: nls.localize(15, null),
        separator: '+',
    }, {
        ctrlKey: nls.localize(16, null),
        shiftKey: nls.localize(17, null),
        altKey: nls.localize(18, null),
        metaKey: nls.localize(19, null),
        separator: '+',
    });
    /**
     * A label provider that prints modifiers in a suitable format for Electron Accelerators.
     * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
     */
    exports.ElectronAcceleratorLabelProvider = new ModifierLabelProvider({
        ctrlKey: 'Ctrl',
        shiftKey: 'Shift',
        altKey: 'Alt',
        metaKey: 'Cmd',
        separator: '+',
    }, {
        ctrlKey: 'Ctrl',
        shiftKey: 'Shift',
        altKey: 'Alt',
        metaKey: 'Super',
        separator: '+',
    });
    /**
     * A label provider that prints modifiers in a suitable format for user settings.
     */
    exports.UserSettingsLabelProvider = new ModifierLabelProvider({
        ctrlKey: 'ctrl',
        shiftKey: 'shift',
        altKey: 'alt',
        metaKey: 'cmd',
        separator: '+',
    }, {
        ctrlKey: 'ctrl',
        shiftKey: 'shift',
        altKey: 'alt',
        metaKey: 'win',
        separator: '+',
    }, {
        ctrlKey: 'ctrl',
        shiftKey: 'shift',
        altKey: 'alt',
        metaKey: 'meta',
        separator: '+',
    });
    function _simpleAsString(modifiers, key, labels) {
        if (key === null) {
            return '';
        }
        var result = [];
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if (modifiers.ctrlKey) {
            result.push(labels.ctrlKey);
        }
        if (modifiers.shiftKey) {
            result.push(labels.shiftKey);
        }
        if (modifiers.altKey) {
            result.push(labels.altKey);
        }
        if (modifiers.metaKey) {
            result.push(labels.metaKey);
        }
        // the actual key
        result.push(key);
        return result.join(labels.separator);
    }
    function _asString(firstPartMod, firstPartKey, chordPartMod, chordPartKey, labels) {
        var result = _simpleAsString(firstPartMod, firstPartKey, labels);
        if (chordPartKey !== null) {
            result += ' ';
            result += _simpleAsString(chordPartMod, chordPartKey, labels);
        }
        return result;
    }
});

define(__m[162/*vs/nls!vs/base/common/severity*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
define(__m[165/*vs/base/common/severity*/], __M([1/*require*/,0/*exports*/,162/*vs/nls!vs/base/common/severity*/,18/*vs/base/common/strings*/]), function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        var _error = 'error';
        var _warning = 'warning';
        var _warn = 'warn';
        var _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
    })(Severity || (Severity = {}));
    exports.default = Severity;
});

define(__m[166/*vs/nls!vs/code/electron-main/auth*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/code/electron-main/auth", data); });
define(__m[174/*vs/nls!vs/code/electron-main/logUploader*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/code/electron-main/logUploader", data); });

define(__m[77/*vs/nls!vs/code/electron-main/menus*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/code/electron-main/menus", data); });
define(__m[78/*vs/nls!vs/code/electron-main/window*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/code/electron-main/window", data); });
define(__m[79/*vs/nls!vs/code/electron-main/windows*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/code/electron-main/windows", data); });
define(__m[80/*vs/nls!vs/platform/configuration/common/configurationRegistry*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/configuration/common/configurationRegistry", data); });
define(__m[81/*vs/nls!vs/platform/dialogs/common/dialogs*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/dialogs/common/dialogs", data); });
define(__m[82/*vs/nls!vs/platform/dialogs/node/dialogService*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/dialogs/node/dialogService", data); });
define(__m[83/*vs/nls!vs/platform/environment/node/argv*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/environment/node/argv", data); });
define(__m[84/*vs/nls!vs/platform/extensions/node/extensionValidator*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/extensions/node/extensionValidator", data); });
define(__m[85/*vs/nls!vs/platform/history/electron-main/historyMainService*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/history/electron-main/historyMainService", data); });
define(__m[86/*vs/nls!vs/platform/issue/electron-main/issueService*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/issue/electron-main/issueService", data); });
define(__m[87/*vs/nls!vs/platform/label/common/label*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/label/common/label", data); });
define(__m[88/*vs/nls!vs/platform/menubar/electron-main/menubar*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/menubar/electron-main/menubar", data); });
define(__m[89/*vs/nls!vs/platform/request/node/request*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/request/node/request", data); });
define(__m[90/*vs/nls!vs/platform/telemetry/common/telemetryService*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/telemetry/common/telemetryService", data); });
define(__m[91/*vs/nls!vs/platform/update/node/update.config.contribution*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/update/node/update.config.contribution", data); });
define(__m[92/*vs/nls!vs/platform/windows/electron-main/windowsService*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/windows/electron-main/windowsService", data); });
define(__m[104/*vs/nls!vs/platform/workspaces/common/workspaces*/], __M([12/*vs/nls*/,10/*vs/nls!vs/code/electron-main/main*/]), function(nls, data) { return nls.create("vs/platform/workspaces/common/workspaces", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[94/*vs/platform/dialogs/node/dialogService*/], __M([1/*require*/,0/*exports*/,181/*readline*/,2/*vs/base/common/winjs.base*/,165/*vs/base/common/severity*/,82/*vs/nls!vs/platform/dialogs/node/dialogService*/,23/*vs/base/common/errors*/]), function (require, exports, readline, winjs_base_1, severity_1, nls_1, errors_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CommandLineDialogService = /** @class */ (function () {
        function CommandLineDialogService() {
        }
        CommandLineDialogService.prototype.show = function (severity, message, options) {
            var _this = this;
            var promise = new winjs_base_1.TPromise(function (c, e) {
                var rl = readline.createInterface({
                    input: process.stdin,
                    output: process.stdout,
                    terminal: true
                });
                rl.prompt();
                rl.write(_this.toQuestion(message, options));
                rl.prompt();
                rl.once('line', function (answer) {
                    rl.close();
                    c(_this.toOption(answer, options));
                });
                rl.once('SIGINT', function () {
                    rl.close();
                    e(errors_1.canceled());
                });
            });
            return promise;
        };
        CommandLineDialogService.prototype.toQuestion = function (message, options) {
            return options.reduce(function (previousValue, currentValue, currentIndex) {
                return previousValue + currentValue + '(' + currentIndex + ')' + (currentIndex < options.length - 1 ? ' | ' : '\n');
            }, message + ' ');
        };
        CommandLineDialogService.prototype.toOption = function (answer, options) {
            var value = parseInt(answer);
            if (!isNaN(value)) {
                return value;
            }
            answer = answer.toLocaleLowerCase();
            for (var i = 0; i < options.length; i++) {
                if (options[i].toLocaleLowerCase() === answer) {
                    return i;
                }
            }
            return -1;
        };
        CommandLineDialogService.prototype.confirm = function (confirmation) {
            return this.show(severity_1.default.Info, confirmation.message, [confirmation.primaryButton, confirmation.secondaryButton || nls_1.localize(0, null)]).then(function (index) {
                return {
                    confirmed: index === 0
                };
            });
        };
        return CommandLineDialogService;
    }());
    exports.CommandLineDialogService = CommandLineDialogService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
define(__m[96/*vs/platform/extensionManagement/common/extensionManagementUtil*/], __M([1/*require*/,0/*exports*/,18/*vs/base/common/strings*/]), function (require, exports, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function areSameExtensions(a, b) {
        if (a.uuid && b.uuid) {
            return a.uuid === b.uuid;
        }
        if (a.id === b.id) {
            return true;
        }
        return strings_1.compareIgnoreCase(a.id, b.id) === 0;
    }
    exports.areSameExtensions = areSameExtensions;
    function adoptToGalleryExtensionId(id) {
        return id.toLocaleLowerCase();
    }
    exports.adoptToGalleryExtensionId = adoptToGalleryExtensionId;
    function getGalleryExtensionId(publisher, name) {
        return publisher.toLocaleLowerCase() + "." + name.toLocaleLowerCase();
    }
    exports.getGalleryExtensionId = getGalleryExtensionId;
    function getGalleryExtensionIdFromLocal(local) {
        return local.manifest ? getGalleryExtensionId(local.manifest.publisher, local.manifest.name) : local.identifier.id;
    }
    exports.getGalleryExtensionIdFromLocal = getGalleryExtensionIdFromLocal;
    exports.LOCAL_EXTENSION_ID_REGEX = /^([^.]+\..+)-(\d+\.\d+\.\d+(-.*)?)$/;
    function getIdFromLocalExtensionId(localExtensionId) {
        var matches = exports.LOCAL_EXTENSION_ID_REGEX.exec(localExtensionId);
        if (matches && matches[1]) {
            return adoptToGalleryExtensionId(matches[1]);
        }
        return adoptToGalleryExtensionId(localExtensionId);
    }
    exports.getIdFromLocalExtensionId = getIdFromLocalExtensionId;
    function getLocalExtensionId(id, version) {
        return id + "-" + version;
    }
    exports.getLocalExtensionId = getLocalExtensionId;
    function groupByExtension(extensions, getExtensionIdentifier) {
        var byExtension = [];
        var findGroup = function (extension) {
            for (var _i = 0, byExtension_1 = byExtension; _i < byExtension_1.length; _i++) {
                var group = byExtension_1[_i];
                if (group.some(function (e) { return areSameExtensions(getExtensionIdentifier(e), getExtensionIdentifier(extension)); })) {
                    return group;
                }
            }
            return null;
        };
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var extension = extensions_1[_i];
            var group = findGroup(extension);
            if (group) {
                group.push(extension);
            }
            else {
                byExtension.push([extension]);
            }
        }
        return byExtension;
    }
    exports.groupByExtension = groupByExtension;
    function getLocalExtensionTelemetryData(extension) {
        return {
            id: getGalleryExtensionIdFromLocal(extension),
            name: extension.manifest.name,
            galleryId: null,
            publisherId: extension.metadata ? extension.metadata.publisherId : null,
            publisherName: extension.manifest.publisher,
            publisherDisplayName: extension.metadata ? extension.metadata.publisherDisplayName : null,
            dependencies: extension.manifest.extensionDependencies && extension.manifest.extensionDependencies.length > 0
        };
    }
    exports.getLocalExtensionTelemetryData = getLocalExtensionTelemetryData;
    /* __GDPR__FRAGMENT__
        "GalleryExtensionTelemetryData" : {
            "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "name": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "galleryId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherId": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "publisherDisplayName": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
            "dependencies": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
            "${include}": [
                "${GalleryExtensionTelemetryData2}"
            ]
        }
    */
    function getGalleryExtensionTelemetryData(extension) {
        return __assign({ id: extension.identifier.id, name: extension.name, galleryId: extension.identifier.uuid, publisherId: extension.publisherId, publisherName: extension.publisher, publisherDisplayName: extension.publisherDisplayName, dependencies: extension.properties.dependencies.length > 0 }, extension.telemetryData);
    }
    exports.getGalleryExtensionTelemetryData = getGalleryExtensionTelemetryData;
    exports.BetterMergeDisabledNowKey = 'extensions/bettermergedisablednow';
    exports.BetterMergeId = 'pprice.better-merge';
    function getMaliciousExtensionsSet(report) {
        var result = new Set();
        for (var _i = 0, report_1 = report; _i < report_1.length; _i++) {
            var extension = report_1[_i];
            if (extension.malicious) {
                result.add(extension.id.id);
            }
        }
        return result;
    }
    exports.getMaliciousExtensionsSet = getMaliciousExtensionsSet;
    var nonWorkspaceExtensions = new Set();
    function isWorkspaceExtension(manifest, configurationService) {
        var extensionId = getGalleryExtensionId(manifest.publisher, manifest.name);
        var configuredWorkspaceExtensions = configurationService.getValue('_workbench.workspaceExtensions') || [];
        if (configuredWorkspaceExtensions.length) {
            if (configuredWorkspaceExtensions.indexOf(extensionId) !== -1) {
                return true;
            }
            if (configuredWorkspaceExtensions.indexOf("-" + extensionId) !== -1) {
                return false;
            }
        }
        if (manifest.main) {
            if ((manifest.categories || []).indexOf('Workspace Extension') !== -1) {
                return true;
            }
            return !nonWorkspaceExtensions.has(extensionId);
        }
        return false;
    }
    exports.isWorkspaceExtension = isWorkspaceExtension;
});

define(__m[55/*vs/platform/instantiation/common/descriptors*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SyncDescriptor = /** @class */ (function () {
        function SyncDescriptor(ctor) {
            var _staticArguments = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                _staticArguments[_i - 1] = arguments[_i];
            }
            this.ctor = ctor;
            this.staticArguments = _staticArguments;
        }
        return SyncDescriptor;
    }());
    exports.SyncDescriptor = SyncDescriptor;
    exports.createSyncDescriptor = function (ctor) {
        var staticArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            staticArguments[_i - 1] = arguments[_i];
        }
        return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0, ctor].concat(staticArguments)))();
    };
});

define(__m[4/*vs/platform/instantiation/common/instantiation*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[57/*vs/platform/backup/common/backup*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IBackupMainService = instantiation_1.createDecorator('backupMainService');
});

define(__m[100/*vs/platform/dialogs/common/dialogs*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/,15/*vs/base/common/paths*/,81/*vs/nls!vs/platform/dialogs/common/dialogs*/]), function (require, exports, instantiation_1, paths_1, nls_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IDialogService = instantiation_1.createDecorator('dialogService');
    var MAX_CONFIRM_FILES = 10;
    function getConfirmMessage(start, resourcesToConfirm) {
        var message = [start];
        message.push('');
        message.push.apply(message, resourcesToConfirm.slice(0, MAX_CONFIRM_FILES).map(function (r) { return paths_1.basename(r.fsPath); }));
        if (resourcesToConfirm.length > MAX_CONFIRM_FILES) {
            if (resourcesToConfirm.length - MAX_CONFIRM_FILES === 1) {
                message.push(nls_1.localize(0, null));
            }
            else {
                message.push(nls_1.localize(1, null, resourcesToConfirm.length - MAX_CONFIRM_FILES));
            }
        }
        message.push('');
        return message.join('\n');
    }
    exports.getConfirmMessage = getConfirmMessage;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[101/*vs/platform/driver/node/driver*/], __M([1/*require*/,0/*exports*/,51/*vs/base/parts/ipc/node/ipc.net*/,2/*vs/base/common/winjs.base*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, ipc_net_1, winjs_base_1, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ID = 'driverService';
    exports.IDriver = instantiation_1.createDecorator(exports.ID);
    var DriverChannel = /** @class */ (function () {
        function DriverChannel(driver) {
            this.driver = driver;
        }
        DriverChannel.prototype.listen = function (event) {
            throw new Error('No event found');
        };
        DriverChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'getWindowIds': return this.driver.getWindowIds();
                case 'capturePage': return this.driver.capturePage(arg);
                case 'reloadWindow': return this.driver.reloadWindow(arg);
                case 'dispatchKeybinding': return this.driver.dispatchKeybinding(arg[0], arg[1]);
                case 'click': return this.driver.click(arg[0], arg[1], arg[2], arg[3]);
                case 'doubleClick': return this.driver.doubleClick(arg[0], arg[1]);
                case 'setValue': return this.driver.setValue(arg[0], arg[1], arg[2]);
                case 'getTitle': return this.driver.getTitle(arg[0]);
                case 'isActiveElement': return this.driver.isActiveElement(arg[0], arg[1]);
                case 'getElements': return this.driver.getElements(arg[0], arg[1], arg[2]);
                case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1], arg[2]);
                case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg[0], arg[1]);
                case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1], arg[2]);
            }
            return undefined;
        };
        return DriverChannel;
    }());
    exports.DriverChannel = DriverChannel;
    var DriverChannelClient = /** @class */ (function () {
        function DriverChannelClient(channel) {
            this.channel = channel;
        }
        DriverChannelClient.prototype.getWindowIds = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('getWindowIds'));
        };
        DriverChannelClient.prototype.capturePage = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('capturePage', windowId));
        };
        DriverChannelClient.prototype.reloadWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('reloadWindow', windowId));
        };
        DriverChannelClient.prototype.dispatchKeybinding = function (windowId, keybinding) {
            return winjs_base_1.TPromise.wrap(this.channel.call('dispatchKeybinding', [windowId, keybinding]));
        };
        DriverChannelClient.prototype.click = function (windowId, selector, xoffset, yoffset) {
            return winjs_base_1.TPromise.wrap(this.channel.call('click', [windowId, selector, xoffset, yoffset]));
        };
        DriverChannelClient.prototype.doubleClick = function (windowId, selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('doubleClick', [windowId, selector]));
        };
        DriverChannelClient.prototype.setValue = function (windowId, selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('setValue', [windowId, selector, text]));
        };
        DriverChannelClient.prototype.getTitle = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getTitle', [windowId]));
        };
        DriverChannelClient.prototype.isActiveElement = function (windowId, selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('isActiveElement', [windowId, selector]));
        };
        DriverChannelClient.prototype.getElements = function (windowId, selector, recursive) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getElements', [windowId, selector, recursive]));
        };
        DriverChannelClient.prototype.typeInEditor = function (windowId, selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('typeInEditor', [windowId, selector, text]));
        };
        DriverChannelClient.prototype.getTerminalBuffer = function (windowId, selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getTerminalBuffer', [windowId, selector]));
        };
        DriverChannelClient.prototype.writeInTerminal = function (windowId, selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('writeInTerminal', [windowId, selector, text]));
        };
        return DriverChannelClient;
    }());
    exports.DriverChannelClient = DriverChannelClient;
    var WindowDriverRegistryChannel = /** @class */ (function () {
        function WindowDriverRegistryChannel(registry) {
            this.registry = registry;
        }
        WindowDriverRegistryChannel.prototype.listen = function (event) {
            throw new Error('No event found');
        };
        WindowDriverRegistryChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'registerWindowDriver': return this.registry.registerWindowDriver(arg);
                case 'reloadWindowDriver': return this.registry.reloadWindowDriver(arg);
            }
            return undefined;
        };
        return WindowDriverRegistryChannel;
    }());
    exports.WindowDriverRegistryChannel = WindowDriverRegistryChannel;
    var WindowDriverRegistryChannelClient = /** @class */ (function () {
        function WindowDriverRegistryChannelClient(channel) {
            this.channel = channel;
        }
        WindowDriverRegistryChannelClient.prototype.registerWindowDriver = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('registerWindowDriver', windowId));
        };
        WindowDriverRegistryChannelClient.prototype.reloadWindowDriver = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('reloadWindowDriver', windowId));
        };
        return WindowDriverRegistryChannelClient;
    }());
    exports.WindowDriverRegistryChannelClient = WindowDriverRegistryChannelClient;
    var WindowDriverChannel = /** @class */ (function () {
        function WindowDriverChannel(driver) {
            this.driver = driver;
        }
        WindowDriverChannel.prototype.listen = function (event) {
            throw new Error('No event found');
        };
        WindowDriverChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'click': return this.driver.click(arg[0], arg[1], arg[2]);
                case 'doubleClick': return this.driver.doubleClick(arg);
                case 'setValue': return this.driver.setValue(arg[0], arg[1]);
                case 'getTitle': return this.driver.getTitle();
                case 'isActiveElement': return this.driver.isActiveElement(arg);
                case 'getElements': return this.driver.getElements(arg[0], arg[1]);
                case 'typeInEditor': return this.driver.typeInEditor(arg[0], arg[1]);
                case 'getTerminalBuffer': return this.driver.getTerminalBuffer(arg);
                case 'writeInTerminal': return this.driver.writeInTerminal(arg[0], arg[1]);
            }
            return undefined;
        };
        return WindowDriverChannel;
    }());
    exports.WindowDriverChannel = WindowDriverChannel;
    var WindowDriverChannelClient = /** @class */ (function () {
        function WindowDriverChannelClient(channel) {
            this.channel = channel;
        }
        WindowDriverChannelClient.prototype.click = function (selector, xoffset, yoffset) {
            return winjs_base_1.TPromise.wrap(this.channel.call('click', [selector, xoffset, yoffset]));
        };
        WindowDriverChannelClient.prototype.doubleClick = function (selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('doubleClick', selector));
        };
        WindowDriverChannelClient.prototype.setValue = function (selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('setValue', [selector, text]));
        };
        WindowDriverChannelClient.prototype.getTitle = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('getTitle'));
        };
        WindowDriverChannelClient.prototype.isActiveElement = function (selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('isActiveElement', selector));
        };
        WindowDriverChannelClient.prototype.getElements = function (selector, recursive) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getElements', [selector, recursive]));
        };
        WindowDriverChannelClient.prototype.typeInEditor = function (selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('typeInEditor', [selector, text]));
        };
        WindowDriverChannelClient.prototype.getTerminalBuffer = function (selector) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getTerminalBuffer', selector));
        };
        WindowDriverChannelClient.prototype.writeInTerminal = function (selector, text) {
            return winjs_base_1.TPromise.wrap(this.channel.call('writeInTerminal', [selector, text]));
        };
        return WindowDriverChannelClient;
    }());
    exports.WindowDriverChannelClient = WindowDriverChannelClient;
    function connect(handle) {
        return __awaiter(this, void 0, void 0, function () {
            var client, channel, driver;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, ipc_net_1.connect(handle, 'driverClient')];
                    case 1:
                        client = _a.sent();
                        channel = client.getChannel('driver');
                        driver = new DriverChannelClient(channel);
                        return [2 /*return*/, { client: client, driver: driver }];
                }
            });
        });
    }
    exports.connect = connect;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[9/*vs/platform/environment/common/environment*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IEnvironmentService = instantiation_1.createDecorator('environmentService');
});














define(__m[46/*vs/platform/files/common/files*/], __M([1/*require*/,0/*exports*/,15/*vs/base/common/paths*/,3/*vs/base/common/platform*/,4/*vs/platform/instantiation/common/instantiation*/,18/*vs/base/common/strings*/,32/*vs/base/common/resources*/,22/*vs/base/common/types*/]), function (require, exports, paths, platform_1, instantiation_1, strings_1, resources_1, types_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IFileService = instantiation_1.createDecorator('fileService');
    var FileType;
    (function (FileType) {
        FileType[FileType["Unknown"] = 0] = "Unknown";
        FileType[FileType["File"] = 1] = "File";
        FileType[FileType["Directory"] = 2] = "Directory";
        FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
    })(FileType = exports.FileType || (exports.FileType = {}));
    var FileSystemProviderCapabilities;
    (function (FileSystemProviderCapabilities) {
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileReadWrite"] = 2] = "FileReadWrite";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileOpenReadWriteClose"] = 4] = "FileOpenReadWriteClose";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["FileFolderCopy"] = 8] = "FileFolderCopy";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["PathCaseSensitive"] = 1024] = "PathCaseSensitive";
        FileSystemProviderCapabilities[FileSystemProviderCapabilities["Readonly"] = 2048] = "Readonly";
    })(FileSystemProviderCapabilities = exports.FileSystemProviderCapabilities || (exports.FileSystemProviderCapabilities = {}));
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
    })(FileOperation = exports.FileOperation || (exports.FileOperation = {}));
    var FileOperationEvent = /** @class */ (function () {
        function FileOperationEvent(_resource, _operation, _target) {
            this._resource = _resource;
            this._operation = _operation;
            this._target = _target;
        }
        Object.defineProperty(FileOperationEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "operation", {
            get: function () {
                return this._operation;
            },
            enumerable: true,
            configurable: true
        });
        return FileOperationEvent;
    }());
    exports.FileOperationEvent = FileOperationEvent;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangesEvent = /** @class */ (function () {
        function FileChangesEvent(changes) {
            this._changes = changes;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type (if provided). In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            var checkForChangeType = !types_1.isUndefinedOrNull(type);
            return this._changes.some(function (change) {
                if (checkForChangeType && change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (change.type === 2 /* DELETED */) {
                    return resources_1.isEqualOrParent(resource, change.resource, !platform_1.isLinux /* ignorecase */);
                }
                return resources_1.isEqual(resource, change.resource, !platform_1.isLinux /* ignorecase */);
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(1 /* ADDED */);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(1 /* ADDED */);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(2 /* DELETED */);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(2 /* DELETED */);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(0 /* UPDATED */);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(0 /* UPDATED */);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }());
    exports.FileChangesEvent = FileChangesEvent;
    function isParent(path, candidate, ignoreCase) {
        if (!path || !candidate || path === candidate) {
            return false;
        }
        if (candidate.length > path.length) {
            return false;
        }
        if (candidate.charAt(candidate.length - 1) !== paths.nativeSep) {
            candidate += paths.nativeSep;
        }
        if (ignoreCase) {
            return strings_1.startsWithIgnoreCase(path, candidate);
        }
        return path.indexOf(candidate) === 0;
    }
    exports.isParent = isParent;
    var StringSnapshot = /** @class */ (function () {
        function StringSnapshot(_value) {
            this._value = _value;
        }
        StringSnapshot.prototype.read = function () {
            var ret = this._value;
            this._value = null;
            return ret;
        };
        return StringSnapshot;
    }());
    exports.StringSnapshot = StringSnapshot;
    /**
     * Helper method to convert a snapshot into its full string form.
     */
    function snapshotToString(snapshot) {
        var chunks = [];
        var chunk;
        while (typeof (chunk = snapshot.read()) === 'string') {
            chunks.push(chunk);
        }
        return chunks.join('');
    }
    exports.snapshotToString = snapshotToString;
    var FileOperationError = /** @class */ (function (_super) {
        __extends(FileOperationError, _super);
        function FileOperationError(message, fileOperationResult, options) {
            var _this = _super.call(this, message) || this;
            _this.fileOperationResult = fileOperationResult;
            _this.options = options;
            return _this;
        }
        FileOperationError.isFileOperationError = function (obj) {
            return obj instanceof Error && !types_1.isUndefinedOrNull(obj.fileOperationResult);
        };
        return FileOperationError;
    }(Error));
    exports.FileOperationError = FileOperationError;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_PERMISSION_DENIED"] = 7] = "FILE_PERMISSION_DENIED";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 8] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 9] = "FILE_INVALID_PATH";
        FileOperationResult[FileOperationResult["FILE_EXCEED_MEMORY_LIMIT"] = 10] = "FILE_EXCEED_MEMORY_LIMIT";
    })(FileOperationResult = exports.FileOperationResult || (exports.FileOperationResult = {}));
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.HotExitConfiguration = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;
    exports.FILES_ASSOCIATIONS_CONFIG = 'files.associations';
    exports.FILES_EXCLUDE_CONFIG = 'files.exclude';
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        cp852: {
            labelLong: 'Central European (CP 852)',
            labelShort: 'CP 852',
            order: 18
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 19
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 20
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 21
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 22
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 23
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 24
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 25
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 26
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 27
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 28
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 29
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 30
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 31
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 32
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 33
        },
        gbk: {
            labelLong: 'Simplified Chinese (GBK)',
            labelShort: 'GBK',
            order: 34
        },
        gb18030: {
            labelLong: 'Simplified Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 35
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 36
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 37
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 38
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 39
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 40
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 41
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 42
        },
        koi8ru: {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 43
        },
        koi8t: {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 44
        },
        gb2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 45
        },
        cp865: {
            labelLong: 'Nordic DOS (CP 865)',
            labelShort: 'CP 865',
            order: 46
        },
        cp850: {
            labelLong: 'Western European DOS (CP 850)',
            labelShort: 'CP 850',
            order: 47
        }
    };
    var FileKind;
    (function (FileKind) {
        FileKind[FileKind["FILE"] = 0] = "FILE";
        FileKind[FileKind["FOLDER"] = 1] = "FOLDER";
        FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
    })(FileKind = exports.FileKind || (exports.FileKind = {}));
    exports.MIN_MAX_MEMORY_SIZE_MB = 2048;
    exports.FALLBACK_MAX_MEMORY_SIZE_MB = 4096;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[44/*vs/platform/history/common/history*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHistoryMainService = instantiation_1.createDecorator('historyMainService');
});

define(__m[61/*vs/platform/instantiation/common/serviceCollection*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ServiceCollection = /** @class */ (function () {
        function ServiceCollection() {
            var entries = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                entries[_i] = arguments[_i];
            }
            this._entries = new Map();
            for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
                var _b = entries_1[_a], id = _b[0], service = _b[1];
                this.set(id, service);
            }
        }
        ServiceCollection.prototype.set = function (id, instanceOrDescriptor) {
            var result = this._entries.get(id);
            this._entries.set(id, instanceOrDescriptor);
            return result;
        };
        ServiceCollection.prototype.forEach = function (callback) {
            this._entries.forEach(function (value, key) { return callback(key, value); });
        };
        ServiceCollection.prototype.has = function (id) {
            return this._entries.has(id);
        };
        ServiceCollection.prototype.get = function (id) {
            return this._entries.get(id);
        };
        return ServiceCollection;
    }());
    exports.ServiceCollection = ServiceCollection;
});

define(__m[106/*vs/platform/instantiation/common/instantiationService*/], __M([1/*require*/,0/*exports*/,23/*vs/base/common/errors*/,22/*vs/base/common/types*/,76/*vs/base/common/assert*/,119/*vs/base/common/graph*/,55/*vs/platform/instantiation/common/descriptors*/,4/*vs/platform/instantiation/common/instantiation*/,61/*vs/platform/instantiation/common/serviceCollection*/]), function (require, exports, errors_1, types_1, assert, graph_1, descriptors_1, instantiation_1, serviceCollection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var InstantiationService = /** @class */ (function () {
        function InstantiationService(services, strict) {
            if (services === void 0) { services = new serviceCollection_1.ServiceCollection(); }
            if (strict === void 0) { strict = false; }
            this._services = services;
            this._strict = strict;
            this._services.set(instantiation_1.IInstantiationService, this);
        }
        InstantiationService.prototype.createChild = function (services) {
            var _this = this;
            this._services.forEach(function (id, thing) {
                if (services.has(id)) {
                    return;
                }
                // If we copy descriptors we might end up with
                // multiple instances of the same service
                if (thing instanceof descriptors_1.SyncDescriptor) {
                    thing = _this._createAndCacheServiceInstance(id, thing);
                }
                services.set(id, thing);
            });
            return new InstantiationService(services, this._strict);
        };
        InstantiationService.prototype.invokeFunction = function (signature) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var accessor;
            try {
                accessor = {
                    get: function (id, isOptional) {
                        var result = _this._getOrCreateServiceInstance(id);
                        if (!result && isOptional !== instantiation_1.optional) {
                            throw new Error("[invokeFunction] unknown service '" + id + "'");
                        }
                        return result;
                    }
                };
                return signature.apply(undefined, [accessor].concat(args));
            }
            finally {
                accessor.get = function () {
                    throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');
                };
            }
        };
        InstantiationService.prototype.createInstance = function (param) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            if (param instanceof descriptors_1.SyncDescriptor) {
                // sync
                return this._createInstance(param, rest);
            }
            else {
                // sync, just ctor
                return this._createInstance(new descriptors_1.SyncDescriptor(param), rest);
            }
        };
        InstantiationService.prototype._createInstance = function (desc, args) {
            // arguments given by createInstance-call and/or the descriptor
            var staticArgs = desc.staticArguments.concat(args);
            // arguments defined by service decorators
            var serviceDependencies = instantiation_1._util.getServiceDependencies(desc.ctor).sort(function (a, b) { return a.index - b.index; });
            var serviceArgs = [];
            for (var _i = 0, serviceDependencies_1 = serviceDependencies; _i < serviceDependencies_1.length; _i++) {
                var dependency = serviceDependencies_1[_i];
                var service = this._getOrCreateServiceInstance(dependency.id);
                if (!service && this._strict && !dependency.optional) {
                    throw new Error("[createInstance] " + desc.ctor.name + " depends on UNKNOWN service " + dependency.id + ".");
                }
                serviceArgs.push(service);
            }
            var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : staticArgs.length;
            // check for argument mismatches, adjust static args if needed
            if (staticArgs.length !== firstServiceArgPos) {
                console.warn("[createInstance] First service dependency of " + desc.ctor.name + " at position " + (firstServiceArgPos + 1) + " conflicts with " + staticArgs.length + " static arguments");
                var delta = firstServiceArgPos - staticArgs.length;
                if (delta > 0) {
                    staticArgs = staticArgs.concat(new Array(delta));
                }
                else {
                    staticArgs = staticArgs.slice(0, firstServiceArgPos);
                }
            }
            // // check for missing args
            // for (let i = 0; i < serviceArgs.length; i++) {
            // 	if (!serviceArgs[i]) {
            // 		console.warn(`${desc.ctor.name} MISSES service dependency ${serviceDependencies[i].id}`, new Error().stack);
            // 	}
            // }
            // now create the instance
            var argArray = [desc.ctor];
            argArray.push.apply(argArray, staticArgs);
            argArray.push.apply(argArray, serviceArgs);
            return types_1.create.apply(null, argArray);
        };
        InstantiationService.prototype._getOrCreateServiceInstance = function (id) {
            var thing = this._services.get(id);
            if (thing instanceof descriptors_1.SyncDescriptor) {
                return this._createAndCacheServiceInstance(id, thing);
            }
            else {
                return thing;
            }
        };
        InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc) {
            assert.ok(this._services.get(id) instanceof descriptors_1.SyncDescriptor);
            var graph = new graph_1.Graph(function (data) { return data.id.toString(); });
            function throwCycleError() {
                var err = new Error('[createInstance] cyclic dependency between services');
                err.message = graph.toString();
                throw err;
            }
            var count = 0;
            var stack = [{ id: id, desc: desc }];
            while (stack.length) {
                var item = stack.pop();
                graph.lookupOrInsertNode(item);
                // TODO@joh use the graph to find a cycle
                // a weak heuristic for cycle checks
                if (count++ > 100) {
                    throwCycleError();
                }
                // check all dependencies for existence and if the need to be created first
                var dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);
                for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                    var dependency = dependencies_1[_i];
                    var instanceOrDesc = this._services.get(dependency.id);
                    if (!instanceOrDesc && !dependency.optional) {
                        console.warn("[createInstance] " + id + " depends on " + dependency.id + " which is NOT registered.");
                    }
                    if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {
                        var d = { id: dependency.id, desc: instanceOrDesc };
                        graph.insertEdge(item, d);
                        stack.push(d);
                    }
                }
            }
            while (true) {
                var roots = graph.roots();
                // if there is no more roots but still
                // nodes in the graph we have a cycle
                if (roots.length === 0) {
                    if (graph.length !== 0) {
                        throwCycleError();
                    }
                    break;
                }
                for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                    var root = roots_1[_a];
                    // create instance and overwrite the service collections
                    var instance = this._createInstance(root.data.desc, []);
                    this._services.set(root.data.id, instance);
                    graph.removeNode(root.data);
                }
            }
            return this._services.get(id);
        };
        return InstantiationService;
    }());
    exports.InstantiationService = InstantiationService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[107/*vs/platform/issue/common/issue*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IIssueService = instantiation_1.createDecorator('issueService');
    var IssueType;
    (function (IssueType) {
        IssueType[IssueType["Bug"] = 0] = "Bug";
        IssueType[IssueType["PerformanceIssue"] = 1] = "PerformanceIssue";
        IssueType[IssueType["FeatureRequest"] = 2] = "FeatureRequest";
        IssueType[IssueType["SettingsSearchIssue"] = 3] = "SettingsSearchIssue";
    })(IssueType = exports.IssueType || (exports.IssueType = {}));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[108/*vs/platform/issue/node/issueIpc*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var IssueChannel = /** @class */ (function () {
        function IssueChannel(service) {
            this.service = service;
        }
        IssueChannel.prototype.listen = function (event) {
            throw new Error('No event found');
        };
        IssueChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'openIssueReporter':
                    return this.service.openReporter(arg);
                case 'openProcessExplorer':
                    return this.service.openProcessExplorer(arg);
            }
            return undefined;
        };
        return IssueChannel;
    }());
    exports.IssueChannel = IssueChannel;
    var IssueChannelClient = /** @class */ (function () {
        function IssueChannelClient(channel) {
            this.channel = channel;
        }
        IssueChannelClient.prototype.openReporter = function (data) {
            return this.channel.call('openIssueReporter', data);
        };
        IssueChannelClient.prototype.openProcessExplorer = function (data) {
            return this.channel.call('openProcessExplorer', data);
        };
        return IssueChannelClient;
    }());
    exports.IssueChannelClient = IssueChannelClient;
});














define(__m[109/*vs/platform/keybinding/common/usLayoutResolvedKeybinding*/], __M([1/*require*/,0/*exports*/,62/*vs/base/common/keyCodes*/,159/*vs/base/common/keybindingLabels*/]), function (require, exports, keyCodes_1, keybindingLabels_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Do not instantiate. Use KeybindingService to get a ResolvedKeybinding seeded with information about the current kb layout.
     */
    var USLayoutResolvedKeybinding = /** @class */ (function (_super) {
        __extends(USLayoutResolvedKeybinding, _super);
        function USLayoutResolvedKeybinding(actual, OS) {
            var _this = _super.call(this) || this;
            _this._os = OS;
            if (actual === null) {
                throw new Error("Invalid USLayoutResolvedKeybinding");
            }
            else if (actual.type === 2 /* Chord */) {
                _this._firstPart = actual.firstPart;
                _this._chordPart = actual.chordPart;
            }
            else {
                _this._firstPart = actual;
                _this._chordPart = null;
            }
            return _this;
        }
        USLayoutResolvedKeybinding.prototype._keyCodeToUILabel = function (keyCode) {
            if (this._os === 2 /* Macintosh */) {
                switch (keyCode) {
                    case 15 /* LeftArrow */:
                        return '';
                    case 16 /* UpArrow */:
                        return '';
                    case 17 /* RightArrow */:
                        return '';
                    case 18 /* DownArrow */:
                        return '';
                }
            }
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        USLayoutResolvedKeybinding.prototype._getUILabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return this._keyCodeToUILabel(keybinding.keyCode);
        };
        USLayoutResolvedKeybinding.prototype.getLabel = function () {
            var firstPart = this._getUILabelForKeybinding(this._firstPart);
            var chordPart = this._getUILabelForKeybinding(this._chordPart);
            return keybindingLabels_1.UILabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
        };
        USLayoutResolvedKeybinding.prototype._getAriaLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return keyCodes_1.KeyCodeUtils.toString(keybinding.keyCode);
        };
        USLayoutResolvedKeybinding.prototype.getAriaLabel = function () {
            var firstPart = this._getAriaLabelForKeybinding(this._firstPart);
            var chordPart = this._getAriaLabelForKeybinding(this._chordPart);
            return keybindingLabels_1.AriaLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
        };
        USLayoutResolvedKeybinding.prototype._keyCodeToElectronAccelerator = function (keyCode) {
            if (keyCode >= 93 /* NUMPAD_0 */ && keyCode <= 108 /* NUMPAD_DIVIDE */) {
                // Electron cannot handle numpad keys
                return null;
            }
            switch (keyCode) {
                case 16 /* UpArrow */:
                    return 'Up';
                case 18 /* DownArrow */:
                    return 'Down';
                case 15 /* LeftArrow */:
                    return 'Left';
                case 17 /* RightArrow */:
                    return 'Right';
            }
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        USLayoutResolvedKeybinding.prototype._getElectronAcceleratorLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return null;
            }
            return this._keyCodeToElectronAccelerator(keybinding.keyCode);
        };
        USLayoutResolvedKeybinding.prototype.getElectronAccelerator = function () {
            if (this._chordPart !== null) {
                // Electron cannot handle chords
                return null;
            }
            var firstPart = this._getElectronAcceleratorLabelForKeybinding(this._firstPart);
            return keybindingLabels_1.ElectronAcceleratorLabelProvider.toLabel(this._firstPart, firstPart, null, null, this._os);
        };
        USLayoutResolvedKeybinding.prototype._getUserSettingsLabelForKeybinding = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            if (keybinding.isDuplicateModifierCase()) {
                return '';
            }
            return keyCodes_1.KeyCodeUtils.toUserSettingsUS(keybinding.keyCode);
        };
        USLayoutResolvedKeybinding.prototype.getUserSettingsLabel = function () {
            var firstPart = this._getUserSettingsLabelForKeybinding(this._firstPart);
            var chordPart = this._getUserSettingsLabelForKeybinding(this._chordPart);
            var result = keybindingLabels_1.UserSettingsLabelProvider.toLabel(this._firstPart, firstPart, this._chordPart, chordPart, this._os);
            return (result ? result.toLowerCase() : result);
        };
        USLayoutResolvedKeybinding.prototype.isWYSIWYG = function () {
            return true;
        };
        USLayoutResolvedKeybinding.prototype.isChord = function () {
            return (this._chordPart ? true : false);
        };
        USLayoutResolvedKeybinding.prototype.getParts = function () {
            return [
                this._toResolvedKeybindingPart(this._firstPart),
                this._toResolvedKeybindingPart(this._chordPart)
            ];
        };
        USLayoutResolvedKeybinding.prototype._toResolvedKeybindingPart = function (keybinding) {
            if (!keybinding) {
                return null;
            }
            return new keyCodes_1.ResolvedKeybindingPart(keybinding.ctrlKey, keybinding.shiftKey, keybinding.altKey, keybinding.metaKey, this._getUILabelForKeybinding(keybinding), this._getAriaLabelForKeybinding(keybinding));
        };
        USLayoutResolvedKeybinding.prototype.getDispatchParts = function () {
            var firstPart = this._firstPart ? USLayoutResolvedKeybinding.getDispatchStr(this._firstPart) : null;
            var chordPart = this._chordPart ? USLayoutResolvedKeybinding.getDispatchStr(this._chordPart) : null;
            return [firstPart, chordPart];
        };
        USLayoutResolvedKeybinding.getDispatchStr = function (keybinding) {
            if (keybinding.isModifierKey()) {
                return null;
            }
            var result = '';
            if (keybinding.ctrlKey) {
                result += 'ctrl+';
            }
            if (keybinding.shiftKey) {
                result += 'shift+';
            }
            if (keybinding.altKey) {
                result += 'alt+';
            }
            if (keybinding.metaKey) {
                result += 'meta+';
            }
            result += keyCodes_1.KeyCodeUtils.toString(keybinding.keyCode);
            return result;
        };
        return USLayoutResolvedKeybinding;
    }(keyCodes_1.ResolvedKeybinding));
    exports.USLayoutResolvedKeybinding = USLayoutResolvedKeybinding;
});

define(__m[110/*vs/platform/lifecycle/common/lifecycle*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/base/common/event*/,4/*vs/platform/instantiation/common/instantiation*/,20/*vs/base/common/async*/]), function (require, exports, winjs_base_1, event_1, instantiation_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');
    var ShutdownReason;
    (function (ShutdownReason) {
        /** Window is closed */
        ShutdownReason[ShutdownReason["CLOSE"] = 1] = "CLOSE";
        /** Application is quit */
        ShutdownReason[ShutdownReason["QUIT"] = 2] = "QUIT";
        /** Window is reloaded */
        ShutdownReason[ShutdownReason["RELOAD"] = 3] = "RELOAD";
        /** Other configuration loaded into window */
        ShutdownReason[ShutdownReason["LOAD"] = 4] = "LOAD";
    })(ShutdownReason = exports.ShutdownReason || (exports.ShutdownReason = {}));
    var StartupKind;
    (function (StartupKind) {
        StartupKind[StartupKind["NewWindow"] = 1] = "NewWindow";
        StartupKind[StartupKind["ReloadedWindow"] = 3] = "ReloadedWindow";
        StartupKind[StartupKind["ReopenedWindow"] = 4] = "ReopenedWindow";
    })(StartupKind = exports.StartupKind || (exports.StartupKind = {}));
    function StartupKindToString(startupKind) {
        switch (startupKind) {
            case 1 /* NewWindow */: return 'NewWindow';
            case 3 /* ReloadedWindow */: return 'ReloadedWindow';
            case 4 /* ReopenedWindow */: return 'ReopenedWindow';
        }
    }
    exports.StartupKindToString = StartupKindToString;
    var LifecyclePhase;
    (function (LifecyclePhase) {
        LifecyclePhase[LifecyclePhase["Starting"] = 1] = "Starting";
        LifecyclePhase[LifecyclePhase["Restoring"] = 2] = "Restoring";
        LifecyclePhase[LifecyclePhase["Running"] = 3] = "Running";
        LifecyclePhase[LifecyclePhase["Eventually"] = 4] = "Eventually";
    })(LifecyclePhase = exports.LifecyclePhase || (exports.LifecyclePhase = {}));
    function LifecyclePhaseToString(phase) {
        switch (phase) {
            case 1 /* Starting */: return 'Starting';
            case 2 /* Restoring */: return 'Restoring';
            case 3 /* Running */: return 'Running';
            case 4 /* Eventually */: return 'Eventually';
        }
    }
    exports.LifecyclePhaseToString = LifecyclePhaseToString;
    exports.NullLifecycleService = {
        _serviceBrand: null,
        phase: 3 /* Running */,
        when: function () { return Promise.resolve(); },
        startupKind: 1 /* NewWindow */,
        onWillShutdown: event_1.Event.None,
        onShutdown: event_1.Event.None
    };
    // Shared veto handling across main and renderer
    function handleVetos(vetos, onError) {
        if (vetos.length === 0) {
            return winjs_base_1.TPromise.as(false);
        }
        var promises = [];
        var lazyValue = false;
        for (var _i = 0, vetos_1 = vetos; _i < vetos_1.length; _i++) {
            var valueOrPromise = vetos_1[_i];
            // veto, done
            if (valueOrPromise === true) {
                return winjs_base_1.TPromise.as(true);
            }
            if (async_1.isThenable(valueOrPromise)) {
                promises.push(valueOrPromise.then(function (value) {
                    if (value) {
                        lazyValue = true; // veto, done
                    }
                }, function (err) {
                    onError(err); // error, treated like a veto, done
                    lazyValue = true;
                }));
            }
        }
        return winjs_base_1.TPromise.join(promises).then(function () { return lazyValue; });
    }
    exports.handleVetos = handleVetos;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[7/*vs/platform/log/common/log*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/,13/*vs/base/common/lifecycle*/,3/*vs/base/common/platform*/,5/*vs/base/common/event*/]), function (require, exports, instantiation_1, lifecycle_1, platform_1, event_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILogService = instantiation_1.createDecorator('logService');
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        LogLevel[LogLevel["Info"] = 2] = "Info";
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        LogLevel[LogLevel["Error"] = 4] = "Error";
        LogLevel[LogLevel["Critical"] = 5] = "Critical";
        LogLevel[LogLevel["Off"] = 6] = "Off";
    })(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
    exports.DEFAULT_LOG_LEVEL = LogLevel.Info;
    var AbstractLogService = /** @class */ (function (_super) {
        __extends(AbstractLogService, _super);
        function AbstractLogService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.level = exports.DEFAULT_LOG_LEVEL;
            _this._onDidChangeLogLevel = _this._register(new event_1.Emitter());
            _this.onDidChangeLogLevel = _this._onDidChangeLogLevel.event;
            return _this;
        }
        AbstractLogService.prototype.setLevel = function (level) {
            if (this.level !== level) {
                this.level = level;
                this._onDidChangeLogLevel.fire(this.level);
            }
        };
        AbstractLogService.prototype.getLevel = function () {
            return this.level;
        };
        return AbstractLogService;
    }(lifecycle_1.Disposable));
    exports.AbstractLogService = AbstractLogService;
    var ConsoleLogMainService = /** @class */ (function (_super) {
        __extends(ConsoleLogMainService, _super);
        function ConsoleLogMainService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            _this.useColors = !platform_1.isWindows;
            return _this;
        }
        ConsoleLogMainService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                if (this.useColors) {
                    console.log.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.log.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                if (this.useColors) {
                    console.warn.apply(console, ["\u001B[93m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.warn.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[91m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                if (this.useColors) {
                    console.error.apply(console, ["\u001B[90m[main " + new Date().toLocaleTimeString() + "]\u001B[0m", message].concat(args));
                }
                else {
                    console.error.apply(console, ["[main " + new Date().toLocaleTimeString() + "]", message].concat(args));
                }
            }
        };
        ConsoleLogMainService.prototype.dispose = function () {
            // noop
        };
        return ConsoleLogMainService;
    }(AbstractLogService));
    exports.ConsoleLogMainService = ConsoleLogMainService;
    var ConsoleLogService = /** @class */ (function (_super) {
        __extends(ConsoleLogService, _super);
        function ConsoleLogService(logLevel) {
            if (logLevel === void 0) { logLevel = exports.DEFAULT_LOG_LEVEL; }
            var _this = _super.call(this) || this;
            _this.setLevel(logLevel);
            return _this;
        }
        ConsoleLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Trace) {
                console.log.apply(console, ['%cTRACE', 'color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Debug) {
                console.log.apply(console, ['%cDEBUG', 'background: #eee; color: #888', message].concat(args));
            }
        };
        ConsoleLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Info) {
                console.log.apply(console, ['%c INFO', 'color: #33f', message].concat(args));
            }
        };
        ConsoleLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Warning) {
                console.log.apply(console, ['%c WARN', 'color: #993', message].concat(args));
            }
        };
        ConsoleLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Error) {
                console.log.apply(console, ['%c  ERR', 'color: #f33', message].concat(args));
            }
        };
        ConsoleLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.getLevel() <= LogLevel.Critical) {
                console.log.apply(console, ['%cCRITI', 'background: #f33; color: white', message].concat(args));
            }
        };
        ConsoleLogService.prototype.dispose = function () { };
        return ConsoleLogService;
    }(AbstractLogService));
    exports.ConsoleLogService = ConsoleLogService;
    var MultiplexLogService = /** @class */ (function (_super) {
        __extends(MultiplexLogService, _super);
        function MultiplexLogService(logServices) {
            var _this = _super.call(this) || this;
            _this.logServices = logServices;
            if (logServices.length) {
                _this.setLevel(logServices[0].getLevel());
            }
            return _this;
        }
        MultiplexLogService.prototype.setLevel = function (level) {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.setLevel(level);
            }
            _super.prototype.setLevel.call(this, level);
        };
        MultiplexLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.trace.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.debug.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.info.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.warn.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.error.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            for (var _a = 0, _b = this.logServices; _a < _b.length; _a++) {
                var logService = _b[_a];
                logService.critical.apply(logService, [message].concat(args));
            }
        };
        MultiplexLogService.prototype.dispose = function () {
            for (var _i = 0, _a = this.logServices; _i < _a.length; _i++) {
                var logService = _a[_i];
                logService.dispose();
            }
        };
        return MultiplexLogService;
    }(AbstractLogService));
    exports.MultiplexLogService = MultiplexLogService;
    var DelegatedLogService = /** @class */ (function (_super) {
        __extends(DelegatedLogService, _super);
        function DelegatedLogService(logService) {
            var _this = _super.call(this) || this;
            _this.logService = logService;
            _this._register(logService);
            return _this;
        }
        Object.defineProperty(DelegatedLogService.prototype, "onDidChangeLogLevel", {
            get: function () {
                return this.logService.onDidChangeLogLevel;
            },
            enumerable: true,
            configurable: true
        });
        DelegatedLogService.prototype.setLevel = function (level) {
            this.logService.setLevel(level);
        };
        DelegatedLogService.prototype.getLevel = function () {
            return this.logService.getLevel();
        };
        DelegatedLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).trace.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).debug.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).info.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).warn.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).error.apply(_a, [message].concat(args));
        };
        DelegatedLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = this.logService).critical.apply(_a, [message].concat(args));
        };
        return DelegatedLogService;
    }(lifecycle_1.Disposable));
    exports.DelegatedLogService = DelegatedLogService;
    var NullLogService = /** @class */ (function () {
        function NullLogService() {
            this.onDidChangeLogLevel = new event_1.Emitter().event;
        }
        NullLogService.prototype.setLevel = function (level) { };
        NullLogService.prototype.getLevel = function () { return LogLevel.Info; };
        NullLogService.prototype.trace = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.debug = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.info = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.warn = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.error = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.critical = function (message) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
        };
        NullLogService.prototype.dispose = function () { };
        return NullLogService;
    }());
    exports.NullLogService = NullLogService;
    function getLogLevel(environmentService) {
        if (environmentService.verbose) {
            return LogLevel.Trace;
        }
        if (typeof environmentService.args.log === 'string') {
            var logLevel = environmentService.args.log.toLowerCase();
            switch (logLevel) {
                case 'trace':
                    return LogLevel.Trace;
                case 'debug':
                    return LogLevel.Debug;
                case 'info':
                    return LogLevel.Info;
                case 'warn':
                    return LogLevel.Warning;
                case 'error':
                    return LogLevel.Error;
                case 'critical':
                    return LogLevel.Critical;
                case 'off':
                    return LogLevel.Off;
            }
        }
        return exports.DEFAULT_LOG_LEVEL;
    }
    exports.getLogLevel = getLogLevel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[112/*vs/platform/log/common/bufferLog*/], __M([1/*require*/,0/*exports*/,7/*vs/platform/log/common/log*/]), function (require, exports, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getLogFunction(logger, level) {
        switch (level) {
            case log_1.LogLevel.Trace: return logger.trace;
            case log_1.LogLevel.Debug: return logger.debug;
            case log_1.LogLevel.Info: return logger.info;
            case log_1.LogLevel.Warning: return logger.warn;
            case log_1.LogLevel.Error: return logger.error;
            case log_1.LogLevel.Critical: return logger.critical;
            default: throw new Error('Invalid log level');
        }
    }
    var BufferLogService = /** @class */ (function (_super) {
        __extends(BufferLogService, _super);
        function BufferLogService() {
            var _this = _super.call(this) || this;
            _this.buffer = [];
            _this._logger = undefined;
            _this._register(_this.onDidChangeLogLevel(function (level) {
                if (_this._logger) {
                    _this._logger.setLevel(level);
                }
            }));
            return _this;
        }
        Object.defineProperty(BufferLogService.prototype, "logger", {
            set: function (logger) {
                this._logger = logger;
                for (var _i = 0, _a = this.buffer; _i < _a.length; _i++) {
                    var _b = _a[_i], level = _b.level, args = _b.args;
                    var fn = getLogFunction(logger, level);
                    fn.apply(logger, args);
                }
                this.buffer = [];
            },
            enumerable: true,
            configurable: true
        });
        BufferLogService.prototype._log = function (level, args) {
            if (this._logger) {
                var fn = getLogFunction(this._logger, level);
                fn.apply(this._logger, args);
            }
            else if (this.getLevel() <= level) {
                this.buffer.push({ level: level, args: args });
            }
        };
        BufferLogService.prototype.trace = function () {
            this._log(log_1.LogLevel.Trace, arguments);
        };
        BufferLogService.prototype.debug = function () {
            this._log(log_1.LogLevel.Debug, arguments);
        };
        BufferLogService.prototype.info = function () {
            this._log(log_1.LogLevel.Info, arguments);
        };
        BufferLogService.prototype.warn = function () {
            this._log(log_1.LogLevel.Warning, arguments);
        };
        BufferLogService.prototype.error = function () {
            this._log(log_1.LogLevel.Error, arguments);
        };
        BufferLogService.prototype.critical = function () {
            this._log(log_1.LogLevel.Critical, arguments);
        };
        BufferLogService.prototype.dispose = function () {
            if (this._logger) {
                this._logger.dispose();
            }
        };
        return BufferLogService;
    }(log_1.AbstractLogService));
    exports.BufferLogService = BufferLogService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[113/*vs/platform/log/node/logIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,7/*vs/platform/log/common/log*/,5/*vs/base/common/event*/]), function (require, exports, winjs_base_1, log_1, event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LogLevelSetterChannel = /** @class */ (function () {
        function LogLevelSetterChannel(service) {
            this.service = service;
            this.onDidChangeLogLevel = event_1.buffer(service.onDidChangeLogLevel, true);
        }
        LogLevelSetterChannel.prototype.listen = function (event) {
            switch (event) {
                case 'onDidChangeLogLevel': return this.onDidChangeLogLevel;
            }
            throw new Error('No event found');
        };
        LogLevelSetterChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'setLevel':
                    this.service.setLevel(arg);
                    return winjs_base_1.TPromise.as(null);
            }
            return undefined;
        };
        return LogLevelSetterChannel;
    }());
    exports.LogLevelSetterChannel = LogLevelSetterChannel;
    var LogLevelSetterChannelClient = /** @class */ (function () {
        function LogLevelSetterChannelClient(channel) {
            this.channel = channel;
        }
        Object.defineProperty(LogLevelSetterChannelClient.prototype, "onDidChangeLogLevel", {
            get: function () {
                return this.channel.listen('onDidChangeLogLevel');
            },
            enumerable: true,
            configurable: true
        });
        LogLevelSetterChannelClient.prototype.setLevel = function (level) {
            return this.channel.call('setLevel', level);
        };
        return LogLevelSetterChannelClient;
    }());
    exports.LogLevelSetterChannelClient = LogLevelSetterChannelClient;
    var FollowerLogService = /** @class */ (function (_super) {
        __extends(FollowerLogService, _super);
        function FollowerLogService(master, logService) {
            var _this = _super.call(this, logService) || this;
            _this.master = master;
            _this._register(master.onDidChangeLogLevel(function (level) { return logService.setLevel(level); }));
            return _this;
        }
        FollowerLogService.prototype.setLevel = function (level) {
            this.master.setLevel(level);
        };
        return FollowerLogService;
    }(log_1.DelegatedLogService));
    exports.FollowerLogService = FollowerLogService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[114/*vs/platform/log/node/spdlogService*/], __M([1/*require*/,0/*exports*/,11/*path*/,7/*vs/platform/log/common/log*/]), function (require, exports, path, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createSpdLogService(processName, logLevel, logsFolder) {
        // Do not crash if spdlog cannot be loaded
        try {
            var _spdlog = require.__$__nodeRequire('spdlog');
            _spdlog.setAsyncMode(8192, 500);
            var logfilePath = path.join(logsFolder, processName + ".log");
            var logger = new _spdlog.RotatingLogger(processName, logfilePath, 1024 * 1024 * 5, 6);
            logger.setLevel(0);
            return new SpdLogService(logger, logLevel);
        }
        catch (e) {
            console.error(e);
        }
        return new log_1.NullLogService();
    }
    exports.createSpdLogService = createSpdLogService;
    function createRotatingLogger(name, filename, filesize, filecount) {
        var _spdlog = require.__$__nodeRequire('spdlog');
        return new _spdlog.RotatingLogger(name, filename, filesize, filecount);
    }
    exports.createRotatingLogger = createRotatingLogger;
    var SpdLogService = /** @class */ (function (_super) {
        __extends(SpdLogService, _super);
        function SpdLogService(logger, level) {
            if (level === void 0) { level = log_1.LogLevel.Error; }
            var _this = _super.call(this) || this;
            _this.logger = logger;
            _this.setLevel(level);
            return _this;
        }
        SpdLogService.prototype.trace = function () {
            if (this.getLevel() <= log_1.LogLevel.Trace) {
                this.logger.trace(this.format(arguments));
            }
        };
        SpdLogService.prototype.debug = function () {
            if (this.getLevel() <= log_1.LogLevel.Debug) {
                this.logger.debug(this.format(arguments));
            }
        };
        SpdLogService.prototype.info = function () {
            if (this.getLevel() <= log_1.LogLevel.Info) {
                this.logger.info(this.format(arguments));
            }
        };
        SpdLogService.prototype.warn = function () {
            if (this.getLevel() <= log_1.LogLevel.Warning) {
                this.logger.warn(this.format(arguments));
            }
        };
        SpdLogService.prototype.error = function () {
            if (this.getLevel() <= log_1.LogLevel.Error) {
                var arg = arguments[0];
                if (arg instanceof Error) {
                    var array = Array.prototype.slice.call(arguments);
                    array[0] = arg.stack;
                    this.logger.error(this.format(array));
                }
                else {
                    this.logger.error(this.format(arguments));
                }
            }
        };
        SpdLogService.prototype.critical = function () {
            if (this.getLevel() <= log_1.LogLevel.Critical) {
                this.logger.critical(this.format(arguments));
            }
        };
        SpdLogService.prototype.dispose = function () {
            this.logger.drop();
        };
        SpdLogService.prototype.format = function (args) {
            var result = '';
            for (var i = 0; i < args.length; i++) {
                var a = args[i];
                if (typeof a === 'object') {
                    try {
                        a = JSON.stringify(a);
                    }
                    catch (e) { }
                }
                result += (i > 0 ? ' ' : '') + a;
            }
            return result;
        };
        return SpdLogService;
    }(log_1.AbstractLogService));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[66/*vs/platform/menubar/common/menubar*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IMenubarService = instantiation_1.createDecorator('menubarService');
    function isMenubarMenuItemSubmenu(menuItem) {
        return menuItem.submenu !== undefined;
    }
    exports.isMenubarMenuItemSubmenu = isMenubarMenuItemSubmenu;
    function isMenubarMenuItemAction(menuItem) {
        return menuItem.checked !== undefined || menuItem.enabled !== undefined;
    }
    exports.isMenubarMenuItemAction = isMenubarMenuItemAction;
    function isMenubarMenuItemSeparator(menuItem) {
        return menuItem.id === 'vscode.menubar.separator';
    }
    exports.isMenubarMenuItemSeparator = isMenubarMenuItemSeparator;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[116/*vs/platform/menubar/node/menubarIpc*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MenubarChannel = /** @class */ (function () {
        function MenubarChannel(service) {
            this.service = service;
        }
        MenubarChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        MenubarChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'updateMenubar': return this.service.updateMenubar(arg[0], arg[1], arg[2]);
            }
            return undefined;
        };
        return MenubarChannel;
    }());
    exports.MenubarChannel = MenubarChannel;
    var MenubarChannelClient = /** @class */ (function () {
        function MenubarChannelClient(channel) {
            this.channel = channel;
        }
        MenubarChannelClient.prototype.updateMenubar = function (windowId, menus, additionalKeybindings) {
            return this.channel.call('updateMenubar', [windowId, menus, additionalKeybindings]);
        };
        return MenubarChannelClient;
    }());
    exports.MenubarChannelClient = MenubarChannelClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[50/*vs/platform/node/package*/], __M([1/*require*/,0/*exports*/,11/*path*/,45/*vs/base/common/amd*/]), function (require, exports, path, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(amd_1.getPathFromAmdModule(require, ''));
    var packageJsonPath = path.join(rootPath, 'package.json');
    exports.default = require.__$__nodeRequire(packageJsonPath);
});

define(__m[118/*vs/platform/extensions/node/extensionValidator*/], __M([1/*require*/,0/*exports*/,84/*vs/nls!vs/platform/extensions/node/extensionValidator*/,50/*vs/platform/node/package*/]), function (require, exports, nls, package_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var VERSION_REGEXP = /^(\^|>=)?((\d+)|x)\.((\d+)|x)\.((\d+)|x)(\-.*)?$/;
    function isValidVersionStr(version) {
        version = version.trim();
        return (version === '*' || VERSION_REGEXP.test(version));
    }
    exports.isValidVersionStr = isValidVersionStr;
    function parseVersion(version) {
        if (!isValidVersionStr(version)) {
            return null;
        }
        version = version.trim();
        if (version === '*') {
            return {
                hasCaret: false,
                hasGreaterEquals: false,
                majorBase: 0,
                majorMustEqual: false,
                minorBase: 0,
                minorMustEqual: false,
                patchBase: 0,
                patchMustEqual: false,
                preRelease: null
            };
        }
        var m = version.match(VERSION_REGEXP);
        return {
            hasCaret: m[1] === '^',
            hasGreaterEquals: m[1] === '>=',
            majorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),
            majorMustEqual: (m[2] === 'x' ? false : true),
            minorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),
            minorMustEqual: (m[4] === 'x' ? false : true),
            patchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),
            patchMustEqual: (m[6] === 'x' ? false : true),
            preRelease: m[8] || null
        };
    }
    exports.parseVersion = parseVersion;
    function normalizeVersion(version) {
        if (!version) {
            return null;
        }
        var majorBase = version.majorBase, majorMustEqual = version.majorMustEqual, minorBase = version.minorBase, minorMustEqual = version.minorMustEqual, patchBase = version.patchBase, patchMustEqual = version.patchMustEqual;
        if (version.hasCaret) {
            if (majorBase === 0) {
                patchMustEqual = false;
            }
            else {
                minorMustEqual = false;
                patchMustEqual = false;
            }
        }
        return {
            majorBase: majorBase,
            majorMustEqual: majorMustEqual,
            minorBase: minorBase,
            minorMustEqual: minorMustEqual,
            patchBase: patchBase,
            patchMustEqual: patchMustEqual,
            isMinimum: version.hasGreaterEquals
        };
    }
    exports.normalizeVersion = normalizeVersion;
    function isValidVersion(_version, _desiredVersion) {
        var version;
        if (typeof _version === 'string') {
            version = normalizeVersion(parseVersion(_version));
        }
        else {
            version = _version;
        }
        var desiredVersion;
        if (typeof _desiredVersion === 'string') {
            desiredVersion = normalizeVersion(parseVersion(_desiredVersion));
        }
        else {
            desiredVersion = _desiredVersion;
        }
        if (!version || !desiredVersion) {
            return false;
        }
        var majorBase = version.majorBase;
        var minorBase = version.minorBase;
        var patchBase = version.patchBase;
        var desiredMajorBase = desiredVersion.majorBase;
        var desiredMinorBase = desiredVersion.minorBase;
        var desiredPatchBase = desiredVersion.patchBase;
        var majorMustEqual = desiredVersion.majorMustEqual;
        var minorMustEqual = desiredVersion.minorMustEqual;
        var patchMustEqual = desiredVersion.patchMustEqual;
        if (desiredVersion.isMinimum) {
            if (majorBase > desiredMajorBase) {
                return true;
            }
            if (majorBase < desiredMajorBase) {
                return false;
            }
            if (minorBase > desiredMinorBase) {
                return true;
            }
            if (minorBase < desiredMinorBase) {
                return false;
            }
            return patchBase >= desiredPatchBase;
        }
        // Anything < 1.0.0 is compatible with >= 1.0.0, except exact matches
        if (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {
            desiredMajorBase = 1;
            desiredMinorBase = 0;
            desiredPatchBase = 0;
            majorMustEqual = true;
            minorMustEqual = false;
            patchMustEqual = false;
        }
        if (majorBase < desiredMajorBase) {
            // smaller major version
            return false;
        }
        if (majorBase > desiredMajorBase) {
            // higher major version
            return (!majorMustEqual);
        }
        // at this point, majorBase are equal
        if (minorBase < desiredMinorBase) {
            // smaller minor version
            return false;
        }
        if (minorBase > desiredMinorBase) {
            // higher minor version
            return (!minorMustEqual);
        }
        // at this point, minorBase are equal
        if (patchBase < desiredPatchBase) {
            // smaller patch version
            return false;
        }
        if (patchBase > desiredPatchBase) {
            // higher patch version
            return (!patchMustEqual);
        }
        // at this point, patchBase are equal
        return true;
    }
    exports.isValidVersion = isValidVersion;
    function isValidExtensionVersion(version, extensionDesc, notices) {
        if (extensionDesc.isBuiltin || typeof extensionDesc.main === 'undefined') {
            // No version check for builtin or declarative extensions
            return true;
        }
        return isVersionValid(version, extensionDesc.engines.vscode, notices);
    }
    exports.isValidExtensionVersion = isValidExtensionVersion;
    function isEngineValid(engine) {
        // TODO@joao: discuss with alex '*' doesn't seem to be a valid engine version
        return engine === '*' || isVersionValid(package_1.default.version, engine);
    }
    exports.isEngineValid = isEngineValid;
    function isVersionValid(currentVersion, requestedVersion, notices) {
        if (notices === void 0) { notices = []; }
        var desiredVersion = normalizeVersion(parseVersion(requestedVersion));
        if (!desiredVersion) {
            notices.push(nls.localize(0, null, requestedVersion));
            return false;
        }
        // enforce that a breaking API version is specified.
        // for 0.X.Y, that means up to 0.X must be specified
        // otherwise for Z.X.Y, that means Z must be specified
        if (desiredVersion.majorBase === 0) {
            // force that major and minor must be specific
            if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {
                notices.push(nls.localize(1, null, requestedVersion));
                return false;
            }
        }
        else {
            // force that major must be specific
            if (!desiredVersion.majorMustEqual) {
                notices.push(nls.localize(2, null, requestedVersion));
                return false;
            }
        }
        if (!isValidVersion(currentVersion, desiredVersion)) {
            notices.push(nls.localize(3, null, currentVersion, requestedVersion));
            return false;
        }
        return true;
    }
    exports.isVersionValid = isVersionValid;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[16/*vs/platform/node/product*/], __M([1/*require*/,0/*exports*/,11/*path*/,45/*vs/base/common/amd*/]), function (require, exports, path, amd_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rootPath = path.dirname(amd_1.getPathFromAmdModule(require, ''));
    var productJsonPath = path.join(rootPath, 'product.json');
    var product = require.__$__nodeRequire(productJsonPath);
    if (process.env['VSCODE_DEV']) {
        product.nameShort += ' Dev';
        product.nameLong += ' Dev';
        product.dataFolderName += '-dev';
    }
    exports.default = product;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[120/*vs/code/electron-main/logUploader*/], __M([1/*require*/,0/*exports*/,26/*os*/,53/*child_process*/,21/*fs*/,11/*path*/,174/*vs/nls!vs/code/electron-main/logUploader*/,2/*vs/base/common/winjs.base*/,16/*vs/platform/node/product*/,35/*vs/base/common/cancellation*/]), function (require, exports, os, cp, fs, path, nls_1, winjs_base_1, product_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var Endpoint = /** @class */ (function () {
        function Endpoint(url) {
            this.url = url;
        }
        Endpoint.getFromProduct = function () {
            var logUploaderUrl = product_1.default.logUploaderUrl;
            return logUploaderUrl ? new Endpoint(logUploaderUrl) : undefined;
        };
        return Endpoint;
    }());
    function uploadLogs(channel, requestService, environmentService) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, logsPath, outZip, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        endpoint = Endpoint.getFromProduct();
                        if (!endpoint) {
                            console.error(nls_1.localize(0, null));
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, channel.call('get-logs-path', null)];
                    case 1:
                        logsPath = _a.sent();
                        return [4 /*yield*/, promptUserToConfirmLogUpload(logsPath, environmentService)];
                    case 2:
                        if (!_a.sent()) return [3 /*break*/, 5];
                        console.log(nls_1.localize(1, null));
                        return [4 /*yield*/, zipLogs(logsPath)];
                    case 3:
                        outZip = _a.sent();
                        return [4 /*yield*/, postLogs(endpoint, outZip, requestService)];
                    case 4:
                        result = _a.sent();
                        console.log(nls_1.localize(2, null, result.blob_id));
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    }
    exports.uploadLogs = uploadLogs;
    function promptUserToConfirmLogUpload(logsPath, environmentService) {
        var confirmKey = 'iConfirmLogsUpload';
        if ((environmentService.args['upload-logs'] || '').toLowerCase() === confirmKey.toLowerCase()) {
            return true;
        }
        else {
            var message = nls_1.localize(3, null)
                + '\n\n' + nls_1.localize(4, null, logsPath)
                + '\n\n' + nls_1.localize(5, null)
                + '\n\n' + nls_1.localize(6, null, confirmKey);
            console.log(message);
            return false;
        }
    }
    function postLogs(endpoint, outZip, requestService) {
        return __awaiter(this, void 0, void 0, function () {
            var dotter, result, e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dotter = setInterval(function () { return console.log('.'); }, 5000);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, requestService.request({
                                url: endpoint.url,
                                type: 'POST',
                                data: Buffer.from(fs.readFileSync(outZip)).toString('base64'),
                                headers: {
                                    'Content-Type': 'application/zip'
                                }
                            }, cancellation_1.CancellationToken.None)];
                    case 2:
                        result = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        clearInterval(dotter);
                        console.log(nls_1.localize(7, null, e_1));
                        throw e_1;
                    case 4: return [2 /*return*/, new winjs_base_1.TPromise(function (res, reject) {
                            var parts = [];
                            result.stream.on('data', function (data) {
                                parts.push(data);
                            });
                            result.stream.on('end', function () {
                                clearInterval(dotter);
                                try {
                                    var response = Buffer.concat(parts).toString('utf-8');
                                    if (result.res.statusCode === 200) {
                                        res(JSON.parse(response));
                                    }
                                    else {
                                        var errorMessage = nls_1.localize(8, null, result.res.statusCode, response);
                                        console.log(errorMessage);
                                        reject(new Error(errorMessage));
                                    }
                                }
                                catch (e) {
                                    console.log(nls_1.localize(9, null));
                                    reject(e);
                                }
                            });
                        })];
                }
            });
        });
    }
    function zipLogs(logsPath) {
        var tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'vscode-log-upload'));
        var outZip = path.join(tempDir, 'logs.zip');
        return new winjs_base_1.TPromise(function (resolve, reject) {
            doZip(logsPath, outZip, tempDir, function (err, stdout, stderr) {
                if (err) {
                    console.error(nls_1.localize(10, null, err.message));
                    reject(err);
                }
                else {
                    resolve(outZip);
                }
            });
        });
    }
    function doZip(logsPath, outZip, tempDir, callback) {
        switch (os.platform()) {
            case 'win32':
                // Copy directory first to avoid file locking issues
                var sub = path.join(tempDir, 'sub');
                return cp.execFile('powershell', ['-Command',
                    "[System.IO.Directory]::CreateDirectory(\"" + sub + "\"); Copy-Item -recurse \"" + logsPath + "\" \"" + sub + "\"; Compress-Archive -Path \"" + sub + "\" -DestinationPath \"" + outZip + "\""], { cwd: logsPath }, callback);
            default:
                return cp.execFile('zip', ['-r', outZip, '.'], { cwd: logsPath }, callback);
        }
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[70/*vs/platform/diagnostics/electron-main/diagnosticsService*/], __M([1/*require*/,0/*exports*/,103/*vs/base/node/stats*/,99/*vs/base/node/ps*/,16/*vs/platform/node/product*/,50/*vs/platform/node/package*/,26/*os*/,64/*vs/base/node/id*/,18/*vs/base/common/strings*/,3/*vs/base/common/platform*/,8/*electron*/,11/*path*/,6/*vs/base/common/uri*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, stats_1, ps_1, product_1, package_1, os, id_1, strings_1, platform_1, electron_1, path_1, uri_1, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ID = 'diagnosticsService';
    exports.IDiagnosticsService = instantiation_1.createDecorator(exports.ID);
    var DiagnosticsService = /** @class */ (function () {
        function DiagnosticsService() {
        }
        DiagnosticsService.prototype.formatEnvironment = function (info) {
            var MB = 1024 * 1024;
            var GB = 1024 * MB;
            var output = [];
            output.push("Version:          " + package_1.default.name + " " + package_1.default.version + " (" + (product_1.default.commit || 'Commit unknown') + ", " + (product_1.default.date || 'Date unknown') + ")");
            output.push("OS Version:       " + os.type() + " " + os.arch() + " " + os.release());
            var cpus = os.cpus();
            if (cpus && cpus.length > 0) {
                output.push("CPUs:             " + cpus[0].model + " (" + cpus.length + " x " + cpus[0].speed + ")");
            }
            output.push("Memory (System):  " + (os.totalmem() / GB).toFixed(2) + "GB (" + (os.freemem() / GB).toFixed(2) + "GB free)");
            if (!platform_1.isWindows) {
                output.push("Load (avg):       " + os.loadavg().map(function (l) { return Math.round(l); }).join(', ')); // only provided on Linux/macOS
            }
            output.push("VM:               " + Math.round((id_1.virtualMachineHint.value() * 100)) + "%");
            output.push("Screen Reader:    " + (electron_1.app.isAccessibilitySupportEnabled() ? 'yes' : 'no'));
            output.push("Process Argv:     " + info.mainArguments.join(' '));
            output.push("GPU Status:       " + this.expandGPUFeatures());
            return output.join('\n');
        };
        DiagnosticsService.prototype.getPerformanceInfo = function (info) {
            var _this = this;
            return ps_1.listProcesses(info.mainPID).then(function (rootProcess) {
                var workspaceInfoMessages = [];
                // Workspace Stats
                var workspaceStatPromises = [];
                if (info.windows.some(function (window) { return window.folderURIs && window.folderURIs.length > 0; })) {
                    info.windows.forEach(function (window) {
                        if (window.folderURIs.length === 0) {
                            return;
                        }
                        workspaceInfoMessages.push("|  Window (" + window.title + ")");
                        window.folderURIs.forEach(function (uriComponents) {
                            var folderUri = uri_1.URI.revive(uriComponents);
                            if (folderUri.scheme === 'file') {
                                var folder_1 = folderUri.fsPath;
                                workspaceStatPromises.push(stats_1.collectWorkspaceStats(folder_1, ['node_modules', '.git']).then(function (stats) { return __awaiter(_this, void 0, void 0, function () {
                                    var countMessage, launchConfigs;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                countMessage = stats.fileCount + " files";
                                                if (stats.maxFilesReached) {
                                                    countMessage = "more than " + countMessage;
                                                }
                                                workspaceInfoMessages.push("|    Folder (" + path_1.basename(folder_1) + "): " + countMessage);
                                                workspaceInfoMessages.push(this.formatWorkspaceStats(stats));
                                                return [4 /*yield*/, stats_1.collectLaunchConfigs(folder_1)];
                                            case 1:
                                                launchConfigs = _a.sent();
                                                if (launchConfigs.length > 0) {
                                                    workspaceInfoMessages.push(this.formatLaunchConfigs(launchConfigs));
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }));
                            }
                            else {
                                workspaceInfoMessages.push("|    Folder (" + folderUri.toString() + "): RPerformance stats not available.");
                            }
                        });
                    });
                }
                return Promise.all(workspaceStatPromises).then(function () {
                    return {
                        processInfo: _this.formatProcessList(info, rootProcess),
                        workspaceInfo: workspaceInfoMessages.join('\n')
                    };
                }).catch(function (error) {
                    return {
                        processInfo: _this.formatProcessList(info, rootProcess),
                        workspaceInfo: "Unable to calculate workspace stats: " + error
                    };
                });
            });
        };
        DiagnosticsService.prototype.getSystemInfo = function (info) {
            var MB = 1024 * 1024;
            var GB = 1024 * MB;
            var systemInfo = {
                'Memory (System)': (os.totalmem() / GB).toFixed(2) + "GB (" + (os.freemem() / GB).toFixed(2) + "GB free)",
                VM: Math.round((id_1.virtualMachineHint.value() * 100)) + "%",
                'Screen Reader': "" + (electron_1.app.isAccessibilitySupportEnabled() ? 'yes' : 'no'),
                'Process Argv': "" + info.mainArguments.join(' '),
                'GPU Status': electron_1.app.getGPUFeatureStatus()
            };
            var cpus = os.cpus();
            if (cpus && cpus.length > 0) {
                systemInfo.CPUs = cpus[0].model + " (" + cpus.length + " x " + cpus[0].speed + ")";
            }
            if (!platform_1.isWindows) {
                systemInfo['Load (avg)'] = "" + os.loadavg().map(function (l) { return Math.round(l); }).join(', ');
            }
            return systemInfo;
        };
        DiagnosticsService.prototype.printDiagnostics = function (info) {
            var _this = this;
            return ps_1.listProcesses(info.mainPID).then(function (rootProcess) {
                // Environment Info
                console.log('');
                console.log(_this.formatEnvironment(info));
                // Process List
                console.log('');
                console.log(_this.formatProcessList(info, rootProcess));
                // Workspace Stats
                var workspaceStatPromises = [];
                if (info.windows.some(function (window) { return window.folderURIs && window.folderURIs.length > 0; })) {
                    console.log('');
                    console.log('Workspace Stats: ');
                    info.windows.forEach(function (window) {
                        if (window.folderURIs.length === 0) {
                            return;
                        }
                        console.log("|  Window (" + window.title + ")");
                        window.folderURIs.forEach(function (uriComponents) {
                            var folderUri = uri_1.URI.revive(uriComponents);
                            if (folderUri.scheme === 'file') {
                                var folder_2 = folderUri.fsPath;
                                workspaceStatPromises.push(stats_1.collectWorkspaceStats(folder_2, ['node_modules', '.git']).then(function (stats) { return __awaiter(_this, void 0, void 0, function () {
                                    var countMessage;
                                    var _this = this;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                countMessage = stats.fileCount + " files";
                                                if (stats.maxFilesReached) {
                                                    countMessage = "more than " + countMessage;
                                                }
                                                console.log("|    Folder (" + path_1.basename(folder_2) + "): " + countMessage);
                                                console.log(this.formatWorkspaceStats(stats));
                                                return [4 /*yield*/, stats_1.collectLaunchConfigs(folder_2).then(function (launchConfigs) {
                                                        if (launchConfigs.length > 0) {
                                                            console.log(_this.formatLaunchConfigs(launchConfigs));
                                                        }
                                                    })];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                }); }).catch(function (error) {
                                    console.log("|      Error: Unable to collect workspace stats for folder " + folder_2 + " (" + error.toString() + ")");
                                }));
                            }
                            else {
                                console.log("|    Folder (" + folderUri.toString() + "): Workspace stats not available.");
                            }
                        });
                    });
                }
                return Promise.all(workspaceStatPromises).then(function () {
                    console.log('');
                    console.log('');
                });
            });
        };
        DiagnosticsService.prototype.formatWorkspaceStats = function (workspaceStats) {
            var output = [];
            var lineLength = 60;
            var col = 0;
            var appendAndWrap = function (name, count) {
                var item = " " + name + "(" + count + ")";
                if (col + item.length > lineLength) {
                    output.push(line);
                    line = '|                 ';
                    col = line.length;
                }
                else {
                    col += item.length;
                }
                line += item;
            };
            // File Types
            var line = '|      File types:';
            var maxShown = 10;
            var max = workspaceStats.fileTypes.length > maxShown ? maxShown : workspaceStats.fileTypes.length;
            for (var i = 0; i < max; i++) {
                var item = workspaceStats.fileTypes[i];
                appendAndWrap(item.name, item.count);
            }
            output.push(line);
            // Conf Files
            if (workspaceStats.configFiles.length >= 0) {
                line = '|      Conf files:';
                col = 0;
                workspaceStats.configFiles.forEach(function (item) {
                    appendAndWrap(item.name, item.count);
                });
                output.push(line);
            }
            return output.join('\n');
        };
        DiagnosticsService.prototype.formatLaunchConfigs = function (configs) {
            var output = [];
            var line = '|      Launch Configs:';
            configs.forEach(function (each) {
                var item = each.count > 1 ? " " + each.name + "(" + each.count + ")" : " " + each.name;
                line += item;
            });
            output.push(line);
            return output.join('\n');
        };
        DiagnosticsService.prototype.expandGPUFeatures = function () {
            var gpuFeatures = electron_1.app.getGPUFeatureStatus();
            var longestFeatureName = Math.max.apply(Math, Object.keys(gpuFeatures).map(function (feature) { return feature.length; }));
            // Make columns aligned by adding spaces after feature name
            return Object.keys(gpuFeatures).map(function (feature) { return feature + ":  " + strings_1.repeat(' ', longestFeatureName - feature.length) + "  " + gpuFeatures[feature]; }).join('\n                  ');
        };
        DiagnosticsService.prototype.formatProcessList = function (info, rootProcess) {
            var mapPidToWindowTitle = new Map();
            info.windows.forEach(function (window) { return mapPidToWindowTitle.set(window.pid, window.title); });
            var output = [];
            output.push('CPU %\tMem MB\t   PID\tProcess');
            if (rootProcess) {
                this.formatProcessItem(mapPidToWindowTitle, output, rootProcess, 0);
            }
            return output.join('\n');
        };
        DiagnosticsService.prototype.formatProcessItem = function (mapPidToWindowTitle, output, item, indent) {
            var _this = this;
            var isRoot = (indent === 0);
            var MB = 1024 * 1024;
            // Format name with indent
            var name;
            if (isRoot) {
                name = product_1.default.applicationName + " main";
            }
            else {
                name = strings_1.repeat('  ', indent) + " " + item.name;
                if (item.name === 'window') {
                    name = name + " (" + mapPidToWindowTitle.get(item.pid) + ")";
                }
            }
            var memory = process.platform === 'win32' ? item.mem : (os.totalmem() * (item.mem / 100));
            output.push(strings_1.pad(Number(item.load.toFixed(0)), 5, ' ') + "\t" + strings_1.pad(Number((memory / MB).toFixed(0)), 6, ' ') + "\t" + strings_1.pad(Number((item.pid).toFixed(0)), 6, ' ') + "\t" + name);
            // Recurse into children if any
            if (Array.isArray(item.children)) {
                item.children.forEach(function (child) { return _this.formatProcessItem(mapPidToWindowTitle, output, child, indent + 1); });
            }
        };
        return DiagnosticsService;
    }());
    exports.DiagnosticsService = DiagnosticsService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[41/*vs/platform/environment/node/argv*/], __M([1/*require*/,0/*exports*/,26/*os*/,180/*minimist*/,143/*assert*/,24/*vs/base/common/arrays*/,83/*vs/nls!vs/platform/environment/node/argv*/,3/*vs/base/common/platform*/,16/*vs/platform/node/product*/,46/*vs/platform/files/common/files*/]), function (require, exports, os, minimist, assert, arrays_1, nls_1, platform_1, product_1, files_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var options = {
        string: [
            'locale',
            'user-data-dir',
            'extensions-dir',
            'folder-uri',
            'file-uri',
            'extensionDevelopmentPath',
            'extensionTestsPath',
            'install-extension',
            'disable-extension',
            'uninstall-extension',
            'debugId',
            'debugPluginHost',
            'debugBrkPluginHost',
            'debugSearch',
            'debugBrkSearch',
            'enable-proposed-api',
            'export-default-configuration',
            'install-source',
            'upload-logs',
            'driver'
        ],
        boolean: [
            'help',
            'version',
            'wait',
            'diff',
            'add',
            'goto',
            'new-window',
            'unity-launch',
            'reuse-window',
            'open-url',
            'performance',
            'prof-startup',
            'verbose',
            'logExtensionHostCommunication',
            'disable-extensions',
            'list-extensions',
            'show-versions',
            'nolazy',
            'issue',
            'skip-getting-started',
            'skip-release-notes',
            'sticky-quickopen',
            'disable-restore-windows',
            'disable-telemetry',
            'disable-updates',
            'disable-crash-reporter',
            'skip-add-to-recently-opened',
            'status',
            'file-write',
            'file-chmod',
            'driver-verbose'
        ],
        alias: {
            add: 'a',
            help: 'h',
            version: 'v',
            wait: 'w',
            diff: 'd',
            goto: 'g',
            status: 's',
            'new-window': 'n',
            'reuse-window': 'r',
            performance: 'p',
            'disable-extensions': 'disableExtensions',
            'extensions-dir': 'extensionHomePath',
            'debugPluginHost': 'inspect-extensions',
            'debugBrkPluginHost': 'inspect-brk-extensions',
            'debugSearch': 'inspect-search',
            'debugBrkSearch': 'inspect-brk-search',
        }
    };
    function validate(args) {
        if (args.goto) {
            args._.forEach(function (arg) { return assert(/^(\w:)?[^:]+(:\d*){0,2}$/.test(arg), nls_1.localize(0, null)); });
        }
        if (args['max-memory']) {
            assert(args['max-memory'] >= files_1.MIN_MAX_MEMORY_SIZE_MB, "The max-memory argument cannot be specified lower than " + files_1.MIN_MAX_MEMORY_SIZE_MB + " MB.");
        }
        return args;
    }
    function stripAppPath(argv) {
        var index = arrays_1.firstIndex(argv, function (a) { return !/^-/.test(a); });
        if (index > -1) {
            return argv.slice(0, index).concat(argv.slice(index + 1));
        }
        return undefined;
    }
    /**
     * Use this to parse raw code process.argv such as: `Electron . --verbose --wait`
     */
    function parseMainProcessArgv(processArgv) {
        var args = processArgv.slice(1);
        // If dev, remove the first non-option argument: it's the app location
        if (process.env['VSCODE_DEV']) {
            args = stripAppPath(args);
        }
        return validate(parseArgs(args));
    }
    exports.parseMainProcessArgv = parseMainProcessArgv;
    /**
     * Use this to parse raw code CLI process.argv such as: `Electron cli.js . --verbose --wait`
     */
    function parseCLIProcessArgv(processArgv) {
        var args = processArgv.slice(2);
        if (process.env['VSCODE_DEV']) {
            args = stripAppPath(args);
        }
        return validate(parseArgs(args));
    }
    exports.parseCLIProcessArgv = parseCLIProcessArgv;
    /**
     * Use this to parse code arguments such as `--verbose --wait`
     */
    function parseArgs(args) {
        return minimist(args, options);
    }
    exports.parseArgs = parseArgs;
    var optionsHelp = {
        '-d, --diff <file> <file>': nls_1.localize(1, null),
        '-a, --add <dir>': nls_1.localize(2, null),
        '-g, --goto <file:line[:character]>': nls_1.localize(3, null),
        '-n, --new-window': nls_1.localize(4, null),
        '-r, --reuse-window': nls_1.localize(5, null),
        '-w, --wait': nls_1.localize(6, null),
        '--locale <locale>': nls_1.localize(7, null),
        '--user-data-dir <dir>': nls_1.localize(8, null),
        '-v, --version': nls_1.localize(9, null),
        '-h, --help': nls_1.localize(10, null)
    };
    var extensionsHelp = {
        '--extensions-dir <dir>': nls_1.localize(11, null),
        '--list-extensions': nls_1.localize(12, null),
        '--show-versions': nls_1.localize(13, null),
        '--install-extension (<extension-id> | <extension-vsix-path>)': nls_1.localize(14, null),
        '--uninstall-extension (<extension-id> | <extension-vsix-path>)': nls_1.localize(15, null),
        '--enable-proposed-api (<extension-id>)': nls_1.localize(16, null)
    };
    var troubleshootingHelp = {
        '--verbose': nls_1.localize(17, null),
        '--log <level>': nls_1.localize(18, null),
        '-s, --status': nls_1.localize(19, null),
        '-p, --performance': nls_1.localize(20, null),
        '--prof-startup': nls_1.localize(21, null),
        '--disable-extensions': nls_1.localize(22, null),
        '--disable-extension <extension-id>': nls_1.localize(23, null),
        '--inspect-extensions': nls_1.localize(24, null),
        '--inspect-brk-extensions': nls_1.localize(25, null),
        '--disable-gpu': nls_1.localize(26, null),
        '--upload-logs': nls_1.localize(27, null),
        '--max-memory': nls_1.localize(28, null)
    };
    function formatOptions(options, columns) {
        var keys = Object.keys(options);
        var argLength = Math.max.apply(null, keys.map(function (k) { return k.length; })) + 2 /*left padding*/ + 1 /*right padding*/;
        if (columns - argLength < 25) {
            // Use a condensed version on narrow terminals
            return keys.reduce(function (r, key) { return r.concat(["  " + key, "      " + options[key]]); }, []).join('\n');
        }
        var descriptionColumns = columns - argLength - 1;
        var result = '';
        keys.forEach(function (k) {
            var wrappedDescription = wrapText(options[k], descriptionColumns);
            var keyPadding = ' '.repeat(argLength - k.length - 2 /*left padding*/);
            if (result.length > 0) {
                result += '\n';
            }
            result += '  ' + k + keyPadding + wrappedDescription[0];
            for (var i = 1; i < wrappedDescription.length; i++) {
                result += '\n' + ' '.repeat(argLength) + wrappedDescription[i];
            }
        });
        return result;
    }
    exports.formatOptions = formatOptions;
    function wrapText(text, columns) {
        var lines = [];
        while (text.length) {
            var index = text.length < columns ? text.length : text.lastIndexOf(' ', columns);
            var line = text.slice(0, index).trim();
            text = text.slice(index);
            lines.push(line);
        }
        return lines;
    }
    function buildHelpMessage(fullName, name, version) {
        var columns = process.stdout.isTTY ? process.stdout.columns : 80;
        var executable = "" + name + (os.platform() === 'win32' ? '.exe' : '');
        return fullName + " " + version + "\n\n" + nls_1.localize(29, null) + ": " + executable + " [" + nls_1.localize(30, null) + "] [" + nls_1.localize(31, null) + "...]\n\n" + (platform_1.isWindows ? nls_1.localize(32, null, product_1.default.applicationName) : nls_1.localize(33, null, product_1.default.applicationName)) + "\n\n" + nls_1.localize(34, null) + ":\n" + formatOptions(optionsHelp, columns) + "\n\n" + nls_1.localize(35, null) + ":\n" + formatOptions(extensionsHelp, columns) + "\n\n" + nls_1.localize(36, null) + ":\n" + formatOptions(troubleshootingHelp, columns);
    }
    exports.buildHelpMessage = buildHelpMessage;
    /**
     * Converts an argument into an array
     * @param arg a argument value. Can be undefined, an entry or an array
     */
    function asArray(arg) {
        if (arg) {
            if (Array.isArray(arg)) {
                return arg;
            }
            return [arg];
        }
        return [];
    }
    exports.asArray = asArray;
    /**
     * Returns whether an argument is present.
     */
    function hasArgs(arg) {
        if (arg) {
            if (Array.isArray(arg)) {
                return !!arg.length;
            }
            return true;
        }
        return false;
    }
    exports.hasArgs = hasArgs;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define(__m[124/*vs/platform/environment/node/environmentService*/], __M([1/*require*/,0/*exports*/,58/*crypto*/,93/*vs/base/node/paths*/,26/*os*/,11/*path*/,52/*vs/base/common/decorators*/,50/*vs/platform/node/package*/,16/*vs/platform/node/product*/,154/*vs/base/common/date*/,3/*vs/base/common/platform*/,45/*vs/base/common/amd*/,6/*vs/base/common/uri*/]), function (require, exports, crypto, paths, os, path, decorators_1, package_1, product_1, date_1, platform_1, amd_1, uri_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Read this before there's any chance it is overwritten
    // Related to https://github.com/Microsoft/vscode/issues/30624
    var xdgRuntimeDir = process.env['XDG_RUNTIME_DIR'];
    function getNixIPCHandle(userDataPath, type) {
        if (xdgRuntimeDir) {
            var scope = crypto.createHash('md5').update(userDataPath).digest('hex').substr(0, 8);
            return path.join(xdgRuntimeDir, "vscode-" + scope + "-" + package_1.default.version + "-" + type + ".sock");
        }
        return path.join(userDataPath, package_1.default.version + "-" + type + ".sock");
    }
    function getWin32IPCHandle(userDataPath, type) {
        var scope = crypto.createHash('md5').update(userDataPath).digest('hex');
        return "\\\\.\\pipe\\" + scope + "-" + package_1.default.version + "-" + type + "-sock";
    }
    function getIPCHandle(userDataPath, type) {
        if (platform_1.isWindows) {
            return getWin32IPCHandle(userDataPath, type);
        }
        return getNixIPCHandle(userDataPath, type);
    }
    function getCLIPath(execPath, appRoot, isBuilt) {
        // Windows
        if (platform_1.isWindows) {
            if (isBuilt) {
                return path.join(path.dirname(execPath), 'bin', product_1.default.applicationName + ".cmd");
            }
            return path.join(appRoot, 'scripts', 'code-cli.bat');
        }
        // Linux
        if (platform_1.isLinux) {
            if (isBuilt) {
                return path.join(path.dirname(execPath), 'bin', "" + product_1.default.applicationName);
            }
            return path.join(appRoot, 'scripts', 'code-cli.sh');
        }
        // macOS
        if (isBuilt) {
            return path.join(appRoot, 'bin', 'code');
        }
        return path.join(appRoot, 'scripts', 'code-cli.sh');
    }
    var EnvironmentService = /** @class */ (function () {
        function EnvironmentService(_args, _execPath) {
            this._args = _args;
            this._execPath = _execPath;
            if (!process.env['VSCODE_LOGS']) {
                var key = date_1.toLocalISOString(new Date()).replace(/-|:|\.\d+Z$/g, '');
                process.env['VSCODE_LOGS'] = path.join(this.userDataPath, 'logs', key);
            }
            this.logsPath = process.env['VSCODE_LOGS'];
        }
        Object.defineProperty(EnvironmentService.prototype, "args", {
            get: function () { return this._args; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appRoot", {
            get: function () { return path.dirname(amd_1.getPathFromAmdModule(require, '')); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "execPath", {
            get: function () { return this._execPath; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "cliPath", {
            get: function () { return getCLIPath(this.execPath, this.appRoot, this.isBuilt); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "userHome", {
            get: function () { return os.homedir(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "userDataPath", {
            get: function () {
                if (process.env['VSCODE_PORTABLE']) {
                    return path.join(process.env['VSCODE_PORTABLE'], 'user-data');
                }
                return parseUserDataDir(this._args, process);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appNameLong", {
            get: function () { return product_1.default.nameLong; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appQuality", {
            get: function () { return product_1.default.quality; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appSettingsHome", {
            get: function () { return path.join(this.userDataPath, 'User'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appSettingsPath", {
            get: function () { return path.join(this.appSettingsHome, 'settings.json'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "settingsSearchBuildId", {
            get: function () { return product_1.default.settingsSearchBuildId; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "settingsSearchUrl", {
            get: function () { return product_1.default.settingsSearchUrl; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "appKeybindingsPath", {
            get: function () { return path.join(this.appSettingsHome, 'keybindings.json'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "isExtensionDevelopment", {
            get: function () { return !!this._args.extensionDevelopmentPath; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "backupHome", {
            get: function () { return path.join(this.userDataPath, 'Backups'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "backupWorkspacesPath", {
            get: function () { return path.join(this.backupHome, 'workspaces.json'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "workspacesHome", {
            get: function () { return path.join(this.userDataPath, 'Workspaces'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "installSourcePath", {
            get: function () { return path.join(this.userDataPath, 'installSource'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "builtinExtensionsPath", {
            get: function () {
                var fromArgs = parsePathArg(this._args['builtin-extensions-dir'], process);
                if (fromArgs) {
                    return fromArgs;
                }
                else {
                    return path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', 'extensions'));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "extensionsPath", {
            get: function () {
                var fromArgs = parsePathArg(this._args['extensions-dir'], process);
                if (fromArgs) {
                    return fromArgs;
                }
                else if (process.env['VSCODE_EXTENSIONS']) {
                    return process.env['VSCODE_EXTENSIONS'];
                }
                else if (process.env['VSCODE_PORTABLE']) {
                    return path.join(process.env['VSCODE_PORTABLE'], 'extensions');
                }
                else {
                    return path.join(this.userHome, product_1.default.dataFolderName, 'extensions');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "extensionDevelopmentLocationURI", {
            get: function () {
                var s = this._args.extensionDevelopmentPath;
                if (s) {
                    if (/^[^:/?#]+?:\/\//.test(s)) {
                        return uri_1.URI.parse(s);
                    }
                    return uri_1.URI.file(path.normalize(s));
                }
                return void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "extensionTestsPath", {
            get: function () { return this._args.extensionTestsPath ? path.normalize(this._args.extensionTestsPath) : this._args.extensionTestsPath; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "disableExtensions", {
            get: function () {
                if (this._args['disable-extensions']) {
                    return true;
                }
                var disableExtensions = this._args['disable-extension'];
                if (disableExtensions) {
                    if (typeof disableExtensions === 'string') {
                        return [disableExtensions];
                    }
                    if (Array.isArray(disableExtensions) && disableExtensions.length > 0) {
                        return disableExtensions;
                    }
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "skipGettingStarted", {
            get: function () { return this._args['skip-getting-started']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "skipReleaseNotes", {
            get: function () { return this._args['skip-release-notes']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "skipAddToRecentlyOpened", {
            get: function () { return this._args['skip-add-to-recently-opened']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "debugExtensionHost", {
            get: function () { return parseExtensionHostPort(this._args, this.isBuilt); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "debugSearch", {
            get: function () { return parseSearchPort(this._args, this.isBuilt); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "isBuilt", {
            get: function () { return !process.env['VSCODE_DEV']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "verbose", {
            get: function () { return this._args.verbose; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "log", {
            get: function () { return this._args.log; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "wait", {
            get: function () { return this._args.wait; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "logExtensionHostCommunication", {
            get: function () { return this._args.logExtensionHostCommunication; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "performance", {
            get: function () { return this._args.performance; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "status", {
            get: function () { return this._args.status; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "mainIPCHandle", {
            get: function () { return getIPCHandle(this.userDataPath, 'main'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "sharedIPCHandle", {
            get: function () { return getIPCHandle(this.userDataPath, 'shared'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "nodeCachedDataDir", {
            get: function () { return this.isBuilt ? path.join(this.userDataPath, 'CachedData', product_1.default.commit || new Array(41).join('0')) : undefined; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "disableUpdates", {
            get: function () { return !!this._args['disable-updates']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "disableCrashReporter", {
            get: function () { return !!this._args['disable-crash-reporter']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "driverHandle", {
            get: function () { return this._args['driver']; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EnvironmentService.prototype, "driverVerbose", {
            get: function () { return this._args['driver-verbose']; },
            enumerable: true,
            configurable: true
        });
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "appRoot", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "cliPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "userHome", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "userDataPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "appSettingsHome", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "appSettingsPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "settingsSearchBuildId", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "settingsSearchUrl", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "appKeybindingsPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "isExtensionDevelopment", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "backupHome", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "backupWorkspacesPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "workspacesHome", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "installSourcePath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "builtinExtensionsPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "extensionsPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "extensionDevelopmentLocationURI", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "extensionTestsPath", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "debugExtensionHost", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "debugSearch", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "mainIPCHandle", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "sharedIPCHandle", null);
        __decorate([
            decorators_1.memoize
        ], EnvironmentService.prototype, "nodeCachedDataDir", null);
        return EnvironmentService;
    }());
    exports.EnvironmentService = EnvironmentService;
    function parseExtensionHostPort(args, isBuild) {
        return parseDebugPort(args.debugPluginHost, args.debugBrkPluginHost, 5870, isBuild, args.debugId);
    }
    exports.parseExtensionHostPort = parseExtensionHostPort;
    function parseSearchPort(args, isBuild) {
        return parseDebugPort(args.debugSearch, args.debugBrkSearch, 5876, isBuild);
    }
    exports.parseSearchPort = parseSearchPort;
    function parseDebugPort(debugArg, debugBrkArg, defaultBuildPort, isBuild, debugId) {
        var portStr = debugBrkArg || debugArg;
        var port = Number(portStr) || (!isBuild ? defaultBuildPort : null);
        var brk = port ? Boolean(!!debugBrkArg) : false;
        return { port: port, break: brk, debugId: debugId };
    }
    exports.parseDebugPort = parseDebugPort;
    function parsePathArg(arg, process) {
        if (!arg) {
            return undefined;
        }
        // Determine if the arg is relative or absolute, if relative use the original CWD
        // (VSCODE_CWD), not the potentially overridden one (process.cwd()).
        var resolved = path.resolve(arg);
        if (path.normalize(arg) === resolved) {
            return resolved;
        }
        else {
            return path.resolve(process.env['VSCODE_CWD'] || process.cwd(), arg);
        }
    }
    function parseUserDataDir(args, process) {
        return parsePathArg(args['user-data-dir'], process) || path.resolve(paths.getDefaultUserDataPath(process.platform));
    }
    exports.parseUserDataDir = parseUserDataDir;
});

define(__m[37/*vs/platform/registry/common/platform*/], __M([1/*require*/,0/*exports*/,22/*vs/base/common/types*/,76/*vs/base/common/assert*/]), function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var RegistryImpl = /** @class */ (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
});

define(__m[126/*vs/platform/jsonschemas/common/jsonContributionRegistry*/], __M([1/*require*/,0/*exports*/,37/*vs/platform/registry/common/platform*/,5/*vs/base/common/event*/]), function (require, exports, platform, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = /** @class */ (function () {
        function JSONContributionRegistry() {
            this._onDidChangeSchema = new event_1.Emitter();
            this.onDidChangeSchema = this._onDidChangeSchema.event;
            this.schemasById = {};
        }
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.notifySchemaChanged = function (uri) {
            this._onDidChangeSchema.fire(uri);
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
});

define(__m[43/*vs/platform/configuration/common/configurationRegistry*/], __M([1/*require*/,0/*exports*/,80/*vs/nls!vs/platform/configuration/common/configurationRegistry*/,5/*vs/base/common/event*/,37/*vs/platform/registry/common/platform*/,22/*vs/base/common/types*/,18/*vs/base/common/strings*/,126/*vs/platform/jsonschemas/common/jsonContributionRegistry*/]), function (require, exports, nls, event_1, platform_1, types, strings, jsonContributionRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Extensions = {
        Configuration: 'base.contributions.configuration'
    };
    var ConfigurationScope;
    (function (ConfigurationScope) {
        ConfigurationScope[ConfigurationScope["APPLICATION"] = 1] = "APPLICATION";
        ConfigurationScope[ConfigurationScope["WINDOW"] = 2] = "WINDOW";
        ConfigurationScope[ConfigurationScope["RESOURCE"] = 3] = "RESOURCE";
    })(ConfigurationScope = exports.ConfigurationScope || (exports.ConfigurationScope = {}));
    exports.allSettings = { properties: {}, patternProperties: {} };
    exports.applicationSettings = { properties: {}, patternProperties: {} };
    exports.windowSettings = { properties: {}, patternProperties: {} };
    exports.resourceSettings = { properties: {}, patternProperties: {} };
    exports.editorConfigurationSchemaId = 'vscode://schemas/settings/editor';
    var contributionRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ConfigurationRegistry = /** @class */ (function () {
        function ConfigurationRegistry() {
            this.overrideIdentifiers = [];
            this._onDidSchemaChange = new event_1.Emitter();
            this.onDidSchemaChange = this._onDidSchemaChange.event;
            this._onDidRegisterConfiguration = new event_1.Emitter();
            this.onDidRegisterConfiguration = this._onDidRegisterConfiguration.event;
            this.configurationContributors = [];
            this.editorConfigurationSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: 'Unknown editor configuration setting' };
            this.configurationProperties = {};
            this.excludedConfigurationProperties = {};
            this.computeOverridePropertyPattern();
            contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
        }
        ConfigurationRegistry.prototype.registerConfiguration = function (configuration, validate) {
            if (validate === void 0) { validate = true; }
            this.registerConfigurations([configuration], [], validate);
        };
        ConfigurationRegistry.prototype.registerConfigurations = function (configurations, defaultConfigurations, validate) {
            var _this = this;
            if (validate === void 0) { validate = true; }
            var configurationNode = this.toConfiguration(defaultConfigurations);
            if (configurationNode) {
                configurations.push(configurationNode);
            }
            var properties = [];
            configurations.forEach(function (configuration) {
                properties.push.apply(properties, _this.validateAndRegisterProperties(configuration, validate)); // fills in defaults
                _this.configurationContributors.push(configuration);
                _this.registerJSONConfiguration(configuration);
                _this.updateSchemaForOverrideSettingsConfiguration(configuration);
            });
            this._onDidRegisterConfiguration.fire(properties);
        };
        ConfigurationRegistry.prototype.notifyConfigurationSchemaUpdated = function (configuration) {
            contributionRegistry.notifySchemaChanged(exports.editorConfigurationSchemaId);
        };
        ConfigurationRegistry.prototype.registerOverrideIdentifiers = function (overrideIdentifiers) {
            var _a;
            (_a = this.overrideIdentifiers).push.apply(_a, overrideIdentifiers);
            this.updateOverridePropertyPatternKey();
        };
        ConfigurationRegistry.prototype.toConfiguration = function (defaultConfigurations) {
            var configurationNode = {
                id: 'defaultOverrides',
                title: nls.localize(0, null),
                properties: {}
            };
            for (var _i = 0, defaultConfigurations_1 = defaultConfigurations; _i < defaultConfigurations_1.length; _i++) {
                var defaultConfiguration = defaultConfigurations_1[_i];
                for (var key in defaultConfiguration.defaults) {
                    var defaultValue = defaultConfiguration.defaults[key];
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key) && typeof defaultValue === 'object') {
                        configurationNode.properties[key] = {
                            type: 'object',
                            default: defaultValue,
                            description: nls.localize(1, null, key),
                            $ref: exports.editorConfigurationSchemaId
                        };
                    }
                }
            }
            return Object.keys(configurationNode.properties).length ? configurationNode : null;
        };
        ConfigurationRegistry.prototype.validateAndRegisterProperties = function (configuration, validate, scope, overridable) {
            if (validate === void 0) { validate = true; }
            if (scope === void 0) { scope = 2 /* WINDOW */; }
            if (overridable === void 0) { overridable = false; }
            scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;
            overridable = configuration.overridable || overridable;
            var propertyKeys = [];
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    var message = void 0;
                    if (validate && (message = validateProperty(key))) {
                        console.warn(message);
                        delete properties[key];
                        continue;
                    }
                    // fill in default values
                    var property = properties[key];
                    var defaultValue = property.default;
                    if (types.isUndefined(defaultValue)) {
                        property.default = getDefaultValue(property.type);
                    }
                    // Inherit overridable property from parent
                    if (overridable) {
                        property.overridable = true;
                    }
                    if (exports.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                        property.scope = void 0; // No scope for overridable properties `[${identifier}]`
                    }
                    else {
                        property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;
                    }
                    // Add to properties maps
                    // Property is included by default if 'included' is unspecified
                    if (properties[key].hasOwnProperty('included') && !properties[key].included) {
                        this.excludedConfigurationProperties[key] = properties[key];
                        delete properties[key];
                        continue;
                    }
                    else {
                        this.configurationProperties[key] = properties[key];
                    }
                    propertyKeys.push(key);
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                for (var _i = 0, subNodes_1 = subNodes; _i < subNodes_1.length; _i++) {
                    var node = subNodes_1[_i];
                    propertyKeys.push.apply(propertyKeys, this.validateAndRegisterProperties(node, validate, scope, overridable));
                }
            }
            return propertyKeys;
        };
        ConfigurationRegistry.prototype.getConfigurations = function () {
            return this.configurationContributors;
        };
        ConfigurationRegistry.prototype.getConfigurationProperties = function () {
            return this.configurationProperties;
        };
        ConfigurationRegistry.prototype.getExcludedConfigurationProperties = function () {
            return this.excludedConfigurationProperties;
        };
        ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
            function register(configuration) {
                var properties = configuration.properties;
                if (properties) {
                    for (var key in properties) {
                        exports.allSettings.properties[key] = properties[key];
                        switch (properties[key].scope) {
                            case 1 /* APPLICATION */:
                                exports.applicationSettings.properties[key] = properties[key];
                                break;
                            case 2 /* WINDOW */:
                                exports.windowSettings.properties[key] = properties[key];
                                break;
                            case 3 /* RESOURCE */:
                                exports.resourceSettings.properties[key] = properties[key];
                                break;
                        }
                    }
                }
                var subNodes = configuration.allOf;
                if (subNodes) {
                    subNodes.forEach(register);
                }
            }
            register(configuration);
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.updateSchemaForOverrideSettingsConfiguration = function (configuration) {
            if (configuration.id !== SETTINGS_OVERRRIDE_NODE_ID) {
                this.update(configuration);
                contributionRegistry.registerSchema(exports.editorConfigurationSchemaId, this.editorConfigurationSchema);
            }
        };
        ConfigurationRegistry.prototype.updateOverridePropertyPatternKey = function () {
            var patternProperties = exports.allSettings.patternProperties[this.overridePropertyPattern];
            if (!patternProperties) {
                patternProperties = {
                    type: 'object',
                    description: nls.localize(2, null),
                    errorMessage: 'Unknown Identifier. Use language identifiers',
                    $ref: exports.editorConfigurationSchemaId
                };
            }
            delete exports.allSettings.patternProperties[this.overridePropertyPattern];
            delete exports.applicationSettings.patternProperties[this.overridePropertyPattern];
            delete exports.windowSettings.patternProperties[this.overridePropertyPattern];
            delete exports.resourceSettings.patternProperties[this.overridePropertyPattern];
            this.computeOverridePropertyPattern();
            exports.allSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.applicationSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.windowSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            exports.resourceSettings.patternProperties[this.overridePropertyPattern] = patternProperties;
            this._onDidSchemaChange.fire();
        };
        ConfigurationRegistry.prototype.update = function (configuration) {
            var _this = this;
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    if (properties[key].overridable) {
                        this.editorConfigurationSchema.properties[key] = this.getConfigurationProperties()[key];
                    }
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                subNodes.forEach(function (subNode) { return _this.update(subNode); });
            }
        };
        ConfigurationRegistry.prototype.computeOverridePropertyPattern = function () {
            this.overridePropertyPattern = this.overrideIdentifiers.length ? OVERRIDE_PATTERN_WITH_SUBSTITUTION.replace('${0}', this.overrideIdentifiers.map(function (identifier) { return strings.createRegExp(identifier, false).source; }).join('|')) : OVERRIDE_PROPERTY;
        };
        return ConfigurationRegistry;
    }());
    var SETTINGS_OVERRRIDE_NODE_ID = 'override';
    var OVERRIDE_PROPERTY = '\\[.*\\]$';
    var OVERRIDE_PATTERN_WITH_SUBSTITUTION = '\\[(${0})\\]$';
    exports.OVERRIDE_PROPERTY_PATTERN = new RegExp(OVERRIDE_PROPERTY);
    function getDefaultValue(type) {
        var t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
            case 'number':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
    var configurationRegistry = new ConfigurationRegistry();
    platform_1.Registry.add(exports.Extensions.Configuration, configurationRegistry);
    function validateProperty(property) {
        if (exports.OVERRIDE_PROPERTY_PATTERN.test(property)) {
            return nls.localize(3, null, property);
        }
        if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
            return nls.localize(4, null, property);
        }
        return null;
    }
    exports.validateProperty = validateProperty;
    function getScopes() {
        var scopes = {};
        var configurationProperties = configurationRegistry.getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(configurationProperties); _i < _a.length; _i++) {
            var key = _a[_i];
            scopes[key] = configurationProperties[key].scope;
        }
        scopes['launch'] = 3 /* RESOURCE */;
        scopes['task'] = 3 /* RESOURCE */;
        return scopes;
    }
    exports.getScopes = getScopes;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[14/*vs/platform/configuration/common/configuration*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/objects*/,22/*vs/base/common/types*/,6/*vs/base/common/uri*/,37/*vs/platform/registry/common/platform*/,4/*vs/platform/instantiation/common/instantiation*/,43/*vs/platform/configuration/common/configurationRegistry*/]), function (require, exports, objects, types, uri_1, platform_1, instantiation_1, configurationRegistry_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    function isConfigurationOverrides(thing) {
        return thing
            && typeof thing === 'object'
            && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
            && (!thing.resource || thing.resource instanceof uri_1.URI);
    }
    exports.isConfigurationOverrides = isConfigurationOverrides;
    var ConfigurationTarget;
    (function (ConfigurationTarget) {
        ConfigurationTarget[ConfigurationTarget["USER"] = 1] = "USER";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE"] = 2] = "WORKSPACE";
        ConfigurationTarget[ConfigurationTarget["WORKSPACE_FOLDER"] = 3] = "WORKSPACE_FOLDER";
        ConfigurationTarget[ConfigurationTarget["DEFAULT"] = 4] = "DEFAULT";
        ConfigurationTarget[ConfigurationTarget["MEMORY"] = 5] = "MEMORY";
    })(ConfigurationTarget = exports.ConfigurationTarget || (exports.ConfigurationTarget = {}));
    function ConfigurationTargetToString(configurationTarget) {
        switch (configurationTarget) {
            case 1 /* USER */: return 'USER';
            case 2 /* WORKSPACE */: return 'WORKSPACE';
            case 3 /* WORKSPACE_FOLDER */: return 'WORKSPACE_FOLDER';
            case 4 /* DEFAULT */: return 'DEFAULT';
            case 5 /* MEMORY */: return 'MEMORY';
        }
    }
    exports.ConfigurationTargetToString = ConfigurationTargetToString;
    function compare(from, to) {
        var added = to.keys.filter(function (key) { return from.keys.indexOf(key) === -1; });
        var removed = from.keys.filter(function (key) { return to.keys.indexOf(key) === -1; });
        var updated = [];
        for (var _i = 0, _a = from.keys; _i < _a.length; _i++) {
            var key = _a[_i];
            var value1 = getConfigurationValue(from.contents, key);
            var value2 = getConfigurationValue(to.contents, key);
            if (!objects.equals(value1, value2)) {
                updated.push(key);
            }
        }
        return { added: added, removed: removed, updated: updated };
    }
    exports.compare = compare;
    function toOverrides(raw, conflictReporter) {
        var overrides = [];
        var configurationProperties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var _i = 0, _a = Object.keys(raw); _i < _a.length; _i++) {
            var key = _a[_i];
            if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                var overrideRaw = {};
                for (var keyInOverrideRaw in raw[key]) {
                    if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {
                        overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                    }
                }
                overrides.push({
                    identifiers: [overrideIdentifierFromKey(key).trim()],
                    contents: toValuesTree(overrideRaw, conflictReporter)
                });
            }
        }
        return overrides;
    }
    exports.toOverrides = toOverrides;
    function toValuesTree(properties, conflictReporter) {
        var root = Object.create(null);
        for (var key in properties) {
            addToValueTree(root, key, properties[key], conflictReporter);
        }
        return root;
    }
    exports.toValuesTree = toValuesTree;
    function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
        var segments = key.split('.');
        var last = segments.pop();
        var curr = settingsTreeRoot;
        for (var i = 0; i < segments.length; i++) {
            var s = segments[i];
            var obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    break;
                default:
                    conflictReporter("Ignoring " + key + " as " + segments.slice(0, i + 1).join('.') + " is " + JSON.stringify(obj));
                    return;
            }
            curr = obj;
        }
        if (typeof curr === 'object') {
            curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
        }
        else {
            conflictReporter("Ignoring " + key + " as " + segments.join('.') + " is " + JSON.stringify(curr));
        }
    }
    exports.addToValueTree = addToValueTree;
    function removeFromValueTree(valueTree, key) {
        var segments = key.split('.');
        doRemoveFromValueTree(valueTree, segments);
    }
    exports.removeFromValueTree = removeFromValueTree;
    function doRemoveFromValueTree(valueTree, segments) {
        var first = segments.shift();
        if (segments.length === 0) {
            // Reached last segment
            delete valueTree[first];
            return;
        }
        if (Object.keys(valueTree).indexOf(first) !== -1) {
            var value = valueTree[first];
            if (typeof value === 'object' && !Array.isArray(value)) {
                doRemoveFromValueTree(value, segments);
                if (Object.keys(value).length === 0) {
                    delete valueTree[first];
                }
            }
        }
    }
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                if (typeof current !== 'object' || current === null) {
                    return undefined;
                }
                current = current[path[i]];
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    function getConfigurationKeys() {
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        return Object.keys(properties);
    }
    exports.getConfigurationKeys = getConfigurationKeys;
    function getDefaultValues() {
        var valueTreeRoot = Object.create(null);
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var key in properties) {
            var value = properties[key].default;
            addToValueTree(valueTreeRoot, key, value, function (message) { return console.error("Conflict in default settings: " + message); });
        }
        return valueTreeRoot;
    }
    exports.getDefaultValues = getDefaultValues;
    function overrideIdentifierFromKey(key) {
        return key.substring(1, key.length - 1);
    }
    exports.overrideIdentifierFromKey = overrideIdentifierFromKey;
    function keyFromOverrideIdentifier(overrideIdentifier) {
        return "[" + overrideIdentifier + "]";
    }
    exports.keyFromOverrideIdentifier = keyFromOverrideIdentifier;
});














define(__m[65/*vs/platform/configuration/common/configurationModels*/], __M([1/*require*/,0/*exports*/,40/*vs/base/common/json*/,38/*vs/base/common/map*/,24/*vs/base/common/arrays*/,22/*vs/base/common/types*/,17/*vs/base/common/objects*/,43/*vs/platform/configuration/common/configurationRegistry*/,14/*vs/platform/configuration/common/configuration*/]), function (require, exports, json, map_1, arrays, types, objects, configurationRegistry_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConfigurationModel = /** @class */ (function () {
        function ConfigurationModel(_contents, _keys, _overrides) {
            if (_contents === void 0) { _contents = {}; }
            if (_keys === void 0) { _keys = []; }
            if (_overrides === void 0) { _overrides = []; }
            this._contents = _contents;
            this._keys = _keys;
            this._overrides = _overrides;
            this.isFrozen = false;
        }
        Object.defineProperty(ConfigurationModel.prototype, "contents", {
            get: function () {
                return this.checkAndFreeze(this._contents);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "overrides", {
            get: function () {
                return this.checkAndFreeze(this._overrides);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModel.prototype, "keys", {
            get: function () {
                return this.checkAndFreeze(this._keys);
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModel.prototype.getValue = function (section) {
            return section ? configuration_1.getConfigurationValue(this.contents, section) : this.contents;
        };
        ConfigurationModel.prototype.override = function (identifier) {
            var overrideContents = this.getContentsForOverrideIdentifer(identifier);
            if (!overrideContents || typeof overrideContents !== 'object' || !Object.keys(overrideContents).length) {
                // If there are no valid overrides, return self
                return this;
            }
            var contents = {};
            for (var _i = 0, _a = arrays.distinct(Object.keys(this.contents).concat(Object.keys(overrideContents))); _i < _a.length; _i++) {
                var key = _a[_i];
                var contentsForKey = this.contents[key];
                var overrideContentsForKey = overrideContents[key];
                // If there are override contents for the key, clone and merge otherwise use base contents
                if (overrideContentsForKey) {
                    // Clone and merge only if base contents and override contents are of type object otherwise just override
                    if (typeof contentsForKey === 'object' && typeof overrideContentsForKey === 'object') {
                        contentsForKey = objects.deepClone(contentsForKey);
                        this.mergeContents(contentsForKey, overrideContentsForKey);
                    }
                    else {
                        contentsForKey = overrideContentsForKey;
                    }
                }
                contents[key] = contentsForKey;
            }
            return new ConfigurationModel(contents);
        };
        ConfigurationModel.prototype.merge = function () {
            var others = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                others[_i] = arguments[_i];
            }
            var contents = objects.deepClone(this.contents);
            var overrides = objects.deepClone(this.overrides);
            var keys = this.keys.slice();
            for (var _a = 0, others_1 = others; _a < others_1.length; _a++) {
                var other = others_1[_a];
                this.mergeContents(contents, other.contents);
                var _loop_1 = function (otherOverride) {
                    var override = overrides.filter(function (o) { return arrays.equals(o.identifiers, otherOverride.identifiers); })[0];
                    if (override) {
                        this_1.mergeContents(override.contents, otherOverride.contents);
                    }
                    else {
                        overrides.push(objects.deepClone(otherOverride));
                    }
                };
                var this_1 = this;
                for (var _b = 0, _c = other.overrides; _b < _c.length; _b++) {
                    var otherOverride = _c[_b];
                    _loop_1(otherOverride);
                }
                for (var _d = 0, _e = other.keys; _d < _e.length; _d++) {
                    var key = _e[_d];
                    if (keys.indexOf(key) === -1) {
                        keys.push(key);
                    }
                }
            }
            return new ConfigurationModel(contents, keys, overrides);
        };
        ConfigurationModel.prototype.freeze = function () {
            this.isFrozen = true;
            return this;
        };
        ConfigurationModel.prototype.mergeContents = function (source, target) {
            for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
                var key = _a[_i];
                if (key in source) {
                    if (types.isObject(source[key]) && types.isObject(target[key])) {
                        this.mergeContents(source[key], target[key]);
                        continue;
                    }
                }
                source[key] = objects.deepClone(target[key]);
            }
        };
        ConfigurationModel.prototype.checkAndFreeze = function (data) {
            if (this.isFrozen && !Object.isFrozen(data)) {
                return objects.deepFreeze(data);
            }
            return data;
        };
        ConfigurationModel.prototype.getContentsForOverrideIdentifer = function (identifier) {
            for (var _i = 0, _a = this.overrides; _i < _a.length; _i++) {
                var override = _a[_i];
                if (override.identifiers.indexOf(identifier) !== -1) {
                    return override.contents;
                }
            }
            return null;
        };
        ConfigurationModel.prototype.toJSON = function () {
            return {
                contents: this.contents,
                overrides: this.overrides,
                keys: this.keys
            };
        };
        // Update methods
        ConfigurationModel.prototype.setValue = function (key, value) {
            this.addKey(key);
            configuration_1.addToValueTree(this.contents, key, value, function (e) { throw new Error(e); });
        };
        ConfigurationModel.prototype.removeValue = function (key) {
            if (this.removeKey(key)) {
                configuration_1.removeFromValueTree(this.contents, key);
            }
        };
        ConfigurationModel.prototype.addKey = function (key) {
            var index = this.keys.length;
            for (var i = 0; i < index; i++) {
                if (key.indexOf(this.keys[i]) === 0) {
                    index = i;
                }
            }
            this.keys.splice(index, 1, key);
        };
        ConfigurationModel.prototype.removeKey = function (key) {
            var index = this.keys.indexOf(key);
            if (index !== -1) {
                this.keys.splice(index, 1);
                return true;
            }
            return false;
        };
        return ConfigurationModel;
    }());
    exports.ConfigurationModel = ConfigurationModel;
    var DefaultConfigurationModel = /** @class */ (function (_super) {
        __extends(DefaultConfigurationModel, _super);
        function DefaultConfigurationModel() {
            var _this = this;
            var contents = configuration_1.getDefaultValues();
            var keys = configuration_1.getConfigurationKeys();
            var overrides = [];
            for (var _i = 0, _a = Object.keys(contents); _i < _a.length; _i++) {
                var key = _a[_i];
                if (configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
                    overrides.push({
                        identifiers: [configuration_1.overrideIdentifierFromKey(key).trim()],
                        contents: configuration_1.toValuesTree(contents[key], function (message) { return console.error("Conflict in default settings file: " + message); })
                    });
                }
            }
            _this = _super.call(this, contents, keys, overrides) || this;
            return _this;
        }
        return DefaultConfigurationModel;
    }(ConfigurationModel));
    exports.DefaultConfigurationModel = DefaultConfigurationModel;
    var ConfigurationModelParser = /** @class */ (function () {
        function ConfigurationModelParser(_name) {
            this._name = _name;
            this._configurationModel = null;
            this._parseErrors = [];
        }
        Object.defineProperty(ConfigurationModelParser.prototype, "configurationModel", {
            get: function () {
                return this._configurationModel || new ConfigurationModel();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationModelParser.prototype, "errors", {
            get: function () {
                return this._parseErrors;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationModelParser.prototype.parse = function (content) {
            var raw = this.parseContent(content);
            var configurationModel = this.parseRaw(raw);
            this._configurationModel = new ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
        };
        ConfigurationModelParser.prototype.parseContent = function (content) {
            var raw = {};
            var currentProperty = null;
            var currentParent = [];
            var previousParents = [];
            var parseErrors = [];
            function onValue(value) {
                if (Array.isArray(currentParent)) {
                    currentParent.push(value);
                }
                else if (currentProperty) {
                    currentParent[currentProperty] = value;
                }
            }
            var visitor = {
                onObjectBegin: function () {
                    var object = {};
                    onValue(object);
                    previousParents.push(currentParent);
                    currentParent = object;
                    currentProperty = null;
                },
                onObjectProperty: function (name) {
                    currentProperty = name;
                },
                onObjectEnd: function () {
                    currentParent = previousParents.pop();
                },
                onArrayBegin: function () {
                    var array = [];
                    onValue(array);
                    previousParents.push(currentParent);
                    currentParent = array;
                    currentProperty = null;
                },
                onArrayEnd: function () {
                    currentParent = previousParents.pop();
                },
                onLiteralValue: onValue,
                onError: function (error) {
                    parseErrors.push({ error: error });
                }
            };
            if (content) {
                try {
                    json.visit(content, visitor);
                    raw = currentParent[0] || {};
                }
                catch (e) {
                    console.error("Error while parsing settings file " + this._name + ": " + e);
                    this._parseErrors = [e];
                }
            }
            return raw;
        };
        ConfigurationModelParser.prototype.parseRaw = function (raw) {
            var _this = this;
            var contents = configuration_1.toValuesTree(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            var keys = Object.keys(raw);
            var overrides = configuration_1.toOverrides(raw, function (message) { return console.error("Conflict in settings file " + _this._name + ": " + message); });
            return { contents: contents, keys: keys, overrides: overrides };
        };
        return ConfigurationModelParser;
    }());
    exports.ConfigurationModelParser = ConfigurationModelParser;
    var Configuration = /** @class */ (function () {
        function Configuration(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations, _memoryConfiguration, _memoryConfigurationByResource, _freeze) {
            if (_workspaceConfiguration === void 0) { _workspaceConfiguration = new ConfigurationModel(); }
            if (_folderConfigurations === void 0) { _folderConfigurations = new map_1.ResourceMap(); }
            if (_memoryConfiguration === void 0) { _memoryConfiguration = new ConfigurationModel(); }
            if (_memoryConfigurationByResource === void 0) { _memoryConfigurationByResource = new map_1.ResourceMap(); }
            if (_freeze === void 0) { _freeze = true; }
            this._defaultConfiguration = _defaultConfiguration;
            this._userConfiguration = _userConfiguration;
            this._workspaceConfiguration = _workspaceConfiguration;
            this._folderConfigurations = _folderConfigurations;
            this._memoryConfiguration = _memoryConfiguration;
            this._memoryConfigurationByResource = _memoryConfigurationByResource;
            this._freeze = _freeze;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations = new map_1.ResourceMap();
        }
        Configuration.prototype.getValue = function (section, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            return consolidateConfigurationModel.getValue(section);
        };
        Configuration.prototype.updateValue = function (key, value, overrides) {
            if (overrides === void 0) { overrides = {}; }
            var memoryConfiguration;
            if (overrides.resource) {
                memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
                if (!memoryConfiguration) {
                    memoryConfiguration = new ConfigurationModel();
                    this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
                }
            }
            else {
                memoryConfiguration = this._memoryConfiguration;
            }
            if (value === void 0) {
                memoryConfiguration.removeValue(key);
            }
            else {
                memoryConfiguration.setValue(key, value);
            }
            if (!overrides.resource) {
                this._workspaceConsolidatedConfiguration = null;
            }
        };
        Configuration.prototype.inspect = function (key, overrides, workspace) {
            var consolidateConfigurationModel = this.getConsolidateConfigurationModel(overrides, workspace);
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource, workspace);
            var memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
            return {
                default: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key),
                user: overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key),
                workspace: workspace ? overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key) : void 0,
                workspaceFolder: folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0,
                memory: overrides.overrideIdentifier ? memoryConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.freeze().getValue(key),
                value: consolidateConfigurationModel.getValue(key)
            };
        };
        Configuration.prototype.keys = function (workspace) {
            var folderConfigurationModel = this.getFolderConfigurationModelForResource(null, workspace);
            return {
                default: this._defaultConfiguration.freeze().keys,
                user: this._userConfiguration.freeze().keys,
                workspace: this._workspaceConfiguration.freeze().keys,
                workspaceFolder: folderConfigurationModel ? folderConfigurationModel.freeze().keys : []
            };
        };
        Configuration.prototype.updateDefaultConfiguration = function (defaultConfiguration) {
            this._defaultConfiguration = defaultConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateUserConfiguration = function (userConfiguration) {
            this._userConfiguration = userConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateWorkspaceConfiguration = function (workspaceConfiguration) {
            this._workspaceConfiguration = workspaceConfiguration;
            this._workspaceConsolidatedConfiguration = null;
            this._foldersConsolidatedConfigurations.clear();
        };
        Configuration.prototype.updateFolderConfiguration = function (resource, configuration) {
            this._folderConfigurations.set(resource, configuration);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Configuration.prototype.deleteFolderConfiguration = function (resource) {
            this.folders.delete(resource);
            this._foldersConsolidatedConfigurations.delete(resource);
        };
        Object.defineProperty(Configuration.prototype, "defaults", {
            get: function () {
                return this._defaultConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "user", {
            get: function () {
                return this._userConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "workspace", {
            get: function () {
                return this._workspaceConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Configuration.prototype, "folders", {
            get: function () {
                return this._folderConfigurations;
            },
            enumerable: true,
            configurable: true
        });
        Configuration.prototype.getConsolidateConfigurationModel = function (overrides, workspace) {
            var configurationModel = this.getConsolidatedConfigurationModelForResource(overrides, workspace);
            return overrides.overrideIdentifier ? configurationModel.override(overrides.overrideIdentifier) : configurationModel;
        };
        Configuration.prototype.getConsolidatedConfigurationModelForResource = function (_a, workspace) {
            var resource = _a.resource;
            var consolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    consolidateConfiguration = this.getFolderConsolidatedConfiguration(root.uri) || consolidateConfiguration;
                }
                var memoryConfigurationForResource = this._memoryConfigurationByResource.get(resource);
                if (memoryConfigurationForResource) {
                    consolidateConfiguration = consolidateConfiguration.merge(memoryConfigurationForResource);
                }
            }
            return consolidateConfiguration;
        };
        Configuration.prototype.getWorkspaceConsolidatedConfiguration = function () {
            if (!this._workspaceConsolidatedConfiguration) {
                this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
                if (this._freeze) {
                    this._workspaceConfiguration = this._workspaceConfiguration.freeze();
                }
            }
            return this._workspaceConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConsolidatedConfiguration = function (folder) {
            var folderConsolidatedConfiguration = this._foldersConsolidatedConfigurations.get(folder);
            if (!folderConsolidatedConfiguration) {
                var workspaceConsolidateConfiguration = this.getWorkspaceConsolidatedConfiguration();
                var folderConfiguration = this._folderConfigurations.get(folder);
                if (folderConfiguration) {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration.merge(folderConfiguration);
                    if (this._freeze) {
                        folderConsolidatedConfiguration = folderConsolidatedConfiguration.freeze();
                    }
                    this._foldersConsolidatedConfigurations.set(folder, folderConsolidatedConfiguration);
                }
                else {
                    folderConsolidatedConfiguration = workspaceConsolidateConfiguration;
                }
            }
            return folderConsolidatedConfiguration;
        };
        Configuration.prototype.getFolderConfigurationModelForResource = function (resource, workspace) {
            if (workspace && resource) {
                var root = workspace.getFolder(resource);
                if (root) {
                    return this._folderConfigurations.get(root.uri);
                }
            }
            return null;
        };
        Configuration.prototype.toData = function () {
            var _this = this;
            return {
                defaults: {
                    contents: this._defaultConfiguration.contents,
                    overrides: this._defaultConfiguration.overrides,
                    keys: this._defaultConfiguration.keys
                },
                user: {
                    contents: this._userConfiguration.contents,
                    overrides: this._userConfiguration.overrides,
                    keys: this._userConfiguration.keys
                },
                workspace: {
                    contents: this._workspaceConfiguration.contents,
                    overrides: this._workspaceConfiguration.overrides,
                    keys: this._workspaceConfiguration.keys
                },
                folders: this._folderConfigurations.keys().reduce(function (result, folder) {
                    var _a = _this._folderConfigurations.get(folder), contents = _a.contents, overrides = _a.overrides, keys = _a.keys;
                    result[folder.toString()] = { contents: contents, overrides: overrides, keys: keys };
                    return result;
                }, Object.create({})),
                isComplete: true
            };
        };
        Configuration.prototype.allKeys = function (workspace) {
            var keys = this.keys(workspace);
            var all = keys.default.slice();
            var addKeys = function (keys) {
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    if (all.indexOf(key) === -1) {
                        all.push(key);
                    }
                }
            };
            addKeys(keys.user);
            addKeys(keys.workspace);
            for (var _i = 0, _a = this.folders.keys(); _i < _a.length; _i++) {
                var resource = _a[_i];
                addKeys(this.folders.get(resource).keys);
            }
            return all;
        };
        return Configuration;
    }());
    exports.Configuration = Configuration;
    var AbstractConfigurationChangeEvent = /** @class */ (function () {
        function AbstractConfigurationChangeEvent() {
        }
        AbstractConfigurationChangeEvent.prototype.doesConfigurationContains = function (configuration, config) {
            var _a;
            var changedKeysTree = configuration.contents;
            var requestedTree = configuration_1.toValuesTree((_a = {}, _a[config] = true, _a), function () { });
            var key;
            while (typeof requestedTree === 'object' && (key = Object.keys(requestedTree)[0])) { // Only one key should present, since we added only one property
                changedKeysTree = changedKeysTree[key];
                if (!changedKeysTree) {
                    return false; // Requested tree is not found
                }
                requestedTree = requestedTree[key];
            }
            return true;
        };
        AbstractConfigurationChangeEvent.prototype.updateKeys = function (configuration, keys, resource) {
            for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
                var key = keys_2[_i];
                configuration.setValue(key, {});
            }
        };
        return AbstractConfigurationChangeEvent;
    }());
    exports.AbstractConfigurationChangeEvent = AbstractConfigurationChangeEvent;
    var ConfigurationChangeEvent = /** @class */ (function (_super) {
        __extends(ConfigurationChangeEvent, _super);
        function ConfigurationChangeEvent(_changedConfiguration, _changedConfigurationByResource) {
            if (_changedConfiguration === void 0) { _changedConfiguration = new ConfigurationModel(); }
            if (_changedConfigurationByResource === void 0) { _changedConfigurationByResource = new map_1.ResourceMap(); }
            var _this = _super.call(this) || this;
            _this._changedConfiguration = _changedConfiguration;
            _this._changedConfigurationByResource = _changedConfigurationByResource;
            return _this;
        }
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfiguration", {
            get: function () {
                return this._changedConfiguration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "changedConfigurationByResource", {
            get: function () {
                return this._changedConfigurationByResource;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.change = function (arg1, arg2) {
            if (arg1 instanceof ConfigurationChangeEvent) {
                this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);
                for (var _i = 0, _a = arg1._changedConfigurationByResource.keys(); _i < _a.length; _i++) {
                    var resource = _a[_i];
                    var changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);
                    changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));
                    this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
                }
            }
            else {
                this.changeWithKeys(arg1, arg2);
            }
            return this;
        };
        ConfigurationChangeEvent.prototype.telemetryData = function (source, sourceConfig) {
            this._source = source;
            this._sourceConfig = sourceConfig;
            return this;
        };
        Object.defineProperty(ConfigurationChangeEvent.prototype, "affectedKeys", {
            get: function () {
                var keys = this._changedConfiguration.keys.slice();
                this._changedConfigurationByResource.forEach(function (model) { return keys.push.apply(keys, model.keys); });
                return arrays.distinct(keys);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "source", {
            get: function () {
                return this._source;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigurationChangeEvent.prototype, "sourceConfig", {
            get: function () {
                return this._sourceConfig;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationChangeEvent.prototype.affectsConfiguration = function (config, resource) {
            var configurationModelsToSearch = [this._changedConfiguration];
            if (resource) {
                var model = this._changedConfigurationByResource.get(resource);
                if (model) {
                    configurationModelsToSearch.push(model);
                }
            }
            else {
                configurationModelsToSearch.push.apply(configurationModelsToSearch, this._changedConfigurationByResource.values());
            }
            for (var _i = 0, configurationModelsToSearch_1 = configurationModelsToSearch; _i < configurationModelsToSearch_1.length; _i++) {
                var configuration = configurationModelsToSearch_1[_i];
                if (this.doesConfigurationContains(configuration, config)) {
                    return true;
                }
            }
            return false;
        };
        ConfigurationChangeEvent.prototype.changeWithKeys = function (keys, resource) {
            var changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;
            this.updateKeys(changedConfiguration, keys);
        };
        ConfigurationChangeEvent.prototype.getOrSetChangedConfigurationForResource = function (resource) {
            var changedConfigurationByResource = this._changedConfigurationByResource.get(resource);
            if (!changedConfigurationByResource) {
                changedConfigurationByResource = new ConfigurationModel();
                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
            }
            return changedConfigurationByResource;
        };
        return ConfigurationChangeEvent;
    }(AbstractConfigurationChangeEvent));
    exports.ConfigurationChangeEvent = ConfigurationChangeEvent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[130/*vs/platform/configuration/node/configuration*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/lifecycle*/,23/*vs/base/common/errors*/,65/*vs/platform/configuration/common/configurationModels*/,68/*vs/base/node/config*/,5/*vs/base/common/event*/,2/*vs/base/common/winjs.base*/]), function (require, exports, lifecycle_1, errors_1, configurationModels_1, config_1, event_1, winjs_base_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UserConfiguration = /** @class */ (function (_super) {
        __extends(UserConfiguration, _super);
        function UserConfiguration(settingsPath) {
            var _this = _super.call(this) || this;
            _this._onDidChangeConfiguration = _this._register(new event_1.Emitter());
            _this.onDidChangeConfiguration = _this._onDidChangeConfiguration.event;
            _this.userConfigModelWatcher = new config_1.ConfigWatcher(settingsPath, {
                changeBufferDelay: 300, onError: function (error) { return errors_1.onUnexpectedError(error); }, defaultConfig: new configurationModels_1.ConfigurationModelParser(settingsPath), parse: function (content, parseErrors) {
                    var userConfigModelParser = new configurationModels_1.ConfigurationModelParser(settingsPath);
                    userConfigModelParser.parse(content);
                    parseErrors = userConfigModelParser.errors.slice();
                    return userConfigModelParser;
                }
            });
            _this._register(_this.userConfigModelWatcher);
            // Listeners
            _this._register(_this.userConfigModelWatcher.onDidUpdateConfiguration(function () { return _this._onDidChangeConfiguration.fire(_this.configurationModel); }));
            return _this;
        }
        Object.defineProperty(UserConfiguration.prototype, "configurationModel", {
            get: function () {
                return this.userConfigModelWatcher.getConfig().configurationModel;
            },
            enumerable: true,
            configurable: true
        });
        UserConfiguration.prototype.reload = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (c) { return _this.userConfigModelWatcher.reload(function () { return c(null); }); });
        };
        return UserConfiguration;
    }(lifecycle_1.Disposable));
    exports.UserConfiguration = UserConfiguration;
});




















var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[131/*vs/platform/configuration/node/configurationService*/], __M([1/*require*/,0/*exports*/,37/*vs/platform/registry/common/platform*/,43/*vs/platform/configuration/common/configurationRegistry*/,13/*vs/base/common/lifecycle*/,14/*vs/platform/configuration/common/configuration*/,65/*vs/platform/configuration/common/configurationModels*/,5/*vs/base/common/event*/,9/*vs/platform/environment/common/environment*/,2/*vs/base/common/winjs.base*/,17/*vs/base/common/objects*/,130/*vs/platform/configuration/node/configuration*/]), function (require, exports, platform_1, configurationRegistry_1, lifecycle_1, configuration_1, configurationModels_1, event_1, environment_1, winjs_base_1, objects_1, configuration_2) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConfigurationService = /** @class */ (function (_super) {
        __extends(ConfigurationService, _super);
        function ConfigurationService(environmentService) {
            var _this = _super.call(this) || this;
            _this._onDidChangeConfiguration = _this._register(new event_1.Emitter());
            _this.onDidChangeConfiguration = _this._onDidChangeConfiguration.event;
            _this.userConfiguration = _this._register(new configuration_2.UserConfiguration(environmentService.appSettingsPath));
            _this.reset();
            // Listeners
            _this._register(_this.userConfiguration.onDidChangeConfiguration(function () { return _this.onDidChangeUserConfiguration(); }));
            _this._register(platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).onDidRegisterConfiguration(function (configurationProperties) { return _this.onDidRegisterConfiguration(configurationProperties); }));
            return _this;
        }
        Object.defineProperty(ConfigurationService.prototype, "configuration", {
            get: function () {
                return this._configuration;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationService.prototype.getConfigurationData = function () {
            return this.configuration.toData();
        };
        ConfigurationService.prototype.getValue = function (arg1, arg2) {
            var section = typeof arg1 === 'string' ? arg1 : void 0;
            var overrides = configuration_1.isConfigurationOverrides(arg1) ? arg1 : configuration_1.isConfigurationOverrides(arg2) ? arg2 : {};
            return this.configuration.getValue(section, overrides, null);
        };
        ConfigurationService.prototype.updateValue = function (key, value, arg3, arg4) {
            return winjs_base_1.TPromise.wrapError(new Error('not supported'));
        };
        ConfigurationService.prototype.inspect = function (key) {
            return this.configuration.inspect(key, {}, null);
        };
        ConfigurationService.prototype.keys = function () {
            return this.configuration.keys(null);
        };
        ConfigurationService.prototype.reloadConfiguration = function (folder) {
            var _this = this;
            return folder ? winjs_base_1.TPromise.as(null) :
                this.userConfiguration.reload().then(function () { return _this.onDidChangeUserConfiguration(); });
        };
        ConfigurationService.prototype.onDidChangeUserConfiguration = function () {
            var _this = this;
            var changedKeys = [];
            var _a = configuration_1.compare(this._configuration.user, this.userConfiguration.configurationModel), added = _a.added, updated = _a.updated, removed = _a.removed;
            changedKeys = added.concat(updated, removed);
            if (changedKeys.length) {
                var oldConfiguartion_1 = this._configuration;
                this.reset();
                changedKeys = changedKeys.filter(function (key) { return !objects_1.equals(oldConfiguartion_1.getValue(key, {}, null), _this._configuration.getValue(key, {}, null)); });
                if (changedKeys.length) {
                    this.trigger(changedKeys, 1 /* USER */);
                }
            }
        };
        ConfigurationService.prototype.onDidRegisterConfiguration = function (keys) {
            this.reset(); // reset our caches
            this.trigger(keys, 4 /* DEFAULT */);
        };
        ConfigurationService.prototype.reset = function () {
            var defaults = new configurationModels_1.DefaultConfigurationModel();
            var user = this.userConfiguration.configurationModel;
            this._configuration = new configurationModels_1.Configuration(defaults, user);
        };
        ConfigurationService.prototype.trigger = function (keys, source) {
            this._onDidChangeConfiguration.fire(new configurationModels_1.ConfigurationChangeEvent().change(keys).telemetryData(source, this.getTargetConfiguration(source)));
        };
        ConfigurationService.prototype.getTargetConfiguration = function (target) {
            switch (target) {
                case 4 /* DEFAULT */:
                    return this._configuration.defaults.contents;
                case 1 /* USER */:
                    return this._configuration.user.contents;
            }
            return {};
        };
        ConfigurationService = __decorate([
            __param(0, environment_1.IEnvironmentService)
        ], ConfigurationService);
        return ConfigurationService;
    }(lifecycle_1.Disposable));
    exports.ConfigurationService = ConfigurationService;
});

define(__m[42/*vs/platform/request/node/request*/], __M([1/*require*/,0/*exports*/,89/*vs/nls!vs/platform/request/node/request*/,4/*vs/platform/instantiation/common/instantiation*/,43/*vs/platform/configuration/common/configurationRegistry*/,37/*vs/platform/registry/common/platform*/]), function (require, exports, nls_1, instantiation_1, configurationRegistry_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IRequestService = instantiation_1.createDecorator('requestService2');
    platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration)
        .registerConfiguration({
        id: 'http',
        order: 15,
        title: nls_1.localize(0, null),
        type: 'object',
        properties: {
            'http.proxy': {
                type: 'string',
                pattern: '^https?://([^:]*(:[^@]*)?@)?([^:]+)(:\\d+)?/?$|^$',
                description: nls_1.localize(1, null)
            },
            'http.proxyStrictSSL': {
                type: 'boolean',
                default: true,
                description: nls_1.localize(2, null)
            },
            'http.proxyAuthorization': {
                type: ['null', 'string'],
                default: null,
                description: nls_1.localize(3, null)
            }
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[28/*vs/platform/state/common/state*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStateService = instantiation_1.createDecorator('stateService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[27/*vs/platform/lifecycle/electron-main/lifecycleMain*/], __M([1/*require*/,0/*exports*/,8/*electron*/,2/*vs/base/common/winjs.base*/,7/*vs/platform/log/common/log*/,28/*vs/platform/state/common/state*/,5/*vs/base/common/event*/,4/*vs/platform/instantiation/common/instantiation*/,110/*vs/platform/lifecycle/common/lifecycle*/,3/*vs/base/common/platform*/]), function (require, exports, electron_1, winjs_base_1, log_1, state_1, event_1, instantiation_1, lifecycle_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ILifecycleService = instantiation_1.createDecorator('lifecycleService');
    var UnloadReason;
    (function (UnloadReason) {
        UnloadReason[UnloadReason["CLOSE"] = 1] = "CLOSE";
        UnloadReason[UnloadReason["QUIT"] = 2] = "QUIT";
        UnloadReason[UnloadReason["RELOAD"] = 3] = "RELOAD";
        UnloadReason[UnloadReason["LOAD"] = 4] = "LOAD";
    })(UnloadReason = exports.UnloadReason || (exports.UnloadReason = {}));
    var LifecycleService = /** @class */ (function () {
        function LifecycleService(logService, stateService) {
            this.logService = logService;
            this.stateService = stateService;
            this._onBeforeShutdown = new event_1.Emitter();
            this.onBeforeShutdown = this._onBeforeShutdown.event;
            this._onShutdown = new event_1.Emitter();
            this.onShutdown = this._onShutdown.event;
            this._onBeforeWindowClose = new event_1.Emitter();
            this.onBeforeWindowClose = this._onBeforeWindowClose.event;
            this._onBeforeWindowUnload = new event_1.Emitter();
            this.onBeforeWindowUnload = this._onBeforeWindowUnload.event;
            this.windowToCloseRequest = Object.create(null);
            this.quitRequested = false;
            this.oneTimeListenerTokenGenerator = 0;
            this._wasRestarted = false;
            this.windowCounter = 0;
            this.handleRestarted();
        }
        LifecycleService.prototype.handleRestarted = function () {
            this._wasRestarted = !!this.stateService.getItem(LifecycleService.QUIT_FROM_RESTART_MARKER);
            if (this._wasRestarted) {
                this.stateService.removeItem(LifecycleService.QUIT_FROM_RESTART_MARKER); // remove the marker right after if found
            }
        };
        Object.defineProperty(LifecycleService.prototype, "wasRestarted", {
            get: function () {
                return this._wasRestarted;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LifecycleService.prototype, "isQuitRequested", {
            get: function () {
                return !!this.quitRequested;
            },
            enumerable: true,
            configurable: true
        });
        LifecycleService.prototype.ready = function () {
            this.registerListeners();
        };
        LifecycleService.prototype.registerListeners = function () {
            var _this = this;
            // before-quit
            electron_1.app.on('before-quit', function (e) {
                _this.logService.trace('Lifecycle#before-quit');
                if (_this.quitRequested) {
                    _this.logService.trace('Lifecycle#before-quit - returning because quit was already requested');
                    return;
                }
                _this.quitRequested = true;
                // Emit event to indicate that we are about to shutdown
                _this.logService.trace('Lifecycle#onBeforeShutdown.fire()');
                _this._onBeforeShutdown.fire();
                // macOS: can run without any window open. in that case we fire
                // the onShutdown() event directly because there is no veto to be expected.
                if (platform_1.isMacintosh && _this.windowCounter === 0) {
                    _this.logService.trace('Lifecycle#onShutdown.fire()');
                    _this._onShutdown.fire();
                }
            });
            // window-all-closed
            electron_1.app.on('window-all-closed', function () {
                _this.logService.trace('Lifecycle#window-all-closed');
                // Windows/Linux: we quit when all windows have closed
                // Mac: we only quit when quit was requested
                if (_this.quitRequested || process.platform !== 'darwin') {
                    electron_1.app.quit();
                }
            });
        };
        LifecycleService.prototype.registerWindow = function (window) {
            var _this = this;
            // track window count
            this.windowCounter++;
            // Window Before Closing: Main -> Renderer
            window.win.on('close', function (e) {
                var windowId = window.id;
                _this.logService.trace('Lifecycle#window-before-close', windowId);
                // The window already acknowledged to be closed
                if (_this.windowToCloseRequest[windowId]) {
                    _this.logService.trace('Lifecycle#window-close', windowId);
                    delete _this.windowToCloseRequest[windowId];
                    return;
                }
                // Otherwise prevent unload and handle it from window
                e.preventDefault();
                _this.unload(window, 1 /* CLOSE */).then(function (veto) {
                    if (!veto) {
                        _this.windowToCloseRequest[windowId] = true;
                        _this.logService.trace('Lifecycle#onBeforeWindowClose.fire()');
                        _this._onBeforeWindowClose.fire(window);
                        window.close();
                    }
                    else {
                        _this.quitRequested = false;
                        delete _this.windowToCloseRequest[windowId];
                    }
                });
            });
            // Window After Closing
            window.win.on('closed', function (e) {
                var windowId = window.id;
                _this.logService.trace('Lifecycle#window-closed', windowId);
                // update window count
                _this.windowCounter--;
                // if there are no more code windows opened, fire the onShutdown event, unless
                // we are on macOS where it is perfectly fine to close the last window and
                // the application continues running (unless quit was actually requested)
                if (_this.windowCounter === 0 && (!platform_1.isMacintosh || _this.isQuitRequested)) {
                    _this.logService.trace('Lifecycle#onShutdown.fire()');
                    _this._onShutdown.fire();
                }
            });
        };
        LifecycleService.prototype.unload = function (window, reason) {
            var _this = this;
            // Always allow to unload a window that is not yet ready
            if (window.readyState !== 3 /* READY */) {
                return winjs_base_1.TPromise.as(false);
            }
            this.logService.trace('Lifecycle#unload()', window.id);
            var windowUnloadReason = this.quitRequested ? 2 /* QUIT */ : reason;
            // first ask the window itself if it vetos the unload
            return this.onBeforeUnloadWindowInRenderer(window, windowUnloadReason).then(function (veto) {
                if (veto) {
                    _this.logService.trace('Lifecycle#unload(): veto in renderer', window.id);
                    return _this.handleVeto(veto);
                }
                // then check for vetos in the main side
                return _this.onBeforeUnloadWindowInMain(window, windowUnloadReason).then(function (veto) {
                    if (veto) {
                        _this.logService.trace('Lifecycle#unload(): veto in main', window.id);
                        return _this.handleVeto(veto);
                    }
                    else {
                        _this.logService.trace('Lifecycle#unload(): unload continues without veto', window.id);
                    }
                    // finally if there are no vetos, unload the renderer
                    return _this.onWillUnloadWindowInRenderer(window, windowUnloadReason).then(function () { return false; });
                });
            });
        };
        LifecycleService.prototype.handleVeto = function (veto) {
            // Any cancellation also cancels a pending quit if present
            if (veto && this.pendingQuitPromiseComplete) {
                this.pendingQuitPromiseComplete(true /* veto */);
                this.pendingQuitPromiseComplete = null;
                this.pendingQuitPromise = null;
            }
            return veto;
        };
        LifecycleService.prototype.onBeforeUnloadWindowInRenderer = function (window, reason) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c) {
                var oneTimeEventToken = _this.oneTimeListenerTokenGenerator++;
                var okChannel = "vscode:ok" + oneTimeEventToken;
                var cancelChannel = "vscode:cancel" + oneTimeEventToken;
                electron_1.ipcMain.once(okChannel, function () {
                    c(false); // no veto
                });
                electron_1.ipcMain.once(cancelChannel, function () {
                    c(true); // veto
                });
                window.send('vscode:onBeforeUnload', { okChannel: okChannel, cancelChannel: cancelChannel, reason: reason });
            });
        };
        LifecycleService.prototype.onBeforeUnloadWindowInMain = function (window, reason) {
            var _this = this;
            var vetos = [];
            this._onBeforeWindowUnload.fire({
                reason: reason,
                window: window,
                veto: function (value) {
                    vetos.push(value);
                }
            });
            return lifecycle_1.handleVetos(vetos, function (err) { return _this.logService.error(err); });
        };
        LifecycleService.prototype.onWillUnloadWindowInRenderer = function (window, reason) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c) {
                var oneTimeEventToken = _this.oneTimeListenerTokenGenerator++;
                var replyChannel = "vscode:reply" + oneTimeEventToken;
                electron_1.ipcMain.once(replyChannel, function () { return c(void 0); });
                window.send('vscode:onWillUnload', { replyChannel: replyChannel, reason: reason });
            });
        };
        /**
         * A promise that completes to indicate if the quit request has been veto'd
         * by the user or not.
         */
        LifecycleService.prototype.quit = function (fromUpdate) {
            var _this = this;
            this.logService.trace('Lifecycle#quit()');
            if (!this.pendingQuitPromise) {
                this.pendingQuitPromise = new winjs_base_1.TPromise(function (c) {
                    // Store as field to access it from a window cancellation
                    _this.pendingQuitPromiseComplete = c;
                    // The will-quit event is fired when all windows have closed without veto
                    electron_1.app.once('will-quit', function () {
                        _this.logService.trace('Lifecycle#will-quit');
                        if (_this.pendingQuitPromiseComplete) {
                            if (fromUpdate) {
                                _this.stateService.setItem(LifecycleService.QUIT_FROM_RESTART_MARKER, true);
                            }
                            _this.pendingQuitPromiseComplete(false /* no veto */);
                            _this.pendingQuitPromiseComplete = null;
                            _this.pendingQuitPromise = null;
                        }
                    });
                    // Calling app.quit() will trigger the close handlers of each opened window
                    // and only if no window vetoed the shutdown, we will get the will-quit event
                    _this.logService.trace('Lifecycle#quit() - calling app.quit()');
                    electron_1.app.quit();
                });
            }
            else {
                this.logService.trace('Lifecycle#quit() - a pending quit was found');
            }
            return this.pendingQuitPromise;
        };
        LifecycleService.prototype.kill = function (code) {
            this.logService.trace('Lifecycle#kill()');
            electron_1.app.exit(code);
        };
        LifecycleService.prototype.relaunch = function (options) {
            var _this = this;
            this.logService.trace('Lifecycle#relaunch()');
            var args = process.argv.slice(1);
            if (options && options.addArgs) {
                args.push.apply(args, options.addArgs);
            }
            if (options && options.removeArgs) {
                for (var _i = 0, _a = options.removeArgs; _i < _a.length; _i++) {
                    var a = _a[_i];
                    var idx = args.indexOf(a);
                    if (idx >= 0) {
                        args.splice(idx, 1);
                    }
                }
            }
            var vetoed = false;
            electron_1.app.once('quit', function () {
                if (!vetoed) {
                    _this.stateService.setItem(LifecycleService.QUIT_FROM_RESTART_MARKER, true);
                    // Windows: we are about to restart and as such we need to restore the original
                    // current working directory we had on startup to get the exact same startup
                    // behaviour. As such, we briefly change back to the VSCODE_CWD and then when
                    // Code starts it will set it back to the installation directory again.
                    try {
                        if (platform_1.isWindows) {
                            process.chdir(process.env['VSCODE_CWD']);
                        }
                    }
                    catch (err) {
                        _this.logService.error(err);
                    }
                    electron_1.app.relaunch({ args: args });
                }
            });
            this.quit().then(function (veto) {
                vetoed = veto;
            });
        };
        LifecycleService.QUIT_FROM_RESTART_MARKER = 'quit.from.restart'; // use a marker to find out if the session was restarted
        LifecycleService = __decorate([
            __param(0, log_1.ILogService),
            __param(1, state_1.IStateService)
        ], LifecycleService);
        return LifecycleService;
    }());
    exports.LifecycleService = LifecycleService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[135/*vs/code/electron-main/sharedProcess*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/objects*/,52/*vs/base/common/decorators*/,9/*vs/platform/environment/common/environment*/,2/*vs/base/common/winjs.base*/,8/*electron*/,20/*vs/base/common/async*/,7/*vs/platform/log/common/log*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,28/*vs/platform/state/common/state*/,59/*vs/code/electron-main/theme*/]), function (require, exports, objects_1, decorators_1, environment_1, winjs_base_1, electron_1, async_1, log_1, lifecycleMain_1, state_1, theme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SharedProcess = /** @class */ (function () {
        function SharedProcess(machineId, userEnv, environmentService, lifecycleService, stateService, logService) {
            this.machineId = machineId;
            this.userEnv = userEnv;
            this.environmentService = environmentService;
            this.lifecycleService = lifecycleService;
            this.stateService = stateService;
            this.logService = logService;
            this.barrier = new async_1.Barrier();
        }
        Object.defineProperty(SharedProcess.prototype, "_whenReady", {
            get: function () {
                var _this = this;
                this.window = new electron_1.BrowserWindow({
                    show: false,
                    backgroundColor: theme_1.getBackgroundColor(this.stateService),
                    webPreferences: {
                        images: false,
                        webaudio: false,
                        webgl: false,
                        disableBlinkFeatures: 'Auxclick' // do NOT change, allows us to identify this window as shared-process in the process explorer
                    }
                });
                var config = objects_1.assign({
                    appRoot: this.environmentService.appRoot,
                    machineId: this.machineId,
                    nodeCachedDataDir: this.environmentService.nodeCachedDataDir,
                    userEnv: this.userEnv
                });
                var url = require.toUrl('vs/code/electron-browser/sharedProcess/sharedProcess.html') + "?config=" + encodeURIComponent(JSON.stringify(config));
                this.window.loadURL(url);
                // Prevent the window from dying
                var onClose = function (e) {
                    _this.logService.trace('SharedProcess#close prevented');
                    // We never allow to close the shared process unless we get explicitly disposed()
                    e.preventDefault();
                    // Still hide the window though if visible
                    if (_this.window.isVisible()) {
                        _this.window.hide();
                    }
                };
                this.window.on('close', onClose);
                this.lifecycleService.onShutdown(function () {
                    // Shut the shared process down when we are quitting
                    //
                    // Note: because we veto the window close, we must first remove our veto.
                    // Otherwise the application would never quit because the shared process
                    // window is refusing to close!
                    //
                    _this.window.removeListener('close', onClose);
                    // Electron seems to crash on Windows without this setTimeout :|
                    setTimeout(function () {
                        try {
                            _this.window.close();
                        }
                        catch (err) {
                            // ignore, as electron is already shutting down
                        }
                        _this.window = null;
                    }, 0);
                });
                return new winjs_base_1.TPromise(function (c, e) {
                    electron_1.ipcMain.once('handshake:hello', function (_a) {
                        var sender = _a.sender;
                        sender.send('handshake:hey there', {
                            sharedIPCHandle: _this.environmentService.sharedIPCHandle,
                            args: _this.environmentService.args,
                            logLevel: _this.logService.getLevel()
                        });
                        electron_1.ipcMain.once('handshake:im ready', function () { return c(null); });
                    });
                });
            },
            enumerable: true,
            configurable: true
        });
        SharedProcess.prototype.spawn = function () {
            this.barrier.open();
        };
        SharedProcess.prototype.whenReady = function () {
            var _this = this;
            return this.barrier.wait().then(function () { return _this._whenReady; });
        };
        SharedProcess.prototype.toggle = function () {
            if (this.window.isVisible()) {
                this.hide();
            }
            else {
                this.show();
            }
        };
        SharedProcess.prototype.show = function () {
            this.window.show();
            this.window.webContents.openDevTools();
        };
        SharedProcess.prototype.hide = function () {
            this.window.webContents.closeDevTools();
            this.window.hide();
        };
        __decorate([
            decorators_1.memoize
        ], SharedProcess.prototype, "_whenReady", null);
        SharedProcess = __decorate([
            __param(2, environment_1.IEnvironmentService),
            __param(3, lifecycleMain_1.ILifecycleService),
            __param(4, state_1.IStateService),
            __param(5, log_1.ILogService)
        ], SharedProcess);
        return SharedProcess;
    }());
    exports.SharedProcess = SharedProcess;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[136/*vs/platform/state/node/stateService*/], __M([1/*require*/,0/*exports*/,11/*path*/,21/*fs*/,9/*vs/platform/environment/common/environment*/,36/*vs/base/node/extfs*/,22/*vs/base/common/types*/,7/*vs/platform/log/common/log*/]), function (require, exports, path, fs, environment_1, extfs_1, types_1, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var FileStorage = /** @class */ (function () {
        function FileStorage(dbPath, onError) {
            this.dbPath = dbPath;
            this.onError = onError;
            this.database = null;
        }
        FileStorage.prototype.ensureLoaded = function () {
            if (!this.database) {
                this.database = this.loadSync();
            }
        };
        FileStorage.prototype.getItem = function (key, defaultValue) {
            this.ensureLoaded();
            var res = this.database[key];
            if (types_1.isUndefinedOrNull(res)) {
                return defaultValue;
            }
            return res;
        };
        FileStorage.prototype.setItem = function (key, data) {
            this.ensureLoaded();
            // Remove an item when it is undefined or null
            if (types_1.isUndefinedOrNull(data)) {
                return this.removeItem(key);
            }
            // Shortcut for primitives that did not change
            if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
                if (this.database[key] === data) {
                    return;
                }
            }
            this.database[key] = data;
            this.saveSync();
        };
        FileStorage.prototype.removeItem = function (key) {
            this.ensureLoaded();
            // Only update if the key is actually present (not undefined)
            if (!types_1.isUndefined(this.database[key])) {
                this.database[key] = void 0;
                this.saveSync();
            }
        };
        FileStorage.prototype.loadSync = function () {
            try {
                return JSON.parse(fs.readFileSync(this.dbPath).toString()); // invalid JSON or permission issue can happen here
            }
            catch (error) {
                if (error && error.code !== 'ENOENT') {
                    this.onError(error);
                }
                return {};
            }
        };
        FileStorage.prototype.saveSync = function () {
            try {
                extfs_1.writeFileAndFlushSync(this.dbPath, JSON.stringify(this.database, null, 4)); // permission issue can happen here
            }
            catch (error) {
                this.onError(error);
            }
        };
        return FileStorage;
    }());
    exports.FileStorage = FileStorage;
    var StateService = /** @class */ (function () {
        function StateService(environmentService, logService) {
            this.fileStorage = new FileStorage(path.join(environmentService.userDataPath, 'storage.json'), function (error) { return logService.error(error); });
        }
        StateService.prototype.getItem = function (key, defaultValue) {
            return this.fileStorage.getItem(key, defaultValue);
        };
        StateService.prototype.setItem = function (key, data) {
            this.fileStorage.setItem(key, data);
        };
        StateService.prototype.removeItem = function (key) {
            this.fileStorage.removeItem(key);
        };
        StateService = __decorate([
            __param(0, environment_1.IEnvironmentService), __param(1, log_1.ILogService)
        ], StateService);
        return StateService;
    }());
    exports.StateService = StateService;
});

define(__m[29/*vs/platform/telemetry/common/telemetry*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ITelemetryService = instantiation_1.createDecorator('telemetryService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[138/*vs/platform/telemetry/common/telemetryService*/], __M([1/*require*/,0/*exports*/,90/*vs/nls!vs/platform/telemetry/common/telemetryService*/,18/*vs/base/common/strings*/,4/*vs/platform/instantiation/common/instantiation*/,14/*vs/platform/configuration/common/configuration*/,43/*vs/platform/configuration/common/configurationRegistry*/,2/*vs/base/common/winjs.base*/,13/*vs/base/common/lifecycle*/,17/*vs/base/common/objects*/,37/*vs/platform/registry/common/platform*/]), function (require, exports, nls_1, strings_1, instantiation_1, configuration_1, configurationRegistry_1, winjs_base_1, lifecycle_1, objects_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TelemetryService = /** @class */ (function () {
        function TelemetryService(config, _configurationService) {
            this._configurationService = _configurationService;
            this._disposables = [];
            this._cleanupPatterns = [];
            this._appender = config.appender;
            this._commonProperties = config.commonProperties || winjs_base_1.TPromise.as({});
            this._piiPaths = config.piiPaths || [];
            this._userOptIn = true;
            // static cleanup pattern for: `file:///DANGEROUS/PATH/resources/app/Useful/Information`
            this._cleanupPatterns = [/file:\/\/\/.*?\/resources\/app\//gi];
            for (var _i = 0, _a = this._piiPaths; _i < _a.length; _i++) {
                var piiPath = _a[_i];
                this._cleanupPatterns.push(new RegExp(strings_1.escapeRegExpCharacters(piiPath), 'gi'));
            }
            if (this._configurationService) {
                this._updateUserOptIn();
                this._configurationService.onDidChangeConfiguration(this._updateUserOptIn, this, this._disposables);
                /* __GDPR__
                    "optInStatus" : {
                        "optIn" : { "classification": "SystemMetaData", "purpose": "BusinessInsight", "isMeasurement": true }
                    }
                */
                this.publicLog('optInStatus', { optIn: this._userOptIn });
            }
        }
        TelemetryService.prototype._updateUserOptIn = function () {
            var config = this._configurationService.getValue(TELEMETRY_SECTION_ID);
            this._userOptIn = config ? config.enableTelemetry : this._userOptIn;
        };
        Object.defineProperty(TelemetryService.prototype, "isOptedIn", {
            get: function () {
                return this._userOptIn;
            },
            enumerable: true,
            configurable: true
        });
        TelemetryService.prototype.getTelemetryInfo = function () {
            return this._commonProperties.then(function (values) {
                // well known properties
                var sessionId = values['sessionID'];
                var instanceId = values['common.instanceId'];
                var machineId = values['common.machineId'];
                return { sessionId: sessionId, instanceId: instanceId, machineId: machineId };
            });
        };
        TelemetryService.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        TelemetryService.prototype.publicLog = function (eventName, data, anonymizeFilePaths) {
            var _this = this;
            // don't send events when the user is optout
            if (!this._userOptIn) {
                return winjs_base_1.TPromise.as(undefined);
            }
            return this._commonProperties.then(function (values) {
                // (first) add common properties
                data = objects_1.mixin(data, values);
                // (last) remove all PII from data
                data = objects_1.cloneAndChange(data, function (value) {
                    if (typeof value === 'string') {
                        return _this._cleanupInfo(value, anonymizeFilePaths);
                    }
                    return undefined;
                });
                _this._appender.log(eventName, data);
            }, function (err) {
                // unsure what to do now...
                console.error(err);
            });
        };
        TelemetryService.prototype._cleanupInfo = function (stack, anonymizeFilePaths) {
            var updatedStack = stack;
            if (anonymizeFilePaths) {
                var cleanUpIndexes = [];
                for (var _i = 0, _a = this._cleanupPatterns; _i < _a.length; _i++) {
                    var regexp = _a[_i];
                    while (true) {
                        var result = regexp.exec(stack);
                        if (!result) {
                            break;
                        }
                        cleanUpIndexes.push([result.index, regexp.lastIndex]);
                    }
                }
                var nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
                var fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
                var _loop_1 = function () {
                    var result = fileRegex.exec(stack);
                    if (!result) {
                        return "break";
                    }
                    // Anoynimize user file paths that do not need to be retained or cleaned up.
                    if (!nodeModulesRegex.test(result[0]) && cleanUpIndexes.every(function (_a) {
                        var x = _a[0], y = _a[1];
                        return result.index < x || result.index >= y;
                    })) {
                        updatedStack = updatedStack.slice(0, result.index) + result[0].replace(/./g, 'a') + updatedStack.slice(fileRegex.lastIndex);
                    }
                };
                while (true) {
                    var state_1 = _loop_1();
                    if (state_1 === "break")
                        break;
                }
            }
            // sanitize with configured cleanup patterns
            for (var _b = 0, _c = this._cleanupPatterns; _b < _c.length; _b++) {
                var regexp = _c[_b];
                updatedStack = updatedStack.replace(regexp, '');
            }
            return updatedStack;
        };
        TelemetryService.IDLE_START_EVENT_NAME = 'UserIdleStart';
        TelemetryService.IDLE_STOP_EVENT_NAME = 'UserIdleStop';
        TelemetryService = __decorate([
            __param(1, instantiation_1.optional(configuration_1.IConfigurationService))
        ], TelemetryService);
        return TelemetryService;
    }());
    exports.TelemetryService = TelemetryService;
    var TELEMETRY_SECTION_ID = 'telemetry';
    platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).registerConfiguration({
        'id': TELEMETRY_SECTION_ID,
        'order': 110,
        'type': 'object',
        'title': nls_1.localize(0, null),
        'properties': {
            'telemetry.enableTelemetry': {
                'type': 'boolean',
                'description': nls_1.localize(1, null),
                'default': false,
                'tags': ['usesOnlineServices']
            }
        }
    });
});










define(__m[139/*vs/platform/telemetry/common/telemetryUtils*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,122/*vs/base/common/mime*/,15/*vs/base/common/paths*/,14/*vs/platform/configuration/common/configuration*/,7/*vs/platform/log/common/log*/]), function (require, exports, winjs_base_1, mime_1, paths, configuration_1, log_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullTelemetryService = new /** @class */ (function () {
        function class_1() {
        }
        class_1.prototype.publicLog = function (eventName, data) {
            return winjs_base_1.TPromise.wrap(null);
        };
        class_1.prototype.getTelemetryInfo = function () {
            return winjs_base_1.TPromise.wrap({
                instanceId: 'someValue.instanceId',
                sessionId: 'someValue.sessionId',
                machineId: 'someValue.machineId'
            });
        };
        return class_1;
    }());
    function combinedAppender() {
        var appenders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            appenders[_i] = arguments[_i];
        }
        return {
            log: function (e, d) { return appenders.forEach(function (a) { return a.log(e, d); }); },
            dispose: function () { return winjs_base_1.TPromise.join(appenders.map(function (a) { return a.dispose(); })); }
        };
    }
    exports.combinedAppender = combinedAppender;
    exports.NullAppender = { log: function () { return null; }, dispose: function () { return winjs_base_1.TPromise.as(null); } };
    var LogAppender = /** @class */ (function () {
        function LogAppender(_logService) {
            this._logService = _logService;
            this.commonPropertiesRegex = /^sessionID$|^version$|^timestamp$|^commitHash$|^common\./;
        }
        LogAppender.prototype.dispose = function () {
            return winjs_base_1.TPromise.as(undefined);
        };
        LogAppender.prototype.log = function (eventName, data) {
            var _this = this;
            var strippedData = {};
            Object.keys(data).forEach(function (key) {
                if (!_this.commonPropertiesRegex.test(key)) {
                    strippedData[key] = data[key];
                }
            });
            this._logService.trace("telemetry/" + eventName, strippedData);
        };
        LogAppender = __decorate([
            __param(0, log_1.ILogService)
        ], LogAppender);
        return LogAppender;
    }());
    exports.LogAppender = LogAppender;
    function telemetryURIDescriptor(uri, hashPath) {
        var fsPath = uri && uri.fsPath;
        return fsPath ? { mimeType: mime_1.guessMimeTypes(fsPath).join(', '), ext: paths.extname(fsPath), path: hashPath(fsPath) } : {};
    }
    exports.telemetryURIDescriptor = telemetryURIDescriptor;
    /**
     * Only add settings that cannot contain any personal/private information of users (PII).
     */
    var configurationValueWhitelist = [
        'editor.tabCompletion',
        'editor.fontFamily',
        'editor.fontWeight',
        'editor.fontSize',
        'editor.lineHeight',
        'editor.letterSpacing',
        'editor.lineNumbers',
        'editor.rulers',
        'editor.wordSeparators',
        'editor.tabSize',
        'editor.insertSpaces',
        'editor.detectIndentation',
        'editor.roundedSelection',
        'editor.scrollBeyondLastLine',
        'editor.minimap.enabled',
        'editor.minimap.side',
        'editor.minimap.renderCharacters',
        'editor.minimap.maxColumn',
        'editor.find.seedSearchStringFromSelection',
        'editor.find.autoFindInSelection',
        'editor.wordWrap',
        'editor.wordWrapColumn',
        'editor.wrappingIndent',
        'editor.mouseWheelScrollSensitivity',
        'editor.multiCursorModifier',
        'editor.quickSuggestions',
        'editor.quickSuggestionsDelay',
        'editor.parameterHints.enabled',
        'editor.parameterHints.cycle',
        'editor.autoClosingBrackets',
        'editor.autoClosingQuotes',
        'editor.autoSurround',
        'editor.autoIndent',
        'editor.formatOnType',
        'editor.formatOnPaste',
        'editor.suggestOnTriggerCharacters',
        'editor.acceptSuggestionOnEnter',
        'editor.acceptSuggestionOnCommitCharacter',
        'editor.snippetSuggestions',
        'editor.emptySelectionClipboard',
        'editor.wordBasedSuggestions',
        'editor.suggestSelection',
        'editor.suggestFontSize',
        'editor.suggestLineHeight',
        'editor.selectionHighlight',
        'editor.occurrencesHighlight',
        'editor.overviewRulerLanes',
        'editor.overviewRulerBorder',
        'editor.cursorBlinking',
        'editor.cursorStyle',
        'editor.mouseWheelZoom',
        'editor.fontLigatures',
        'editor.hideCursorInOverviewRuler',
        'editor.renderWhitespace',
        'editor.renderControlCharacters',
        'editor.renderIndentGuides',
        'editor.renderLineHighlight',
        'editor.codeLens',
        'editor.folding',
        'editor.showFoldingControls',
        'editor.matchBrackets',
        'editor.glyphMargin',
        'editor.useTabStops',
        'editor.trimAutoWhitespace',
        'editor.stablePeek',
        'editor.dragAndDrop',
        'editor.formatOnSave',
        'editor.colorDecorators',
        'breadcrumbs.enabled',
        'breadcrumbs.filePath',
        'breadcrumbs.symbolPath',
        'breadcrumbs.useQuickPick',
        'explorer.openEditors.visible',
        'extensions.autoUpdate',
        'files.associations',
        'files.autoGuessEncoding',
        'files.autoSave',
        'files.autoSaveDelay',
        'files.encoding',
        'files.eol',
        'files.hotExit',
        'files.trimTrailingWhitespace',
        'git.confirmSync',
        'git.enabled',
        'http.proxyStrictSSL',
        'javascript.validate.enable',
        'php.builtInCompletions.enable',
        'php.validate.enable',
        'php.validate.run',
        'terminal.integrated.fontFamily',
        'window.openFilesInNewWindow',
        'window.restoreWindows',
        'window.zoomLevel',
        'workbench.editor.enablePreview',
        'workbench.editor.enablePreviewFromQuickOpen',
        'workbench.editor.showTabs',
        'workbench.editor.swipeToNavigate',
        'workbench.sideBar.location',
        'workbench.startupEditor',
        'workbench.statusBar.visible',
        'workbench.welcome.enabled',
    ];
    function configurationTelemetry(telemetryService, configurationService) {
        return configurationService.onDidChangeConfiguration(function (event) {
            if (event.source !== 4 /* DEFAULT */) {
                /* __GDPR__
                    "updateConfiguration" : {
                        "configurationSource" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "configurationKeys": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateConfiguration', {
                    configurationSource: configuration_1.ConfigurationTargetToString(event.source),
                    configurationKeys: flattenKeys(event.sourceConfig)
                });
                /* __GDPR__
                    "updateConfigurationValues" : {
                        "configurationSource" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                        "configurationValues": { "classification": "CustomerContent", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateConfigurationValues', {
                    configurationSource: configuration_1.ConfigurationTargetToString(event.source),
                    configurationValues: flattenValues(event.sourceConfig, configurationValueWhitelist)
                });
            }
        });
    }
    exports.configurationTelemetry = configurationTelemetry;
    function keybindingsTelemetry(telemetryService, keybindingService) {
        return keybindingService.onDidUpdateKeybindings(function (event) {
            if (event.source === 2 /* User */ && event.keybindings) {
                /* __GDPR__
                    "updateKeybindings" : {
                        "bindings": { "classification": "CustomerContent", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('updateKeybindings', {
                    bindings: event.keybindings.map(function (binding) { return ({
                        key: binding.key,
                        command: binding.command,
                        when: binding.when,
                        args: binding.args ? true : undefined
                    }); })
                });
            }
        });
    }
    exports.keybindingsTelemetry = keybindingsTelemetry;
    function flattenKeys(value) {
        if (!value) {
            return [];
        }
        var result = [];
        flatKeys(result, '', value);
        return result;
    }
    function flatKeys(result, prefix, value) {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            Object.keys(value)
                .forEach(function (key) { return flatKeys(result, prefix ? prefix + "." + key : key, value[key]); });
        }
        else {
            result.push(prefix);
        }
    }
    function flattenValues(value, keys) {
        if (!value) {
            return [];
        }
        return keys.reduce(function (array, key) {
            var _a;
            var v = key.split('.')
                .reduce(function (tmp, k) { return tmp && typeof tmp === 'object' ? tmp[k] : undefined; }, value);
            if (typeof v !== 'undefined') {
                array.push((_a = {}, _a[key] = v, _a));
            }
            return array;
        }, []);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[140/*vs/platform/telemetry/node/commonProperties*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/platform*/,26/*os*/,39/*vs/base/common/uuid*/,34/*vs/base/node/pfs*/]), function (require, exports, Platform, os, uuid, pfs_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function resolveCommonProperties(commit, version, machineId, installSourcePath) {
        var result = Object.create(null);
        // __GDPR__COMMON__ "common.machineId" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
        result['common.machineId'] = machineId;
        // __GDPR__COMMON__ "sessionID" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['sessionID'] = uuid.generateUuid() + Date.now();
        // __GDPR__COMMON__ "commitHash" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['commitHash'] = commit;
        // __GDPR__COMMON__ "version" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['version'] = version;
        // __GDPR__COMMON__ "common.platformVersion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['common.platformVersion'] = (os.release() || '').replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, '$1$2$3');
        // __GDPR__COMMON__ "common.platform" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
        result['common.platform'] = Platform.PlatformToString(Platform.platform);
        // __GDPR__COMMON__ "common.nodePlatform" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['common.nodePlatform'] = process.platform;
        // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth" }
        result['common.nodeArch'] = process.arch;
        // dynamic properties which value differs on each call
        var seq = 0;
        var startTime = Date.now();
        Object.defineProperties(result, {
            // __GDPR__COMMON__ "timestamp" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            'timestamp': {
                get: function () { return new Date(); },
                enumerable: true
            },
            // __GDPR__COMMON__ "common.timesincesessionstart" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
            'common.timesincesessionstart': {
                get: function () { return Date.now() - startTime; },
                enumerable: true
            },
            // __GDPR__COMMON__ "common.sequence" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
            'common.sequence': {
                get: function () { return seq++; },
                enumerable: true
            }
        });
        return pfs_1.readFile(installSourcePath, 'utf8').then(function (contents) {
            // __GDPR__COMMON__ "common.source" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
            result['common.source'] = contents.slice(0, 30);
            return result;
        }, function (error) {
            return result;
        });
    }
    exports.resolveCommonProperties = resolveCommonProperties;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[141/*vs/platform/telemetry/node/telemetryIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var TelemetryAppenderChannel = /** @class */ (function () {
        function TelemetryAppenderChannel(appender) {
            this.appender = appender;
        }
        TelemetryAppenderChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        TelemetryAppenderChannel.prototype.call = function (command, _a) {
            var eventName = _a.eventName, data = _a.data;
            this.appender.log(eventName, data);
            return winjs_base_1.TPromise.as(null);
        };
        return TelemetryAppenderChannel;
    }());
    exports.TelemetryAppenderChannel = TelemetryAppenderChannel;
    var TelemetryAppenderClient = /** @class */ (function () {
        function TelemetryAppenderClient(channel) {
            this.channel = channel;
        }
        TelemetryAppenderClient.prototype.log = function (eventName, data) {
            this.channel.call('log', { eventName: eventName, data: data })
                .then(null, function (err) { return "Failed to log telemetry: " + console.warn(err); });
            return winjs_base_1.TPromise.as(null);
        };
        TelemetryAppenderClient.prototype.dispose = function () {
            // TODO
        };
        return TelemetryAppenderClient;
    }());
    exports.TelemetryAppenderClient = TelemetryAppenderClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[33/*vs/platform/update/common/update*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Updates are run as a state machine:
     *
     *      Uninitialized
     *           
     *          Idle
     *            
     *   Checking for Updates    Available for Download
     *         
     *     Downloading     Ready
     *                        
     *     Downloaded     Updating
     *
     * Available: There is an update available for download (linux).
     * Ready: Code will be updated as soon as it restarts (win32, darwin).
     * Donwloaded: There is an update ready to be installed in the background (win32).
     */
    var StateType;
    (function (StateType) {
        StateType["Uninitialized"] = "uninitialized";
        StateType["Idle"] = "idle";
        StateType["CheckingForUpdates"] = "checking for updates";
        StateType["AvailableForDownload"] = "available for download";
        StateType["Downloading"] = "downloading";
        StateType["Downloaded"] = "downloaded";
        StateType["Updating"] = "updating";
        StateType["Ready"] = "ready";
    })(StateType = exports.StateType || (exports.StateType = {}));
    var UpdateType;
    (function (UpdateType) {
        UpdateType[UpdateType["Setup"] = 0] = "Setup";
        UpdateType[UpdateType["Archive"] = 1] = "Archive";
    })(UpdateType = exports.UpdateType || (exports.UpdateType = {}));
    exports.State = {
        Uninitialized: { type: "uninitialized" /* Uninitialized */ },
        Idle: function (updateType) { return ({ type: "idle" /* Idle */, updateType: updateType }); },
        CheckingForUpdates: function (context) { return ({ type: "checking for updates" /* CheckingForUpdates */, context: context }); },
        AvailableForDownload: function (update) { return ({ type: "available for download" /* AvailableForDownload */, update: update }); },
        Downloading: function (update) { return ({ type: "downloading" /* Downloading */, update: update }); },
        Downloaded: function (update) { return ({ type: "downloaded" /* Downloaded */, update: update }); },
        Updating: function (update) { return ({ type: "updating" /* Updating */, update: update }); },
        Ready: function (update) { return ({ type: "ready" /* Ready */, update: update }); },
    };
    exports.IUpdateService = instantiation_1.createDecorator('updateService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[60/*vs/platform/update/electron-main/abstractUpdateService*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/event*/,20/*vs/base/common/async*/,14/*vs/platform/configuration/common/configuration*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,16/*vs/platform/node/product*/,2/*vs/base/common/winjs.base*/,33/*vs/platform/update/common/update*/,9/*vs/platform/environment/common/environment*/,7/*vs/platform/log/common/log*/,42/*vs/platform/request/node/request*/,35/*vs/base/common/cancellation*/]), function (require, exports, event_1, async_1, configuration_1, lifecycleMain_1, product_1, winjs_base_1, update_1, environment_1, log_1, request_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createUpdateURL(platform, quality) {
        return product_1.default.updateUrl + "/api/update/" + platform + "/" + quality + "/" + product_1.default.commit;
    }
    exports.createUpdateURL = createUpdateURL;
    var AbstractUpdateService = /** @class */ (function () {
        function AbstractUpdateService(lifecycleService, configurationService, environmentService, requestService, logService) {
            var _this = this;
            this.lifecycleService = lifecycleService;
            this.configurationService = configurationService;
            this.environmentService = environmentService;
            this.requestService = requestService;
            this.logService = logService;
            this._state = update_1.State.Uninitialized;
            this.throttler = new async_1.Throttler();
            this._onStateChange = new event_1.Emitter();
            if (this.environmentService.disableUpdates) {
                this.logService.info('update#ctor - updates are disabled');
                return;
            }
            if (!product_1.default.updateUrl || !product_1.default.commit) {
                this.logService.info('update#ctor - updates are disabled');
                return;
            }
            var quality = this.getProductQuality();
            if (!quality) {
                this.logService.info('update#ctor - updates are disabled');
                return;
            }
            this.url = this.buildUpdateFeedUrl(quality);
            if (!this.url) {
                this.logService.info('update#ctor - updates are disabled');
                return;
            }
            this.setState(update_1.State.Idle(this.getUpdateType()));
            // Start checking for updates after 30 seconds
            this.scheduleCheckForUpdates(30 * 1000).then(null, function (err) { return _this.logService.error(err); });
        }
        Object.defineProperty(AbstractUpdateService.prototype, "onStateChange", {
            get: function () { return this._onStateChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractUpdateService.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        AbstractUpdateService.prototype.setState = function (state) {
            this.logService.info('update#setState', state.type);
            this._state = state;
            this._onStateChange.fire(state);
        };
        AbstractUpdateService.prototype.getProductQuality = function () {
            var quality = this.configurationService.getValue('update.channel');
            return quality === 'none' ? null : product_1.default.quality;
        };
        AbstractUpdateService.prototype.scheduleCheckForUpdates = function (delay) {
            var _this = this;
            if (delay === void 0) { delay = 60 * 60 * 1000; }
            return async_1.timeout(delay)
                .then(function () { return _this.checkForUpdates(null); })
                .then(function (update) {
                if (update) {
                    // Update found, no need to check more
                    return winjs_base_1.TPromise.as(null);
                }
                // Check again after 1 hour
                return _this.scheduleCheckForUpdates(60 * 60 * 1000);
            });
        };
        AbstractUpdateService.prototype.checkForUpdates = function (context) {
            var _this = this;
            this.logService.trace('update#checkForUpdates, state = ', this.state.type);
            if (this.state.type !== "idle" /* Idle */) {
                return winjs_base_1.TPromise.as(null);
            }
            return this.throttler.queue(function () { return winjs_base_1.TPromise.as(_this.doCheckForUpdates(context)); });
        };
        AbstractUpdateService.prototype.downloadUpdate = function () {
            this.logService.trace('update#downloadUpdate, state = ', this.state.type);
            if (this.state.type !== "available for download" /* AvailableForDownload */) {
                return winjs_base_1.TPromise.as(null);
            }
            return this.doDownloadUpdate(this.state);
        };
        AbstractUpdateService.prototype.doDownloadUpdate = function (state) {
            return winjs_base_1.TPromise.as(null);
        };
        AbstractUpdateService.prototype.applyUpdate = function () {
            this.logService.trace('update#applyUpdate, state = ', this.state.type);
            if (this.state.type !== "downloaded" /* Downloaded */) {
                return winjs_base_1.TPromise.as(null);
            }
            return this.doApplyUpdate();
        };
        AbstractUpdateService.prototype.doApplyUpdate = function () {
            return winjs_base_1.TPromise.as(null);
        };
        AbstractUpdateService.prototype.quitAndInstall = function () {
            var _this = this;
            this.logService.trace('update#quitAndInstall, state = ', this.state.type);
            if (this.state.type !== "ready" /* Ready */) {
                return winjs_base_1.TPromise.as(null);
            }
            this.logService.trace('update#quitAndInstall(): before lifecycle quit()');
            this.lifecycleService.quit(true /* from update */).then(function (vetod) {
                _this.logService.trace("update#quitAndInstall(): after lifecycle quit() with veto: " + vetod);
                if (vetod) {
                    return;
                }
                _this.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');
                _this.doQuitAndInstall();
            });
            return winjs_base_1.TPromise.as(null);
        };
        AbstractUpdateService.prototype.isLatestVersion = function () {
            if (!this.url) {
                return winjs_base_1.TPromise.as(undefined);
            }
            return this.requestService.request({ url: this.url }, cancellation_1.CancellationToken.None).then(function (context) {
                // The update server replies with 204 (No Content) when no
                // update is available - that's all we want to know.
                if (context.res.statusCode === 204) {
                    return true;
                }
                else {
                    return false;
                }
            });
        };
        AbstractUpdateService.prototype.getUpdateType = function () {
            return 1 /* Archive */;
        };
        AbstractUpdateService.prototype.doQuitAndInstall = function () {
            // noop
        };
        AbstractUpdateService = __decorate([
            __param(0, lifecycleMain_1.ILifecycleService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, request_1.IRequestService),
            __param(4, log_1.ILogService)
        ], AbstractUpdateService);
        return AbstractUpdateService;
    }());
    exports.AbstractUpdateService = AbstractUpdateService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[144/*vs/platform/update/electron-main/updateService.darwin*/], __M([1/*require*/,0/*exports*/,8/*electron*/,13/*vs/base/common/lifecycle*/,5/*vs/base/common/event*/,52/*vs/base/common/decorators*/,14/*vs/platform/configuration/common/configuration*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,33/*vs/platform/update/common/update*/,29/*vs/platform/telemetry/common/telemetry*/,9/*vs/platform/environment/common/environment*/,7/*vs/platform/log/common/log*/,60/*vs/platform/update/electron-main/abstractUpdateService*/,42/*vs/platform/request/node/request*/]), function (require, exports, electron, lifecycle_1, event_1, decorators_1, configuration_1, lifecycleMain_1, update_1, telemetry_1, environment_1, log_1, abstractUpdateService_1, request_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DarwinUpdateService = /** @class */ (function (_super) {
        __extends(DarwinUpdateService, _super);
        function DarwinUpdateService(lifecycleService, configurationService, telemetryService, environmentService, requestService, logService) {
            var _this = _super.call(this, lifecycleService, configurationService, environmentService, requestService, logService) || this;
            _this.telemetryService = telemetryService;
            _this.disposables = [];
            _this.onRawError(_this.onError, _this, _this.disposables);
            _this.onRawUpdateAvailable(_this.onUpdateAvailable, _this, _this.disposables);
            _this.onRawUpdateDownloaded(_this.onUpdateDownloaded, _this, _this.disposables);
            _this.onRawUpdateNotAvailable(_this.onUpdateNotAvailable, _this, _this.disposables);
            return _this;
        }
        Object.defineProperty(DarwinUpdateService.prototype, "onRawError", {
            get: function () { return event_1.fromNodeEventEmitter(electron.autoUpdater, 'error', function (_, message) { return message; }); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DarwinUpdateService.prototype, "onRawUpdateNotAvailable", {
            get: function () { return event_1.fromNodeEventEmitter(electron.autoUpdater, 'update-not-available'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DarwinUpdateService.prototype, "onRawUpdateAvailable", {
            get: function () { return event_1.fromNodeEventEmitter(electron.autoUpdater, 'update-available', function (_, url, version) { return ({ url: url, version: version, productVersion: version }); }); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DarwinUpdateService.prototype, "onRawUpdateDownloaded", {
            get: function () { return event_1.fromNodeEventEmitter(electron.autoUpdater, 'update-downloaded', function (_, releaseNotes, version, date) { return ({ releaseNotes: releaseNotes, version: version, productVersion: version, date: date }); }); },
            enumerable: true,
            configurable: true
        });
        DarwinUpdateService.prototype.onError = function (err) {
            this.logService.error('UpdateService error: ', err);
            this.setState(update_1.State.Idle(1 /* Archive */));
        };
        DarwinUpdateService.prototype.buildUpdateFeedUrl = function (quality) {
            var url = abstractUpdateService_1.createUpdateURL('darwin', quality);
            try {
                electron.autoUpdater.setFeedURL({ url: url });
            }
            catch (e) {
                // application is very likely not signed
                this.logService.error('Failed to set update feed URL', e);
                return undefined;
            }
            return url;
        };
        DarwinUpdateService.prototype.doCheckForUpdates = function (context) {
            this.setState(update_1.State.CheckingForUpdates(context));
            electron.autoUpdater.checkForUpdates();
        };
        DarwinUpdateService.prototype.onUpdateAvailable = function (update) {
            if (this.state.type !== "checking for updates" /* CheckingForUpdates */) {
                return;
            }
            this.setState(update_1.State.Downloading(update));
        };
        DarwinUpdateService.prototype.onUpdateDownloaded = function (update) {
            if (this.state.type !== "downloading" /* Downloading */) {
                return;
            }
            /* __GDPR__
                "update:downloaded" : {
                    "version" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('update:downloaded', { version: update.version });
            this.setState(update_1.State.Ready(update));
        };
        DarwinUpdateService.prototype.onUpdateNotAvailable = function () {
            if (this.state.type !== "checking for updates" /* CheckingForUpdates */) {
                return;
            }
            /* __GDPR__
                    "update:notAvailable" : {
                        "explicit" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                    }
                */
            this.telemetryService.publicLog('update:notAvailable', { explicit: !!this.state.context });
            this.setState(update_1.State.Idle(1 /* Archive */));
        };
        DarwinUpdateService.prototype.doQuitAndInstall = function () {
            // for some reason updating on Mac causes the local storage not to be flushed.
            // we workaround this issue by forcing an explicit flush of the storage data.
            // see also https://github.com/Microsoft/vscode/issues/172
            this.logService.trace('update#quitAndInstall(): calling flushStorageData()');
            electron.session.defaultSession.flushStorageData();
            this.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');
            electron.autoUpdater.quitAndInstall();
        };
        DarwinUpdateService.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        __decorate([
            decorators_1.memoize
        ], DarwinUpdateService.prototype, "onRawError", null);
        __decorate([
            decorators_1.memoize
        ], DarwinUpdateService.prototype, "onRawUpdateNotAvailable", null);
        __decorate([
            decorators_1.memoize
        ], DarwinUpdateService.prototype, "onRawUpdateAvailable", null);
        __decorate([
            decorators_1.memoize
        ], DarwinUpdateService.prototype, "onRawUpdateDownloaded", null);
        DarwinUpdateService = __decorate([
            __param(0, lifecycleMain_1.ILifecycleService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, telemetry_1.ITelemetryService),
            __param(3, environment_1.IEnvironmentService),
            __param(4, request_1.IRequestService),
            __param(5, log_1.ILogService)
        ], DarwinUpdateService);
        return DarwinUpdateService;
    }(abstractUpdateService_1.AbstractUpdateService));
    exports.DarwinUpdateService = DarwinUpdateService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[145/*vs/platform/update/node/update.config.contribution*/], __M([1/*require*/,0/*exports*/,91/*vs/nls!vs/platform/update/node/update.config.contribution*/,37/*vs/platform/registry/common/platform*/,43/*vs/platform/configuration/common/configurationRegistry*/]), function (require, exports, nls, platform_1, configurationRegistry_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    configurationRegistry.registerConfiguration({
        'id': 'update',
        'order': 15,
        'title': nls.localize(0, null),
        'type': 'object',
        'properties': {
            'update.channel': {
                'type': 'string',
                'enum': ['none', 'default'],
                'default': 'default',
                'scope': 1 /* APPLICATION */,
                'description': nls.localize(1, null),
                'tags': ['usesOnlineServices']
            },
            'update.enableWindowsBackgroundUpdates': {
                'type': 'boolean',
                'default': true,
                'scope': 1 /* APPLICATION */,
                'description': nls.localize(2, null),
                'tags': ['usesOnlineServices']
            },
            'update.showReleaseNotes': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(3, null),
                'tags': ['usesOnlineServices']
            }
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[146/*vs/code/code.main*/], __M([1/*require*/,0/*exports*/,145/*vs/platform/update/node/update.config.contribution*/]), function (require, exports) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[147/*vs/platform/update/node/updateIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/base/common/event*/,33/*vs/platform/update/common/update*/]), function (require, exports, winjs_base_1, event_1, update_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var UpdateChannel = /** @class */ (function () {
        function UpdateChannel(service) {
            this.service = service;
        }
        UpdateChannel.prototype.listen = function (event, arg) {
            switch (event) {
                case 'onStateChange': return this.service.onStateChange;
            }
            throw new Error('No event found');
        };
        UpdateChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'checkForUpdates': return this.service.checkForUpdates(arg);
                case 'downloadUpdate': return this.service.downloadUpdate();
                case 'applyUpdate': return this.service.applyUpdate();
                case 'quitAndInstall': return this.service.quitAndInstall();
                case '_getInitialState': return winjs_base_1.TPromise.as(this.service.state);
                case 'isLatestVersion': return this.service.isLatestVersion();
            }
            return undefined;
        };
        return UpdateChannel;
    }());
    exports.UpdateChannel = UpdateChannel;
    var UpdateChannelClient = /** @class */ (function () {
        function UpdateChannelClient(channel) {
            var _this = this;
            this.channel = channel;
            this._onStateChange = new event_1.Emitter();
            this._state = update_1.State.Uninitialized;
            // always set this._state as the state changes
            this.onStateChange(function (state) { return _this._state = state; });
            channel.call('_getInitialState').then(function (state) {
                // fire initial state
                _this._onStateChange.fire(state);
                // fire subsequent states as they come in from remote
                _this.channel.listen('onStateChange')(function (state) { return _this._onStateChange.fire(state); });
            });
        }
        Object.defineProperty(UpdateChannelClient.prototype, "onStateChange", {
            get: function () { return this._onStateChange.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UpdateChannelClient.prototype, "state", {
            get: function () { return this._state; },
            enumerable: true,
            configurable: true
        });
        UpdateChannelClient.prototype.checkForUpdates = function (context) {
            return this.channel.call('checkForUpdates', context);
        };
        UpdateChannelClient.prototype.downloadUpdate = function () {
            return this.channel.call('downloadUpdate');
        };
        UpdateChannelClient.prototype.applyUpdate = function () {
            return this.channel.call('applyUpdate');
        };
        UpdateChannelClient.prototype.quitAndInstall = function () {
            return this.channel.call('quitAndInstall');
        };
        UpdateChannelClient.prototype.isLatestVersion = function () {
            return this.channel.call('isLatestVersion');
        };
        return UpdateChannelClient;
    }());
    exports.UpdateChannelClient = UpdateChannelClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[49/*vs/platform/url/common/url*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ID = 'urlService';
    exports.IURLService = instantiation_1.createDecorator(exports.ID);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/













define(__m[149/*vs/platform/url/common/urlService*/], __M([1/*require*/,0/*exports*/,13/*vs/base/common/lifecycle*/,20/*vs/base/common/async*/]), function (require, exports, lifecycle_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var URLService = /** @class */ (function () {
        function URLService() {
            this.handlers = new Set();
        }
        URLService.prototype.open = function (uri) {
            var handlers = Array.from(this.handlers);
            return async_1.first(handlers.map(function (h) { return function () { return h.handleURL(uri); }; }), undefined, false);
        };
        URLService.prototype.registerHandler = function (handler) {
            var _this = this;
            this.handlers.add(handler);
            return lifecycle_1.toDisposable(function () { return _this.handlers.delete(handler); });
        };
        return URLService;
    }());
    exports.URLService = URLService;
    var RelayURLService = /** @class */ (function (_super) {
        __extends(RelayURLService, _super);
        function RelayURLService(urlService) {
            var _this = _super.call(this) || this;
            _this.urlService = urlService;
            return _this;
        }
        RelayURLService.prototype.open = function (uri) {
            return this.urlService.open(uri);
        };
        RelayURLService.prototype.handleURL = function (uri) {
            return _super.prototype.open.call(this, uri);
        };
        return RelayURLService;
    }(URLService));
    exports.RelayURLService = RelayURLService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[150/*vs/platform/url/node/urlIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,6/*vs/base/common/uri*/]), function (require, exports, winjs_base_1, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var URLServiceChannel = /** @class */ (function () {
        function URLServiceChannel(service) {
            this.service = service;
        }
        URLServiceChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        URLServiceChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'open': return this.service.open(uri_1.URI.revive(arg));
            }
            return undefined;
        };
        return URLServiceChannel;
    }());
    exports.URLServiceChannel = URLServiceChannel;
    var URLServiceChannelClient = /** @class */ (function () {
        function URLServiceChannelClient(channel) {
            this.channel = channel;
        }
        URLServiceChannelClient.prototype.open = function (url) {
            return winjs_base_1.TPromise.wrap(this.channel.call('open', url.toJSON()));
        };
        URLServiceChannelClient.prototype.registerHandler = function (handler) {
            throw new Error('Not implemented.');
        };
        return URLServiceChannelClient;
    }());
    exports.URLServiceChannelClient = URLServiceChannelClient;
    var URLHandlerChannel = /** @class */ (function () {
        function URLHandlerChannel(handler) {
            this.handler = handler;
        }
        URLHandlerChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        URLHandlerChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'handleURL': return this.handler.handleURL(uri_1.URI.revive(arg));
            }
            return undefined;
        };
        return URLHandlerChannel;
    }());
    exports.URLHandlerChannel = URLHandlerChannel;
    var URLHandlerChannelClient = /** @class */ (function () {
        function URLHandlerChannelClient(channel) {
            this.channel = channel;
        }
        URLHandlerChannelClient.prototype.handleURL = function (uri) {
            return winjs_base_1.TPromise.wrap(this.channel.call('handleURL', uri.toJSON()));
        };
        return URLHandlerChannelClient;
    }());
    exports.URLHandlerChannelClient = URLHandlerChannelClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[69/*vs/platform/windows/common/windows*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,4/*vs/platform/instantiation/common/instantiation*/,5/*vs/base/common/event*/,13/*vs/base/common/lifecycle*/]), function (require, exports, winjs_base_1, instantiation_1, event_1, lifecycle_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWindowsService = instantiation_1.createDecorator('windowsService');
    exports.IWindowService = instantiation_1.createDecorator('windowService');
    var OpenContext;
    (function (OpenContext) {
        // opening when running from the command line
        OpenContext[OpenContext["CLI"] = 0] = "CLI";
        // macOS only: opening from the dock (also when opening files to a running instance from desktop)
        OpenContext[OpenContext["DOCK"] = 1] = "DOCK";
        // opening from the main application window
        OpenContext[OpenContext["MENU"] = 2] = "MENU";
        // opening from a file or folder dialog
        OpenContext[OpenContext["DIALOG"] = 3] = "DIALOG";
        // opening from the OS's UI
        OpenContext[OpenContext["DESKTOP"] = 4] = "DESKTOP";
        // opening through the API
        OpenContext[OpenContext["API"] = 5] = "API";
    })(OpenContext = exports.OpenContext || (exports.OpenContext = {}));
    var ReadyState;
    (function (ReadyState) {
        /**
         * This window has not loaded any HTML yet
         */
        ReadyState[ReadyState["NONE"] = 0] = "NONE";
        /**
         * This window is loading HTML
         */
        ReadyState[ReadyState["LOADING"] = 1] = "LOADING";
        /**
         * This window is navigating to another HTML
         */
        ReadyState[ReadyState["NAVIGATING"] = 2] = "NAVIGATING";
        /**
         * This window is done loading HTML
         */
        ReadyState[ReadyState["READY"] = 3] = "READY";
    })(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
    var ActiveWindowManager = /** @class */ (function () {
        function ActiveWindowManager(windowsService) {
            var _this = this;
            this.disposables = [];
            var onActiveWindowChange = event_1.latch(event_1.anyEvent(windowsService.onWindowOpen, windowsService.onWindowFocus));
            onActiveWindowChange(this.setActiveWindow, this, this.disposables);
            this.firstActiveWindowIdPromise = windowsService.getActiveWindowId()
                .then(function (id) { return (typeof _this._activeWindowId === 'undefined') && _this.setActiveWindow(id); });
        }
        ActiveWindowManager.prototype.setActiveWindow = function (windowId) {
            if (this.firstActiveWindowIdPromise) {
                this.firstActiveWindowIdPromise = null;
            }
            this._activeWindowId = windowId;
        };
        ActiveWindowManager.prototype.getActiveClientId = function () {
            if (this.firstActiveWindowIdPromise) {
                return this.firstActiveWindowIdPromise;
            }
            return winjs_base_1.TPromise.as("window:" + this._activeWindowId);
        };
        ActiveWindowManager.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        ActiveWindowManager = __decorate([
            __param(0, exports.IWindowsService)
        ], ActiveWindowManager);
        return ActiveWindowManager;
    }());
    exports.ActiveWindowManager = ActiveWindowManager;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[25/*vs/platform/windows/electron-main/windows*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowMode;
    (function (WindowMode) {
        WindowMode[WindowMode["Maximized"] = 0] = "Maximized";
        WindowMode[WindowMode["Normal"] = 1] = "Normal";
        WindowMode[WindowMode["Minimized"] = 2] = "Minimized";
        WindowMode[WindowMode["Fullscreen"] = 3] = "Fullscreen";
    })(WindowMode = exports.WindowMode || (exports.WindowMode = {}));
    exports.IWindowsMainService = instantiation_1.createDecorator('windowsMainService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[153/*vs/code/electron-main/auth*/], __M([1/*require*/,0/*exports*/,166/*vs/nls!vs/code/electron-main/auth*/,13/*vs/base/common/lifecycle*/,25/*vs/platform/windows/electron-main/windows*/,5/*vs/base/common/event*/,8/*electron*/]), function (require, exports, nls_1, lifecycle_1, windows_1, event_1, electron_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProxyAuthHandler = /** @class */ (function () {
        function ProxyAuthHandler(windowsMainService) {
            this.windowsMainService = windowsMainService;
            this.retryCount = 0;
            this.disposables = [];
            var onLogin = event_1.fromNodeEventEmitter(electron_1.app, 'login', function (event, webContents, req, authInfo, cb) { return ({ event: event, webContents: webContents, req: req, authInfo: authInfo, cb: cb }); });
            onLogin(this.onLogin, this, this.disposables);
        }
        ProxyAuthHandler.prototype.onLogin = function (_a) {
            var event = _a.event, authInfo = _a.authInfo, cb = _a.cb;
            if (!authInfo.isProxy) {
                return;
            }
            if (this.retryCount++ > 1) {
                return;
            }
            event.preventDefault();
            var opts = {
                alwaysOnTop: true,
                skipTaskbar: true,
                resizable: false,
                width: 450,
                height: 220,
                show: true,
                title: 'VS Code'
            };
            var focusedWindow = this.windowsMainService.getFocusedWindow();
            if (focusedWindow) {
                opts.parent = focusedWindow.win;
                opts.modal = true;
            }
            var win = new electron_1.BrowserWindow(opts);
            var config = {};
            var baseUrl = require.toUrl('vs/code/electron-browser/proxy/auth.html');
            var url = baseUrl + "?config=" + encodeURIComponent(JSON.stringify(config));
            var proxyUrl = authInfo.host + ":" + authInfo.port;
            var title = nls_1.localize(0, null);
            var message = nls_1.localize(1, null, proxyUrl);
            var data = { title: title, message: message };
            var javascript = 'promptForCredentials(' + JSON.stringify(data) + ')';
            var onWindowClose = function () { return cb('', ''); };
            win.on('close', onWindowClose);
            win.setMenu(null);
            win.loadURL(url);
            win.webContents.executeJavaScript(javascript, true).then(function (_a) {
                var username = _a.username, password = _a.password;
                cb(username, password);
                win.removeListener('close', onWindowClose);
                win.close();
            });
        };
        ProxyAuthHandler.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        ProxyAuthHandler = __decorate([
            __param(0, windows_1.IWindowsMainService)
        ], ProxyAuthHandler);
        return ProxyAuthHandler;
    }());
    exports.ProxyAuthHandler = ProxyAuthHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[71/*vs/code/electron-main/keyboard*/], __M([1/*require*/,0/*exports*/,179/*native-keymap*/,28/*vs/platform/state/common/state*/,5/*vs/base/common/event*/,68/*vs/base/node/config*/,9/*vs/platform/environment/common/environment*/,8/*electron*/,25/*vs/platform/windows/electron-main/windows*/,7/*vs/platform/log/common/log*/]), function (require, exports, nativeKeymap, state_1, event_1, config_1, environment_1, electron_1, windows_1, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var KeyboardLayoutMonitor = /** @class */ (function () {
        function KeyboardLayoutMonitor() {
            this._emitter = new event_1.Emitter();
            this._registered = false;
        }
        KeyboardLayoutMonitor.prototype.onDidChangeKeyboardLayout = function (callback) {
            var _this = this;
            if (!this._registered) {
                this._registered = true;
                nativeKeymap.onDidChangeKeyboardLayout(function () {
                    _this._emitter.fire();
                });
            }
            return this._emitter.event(callback);
        };
        KeyboardLayoutMonitor.INSTANCE = new KeyboardLayoutMonitor();
        return KeyboardLayoutMonitor;
    }());
    exports.KeyboardLayoutMonitor = KeyboardLayoutMonitor;
    var KeybindingsResolver = /** @class */ (function () {
        function KeybindingsResolver(stateService, environmentService, windowsMainService, logService) {
            var _this = this;
            this.stateService = stateService;
            this.windowsMainService = windowsMainService;
            this.logService = logService;
            this._onKeybindingsChanged = new event_1.Emitter();
            this.onKeybindingsChanged = this._onKeybindingsChanged.event;
            this.commandIds = new Set();
            this.keybindings = this.stateService.getItem(KeybindingsResolver.lastKnownKeybindingsMapStorageKey) || Object.create(null);
            this.keybindingsWatcher = new config_1.ConfigWatcher(environmentService.appKeybindingsPath, { changeBufferDelay: 100, onError: function (error) { return _this.logService.error(error); } });
            this.registerListeners();
        }
        KeybindingsResolver.prototype.registerListeners = function () {
            var _this = this;
            // Listen to resolved keybindings from window
            electron_1.ipcMain.on('vscode:keybindingsResolved', function (event, rawKeybindings) {
                var keybindings = [];
                try {
                    keybindings = JSON.parse(rawKeybindings);
                }
                catch (error) {
                    // Should not happen
                }
                // Fill hash map of resolved keybindings and check for changes
                var keybindingsChanged = false;
                var keybindingsCount = 0;
                var resolvedKeybindings = Object.create(null);
                keybindings.forEach(function (keybinding) {
                    keybindingsCount++;
                    resolvedKeybindings[keybinding.id] = keybinding;
                    if (!_this.keybindings[keybinding.id] || keybinding.label !== _this.keybindings[keybinding.id].label) {
                        keybindingsChanged = true;
                    }
                });
                // A keybinding might have been unassigned, so we have to account for that too
                if (Object.keys(_this.keybindings).length !== keybindingsCount) {
                    keybindingsChanged = true;
                }
                if (keybindingsChanged) {
                    _this.keybindings = resolvedKeybindings;
                    _this.stateService.setItem(KeybindingsResolver.lastKnownKeybindingsMapStorageKey, _this.keybindings); // keep to restore instantly after restart
                    _this._onKeybindingsChanged.fire();
                }
            });
            // Resolve keybindings when any first window is loaded
            var onceOnWindowReady = event_1.once(this.windowsMainService.onWindowReady);
            onceOnWindowReady(function (win) { return _this.resolveKeybindings(win); });
            // Resolve keybindings again when keybindings.json changes
            this.keybindingsWatcher.onDidUpdateConfiguration(function () { return _this.resolveKeybindings(); });
            // Resolve keybindings when window reloads because an installed extension could have an impact
            this.windowsMainService.onWindowReload(function () { return _this.resolveKeybindings(); });
        };
        KeybindingsResolver.prototype.resolveKeybindings = function (win) {
            if (win === void 0) { win = this.windowsMainService.getLastActiveWindow(); }
            if (this.commandIds.size && win) {
                var commandIds_1 = [];
                this.commandIds.forEach(function (id) { return commandIds_1.push(id); });
                win.sendWhenReady('vscode:resolveKeybindings', JSON.stringify(commandIds_1));
            }
        };
        KeybindingsResolver.prototype.getKeybinding = function (commandId) {
            if (!commandId) {
                return void 0;
            }
            if (!this.commandIds.has(commandId)) {
                this.commandIds.add(commandId);
            }
            return this.keybindings[commandId];
        };
        KeybindingsResolver.prototype.dispose = function () {
            this._onKeybindingsChanged.dispose();
            this.keybindingsWatcher.dispose();
        };
        KeybindingsResolver.lastKnownKeybindingsMapStorageKey = 'lastKnownKeybindings';
        KeybindingsResolver = __decorate([
            __param(0, state_1.IStateService),
            __param(1, environment_1.IEnvironmentService),
            __param(2, windows_1.IWindowsMainService),
            __param(3, log_1.ILogService)
        ], KeybindingsResolver);
        return KeybindingsResolver;
    }());
    exports.KeybindingsResolver = KeybindingsResolver;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












































define(__m[156/*vs/platform/driver/electron-main/driver*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,101/*vs/platform/driver/node/driver*/,25/*vs/platform/windows/electron-main/windows*/,51/*vs/base/parts/ipc/node/ipc.net*/,13/*vs/base/common/lifecycle*/,62/*vs/base/common/keyCodes*/,109/*vs/platform/keybinding/common/usLayoutResolvedKeybinding*/,3/*vs/base/common/platform*/,5/*vs/base/common/event*/,73/*vs/base/common/scanCode*/,134/*vs/base/common/keybindingParser*/,20/*vs/base/common/async*/]), function (require, exports, winjs_base_1, driver_1, windows_1, ipc_net_1, lifecycle_1, keyCodes_1, usLayoutResolvedKeybinding_1, platform_1, event_1, scanCode_1, keybindingParser_1, async_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowRouter = /** @class */ (function () {
        function WindowRouter(windowId) {
            this.windowId = windowId;
        }
        WindowRouter.prototype.routeCall = function () {
            return winjs_base_1.TPromise.as("window:" + this.windowId);
        };
        WindowRouter.prototype.routeEvent = function () {
            return winjs_base_1.TPromise.as("window:" + this.windowId);
        };
        return WindowRouter;
    }());
    function isSilentKeyCode(keyCode) {
        return keyCode < 21 /* KEY_0 */;
    }
    var Driver = /** @class */ (function () {
        function Driver(windowServer, options, windowsService) {
            this.windowServer = windowServer;
            this.options = options;
            this.windowsService = windowsService;
            this.registeredWindowIds = new Set();
            this.reloadingWindowIds = new Set();
            this.onDidReloadingChange = new event_1.Emitter();
        }
        Driver.prototype.registerWindowDriver = function (windowId) {
            this.registeredWindowIds.add(windowId);
            this.reloadingWindowIds.delete(windowId);
            this.onDidReloadingChange.fire();
            return winjs_base_1.TPromise.as(this.options);
        };
        Driver.prototype.reloadWindowDriver = function (windowId) {
            this.reloadingWindowIds.add(windowId);
            return winjs_base_1.TPromise.as(null);
        };
        Driver.prototype.getWindowIds = function () {
            var _this = this;
            return winjs_base_1.TPromise.as(this.windowsService.getWindows()
                .map(function (w) { return w.id; })
                .filter(function (id) { return _this.registeredWindowIds.has(id) && !_this.reloadingWindowIds.has(id); }));
        };
        Driver.prototype.capturePage = function (windowId) {
            var _this = this;
            return this.whenUnfrozen(windowId).then(function () {
                var window = _this.windowsService.getWindowById(windowId);
                var webContents = window.win.webContents;
                return new winjs_base_1.TPromise(function (c) { return webContents.capturePage(function (image) { return c(image.toPNG().toString('base64')); }); });
            });
        };
        Driver.prototype.reloadWindow = function (windowId) {
            var _this = this;
            return this.whenUnfrozen(windowId).then(function () {
                var window = _this.windowsService.getWindowById(windowId);
                _this.reloadingWindowIds.add(windowId);
                _this.windowsService.reload(window);
            });
        };
        Driver.prototype.dispatchKeybinding = function (windowId, keybinding) {
            var _this = this;
            return this.whenUnfrozen(windowId).then(function () {
                var _a = keybindingParser_1.KeybindingParser.parseUserBinding(keybinding), first = _a[0], second = _a[1];
                return _this._dispatchKeybinding(windowId, first).then(function () {
                    if (second) {
                        return _this._dispatchKeybinding(windowId, second);
                    }
                    else {
                        return winjs_base_1.TPromise.as(null);
                    }
                });
            });
        };
        Driver.prototype._dispatchKeybinding = function (windowId, keybinding) {
            if (keybinding instanceof scanCode_1.ScanCodeBinding) {
                return winjs_base_1.TPromise.wrapError(new Error('ScanCodeBindings not supported'));
            }
            var window = this.windowsService.getWindowById(windowId);
            var webContents = window.win.webContents;
            var noModifiedKeybinding = new keyCodes_1.SimpleKeybinding(false, false, false, false, keybinding.keyCode);
            var resolvedKeybinding = new usLayoutResolvedKeybinding_1.USLayoutResolvedKeybinding(noModifiedKeybinding, platform_1.OS);
            var keyCode = resolvedKeybinding.getElectronAccelerator();
            var modifiers = [];
            if (keybinding.ctrlKey) {
                modifiers.push('ctrl');
            }
            if (keybinding.metaKey) {
                modifiers.push('meta');
            }
            if (keybinding.shiftKey) {
                modifiers.push('shift');
            }
            if (keybinding.altKey) {
                modifiers.push('alt');
            }
            webContents.sendInputEvent({ type: 'keyDown', keyCode: keyCode, modifiers: modifiers });
            if (!isSilentKeyCode(keybinding.keyCode)) {
                webContents.sendInputEvent({ type: 'char', keyCode: keyCode, modifiers: modifiers });
            }
            webContents.sendInputEvent({ type: 'keyUp', keyCode: keyCode, modifiers: modifiers });
            return winjs_base_1.TPromise.wrap(async_1.timeout(100));
        };
        Driver.prototype.click = function (windowId, selector, xoffset, yoffset) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.click(selector, xoffset, yoffset);
            });
        };
        Driver.prototype.doubleClick = function (windowId, selector) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.doubleClick(selector);
            });
        };
        Driver.prototype.setValue = function (windowId, selector, text) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.setValue(selector, text);
            });
        };
        Driver.prototype.getTitle = function (windowId) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.getTitle();
            });
        };
        Driver.prototype.isActiveElement = function (windowId, selector) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.isActiveElement(selector);
            });
        };
        Driver.prototype.getElements = function (windowId, selector, recursive) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.getElements(selector, recursive);
            });
        };
        Driver.prototype.typeInEditor = function (windowId, selector, text) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.typeInEditor(selector, text);
            });
        };
        Driver.prototype.getTerminalBuffer = function (windowId, selector) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.getTerminalBuffer(selector);
            });
        };
        Driver.prototype.writeInTerminal = function (windowId, selector, text) {
            return this.getWindowDriver(windowId).then(function (windowDriver) {
                return windowDriver.writeInTerminal(selector, text);
            });
        };
        Driver.prototype.getWindowDriver = function (windowId) {
            var _this = this;
            return this.whenUnfrozen(windowId).then(function () {
                var router = new WindowRouter(windowId);
                var windowDriverChannel = _this.windowServer.getChannel('windowDriver', router);
                return new driver_1.WindowDriverChannelClient(windowDriverChannel);
            });
        };
        Driver.prototype.whenUnfrozen = function (windowId) {
            return winjs_base_1.TPromise.wrap(this._whenUnfrozen(windowId));
        };
        Driver.prototype._whenUnfrozen = function (windowId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.reloadingWindowIds.has(windowId)) return [3 /*break*/, 2];
                            return [4 /*yield*/, event_1.toPromise(this.onDidReloadingChange.event)];
                        case 1:
                            _a.sent();
                            return [3 /*break*/, 0];
                        case 2: return [2 /*return*/];
                    }
                });
            });
        };
        Driver = __decorate([
            __param(2, windows_1.IWindowsMainService)
        ], Driver);
        return Driver;
    }());
    exports.Driver = Driver;
    function serve(windowServer, handle, environmentService, instantiationService) {
        return __awaiter(this, void 0, void 0, function () {
            var verbose, driver, windowDriverRegistryChannel, server, channel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        verbose = environmentService.driverVerbose;
                        driver = instantiationService.createInstance(Driver, windowServer, { verbose: verbose });
                        windowDriverRegistryChannel = new driver_1.WindowDriverRegistryChannel(driver);
                        windowServer.registerChannel('windowDriverRegistry', windowDriverRegistryChannel);
                        return [4 /*yield*/, ipc_net_1.serve(handle)];
                    case 1:
                        server = _a.sent();
                        channel = new driver_1.DriverChannel(driver);
                        server.registerChannel('driver', channel);
                        return [2 /*return*/, lifecycle_1.combinedDisposable([server, windowServer])];
                }
            });
        });
    }
    exports.serve = serve;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[157/*vs/platform/url/electron-main/electronUrlListener*/], __M([1/*require*/,0/*exports*/,5/*vs/base/common/event*/,49/*vs/platform/url/common/url*/,16/*vs/platform/node/product*/,8/*electron*/,6/*vs/base/common/uri*/,13/*vs/base/common/lifecycle*/,25/*vs/platform/windows/electron-main/windows*/]), function (require, exports, event_1, url_1, product_1, electron_1, uri_1, lifecycle_1, windows_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function uriFromRawUrl(url) {
        try {
            return uri_1.URI.parse(url);
        }
        catch (e) {
            return null;
        }
    }
    var ElectronURLListener = /** @class */ (function () {
        function ElectronURLListener(initial, urlService, windowsService) {
            this.urlService = urlService;
            this.disposables = [];
            var globalBuffer = (global.getOpenUrls() || []);
            var rawBuffer = (typeof initial === 'string' ? [initial] : initial).concat(globalBuffer);
            var buffer = rawBuffer.map(uriFromRawUrl).filter(function (uri) { return !!uri; });
            var flush = function () { return buffer.forEach(function (uri) { return urlService.open(uri); }); };
            electron_1.app.setAsDefaultProtocolClient(product_1.default.urlProtocol, process.execPath, ['--open-url', '--']);
            var onOpenElectronUrl = event_1.mapEvent(event_1.fromNodeEventEmitter(electron_1.app, 'open-url', function (event, url) { return ({ event: event, url: url }); }), function (_a) {
                var event = _a.event, url = _a.url;
                // always prevent default and return the url as string
                event.preventDefault();
                return url;
            });
            var onOpenUrl = event_1.filterEvent(event_1.mapEvent(onOpenElectronUrl, uriFromRawUrl), function (uri) { return !!uri; });
            onOpenUrl(this.urlService.open, this.urlService, this.disposables);
            var isWindowReady = windowsService.getWindows()
                .filter(function (w) { return w.readyState === 3 /* READY */; })
                .length > 0;
            if (isWindowReady) {
                flush();
            }
            else {
                event_1.once(windowsService.onWindowReady)(flush);
            }
        }
        ElectronURLListener.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        ElectronURLListener = __decorate([
            __param(1, url_1.IURLService),
            __param(2, windows_1.IWindowsMainService)
        ], ElectronURLListener);
        return ElectronURLListener;
    }());
    exports.ElectronURLListener = ElectronURLListener;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




















define(__m[158/*vs/platform/windows/electron-main/windowsService*/], __M([1/*require*/,0/*exports*/,92/*vs/nls!vs/platform/windows/electron-main/windowsService*/,2/*vs/base/common/winjs.base*/,13/*vs/base/common/lifecycle*/,17/*vs/base/common/objects*/,6/*vs/base/common/uri*/,16/*vs/platform/node/product*/,9/*vs/platform/environment/common/environment*/,8/*electron*/,5/*vs/base/common/event*/,49/*vs/platform/url/common/url*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,25/*vs/platform/windows/electron-main/windows*/,44/*vs/platform/history/common/history*/,30/*vs/base/common/network*/,31/*vs/base/common/labels*/,3/*vs/base/common/platform*/,7/*vs/platform/log/common/log*/]), function (require, exports, nls, winjs_base_1, lifecycle_1, objects_1, uri_1, product_1, environment_1, electron_1, event_1, url_1, lifecycleMain_1, windows_1, history_1, network_1, labels_1, platform_1, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowsService = /** @class */ (function () {
        function WindowsService(sharedProcess, windowsMainService, environmentService, urlService, lifecycleService, historyService, logService) {
            var _this = this;
            this.sharedProcess = sharedProcess;
            this.windowsMainService = windowsMainService;
            this.environmentService = environmentService;
            this.lifecycleService = lifecycleService;
            this.historyService = historyService;
            this.logService = logService;
            this.disposables = [];
            this.onWindowOpen = event_1.filterEvent(event_1.fromNodeEventEmitter(electron_1.app, 'browser-window-created', function (_, w) { return w.id; }), function (id) { return !!_this.windowsMainService.getWindowById(id); });
            this.onWindowBlur = event_1.filterEvent(event_1.fromNodeEventEmitter(electron_1.app, 'browser-window-blur', function (_, w) { return w.id; }), function (id) { return !!_this.windowsMainService.getWindowById(id); });
            this.onWindowMaximize = event_1.filterEvent(event_1.fromNodeEventEmitter(electron_1.app, 'browser-window-maximize', function (_, w) { return w.id; }), function (id) { return !!_this.windowsMainService.getWindowById(id); });
            this.onWindowUnmaximize = event_1.filterEvent(event_1.fromNodeEventEmitter(electron_1.app, 'browser-window-unmaximize', function (_, w) { return w.id; }), function (id) { return !!_this.windowsMainService.getWindowById(id); });
            this.onWindowFocus = event_1.anyEvent(event_1.mapEvent(event_1.filterEvent(event_1.mapEvent(this.windowsMainService.onWindowsCountChanged, function () { return _this.windowsMainService.getLastActiveWindow(); }), function (w) { return !!w; }), function (w) { return w.id; }), event_1.filterEvent(event_1.fromNodeEventEmitter(electron_1.app, 'browser-window-focus', function (_, w) { return w.id; }), function (id) { return !!_this.windowsMainService.getWindowById(id); }));
            this.onRecentlyOpenedChange = this.historyService.onRecentlyOpenedChange;
            urlService.registerHandler(this);
            // remember last active window id
            event_1.latch(event_1.anyEvent(this.onWindowOpen, this.onWindowFocus))(function (id) { return _this._activeWindowId = id; }, null, this.disposables);
        }
        WindowsService.prototype.pickFileFolderAndOpen = function (options) {
            this.logService.trace('windowsService#pickFileFolderAndOpen');
            this.windowsMainService.pickFileFolderAndOpen(options);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.pickFileAndOpen = function (options) {
            this.logService.trace('windowsService#pickFileAndOpen');
            this.windowsMainService.pickFileAndOpen(options);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.pickFolderAndOpen = function (options) {
            this.logService.trace('windowsService#pickFolderAndOpen');
            this.windowsMainService.pickFolderAndOpen(options);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.pickWorkspaceAndOpen = function (options) {
            this.logService.trace('windowsService#pickWorkspaceAndOpen');
            this.windowsMainService.pickWorkspaceAndOpen(options);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.showMessageBox = function (windowId, options) {
            this.logService.trace('windowsService#showMessageBox', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            return this.windowsMainService.showMessageBox(options, codeWindow);
        };
        WindowsService.prototype.showSaveDialog = function (windowId, options) {
            this.logService.trace('windowsService#showSaveDialog', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            return this.windowsMainService.showSaveDialog(options, codeWindow);
        };
        WindowsService.prototype.showOpenDialog = function (windowId, options) {
            this.logService.trace('windowsService#showOpenDialog', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            return this.windowsMainService.showOpenDialog(options, codeWindow);
        };
        WindowsService.prototype.reloadWindow = function (windowId, args) {
            this.logService.trace('windowsService#reloadWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                this.windowsMainService.reload(codeWindow, args);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.openDevTools = function (windowId, options) {
            this.logService.trace('windowsService#openDevTools', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.webContents.openDevTools(options);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.toggleDevTools = function (windowId) {
            this.logService.trace('windowsService#toggleDevTools', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                var contents = codeWindow.win.webContents;
                if (platform_1.isMacintosh && codeWindow.hasHiddenTitleBarStyle() && !codeWindow.win.isFullScreen() && !contents.isDevToolsOpened()) {
                    contents.openDevTools({ mode: 'undocked' }); // due to https://github.com/electron/electron/issues/3647
                }
                else {
                    contents.toggleDevTools();
                }
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.updateTouchBar = function (windowId, items) {
            this.logService.trace('windowsService#updateTouchBar', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.updateTouchBar(items);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.closeWorkspace = function (windowId) {
            this.logService.trace('windowsService#closeWorkspace', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                this.windowsMainService.closeWorkspace(codeWindow);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.enterWorkspace = function (windowId, path) {
            this.logService.trace('windowsService#enterWorkspace', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return this.windowsMainService.enterWorkspace(codeWindow, path);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.createAndEnterWorkspace = function (windowId, folders, path) {
            this.logService.trace('windowsService#createAndEnterWorkspace', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return this.windowsMainService.createAndEnterWorkspace(codeWindow, folders, path);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.saveAndEnterWorkspace = function (windowId, path) {
            this.logService.trace('windowsService#saveAndEnterWorkspace', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return this.windowsMainService.saveAndEnterWorkspace(codeWindow, path);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.toggleFullScreen = function (windowId) {
            this.logService.trace('windowsService#toggleFullScreen', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.toggleFullScreen();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.setRepresentedFilename = function (windowId, fileName) {
            this.logService.trace('windowsService#setRepresentedFilename', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.setRepresentedFilename(fileName);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.addRecentlyOpened = function (files) {
            this.logService.trace('windowsService#addRecentlyOpened');
            this.historyService.addRecentlyOpened(void 0, files);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.removeFromRecentlyOpened = function (paths) {
            this.logService.trace('windowsService#removeFromRecentlyOpened');
            this.historyService.removeFromRecentlyOpened(paths);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.clearRecentlyOpened = function () {
            this.logService.trace('windowsService#clearRecentlyOpened');
            this.historyService.clearRecentlyOpened();
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.getRecentlyOpened = function (windowId) {
            this.logService.trace('windowsService#getRecentlyOpened', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return winjs_base_1.TPromise.as(this.historyService.getRecentlyOpened(codeWindow.config.workspace || codeWindow.config.folderUri, codeWindow.config.filesToOpen));
            }
            return winjs_base_1.TPromise.as(this.historyService.getRecentlyOpened());
        };
        WindowsService.prototype.newWindowTab = function () {
            this.logService.trace('windowsService#newWindowTab');
            this.windowsMainService.openNewTabbedWindow(5 /* API */);
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.showPreviousWindowTab = function () {
            this.logService.trace('windowsService#showPreviousWindowTab');
            electron_1.Menu.sendActionToFirstResponder('selectPreviousTab:');
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.showNextWindowTab = function () {
            this.logService.trace('windowsService#showNextWindowTab');
            electron_1.Menu.sendActionToFirstResponder('selectNextTab:');
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.moveWindowTabToNewWindow = function () {
            this.logService.trace('windowsService#moveWindowTabToNewWindow');
            electron_1.Menu.sendActionToFirstResponder('moveTabToNewWindow:');
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.mergeAllWindowTabs = function () {
            this.logService.trace('windowsService#mergeAllWindowTabs');
            electron_1.Menu.sendActionToFirstResponder('mergeAllWindows:');
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.toggleWindowTabsBar = function () {
            this.logService.trace('windowsService#toggleWindowTabsBar');
            electron_1.Menu.sendActionToFirstResponder('toggleTabBar:');
            return winjs_base_1.TPromise.as(void 0);
        };
        WindowsService.prototype.focusWindow = function (windowId) {
            this.logService.trace('windowsService#focusWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.focus();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.closeWindow = function (windowId) {
            this.logService.trace('windowsService#closeWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.close();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.isFocused = function (windowId) {
            this.logService.trace('windowsService#isFocused', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return winjs_base_1.TPromise.as(codeWindow.win.isFocused());
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.isMaximized = function (windowId) {
            this.logService.trace('windowsService#isMaximized', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                return winjs_base_1.TPromise.as(codeWindow.win.isMaximized());
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.maximizeWindow = function (windowId) {
            this.logService.trace('windowsService#maximizeWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.maximize();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.unmaximizeWindow = function (windowId) {
            this.logService.trace('windowsService#unmaximizeWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.unmaximize();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.minimizeWindow = function (windowId) {
            this.logService.trace('windowsService#minimizeWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.minimize();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.onWindowTitleDoubleClick = function (windowId) {
            this.logService.trace('windowsService#onWindowTitleDoubleClick', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.onWindowTitleDoubleClick();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.setDocumentEdited = function (windowId, flag) {
            this.logService.trace('windowsService#setDocumentEdited', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow && codeWindow.win.isDocumentEdited() !== flag) {
                codeWindow.win.setDocumentEdited(flag);
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.openWindow = function (windowId, paths, options) {
            this.logService.trace('windowsService#openWindow');
            if (!paths || !paths.length) {
                return winjs_base_1.TPromise.as(null);
            }
            this.windowsMainService.open({
                context: 5 /* API */,
                contextWindowId: windowId,
                urisToOpen: paths,
                cli: options && options.args ? __assign({}, this.environmentService.args, options.args) : this.environmentService.args,
                forceNewWindow: options && options.forceNewWindow,
                forceReuseWindow: options && options.forceReuseWindow,
                forceOpenWorkspaceAsFile: options && options.forceOpenWorkspaceAsFile
            });
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.openNewWindow = function () {
            this.logService.trace('windowsService#openNewWindow');
            this.windowsMainService.openNewWindow(5 /* API */);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.showWindow = function (windowId) {
            this.logService.trace('windowsService#showWindow', windowId);
            var codeWindow = this.windowsMainService.getWindowById(windowId);
            if (codeWindow) {
                codeWindow.win.show();
            }
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.getWindows = function () {
            this.logService.trace('windowsService#getWindows');
            var windows = this.windowsMainService.getWindows();
            var result = windows.map(function (w) { return ({ id: w.id, workspace: w.openedWorkspace, folderUri: w.openedFolderUri, title: w.win.getTitle(), filename: w.getRepresentedFilename() }); });
            return winjs_base_1.TPromise.as(result);
        };
        WindowsService.prototype.getWindowCount = function () {
            this.logService.trace('windowsService#getWindowCount');
            return winjs_base_1.TPromise.as(this.windowsMainService.getWindows().length);
        };
        WindowsService.prototype.log = function (severity) {
            var messages = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                messages[_i - 1] = arguments[_i];
            }
            var _a;
            (_a = console[severity]).apply.apply(_a, [console].concat(messages));
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.showItemInFolder = function (path) {
            this.logService.trace('windowsService#showItemInFolder');
            electron_1.shell.showItemInFolder(path);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.getActiveWindowId = function () {
            return winjs_base_1.TPromise.as(this._activeWindowId);
        };
        WindowsService.prototype.openExternal = function (url) {
            this.logService.trace('windowsService#openExternal');
            return winjs_base_1.TPromise.as(electron_1.shell.openExternal(url));
        };
        WindowsService.prototype.startCrashReporter = function (config) {
            this.logService.trace('windowsService#startCrashReporter');
            electron_1.crashReporter.start(config);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.quit = function () {
            this.logService.trace('windowsService#quit');
            this.windowsMainService.quit();
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.relaunch = function (options) {
            this.logService.trace('windowsService#relaunch');
            this.lifecycleService.relaunch(options);
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.whenSharedProcessReady = function () {
            this.logService.trace('windowsService#whenSharedProcessReady');
            return this.sharedProcess.whenReady();
        };
        WindowsService.prototype.toggleSharedProcess = function () {
            this.logService.trace('windowsService#toggleSharedProcess');
            this.sharedProcess.toggle();
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.openAboutDialog = function () {
            this.logService.trace('windowsService#openAboutDialog');
            var lastActiveWindow = this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();
            var version = electron_1.app.getVersion();
            if (product_1.default.target) {
                version = version + " (" + product_1.default.target + " setup)";
            }
            var detail = nls.localize(0, null, product_1.default.kodeStudioVersion, product_1.default.commit || 'Unknown', product_1.default.date || 'Unknown', process.versions['electron'], process.versions['chrome'], process.versions['node'], process.versions['v8'], process.arch);
            var buttons = [nls.localize(1, null)];
            if (platform_1.isWindows) {
                buttons.push(labels_1.mnemonicButtonLabel(nls.localize(2, null))); // https://github.com/Microsoft/vscode/issues/37608
            }
            this.windowsMainService.showMessageBox({
                title: product_1.default.nameLong,
                type: 'info',
                message: product_1.default.nameLong,
                detail: "\n" + detail,
                buttons: buttons,
                noLink: true
            }, lastActiveWindow).then(function (result) {
                if (platform_1.isWindows && result.button === 1) {
                    electron_1.clipboard.writeText(detail);
                }
            });
            return winjs_base_1.TPromise.as(null);
        };
        WindowsService.prototype.handleURL = function (uri) {
            // Catch file URLs
            if (uri.authority === network_1.Schemas.file && !!uri.path) {
                this.openFileForURI(uri_1.URI.file(uri.fsPath));
                return winjs_base_1.TPromise.as(true);
            }
            return winjs_base_1.TPromise.wrap(false);
        };
        WindowsService.prototype.openFileForURI = function (uri) {
            var cli = objects_1.assign(Object.create(null), this.environmentService.args, { goto: true });
            var urisToOpen = [uri];
            this.windowsMainService.open({ context: 5 /* API */, cli: cli, urisToOpen: urisToOpen });
            return winjs_base_1.TPromise.wrap(true);
        };
        WindowsService.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        WindowsService = __decorate([
            __param(1, windows_1.IWindowsMainService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, url_1.IURLService),
            __param(4, lifecycleMain_1.ILifecycleService),
            __param(5, history_1.IHistoryMainService),
            __param(6, log_1.ILogService)
        ], WindowsService);
        return WindowsService;
    }());
    exports.WindowsService = WindowsService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[19/*vs/platform/workspaces/common/workspaces*/], __M([1/*require*/,0/*exports*/,4/*vs/platform/instantiation/common/instantiation*/,104/*vs/nls!vs/platform/workspaces/common/workspaces*/,6/*vs/base/common/uri*/]), function (require, exports, instantiation_1, nls_1, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspacesMainService = instantiation_1.createDecorator('workspacesMainService');
    exports.IWorkspacesService = instantiation_1.createDecorator('workspacesService');
    exports.WORKSPACE_EXTENSION = 'code-workspace';
    exports.WORKSPACE_FILTER = [{ name: nls_1.localize(0, null), extensions: [exports.WORKSPACE_EXTENSION] }];
    exports.UNTITLED_WORKSPACE_NAME = 'workspace.json';
    function isStoredWorkspaceFolder(thing) {
        return isRawFileWorkspaceFolder(thing) || isRawUriWorkspaceFolder(thing);
    }
    exports.isStoredWorkspaceFolder = isStoredWorkspaceFolder;
    function isRawFileWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.path === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawFileWorkspaceFolder = isRawFileWorkspaceFolder;
    function isRawUriWorkspaceFolder(thing) {
        return thing
            && typeof thing === 'object'
            && typeof thing.uri === 'string'
            && (!thing.name || typeof thing.name === 'string');
    }
    exports.isRawUriWorkspaceFolder = isRawUriWorkspaceFolder;
    function isSingleFolderWorkspaceIdentifier(obj) {
        return obj instanceof uri_1.URI;
    }
    exports.isSingleFolderWorkspaceIdentifier = isSingleFolderWorkspaceIdentifier;
    function isWorkspaceIdentifier(obj) {
        var workspaceIdentifier = obj;
        return workspaceIdentifier && typeof workspaceIdentifier.id === 'string' && typeof workspaceIdentifier.configPath === 'string';
    }
    exports.isWorkspaceIdentifier = isWorkspaceIdentifier;
    function toWorkspaceIdentifier(workspace) {
        if (workspace.configuration) {
            return {
                configPath: workspace.configuration.fsPath,
                id: workspace.id
            };
        }
        if (workspace.folders.length === 1) {
            return workspace.folders[0].uri;
        }
        // Empty workspace
        return undefined;
    }
    exports.toWorkspaceIdentifier = toWorkspaceIdentifier;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[160/*vs/code/node/windowsFinder*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/platform*/,15/*vs/base/common/paths*/,19/*vs/platform/workspaces/common/workspaces*/,6/*vs/base/common/uri*/,32/*vs/base/common/resources*/]), function (require, exports, platform, paths, workspaces_1, uri_1, resources_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function findBestWindowOrFolderForFile(_a) {
        var windows = _a.windows, newWindow = _a.newWindow, reuseWindow = _a.reuseWindow, context = _a.context, fileUri = _a.fileUri, workspaceResolver = _a.workspaceResolver;
        if (!newWindow && fileUri && (context === 4 /* DESKTOP */ || context === 0 /* CLI */ || context === 1 /* DOCK */)) {
            var windowOnFilePath = findWindowOnFilePath(windows, fileUri, workspaceResolver);
            if (windowOnFilePath) {
                return windowOnFilePath;
            }
        }
        return !newWindow ? getLastActiveWindow(windows) : null;
    }
    exports.findBestWindowOrFolderForFile = findBestWindowOrFolderForFile;
    function findWindowOnFilePath(windows, fileUri, workspaceResolver) {
        // First check for windows with workspaces that have a parent folder of the provided path opened
        var workspaceWindows = windows.filter(function (window) { return !!window.openedWorkspace; });
        for (var i = 0; i < workspaceWindows.length; i++) {
            var window_1 = workspaceWindows[i];
            var resolvedWorkspace = workspaceResolver(window_1.openedWorkspace);
            if (resolvedWorkspace && resolvedWorkspace.folders.some(function (folder) { return resources_1.isEqualOrParent(fileUri, folder.uri); })) {
                return window_1;
            }
        }
        // Then go with single folder windows that are parent of the provided file path
        var singleFolderWindowsOnFilePath = windows.filter(function (window) { return window.openedFolderUri && resources_1.isEqualOrParent(fileUri, window.openedFolderUri); });
        if (singleFolderWindowsOnFilePath.length) {
            return singleFolderWindowsOnFilePath.sort(function (a, b) { return -(a.openedFolderUri.path.length - b.openedFolderUri.path.length); })[0];
        }
        return null;
    }
    function getLastActiveWindow(windows) {
        var lastFocusedDate = Math.max.apply(Math, windows.map(function (window) { return window.lastFocusTime; }));
        return windows.filter(function (window) { return window.lastFocusTime === lastFocusedDate; })[0];
    }
    exports.getLastActiveWindow = getLastActiveWindow;
    function findWindowOnWorkspace(windows, workspace) {
        if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
            for (var _i = 0, windows_1 = windows; _i < windows_1.length; _i++) {
                var window_2 = windows_1[_i];
                // match on folder
                if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                    if (window_2.openedFolderUri && resources_1.isEqual(window_2.openedFolderUri, workspace)) {
                        return window_2;
                    }
                }
            }
        }
        else if (workspaces_1.isWorkspaceIdentifier(workspace)) {
            for (var _a = 0, windows_2 = windows; _a < windows_2.length; _a++) {
                var window_3 = windows_2[_a];
                // match on workspace
                if (window_3.openedWorkspace && window_3.openedWorkspace.id === workspace.id) {
                    return window_3;
                }
            }
        }
        return null;
    }
    exports.findWindowOnWorkspace = findWindowOnWorkspace;
    function findWindowOnExtensionDevelopmentPath(windows, extensionDevelopmentPath) {
        for (var _i = 0, windows_3 = windows; _i < windows_3.length; _i++) {
            var window_4 = windows_3[_i];
            // match on extension development path. The path can be a path or uri string, using paths.isEqual is not 100% correct but good enough
            if (paths.isEqual(window_4.extensionDevelopmentPath, extensionDevelopmentPath, !platform.isLinux /* ignorecase */)) {
                return window_4;
            }
        }
        return null;
    }
    exports.findWindowOnExtensionDevelopmentPath = findWindowOnExtensionDevelopmentPath;
    function findWindowOnWorkspaceOrFolderUri(windows, uri) {
        if (!uri) {
            return null;
        }
        for (var _i = 0, windows_4 = windows; _i < windows_4.length; _i++) {
            var window_5 = windows_4[_i];
            // check for workspace config path
            if (window_5.openedWorkspace && resources_1.isEqual(uri_1.URI.file(window_5.openedWorkspace.configPath), uri, !platform.isLinux /* ignorecase */)) {
                return window_5;
            }
            // check for folder path
            if (window_5.openedFolderUri && resources_1.isEqual(window_5.openedFolderUri, uri)) {
                return window_5;
            }
        }
        return null;
    }
    exports.findWindowOnWorkspaceOrFolderUri = findWindowOnWorkspaceOrFolderUri;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[161/*vs/platform/backup/electron-main/backupMainService*/], __M([1/*require*/,0/*exports*/,21/*fs*/,11/*path*/,58/*crypto*/,3/*vs/base/common/platform*/,36/*vs/base/node/extfs*/,24/*vs/base/common/arrays*/,9/*vs/platform/environment/common/environment*/,14/*vs/platform/configuration/common/configuration*/,46/*vs/platform/files/common/files*/,7/*vs/platform/log/common/log*/,19/*vs/platform/workspaces/common/workspaces*/,6/*vs/base/common/uri*/,32/*vs/base/common/resources*/,15/*vs/base/common/paths*/,30/*vs/base/common/network*/]), function (require, exports, fs, path, crypto, platform, extfs, arrays, environment_1, configuration_1, files_1, log_1, workspaces_1, uri_1, resources_1, paths_1, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BackupMainService = /** @class */ (function () {
        function BackupMainService(environmentService, configurationService, logService) {
            this.configurationService = configurationService;
            this.logService = logService;
            this.backupHome = environmentService.backupHome;
            this.workspacesJsonPath = environmentService.backupWorkspacesPath;
            this.loadSync();
        }
        BackupMainService.prototype.getWorkspaceBackups = function () {
            if (this.isHotExitOnExitAndWindowClose()) {
                // Only non-folder windows are restored on main process launch when
                // hot exit is configured as onExitAndWindowClose.
                return [];
            }
            return this.rootWorkspaces.slice(0); // return a copy
        };
        BackupMainService.prototype.getFolderBackupPaths = function () {
            if (this.isHotExitOnExitAndWindowClose()) {
                // Only non-folder windows are restored on main process launch when
                // hot exit is configured as onExitAndWindowClose.
                return [];
            }
            return this.folderWorkspaces.slice(0); // return a copy
        };
        BackupMainService.prototype.isHotExitEnabled = function () {
            return this.getHotExitConfig() !== files_1.HotExitConfiguration.OFF;
        };
        BackupMainService.prototype.isHotExitOnExitAndWindowClose = function () {
            return this.getHotExitConfig() === files_1.HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE;
        };
        BackupMainService.prototype.getHotExitConfig = function () {
            var config = this.configurationService.getValue();
            return (config && config.files && config.files.hotExit) || files_1.HotExitConfiguration.ON_EXIT;
        };
        BackupMainService.prototype.getEmptyWindowBackupPaths = function () {
            return this.emptyWorkspaces.slice(0); // return a copy
        };
        BackupMainService.prototype.registerWorkspaceBackupSync = function (workspace, migrateFrom) {
            if (!this.rootWorkspaces.some(function (w) { return w.id === workspace.id; })) {
                this.rootWorkspaces.push(workspace);
                this.saveSync();
            }
            var backupPath = this.getBackupPath(workspace.id);
            if (migrateFrom) {
                this.moveBackupFolderSync(backupPath, migrateFrom);
            }
            return backupPath;
        };
        BackupMainService.prototype.moveBackupFolderSync = function (backupPath, moveFromPath) {
            // Target exists: make sure to convert existing backups to empty window backups
            if (fs.existsSync(backupPath)) {
                this.convertToEmptyWindowBackup(backupPath);
            }
            // When we have data to migrate from, move it over to the target location
            if (fs.existsSync(moveFromPath)) {
                try {
                    fs.renameSync(moveFromPath, backupPath);
                }
                catch (ex) {
                    this.logService.error("Backup: Could not move backup folder to new location: " + ex.toString());
                }
            }
        };
        BackupMainService.prototype.unregisterWorkspaceBackupSync = function (workspace) {
            var index = arrays.firstIndex(this.rootWorkspaces, function (w) { return w.id === workspace.id; });
            if (index !== -1) {
                this.rootWorkspaces.splice(index, 1);
                this.saveSync();
            }
        };
        BackupMainService.prototype.registerFolderBackupSync = function (folderUri) {
            if (!this.folderWorkspaces.some(function (uri) { return resources_1.isEqual(folderUri, uri); })) {
                this.folderWorkspaces.push(folderUri);
                this.saveSync();
            }
            return this.getBackupPath(this.getFolderHash(folderUri));
        };
        BackupMainService.prototype.unregisterFolderBackupSync = function (folderUri) {
            var index = arrays.firstIndex(this.folderWorkspaces, function (uri) { return resources_1.isEqual(folderUri, uri); });
            if (index !== -1) {
                this.folderWorkspaces.splice(index, 1);
                this.saveSync();
            }
        };
        BackupMainService.prototype.registerEmptyWindowBackupSync = function (backupFolder) {
            // Generate a new folder if this is a new empty workspace
            if (!backupFolder) {
                backupFolder = this.getRandomEmptyWindowId();
            }
            if (!this.emptyWorkspaces.some(function (w) { return paths_1.isEqual(w, backupFolder, !platform.isLinux); })) {
                this.emptyWorkspaces.push(backupFolder);
                this.saveSync();
            }
            return this.getBackupPath(backupFolder);
        };
        BackupMainService.prototype.unregisterEmptyWindowBackupSync = function (backupFolder) {
            var index = arrays.firstIndex(this.emptyWorkspaces, function (w) { return paths_1.isEqual(w, backupFolder, !platform.isLinux); });
            if (index !== -1) {
                this.emptyWorkspaces.splice(index, 1);
                this.saveSync();
            }
        };
        BackupMainService.prototype.loadSync = function () {
            var backups;
            try {
                backups = JSON.parse(fs.readFileSync(this.workspacesJsonPath, 'utf8').toString()); // invalid JSON or permission issue can happen here
            }
            catch (error) {
                backups = Object.create(null);
            }
            // read empty worrkspace backs first
            this.emptyWorkspaces = this.validateEmptyWorkspaces(backups.emptyWorkspaces);
            // read workspace backups
            this.rootWorkspaces = this.validateWorkspaces(backups.rootWorkspaces);
            // read folder backups
            var workspaceFolders;
            try {
                if (Array.isArray(backups.folderURIWorkspaces)) {
                    workspaceFolders = backups.folderURIWorkspaces.map(function (f) { return uri_1.URI.parse(f); });
                }
                else if (Array.isArray(backups.folderWorkspaces)) {
                    // migrate legacy folder paths
                    workspaceFolders = [];
                    for (var _i = 0, _a = backups.folderWorkspaces; _i < _a.length; _i++) {
                        var folderPath = _a[_i];
                        var oldFolderHash = this.getLegacyFolderHash(folderPath);
                        var folderUri = uri_1.URI.file(folderPath);
                        var newFolderHash = this.getFolderHash(folderUri);
                        if (newFolderHash !== oldFolderHash) {
                            this.moveBackupFolderSync(this.getBackupPath(newFolderHash), this.getBackupPath(oldFolderHash));
                        }
                        workspaceFolders.push(folderUri);
                    }
                }
            }
            catch (e) {
                // ignore URI parsing exceptions
            }
            this.folderWorkspaces = this.validateFolders(workspaceFolders);
            // save again in case some workspaces or folders have been removed
            this.saveSync();
        };
        BackupMainService.prototype.getBackupPath = function (oldFolderHash) {
            return path.join(this.backupHome, oldFolderHash);
        };
        BackupMainService.prototype.validateWorkspaces = function (rootWorkspaces) {
            if (!Array.isArray(rootWorkspaces)) {
                return [];
            }
            var seenIds = Object.create(null);
            var result = [];
            // Validate Workspaces
            for (var _i = 0, rootWorkspaces_1 = rootWorkspaces; _i < rootWorkspaces_1.length; _i++) {
                var workspace = rootWorkspaces_1[_i];
                if (!workspaces_1.isWorkspaceIdentifier(workspace)) {
                    return []; // wrong format, skip all entries
                }
                if (!seenIds[workspace.id]) {
                    seenIds[workspace.id] = true;
                    var backupPath = this.getBackupPath(workspace.id);
                    var hasBackups = this.hasBackupsSync(backupPath);
                    // If the workspace has no backups, ignore it
                    if (hasBackups) {
                        if (fs.existsSync(workspace.configPath)) {
                            result.push(workspace);
                        }
                        else {
                            // If the workspace has backups, but the target workspace is missing, convert backups to empty ones
                            this.convertToEmptyWindowBackup(backupPath);
                        }
                    }
                    else {
                        this.deleteStaleBackup(backupPath);
                    }
                }
            }
            return result;
        };
        BackupMainService.prototype.validateFolders = function (folderWorkspaces) {
            if (!Array.isArray(folderWorkspaces)) {
                return [];
            }
            var result = [];
            var seen = Object.create(null);
            for (var _i = 0, folderWorkspaces_1 = folderWorkspaces; _i < folderWorkspaces_1.length; _i++) {
                var folderURI = folderWorkspaces_1[_i];
                var key = resources_1.getComparisonKey(folderURI);
                if (!seen[key]) {
                    seen[key] = true;
                    var backupPath = this.getBackupPath(this.getFolderHash(folderURI));
                    var hasBackups = this.hasBackupsSync(backupPath);
                    // If the folder has no backups, ignore it
                    if (hasBackups) {
                        if (folderURI.scheme !== network_1.Schemas.file || fs.existsSync(folderURI.fsPath)) {
                            result.push(folderURI);
                        }
                        else {
                            // If the folder has backups, but the target workspace is missing, convert backups to empty ones
                            this.convertToEmptyWindowBackup(backupPath);
                        }
                    }
                    else {
                        this.deleteStaleBackup(backupPath);
                    }
                }
            }
            return result;
        };
        BackupMainService.prototype.validateEmptyWorkspaces = function (emptyWorkspaces) {
            if (!Array.isArray(emptyWorkspaces)) {
                return [];
            }
            var result = [];
            var seen = Object.create(null);
            // Validate Empty Windows
            for (var _i = 0, emptyWorkspaces_1 = emptyWorkspaces; _i < emptyWorkspaces_1.length; _i++) {
                var backupFolder = emptyWorkspaces_1[_i];
                if (typeof backupFolder !== 'string') {
                    return [];
                }
                if (!seen[backupFolder]) {
                    seen[backupFolder] = true;
                    var backupPath = this.getBackupPath(backupFolder);
                    if (this.hasBackupsSync(backupPath)) {
                        result.push(backupFolder);
                    }
                    else {
                        this.deleteStaleBackup(backupPath);
                    }
                }
            }
            return result;
        };
        BackupMainService.prototype.deleteStaleBackup = function (backupPath) {
            try {
                if (fs.existsSync(backupPath)) {
                    extfs.delSync(backupPath);
                }
            }
            catch (ex) {
                this.logService.error("Backup: Could not delete stale backup: " + ex.toString());
            }
        };
        BackupMainService.prototype.convertToEmptyWindowBackup = function (backupPath) {
            // New empty window backup
            var newBackupFolder = this.getRandomEmptyWindowId();
            while (this.emptyWorkspaces.some(function (w) { return paths_1.isEqual(w, newBackupFolder, platform.isLinux); })) {
                newBackupFolder = this.getRandomEmptyWindowId();
            }
            // Rename backupPath to new empty window backup path
            var newEmptyWindowBackupPath = this.getBackupPath(newBackupFolder);
            try {
                fs.renameSync(backupPath, newEmptyWindowBackupPath);
            }
            catch (ex) {
                this.logService.error("Backup: Could not rename backup folder: " + ex.toString());
                return false;
            }
            this.emptyWorkspaces.push(newBackupFolder);
            return true;
        };
        BackupMainService.prototype.hasBackupsSync = function (backupPath) {
            try {
                var backupSchemas = extfs.readdirSync(backupPath);
                if (backupSchemas.length === 0) {
                    return false; // empty backups
                }
                return backupSchemas.some(function (backupSchema) {
                    try {
                        return extfs.readdirSync(path.join(backupPath, backupSchema)).length > 0;
                    }
                    catch (error) {
                        return false; // invalid folder
                    }
                });
            }
            catch (error) {
                return false; // backup path does not exist
            }
        };
        BackupMainService.prototype.saveSync = function () {
            try {
                // The user data directory must exist so only the Backup directory needs to be checked.
                if (!fs.existsSync(this.backupHome)) {
                    fs.mkdirSync(this.backupHome);
                }
                var backups = {
                    rootWorkspaces: this.rootWorkspaces,
                    folderURIWorkspaces: this.folderWorkspaces.map(function (f) { return f.toString(); }),
                    emptyWorkspaces: this.emptyWorkspaces
                };
                extfs.writeFileAndFlushSync(this.workspacesJsonPath, JSON.stringify(backups));
            }
            catch (ex) {
                this.logService.error("Backup: Could not save workspaces.json: " + ex.toString());
            }
        };
        BackupMainService.prototype.getRandomEmptyWindowId = function () {
            return (Date.now() + Math.round(Math.random() * 1000)).toString();
        };
        BackupMainService.prototype.getFolderHash = function (folderUri) {
            var key;
            if (folderUri.scheme === network_1.Schemas.file) {
                // for backward compatibility, use the fspath as key
                key = platform.isLinux ? folderUri.fsPath : folderUri.fsPath.toLowerCase();
            }
            else {
                key = resources_1.hasToIgnoreCase(folderUri) ? folderUri.toString().toLowerCase() : folderUri.toString();
            }
            return crypto.createHash('md5').update(key).digest('hex');
        };
        BackupMainService.prototype.getLegacyFolderHash = function (folderPath) {
            return crypto.createHash('md5').update(platform.isLinux ? folderPath : folderPath.toLowerCase()).digest('hex');
        };
        BackupMainService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, log_1.ILogService)
        ], BackupMainService);
        return BackupMainService;
    }());
    exports.BackupMainService = BackupMainService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[63/*vs/platform/launch/electron-main/launchService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,7/*vs/platform/log/common/log*/,49/*vs/platform/url/common/url*/,3/*vs/base/common/platform*/,9/*vs/platform/environment/common/environment*/,4/*vs/platform/instantiation/common/instantiation*/,25/*vs/platform/windows/electron-main/windows*/,34/*vs/base/node/pfs*/,19/*vs/platform/workspaces/common/workspaces*/,14/*vs/platform/configuration/common/configuration*/,6/*vs/base/common/uri*/,8/*electron*/,41/*vs/platform/environment/node/argv*/]), function (require, exports, winjs_base_1, log_1, url_1, platform_1, environment_1, instantiation_1, windows_1, pfs_1, workspaces_1, configuration_1, uri_1, electron_1, argv_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ID = 'launchService';
    exports.ILaunchService = instantiation_1.createDecorator(exports.ID);
    function parseOpenUrl(args) {
        if (args['open-url'] && args._urls && args._urls.length > 0) {
            // --open-url must contain -- followed by the url(s)
            // process.argv is used over args._ as args._ are resolved to file paths at this point
            return args._urls
                .map(function (url) {
                try {
                    return uri_1.URI.parse(url);
                }
                catch (err) {
                    return null;
                }
            })
                .filter(function (uri) { return !!uri; });
        }
        return [];
    }
    var LaunchChannel = /** @class */ (function () {
        function LaunchChannel(service) {
            this.service = service;
        }
        LaunchChannel.prototype.listen = function (event) {
            throw new Error('No event found');
        };
        LaunchChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'start':
                    var _a = arg, args = _a.args, userEnv = _a.userEnv;
                    return this.service.start(args, userEnv);
                case 'get-main-process-id':
                    return this.service.getMainProcessId();
                case 'get-main-process-info':
                    return this.service.getMainProcessInfo();
                case 'get-logs-path':
                    return this.service.getLogsPath();
            }
            return undefined;
        };
        return LaunchChannel;
    }());
    exports.LaunchChannel = LaunchChannel;
    var LaunchChannelClient = /** @class */ (function () {
        function LaunchChannelClient(channel) {
            this.channel = channel;
        }
        LaunchChannelClient.prototype.start = function (args, userEnv) {
            return this.channel.call('start', { args: args, userEnv: userEnv });
        };
        LaunchChannelClient.prototype.getMainProcessId = function () {
            return this.channel.call('get-main-process-id', null);
        };
        LaunchChannelClient.prototype.getMainProcessInfo = function () {
            return this.channel.call('get-main-process-info', null);
        };
        LaunchChannelClient.prototype.getLogsPath = function () {
            return this.channel.call('get-logs-path', null);
        };
        return LaunchChannelClient;
    }());
    exports.LaunchChannelClient = LaunchChannelClient;
    var LaunchService = /** @class */ (function () {
        function LaunchService(logService, windowsMainService, urlService, workspacesMainService, environmentService, configurationService) {
            this.logService = logService;
            this.windowsMainService = windowsMainService;
            this.urlService = urlService;
            this.workspacesMainService = workspacesMainService;
            this.environmentService = environmentService;
            this.configurationService = configurationService;
        }
        LaunchService.prototype.start = function (args, userEnv) {
            var _this = this;
            this.logService.trace('Received data from other instance: ', args, userEnv);
            var urlsToOpen = parseOpenUrl(args);
            // Check early for open-url which is handled in URL service
            if (urlsToOpen.length) {
                var whenWindowReady = winjs_base_1.TPromise.as(null);
                // Create a window if there is none
                if (this.windowsMainService.getWindowCount() === 0) {
                    var window_1 = this.windowsMainService.openNewWindow(4 /* DESKTOP */)[0];
                    whenWindowReady = window_1.ready();
                }
                // Make sure a window is open, ready to receive the url event
                whenWindowReady.then(function () {
                    for (var _i = 0, urlsToOpen_1 = urlsToOpen; _i < urlsToOpen_1.length; _i++) {
                        var url = urlsToOpen_1[_i];
                        _this.urlService.open(url);
                    }
                });
                return winjs_base_1.TPromise.as(null);
            }
            // Otherwise handle in windows service
            return this.startOpenWindow(args, userEnv);
        };
        LaunchService.prototype.startOpenWindow = function (args, userEnv) {
            var context = !!userEnv['VSCODE_CLI'] ? 0 /* CLI */ : 4 /* DESKTOP */;
            var usedWindows;
            // Special case extension development
            if (!!args.extensionDevelopmentPath) {
                this.windowsMainService.openExtensionDevelopmentHostWindow({ context: context, cli: args, userEnv: userEnv });
            }
            // Start without file/folder arguments
            else if (!argv_1.hasArgs(args._) && !argv_1.hasArgs(args['folder-uri']) && !argv_1.hasArgs(args['file-uri'])) {
                var openNewWindow = false;
                // Force new window
                if (args['new-window'] || args['unity-launch']) {
                    openNewWindow = true;
                }
                // Force reuse window
                else if (args['reuse-window']) {
                    openNewWindow = false;
                }
                // Otherwise check for settings
                else {
                    var windowConfig = this.configurationService.getValue('window');
                    var openWithoutArgumentsInNewWindowConfig = (windowConfig && windowConfig.openWithoutArgumentsInNewWindow) || 'default' /* default */;
                    switch (openWithoutArgumentsInNewWindowConfig) {
                        case 'on':
                            openNewWindow = true;
                            break;
                        case 'off':
                            openNewWindow = false;
                            break;
                        default:
                            openNewWindow = !platform_1.isMacintosh; // prefer to restore running instance on macOS
                    }
                }
                if (openNewWindow) {
                    usedWindows = this.windowsMainService.open({ context: context, cli: args, userEnv: userEnv, forceNewWindow: true, forceEmpty: true });
                }
                else {
                    usedWindows = [this.windowsMainService.focusLastActive(args, context)];
                }
            }
            // Start with file/folder arguments
            else {
                usedWindows = this.windowsMainService.open({
                    context: context,
                    cli: args,
                    userEnv: userEnv,
                    forceNewWindow: args['new-window'],
                    preferNewWindow: !args['reuse-window'] && !args.wait,
                    forceReuseWindow: args['reuse-window'],
                    diffMode: args.diff,
                    addMode: args.add
                });
            }
            // If the other instance is waiting to be killed, we hook up a window listener if one window
            // is being used and only then resolve the startup promise which will kill this second instance.
            // In addition, we poll for the wait marker file to be deleted to return.
            if (args.wait && usedWindows.length === 1 && usedWindows[0]) {
                return winjs_base_1.TPromise.any([
                    this.windowsMainService.waitForWindowCloseOrLoad(usedWindows[0].id),
                    pfs_1.whenDeleted(args.waitMarkerFilePath)
                ]).then(function () { return void 0; }, function () { return void 0; });
            }
            return winjs_base_1.TPromise.as(null);
        };
        LaunchService.prototype.getMainProcessId = function () {
            this.logService.trace('Received request for process ID from other instance.');
            return winjs_base_1.TPromise.as(process.pid);
        };
        LaunchService.prototype.getMainProcessInfo = function () {
            var _this = this;
            this.logService.trace('Received request for main process info from other instance.');
            var windows = [];
            electron_1.BrowserWindow.getAllWindows().forEach(function (window) {
                var codeWindow = _this.windowsMainService.getWindowById(window.id);
                if (codeWindow) {
                    windows.push(_this.codeWindowToInfo(codeWindow));
                }
                else {
                    windows.push(_this.browserWindowToInfo(window));
                }
            });
            return winjs_base_1.TPromise.wrap({
                mainPID: process.pid,
                mainArguments: process.argv,
                windows: windows
            });
        };
        LaunchService.prototype.getLogsPath = function () {
            this.logService.trace('Received request for logs path from other instance.');
            return winjs_base_1.TPromise.as(this.environmentService.logsPath);
        };
        LaunchService.prototype.codeWindowToInfo = function (window) {
            var folderURIs = [];
            if (window.openedFolderUri) {
                folderURIs.push(window.openedFolderUri);
            }
            else if (window.openedWorkspace) {
                var rootFolders = this.workspacesMainService.resolveWorkspaceSync(window.openedWorkspace.configPath).folders;
                rootFolders.forEach(function (root) {
                    folderURIs.push(root.uri);
                });
            }
            return this.browserWindowToInfo(window.win, folderURIs);
        };
        LaunchService.prototype.browserWindowToInfo = function (win, folderURIs) {
            if (folderURIs === void 0) { folderURIs = []; }
            return {
                pid: win.webContents.getOSProcessId(),
                title: win.getTitle(),
                folderURIs: folderURIs
            };
        };
        LaunchService = __decorate([
            __param(0, log_1.ILogService),
            __param(1, windows_1.IWindowsMainService),
            __param(2, url_1.IURLService),
            __param(3, workspaces_1.IWorkspacesMainService),
            __param(4, environment_1.IEnvironmentService),
            __param(5, configuration_1.IConfigurationService)
        ], LaunchService);
        return LaunchService;
    }());
    exports.LaunchService = LaunchService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[163/*vs/platform/issue/electron-main/issueService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,86/*vs/nls!vs/platform/issue/electron-main/issueService*/,17/*vs/base/common/objects*/,41/*vs/platform/environment/node/argv*/,8/*electron*/,63/*vs/platform/launch/electron-main/launchService*/,70/*vs/platform/diagnostics/electron-main/diagnosticsService*/,9/*vs/platform/environment/common/environment*/,3/*vs/base/common/platform*/,7/*vs/platform/log/common/log*/]), function (require, exports, winjs_base_1, nls_1, objects, argv_1, electron_1, launchService_1, diagnosticsService_1, environment_1, platform_1, log_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var DEFAULT_BACKGROUND_COLOR = '#1E1E1E';
    var IssueService = /** @class */ (function () {
        function IssueService(machineId, userEnv, environmentService, launchService, logService, diagnosticsService) {
            this.machineId = machineId;
            this.userEnv = userEnv;
            this.environmentService = environmentService;
            this.launchService = launchService;
            this.logService = logService;
            this.diagnosticsService = diagnosticsService;
        }
        IssueService.prototype.openReporter = function (data) {
            var _this = this;
            electron_1.ipcMain.on('vscode:issueSystemInfoRequest', function (event) {
                _this.getSystemInformation().then(function (msg) {
                    event.sender.send('vscode:issueSystemInfoResponse', msg);
                });
            });
            electron_1.ipcMain.on('vscode:issuePerformanceInfoRequest', function (event) {
                _this.getPerformanceInfo().then(function (msg) {
                    event.sender.send('vscode:issuePerformanceInfoResponse', msg);
                });
            });
            electron_1.ipcMain.on('vscode:workbenchCommand', function (event, arg) {
                _this._issueParentWindow.webContents.send('vscode:runAction', { id: arg, from: 'issueReporter' });
            });
            electron_1.ipcMain.on('vscode:closeIssueReporter', function (event) {
                if (_this._issueWindow) {
                    _this._issueWindow.close();
                }
            });
            this._issueParentWindow = electron_1.BrowserWindow.getFocusedWindow();
            var position = this.getWindowPosition(this._issueParentWindow, 700, 800);
            if (!this._issueWindow) {
                this._issueWindow = new electron_1.BrowserWindow({
                    width: position.width,
                    height: position.height,
                    minWidth: 300,
                    minHeight: 200,
                    x: position.x,
                    y: position.y,
                    title: nls_1.localize(0, null),
                    backgroundColor: data.styles.backgroundColor || DEFAULT_BACKGROUND_COLOR
                });
                this._issueWindow.setMenuBarVisibility(false); // workaround for now, until a menu is implemented
                // Modified when testing UI
                var features = {};
                this.logService.trace('issueService#openReporter: opening issue reporter');
                this._issueWindow.loadURL(this.getIssueReporterPath(data, features));
                this._issueWindow.on('close', function () { return _this._issueWindow = null; });
                this._issueParentWindow.on('closed', function () {
                    if (_this._issueWindow) {
                        _this._issueWindow.close();
                        _this._issueWindow = null;
                    }
                });
            }
            this._issueWindow.focus();
            return winjs_base_1.TPromise.as(null);
        };
        IssueService.prototype.openProcessExplorer = function (data) {
            var _this = this;
            electron_1.ipcMain.on('windowsInfoRequest', function (event) {
                _this.launchService.getMainProcessInfo().then(function (info) {
                    event.sender.send('vscode:windowsInfoResponse', info.windows);
                });
            });
            // Create as singleton
            if (!this._processExplorerWindow) {
                var parentWindow = electron_1.BrowserWindow.getFocusedWindow();
                var position = this.getWindowPosition(parentWindow, 800, 300);
                this._processExplorerWindow = new electron_1.BrowserWindow({
                    skipTaskbar: true,
                    resizable: true,
                    width: position.width,
                    height: position.height,
                    minWidth: 300,
                    minHeight: 200,
                    x: position.x,
                    y: position.y,
                    backgroundColor: data.styles.backgroundColor,
                    title: nls_1.localize(1, null)
                });
                this._processExplorerWindow.setMenuBarVisibility(false);
                var windowConfiguration = {
                    appRoot: this.environmentService.appRoot,
                    nodeCachedDataDir: this.environmentService.nodeCachedDataDir,
                    windowId: this._processExplorerWindow.id,
                    userEnv: this.userEnv,
                    machineId: this.machineId,
                    data: data
                };
                var environment = argv_1.parseArgs(process.argv);
                var config = objects.assign(environment, windowConfiguration);
                for (var key in config) {
                    if (config[key] === void 0 || config[key] === null || config[key] === '') {
                        delete config[key]; // only send over properties that have a true value
                    }
                }
                this._processExplorerWindow.loadURL(require.toUrl('vs/code/electron-browser/processExplorer/processExplorer.html') + "?config=" + encodeURIComponent(JSON.stringify(config)));
                this._processExplorerWindow.on('close', function () { return _this._processExplorerWindow = void 0; });
                parentWindow.on('close', function () {
                    if (_this._processExplorerWindow) {
                        _this._processExplorerWindow.close();
                        _this._processExplorerWindow = null;
                    }
                });
            }
            // Focus
            this._processExplorerWindow.focus();
            return winjs_base_1.TPromise.as(null);
        };
        IssueService.prototype.getWindowPosition = function (parentWindow, defaultWidth, defaultHeight) {
            // We want the new window to open on the same display that the parent is in
            var displayToUse;
            var displays = electron_1.screen.getAllDisplays();
            // Single Display
            if (displays.length === 1) {
                displayToUse = displays[0];
            }
            // Multi Display
            else {
                // on mac there is 1 menu per window so we need to use the monitor where the cursor currently is
                if (platform_1.isMacintosh) {
                    var cursorPoint = electron_1.screen.getCursorScreenPoint();
                    displayToUse = electron_1.screen.getDisplayNearestPoint(cursorPoint);
                }
                // if we have a last active window, use that display for the new window
                if (!displayToUse && parentWindow) {
                    displayToUse = electron_1.screen.getDisplayMatching(parentWindow.getBounds());
                }
                // fallback to primary display or first display
                if (!displayToUse) {
                    displayToUse = electron_1.screen.getPrimaryDisplay() || displays[0];
                }
            }
            var state = {
                width: defaultWidth,
                height: defaultHeight,
                x: undefined,
                y: undefined
            };
            var displayBounds = displayToUse.bounds;
            state.x = displayBounds.x + (displayBounds.width / 2) - (state.width / 2);
            state.y = displayBounds.y + (displayBounds.height / 2) - (state.height / 2);
            if (displayBounds.width > 0 && displayBounds.height > 0 /* Linux X11 sessions sometimes report wrong display bounds */) {
                if (state.x < displayBounds.x) {
                    state.x = displayBounds.x; // prevent window from falling out of the screen to the left
                }
                if (state.y < displayBounds.y) {
                    state.y = displayBounds.y; // prevent window from falling out of the screen to the top
                }
                if (state.x > (displayBounds.x + displayBounds.width)) {
                    state.x = displayBounds.x; // prevent window from falling out of the screen to the right
                }
                if (state.y > (displayBounds.y + displayBounds.height)) {
                    state.y = displayBounds.y; // prevent window from falling out of the screen to the bottom
                }
                if (state.width > displayBounds.width) {
                    state.width = displayBounds.width; // prevent window from exceeding display bounds width
                }
                if (state.height > displayBounds.height) {
                    state.height = displayBounds.height; // prevent window from exceeding display bounds height
                }
            }
            return state;
        };
        IssueService.prototype.getSystemInformation = function () {
            var _this = this;
            return new winjs_base_1.Promise(function (resolve, reject) {
                _this.launchService.getMainProcessInfo().then(function (info) {
                    resolve(_this.diagnosticsService.getSystemInfo(info));
                });
            });
        };
        IssueService.prototype.getPerformanceInfo = function () {
            var _this = this;
            return new winjs_base_1.Promise(function (resolve, reject) {
                _this.launchService.getMainProcessInfo().then(function (info) {
                    _this.diagnosticsService.getPerformanceInfo(info)
                        .then(function (diagnosticInfo) {
                        resolve(diagnosticInfo);
                    })
                        .catch(function (err) {
                        _this.logService.warn('issueService#getPerformanceInfo ', err.message);
                        reject(err);
                    });
                });
            });
        };
        IssueService.prototype.getIssueReporterPath = function (data, features) {
            var windowConfiguration = {
                appRoot: this.environmentService.appRoot,
                nodeCachedDataDir: this.environmentService.nodeCachedDataDir,
                windowId: this._issueWindow.id,
                machineId: this.machineId,
                userEnv: this.userEnv,
                data: data,
                features: features
            };
            var environment = argv_1.parseArgs(process.argv);
            var config = objects.assign(environment, windowConfiguration);
            for (var key in config) {
                if (config[key] === void 0 || config[key] === null || config[key] === '') {
                    delete config[key]; // only send over properties that have a true value
                }
            }
            return require.toUrl('vs/code/electron-browser/issue/issueReporter.html') + "?config=" + encodeURIComponent(JSON.stringify(config));
        };
        IssueService = __decorate([
            __param(2, environment_1.IEnvironmentService),
            __param(3, launchService_1.ILaunchService),
            __param(4, log_1.ILogService),
            __param(5, diagnosticsService_1.IDiagnosticsService)
        ], IssueService);
        return IssueService;
    }());
    exports.IssueService = IssueService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[164/*vs/platform/windows/node/windowsIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,5/*vs/base/common/event*/,19/*vs/platform/workspaces/common/workspaces*/,6/*vs/base/common/uri*/]), function (require, exports, winjs_base_1, event_1, workspaces_1, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowsChannel = /** @class */ (function () {
        function WindowsChannel(service) {
            this.service = service;
            this.onWindowOpen = event_1.buffer(service.onWindowOpen, true);
            this.onWindowFocus = event_1.buffer(service.onWindowFocus, true);
            this.onWindowBlur = event_1.buffer(service.onWindowBlur, true);
            this.onWindowMaximize = event_1.buffer(service.onWindowMaximize, true);
            this.onWindowUnmaximize = event_1.buffer(service.onWindowUnmaximize, true);
            this.onRecentlyOpenedChange = event_1.buffer(service.onRecentlyOpenedChange, true);
        }
        WindowsChannel.prototype.listen = function (event, arg) {
            switch (event) {
                case 'onWindowOpen': return this.onWindowOpen;
                case 'onWindowFocus': return this.onWindowFocus;
                case 'onWindowBlur': return this.onWindowBlur;
                case 'onWindowMaximize': return this.onWindowMaximize;
                case 'onWindowUnmaximize': return this.onWindowUnmaximize;
                case 'onRecentlyOpenedChange': return this.onRecentlyOpenedChange;
            }
            throw new Error('No event found');
        };
        WindowsChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'pickFileFolderAndOpen': return this.service.pickFileFolderAndOpen(arg);
                case 'pickFileAndOpen': return this.service.pickFileAndOpen(arg);
                case 'pickFolderAndOpen': return this.service.pickFolderAndOpen(arg);
                case 'pickWorkspaceAndOpen': return this.service.pickWorkspaceAndOpen(arg);
                case 'showMessageBox': return this.service.showMessageBox(arg[0], arg[1]);
                case 'showSaveDialog': return this.service.showSaveDialog(arg[0], arg[1]);
                case 'showOpenDialog': return this.service.showOpenDialog(arg[0], arg[1]);
                case 'reloadWindow': return this.service.reloadWindow(arg[0], arg[1]);
                case 'openDevTools': return this.service.openDevTools(arg[0], arg[1]);
                case 'toggleDevTools': return this.service.toggleDevTools(arg);
                case 'closeWorkspace': return this.service.closeWorkspace(arg);
                case 'enterWorkspace': return this.service.enterWorkspace(arg[0], arg[1]);
                case 'createAndEnterWorkspace': {
                    var rawFolders = arg[1];
                    var folders = void 0;
                    if (Array.isArray(rawFolders)) {
                        folders = rawFolders.map(function (rawFolder) {
                            return {
                                uri: uri_1.URI.revive(rawFolder.uri),
                                name: rawFolder.name
                            };
                        });
                    }
                    return this.service.createAndEnterWorkspace(arg[0], folders, arg[2]);
                }
                case 'saveAndEnterWorkspace': return this.service.saveAndEnterWorkspace(arg[0], arg[1]);
                case 'toggleFullScreen': return this.service.toggleFullScreen(arg);
                case 'setRepresentedFilename': return this.service.setRepresentedFilename(arg[0], arg[1]);
                case 'addRecentlyOpened': return this.service.addRecentlyOpened(arg.map(uri_1.URI.revive));
                case 'removeFromRecentlyOpened': {
                    var paths = arg;
                    if (Array.isArray(paths)) {
                        paths = paths.map(function (path) { return workspaces_1.isWorkspaceIdentifier(path) ? path : uri_1.URI.revive(path); });
                    }
                    return this.service.removeFromRecentlyOpened(paths);
                }
                case 'clearRecentlyOpened': return this.service.clearRecentlyOpened();
                case 'newWindowTab': return this.service.newWindowTab();
                case 'showPreviousWindowTab': return this.service.showPreviousWindowTab();
                case 'showNextWindowTab': return this.service.showNextWindowTab();
                case 'moveWindowTabToNewWindow': return this.service.moveWindowTabToNewWindow();
                case 'mergeAllWindowTabs': return this.service.mergeAllWindowTabs();
                case 'toggleWindowTabsBar': return this.service.toggleWindowTabsBar();
                case 'updateTouchBar': return this.service.updateTouchBar(arg[0], arg[1]);
                case 'getRecentlyOpened': return this.service.getRecentlyOpened(arg);
                case 'focusWindow': return this.service.focusWindow(arg);
                case 'closeWindow': return this.service.closeWindow(arg);
                case 'isFocused': return this.service.isFocused(arg);
                case 'isMaximized': return this.service.isMaximized(arg);
                case 'maximizeWindow': return this.service.maximizeWindow(arg);
                case 'unmaximizeWindow': return this.service.unmaximizeWindow(arg);
                case 'minimizeWindow': return this.service.minimizeWindow(arg);
                case 'onWindowTitleDoubleClick': return this.service.onWindowTitleDoubleClick(arg);
                case 'setDocumentEdited': return this.service.setDocumentEdited(arg[0], arg[1]);
                case 'openWindow': return this.service.openWindow(arg[0], arg[1] ? arg[1].map(function (r) { return uri_1.URI.revive(r); }) : arg[1], arg[2]);
                case 'openNewWindow': return this.service.openNewWindow();
                case 'showWindow': return this.service.showWindow(arg);
                case 'getWindows': return this.service.getWindows();
                case 'getWindowCount': return this.service.getWindowCount();
                case 'relaunch': return this.service.relaunch(arg[0]);
                case 'whenSharedProcessReady': return this.service.whenSharedProcessReady();
                case 'toggleSharedProcess': return this.service.toggleSharedProcess();
                case 'quit': return this.service.quit();
                case 'log': return this.service.log(arg[0], arg[1]);
                case 'showItemInFolder': return this.service.showItemInFolder(arg);
                case 'getActiveWindowId': return this.service.getActiveWindowId();
                case 'openExternal': return this.service.openExternal(arg);
                case 'startCrashReporter': return this.service.startCrashReporter(arg);
                case 'openAboutDialog': return this.service.openAboutDialog();
            }
            return undefined;
        };
        return WindowsChannel;
    }());
    exports.WindowsChannel = WindowsChannel;
    var WindowsChannelClient = /** @class */ (function () {
        function WindowsChannelClient(channel) {
            this.channel = channel;
        }
        Object.defineProperty(WindowsChannelClient.prototype, "onWindowOpen", {
            get: function () { return this.channel.listen('onWindowOpen'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowsChannelClient.prototype, "onWindowFocus", {
            get: function () { return this.channel.listen('onWindowFocus'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowsChannelClient.prototype, "onWindowBlur", {
            get: function () { return this.channel.listen('onWindowBlur'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowsChannelClient.prototype, "onWindowMaximize", {
            get: function () { return this.channel.listen('onWindowMaximize'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowsChannelClient.prototype, "onWindowUnmaximize", {
            get: function () { return this.channel.listen('onWindowUnmaximize'); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WindowsChannelClient.prototype, "onRecentlyOpenedChange", {
            get: function () { return this.channel.listen('onRecentlyOpenedChange'); },
            enumerable: true,
            configurable: true
        });
        WindowsChannelClient.prototype.pickFileFolderAndOpen = function (options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('pickFileFolderAndOpen', options));
        };
        WindowsChannelClient.prototype.pickFileAndOpen = function (options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('pickFileAndOpen', options));
        };
        WindowsChannelClient.prototype.pickFolderAndOpen = function (options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('pickFolderAndOpen', options));
        };
        WindowsChannelClient.prototype.pickWorkspaceAndOpen = function (options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('pickWorkspaceAndOpen', options));
        };
        WindowsChannelClient.prototype.showMessageBox = function (windowId, options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('showMessageBox', [windowId, options]));
        };
        WindowsChannelClient.prototype.showSaveDialog = function (windowId, options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('showSaveDialog', [windowId, options]));
        };
        WindowsChannelClient.prototype.showOpenDialog = function (windowId, options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('showOpenDialog', [windowId, options]));
        };
        WindowsChannelClient.prototype.reloadWindow = function (windowId, args) {
            return winjs_base_1.TPromise.wrap(this.channel.call('reloadWindow', [windowId, args]));
        };
        WindowsChannelClient.prototype.openDevTools = function (windowId, options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('openDevTools', [windowId, options]));
        };
        WindowsChannelClient.prototype.toggleDevTools = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('toggleDevTools', windowId));
        };
        WindowsChannelClient.prototype.closeWorkspace = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('closeWorkspace', windowId));
        };
        WindowsChannelClient.prototype.enterWorkspace = function (windowId, path) {
            return winjs_base_1.TPromise.wrap(this.channel.call('enterWorkspace', [windowId, path]));
        };
        WindowsChannelClient.prototype.createAndEnterWorkspace = function (windowId, folders, path) {
            return winjs_base_1.TPromise.wrap(this.channel.call('createAndEnterWorkspace', [windowId, folders, path]));
        };
        WindowsChannelClient.prototype.saveAndEnterWorkspace = function (windowId, path) {
            return winjs_base_1.TPromise.wrap(this.channel.call('saveAndEnterWorkspace', [windowId, path]));
        };
        WindowsChannelClient.prototype.toggleFullScreen = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('toggleFullScreen', windowId));
        };
        WindowsChannelClient.prototype.setRepresentedFilename = function (windowId, fileName) {
            return winjs_base_1.TPromise.wrap(this.channel.call('setRepresentedFilename', [windowId, fileName]));
        };
        WindowsChannelClient.prototype.addRecentlyOpened = function (files) {
            return winjs_base_1.TPromise.wrap(this.channel.call('addRecentlyOpened', files));
        };
        WindowsChannelClient.prototype.removeFromRecentlyOpened = function (paths) {
            return winjs_base_1.TPromise.wrap(this.channel.call('removeFromRecentlyOpened', paths));
        };
        WindowsChannelClient.prototype.clearRecentlyOpened = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('clearRecentlyOpened'));
        };
        WindowsChannelClient.prototype.getRecentlyOpened = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('getRecentlyOpened', windowId))
                .then(function (recentlyOpened) {
                recentlyOpened.workspaces = recentlyOpened.workspaces.map(function (workspace) { return workspaces_1.isWorkspaceIdentifier(workspace) ? workspace : uri_1.URI.revive(workspace); });
                recentlyOpened.files = recentlyOpened.files.map(uri_1.URI.revive);
                return recentlyOpened;
            });
        };
        WindowsChannelClient.prototype.newWindowTab = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('newWindowTab'));
        };
        WindowsChannelClient.prototype.showPreviousWindowTab = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('showPreviousWindowTab'));
        };
        WindowsChannelClient.prototype.showNextWindowTab = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('showNextWindowTab'));
        };
        WindowsChannelClient.prototype.moveWindowTabToNewWindow = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('moveWindowTabToNewWindow'));
        };
        WindowsChannelClient.prototype.mergeAllWindowTabs = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('mergeAllWindowTabs'));
        };
        WindowsChannelClient.prototype.toggleWindowTabsBar = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('toggleWindowTabsBar'));
        };
        WindowsChannelClient.prototype.focusWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('focusWindow', windowId));
        };
        WindowsChannelClient.prototype.closeWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('closeWindow', windowId));
        };
        WindowsChannelClient.prototype.isFocused = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('isFocused', windowId));
        };
        WindowsChannelClient.prototype.isMaximized = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('isMaximized', windowId));
        };
        WindowsChannelClient.prototype.maximizeWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('maximizeWindow', windowId));
        };
        WindowsChannelClient.prototype.unmaximizeWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('unmaximizeWindow', windowId));
        };
        WindowsChannelClient.prototype.minimizeWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('minimizeWindow', windowId));
        };
        WindowsChannelClient.prototype.onWindowTitleDoubleClick = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('onWindowTitleDoubleClick', windowId));
        };
        WindowsChannelClient.prototype.setDocumentEdited = function (windowId, flag) {
            return winjs_base_1.TPromise.wrap(this.channel.call('setDocumentEdited', [windowId, flag]));
        };
        WindowsChannelClient.prototype.quit = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('quit'));
        };
        WindowsChannelClient.prototype.relaunch = function (options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('relaunch', [options]));
        };
        WindowsChannelClient.prototype.whenSharedProcessReady = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('whenSharedProcessReady'));
        };
        WindowsChannelClient.prototype.toggleSharedProcess = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('toggleSharedProcess'));
        };
        WindowsChannelClient.prototype.openWindow = function (windowId, paths, options) {
            return winjs_base_1.TPromise.wrap(this.channel.call('openWindow', [windowId, paths, options]));
        };
        WindowsChannelClient.prototype.openNewWindow = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('openNewWindow'));
        };
        WindowsChannelClient.prototype.showWindow = function (windowId) {
            return winjs_base_1.TPromise.wrap(this.channel.call('showWindow', windowId));
        };
        WindowsChannelClient.prototype.getWindows = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('getWindows').then(function (result) { result.forEach(function (win) { return win.folderUri = win.folderUri ? uri_1.URI.revive(win.folderUri) : win.folderUri; }); return result; }));
        };
        WindowsChannelClient.prototype.getWindowCount = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('getWindowCount'));
        };
        WindowsChannelClient.prototype.log = function (severity) {
            var messages = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                messages[_i - 1] = arguments[_i];
            }
            return winjs_base_1.TPromise.wrap(this.channel.call('log', [severity, messages]));
        };
        WindowsChannelClient.prototype.showItemInFolder = function (path) {
            return winjs_base_1.TPromise.wrap(this.channel.call('showItemInFolder', path));
        };
        WindowsChannelClient.prototype.getActiveWindowId = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('getActiveWindowId'));
        };
        WindowsChannelClient.prototype.openExternal = function (url) {
            return winjs_base_1.TPromise.wrap(this.channel.call('openExternal', url));
        };
        WindowsChannelClient.prototype.startCrashReporter = function (config) {
            return winjs_base_1.TPromise.wrap(this.channel.call('startCrashReporter', config));
        };
        WindowsChannelClient.prototype.updateTouchBar = function (windowId, items) {
            return winjs_base_1.TPromise.wrap(this.channel.call('updateTouchBar', [windowId, items]));
        };
        WindowsChannelClient.prototype.openAboutDialog = function () {
            return winjs_base_1.TPromise.wrap(this.channel.call('openAboutDialog'));
        };
        return WindowsChannelClient;
    }());
    exports.WindowsChannelClient = WindowsChannelClient;
});

define(__m[74/*vs/platform/workspace/common/workspace*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,15/*vs/base/common/paths*/,32/*vs/base/common/resources*/,4/*vs/platform/instantiation/common/instantiation*/,38/*vs/base/common/map*/,19/*vs/platform/workspaces/common/workspaces*/,24/*vs/base/common/arrays*/,3/*vs/base/common/platform*/]), function (require, exports, uri_1, paths, resources, instantiation_1, map_1, workspaces_1, arrays_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var WorkbenchState;
    (function (WorkbenchState) {
        WorkbenchState[WorkbenchState["EMPTY"] = 1] = "EMPTY";
        WorkbenchState[WorkbenchState["FOLDER"] = 2] = "FOLDER";
        WorkbenchState[WorkbenchState["WORKSPACE"] = 3] = "WORKSPACE";
    })(WorkbenchState = exports.WorkbenchState || (exports.WorkbenchState = {}));
    var IWorkspace;
    (function (IWorkspace) {
        function isIWorkspace(thing) {
            return thing && typeof thing === 'object'
                && typeof thing.id === 'string'
                && Array.isArray(thing.folders);
        }
        IWorkspace.isIWorkspace = isIWorkspace;
    })(IWorkspace = exports.IWorkspace || (exports.IWorkspace = {}));
    var IWorkspaceFolder;
    (function (IWorkspaceFolder) {
        function isIWorkspaceFolder(thing) {
            return thing && typeof thing === 'object'
                && uri_1.URI.isUri(thing.uri)
                && typeof thing.name === 'string'
                && typeof thing.toResource === 'function';
        }
        IWorkspaceFolder.isIWorkspaceFolder = isIWorkspaceFolder;
    })(IWorkspaceFolder = exports.IWorkspaceFolder || (exports.IWorkspaceFolder = {}));
    var Workspace = /** @class */ (function () {
        function Workspace(_id, folders, _configuration, _ctime) {
            if (folders === void 0) { folders = []; }
            if (_configuration === void 0) { _configuration = null; }
            this._id = _id;
            this._configuration = _configuration;
            this._ctime = _ctime;
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            this.folders = folders;
        }
        Workspace.prototype.update = function (workspace) {
            this._id = workspace.id;
            this._configuration = workspace.configuration;
            this._ctime = workspace.ctime;
            this.folders = workspace.folders;
        };
        Object.defineProperty(Workspace.prototype, "folders", {
            get: function () {
                return this._folders;
            },
            set: function (folders) {
                this._folders = folders;
                this.updateFoldersMap();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "ctime", {
            get: function () {
                return this._ctime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Workspace.prototype, "configuration", {
            get: function () {
                return this._configuration;
            },
            set: function (configuration) {
                this._configuration = configuration;
            },
            enumerable: true,
            configurable: true
        });
        Workspace.prototype.getFolder = function (resource) {
            if (!resource) {
                return null;
            }
            return this._foldersMap.findSubstr(resource.toString());
        };
        Workspace.prototype.updateFoldersMap = function () {
            this._foldersMap = map_1.TernarySearchTree.forPaths();
            for (var _i = 0, _a = this.folders; _i < _a.length; _i++) {
                var folder = _a[_i];
                this._foldersMap.set(folder.uri.toString(), folder);
            }
        };
        Workspace.prototype.toJSON = function () {
            return { id: this.id, folders: this.folders, configuration: this.configuration };
        };
        return Workspace;
    }());
    exports.Workspace = Workspace;
    var WorkspaceFolder = /** @class */ (function () {
        function WorkspaceFolder(data, raw) {
            this.raw = raw;
            this.uri = data.uri;
            this.index = data.index;
            this.name = data.name;
        }
        WorkspaceFolder.prototype.toResource = function (relativePath) {
            return resources.joinPath(this.uri, relativePath);
        };
        WorkspaceFolder.prototype.toJSON = function () {
            return { uri: this.uri, name: this.name, index: this.index };
        };
        return WorkspaceFolder;
    }());
    exports.WorkspaceFolder = WorkspaceFolder;
    function toWorkspaceFolders(configuredFolders, relativeTo) {
        var workspaceFolders = parseWorkspaceFolders(configuredFolders, relativeTo);
        return ensureUnique(arrays_1.coalesce(workspaceFolders))
            .map(function (_a, index) {
            var uri = _a.uri, raw = _a.raw, name = _a.name;
            return new WorkspaceFolder({ uri: uri, name: name || resources.basenameOrAuthority(uri), index: index }, raw);
        });
    }
    exports.toWorkspaceFolders = toWorkspaceFolders;
    function parseWorkspaceFolders(configuredFolders, relativeTo) {
        return configuredFolders.map(function (configuredFolder, index) {
            var uri;
            if (workspaces_1.isRawFileWorkspaceFolder(configuredFolder)) {
                uri = toUri(configuredFolder.path, relativeTo);
            }
            else if (workspaces_1.isRawUriWorkspaceFolder(configuredFolder)) {
                try {
                    uri = uri_1.URI.parse(configuredFolder.uri);
                    // this makes sure all workspace folder are absolute
                    if (uri.path[0] !== '/') {
                        uri = uri.with({ path: '/' + uri.path });
                    }
                }
                catch (e) {
                    console.warn(e);
                    // ignore
                }
            }
            if (!uri) {
                return void 0;
            }
            return new WorkspaceFolder({ uri: uri, name: configuredFolder.name, index: index }, configuredFolder);
        });
    }
    function toUri(path, relativeTo) {
        if (path) {
            if (paths.isAbsolute(path)) {
                return uri_1.URI.file(path);
            }
            if (relativeTo) {
                return resources.joinPath(relativeTo, path);
            }
        }
        return null;
    }
    function ensureUnique(folders) {
        return arrays_1.distinct(folders, function (folder) { return platform_1.isLinux ? folder.uri.toString() : folder.uri.toString().toLowerCase(); });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[48/*vs/platform/label/common/label*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/uri*/,5/*vs/base/common/event*/,9/*vs/platform/environment/common/environment*/,74/*vs/platform/workspace/common/workspace*/,4/*vs/platform/instantiation/common/instantiation*/,32/*vs/base/common/resources*/,3/*vs/base/common/platform*/,31/*vs/base/common/labels*/,18/*vs/base/common/strings*/,19/*vs/platform/workspaces/common/workspaces*/,87/*vs/nls!vs/platform/label/common/label*/,46/*vs/platform/files/common/files*/,15/*vs/base/common/paths*/,30/*vs/base/common/network*/]), function (require, exports, uri_1, event_1, environment_1, workspace_1, instantiation_1, resources_1, platform_1, labels_1, strings_1, workspaces_1, nls_1, files_1, paths_1, network_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LABEL_SERVICE_ID = 'label';
    var sepRegexp = /\//g;
    var labelMatchingRegexp = /\$\{scheme\}|\$\{authority\}|\$\{path\}/g;
    function hasDriveLetter(path) {
        return platform_1.isWindows && path && path[2] === ':';
    }
    var LabelService = /** @class */ (function () {
        function LabelService(environmentService, contextService) {
            this.environmentService = environmentService;
            this.contextService = contextService;
            this.formatters = new Map();
            this._onDidRegisterFormatter = new event_1.Emitter();
        }
        Object.defineProperty(LabelService.prototype, "onDidRegisterFormatter", {
            get: function () {
                return this._onDidRegisterFormatter.event;
            },
            enumerable: true,
            configurable: true
        });
        LabelService.prototype.getUriLabel = function (resource, relative, forceNoTildify) {
            if (!resource) {
                return undefined;
            }
            var formatter = this.formatters.get(resource.scheme);
            if (!formatter) {
                return labels_1.getPathLabel(resource.path, this.environmentService, relative ? this.contextService : undefined);
            }
            if (relative) {
                var baseResource = this.contextService && this.contextService.getWorkspaceFolder(resource);
                if (baseResource) {
                    var relativeLabel = void 0;
                    if (resources_1.isEqual(baseResource.uri, resource, !platform_1.isLinux)) {
                        relativeLabel = ''; // no label if resources are identical
                    }
                    else {
                        var baseResourceLabel = this.formatUri(baseResource.uri, formatter, forceNoTildify);
                        relativeLabel = strings_1.ltrim(this.formatUri(resource, formatter, forceNoTildify).substring(baseResourceLabel.length), formatter.uri.separator);
                    }
                    var hasMultipleRoots = this.contextService.getWorkspace().folders.length > 1;
                    if (hasMultipleRoots) {
                        var rootName = (baseResource && baseResource.name) ? baseResource.name : resources_1.basenameOrAuthority(baseResource.uri);
                        relativeLabel = relativeLabel ? (rootName + '  ' + relativeLabel) : rootName; // always show root basename if there are multiple
                    }
                    return relativeLabel;
                }
            }
            return this.formatUri(resource, formatter, forceNoTildify);
        };
        LabelService.prototype.getWorkspaceLabel = function (workspace, options) {
            if (!workspaces_1.isWorkspaceIdentifier(workspace) && !workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                workspace = workspaces_1.toWorkspaceIdentifier(workspace);
                if (!workspace) {
                    return '';
                }
            }
            // Workspace: Single Folder
            if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                // Folder on disk
                var formatter = this.formatters.get(workspace.scheme);
                var label = options && options.verbose ? this.getUriLabel(workspace) : resources_1.basenameOrAuthority(workspace);
                if (workspace.scheme === network_1.Schemas.file) {
                    return label;
                }
                var suffix = formatter && formatter.workspace && (typeof formatter.workspace.suffix === 'string') ? formatter.workspace.suffix : workspace.scheme;
                return suffix ? label + " (" + suffix + ")" : label;
            }
            // Workspace: Untitled
            if (files_1.isParent(workspace.configPath, this.environmentService.workspacesHome, !platform_1.isLinux /* ignore case */)) {
                return nls_1.localize(0, null);
            }
            // Workspace: Saved
            var filename = paths_1.basename(workspace.configPath);
            var workspaceName = filename.substr(0, filename.length - workspaces_1.WORKSPACE_EXTENSION.length - 1);
            if (options && options.verbose) {
                return nls_1.localize(1, null, this.getUriLabel(uri_1.URI.file(paths_1.join(paths_1.dirname(workspace.configPath), workspaceName))));
            }
            return nls_1.localize(2, null, workspaceName);
        };
        LabelService.prototype.registerFormatter = function (scheme, formatter) {
            var _this = this;
            this.formatters.set(scheme, formatter);
            this._onDidRegisterFormatter.fire({ scheme: scheme, formatter: formatter });
            return {
                dispose: function () { return _this.formatters.delete(scheme); }
            };
        };
        LabelService.prototype.formatUri = function (resource, formatter, forceNoTildify) {
            var label = formatter.uri.label.replace(labelMatchingRegexp, function (match) {
                switch (match) {
                    case '${scheme}': return resource.scheme;
                    case '${authority}': return resource.authority;
                    case '${path}': return resource.path;
                    default: return '';
                }
            });
            // convert \c:\something => C:\something
            if (formatter.uri.normalizeDriveLetter && hasDriveLetter(label)) {
                label = label.charAt(1).toUpperCase() + label.substr(2);
            }
            if (formatter.uri.tildify && !forceNoTildify) {
                label = labels_1.tildify(label, this.environmentService.userHome);
            }
            return label.replace(sepRegexp, formatter.uri.separator);
        };
        LabelService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, workspace_1.IWorkspaceContextService)
        ], LabelService);
        return LabelService;
    }());
    exports.LabelService = LabelService;
    exports.ILabelService = instantiation_1.createDecorator(LABEL_SERVICE_ID);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[167/*vs/code/electron-main/menus*/], __M([1/*require*/,0/*exports*/,77/*vs/nls!vs/code/electron-main/menus*/,3/*vs/base/common/platform*/,24/*vs/base/common/arrays*/,9/*vs/platform/environment/common/environment*/,8/*electron*/,69/*vs/platform/windows/common/windows*/,14/*vs/platform/configuration/common/configuration*/,46/*vs/platform/files/common/files*/,29/*vs/platform/telemetry/common/telemetry*/,33/*vs/platform/update/common/update*/,16/*vs/platform/node/product*/,20/*vs/base/common/async*/,4/*vs/platform/instantiation/common/instantiation*/,31/*vs/base/common/labels*/,71/*vs/code/electron-main/keyboard*/,25/*vs/platform/windows/electron-main/windows*/,44/*vs/platform/history/common/history*/,19/*vs/platform/workspaces/common/workspaces*/,6/*vs/base/common/uri*/,48/*vs/platform/label/common/label*/]), function (require, exports, nls, platform_1, arrays, environment_1, electron_1, windows_1, configuration_1, files_1, telemetry_1, update_1, product_1, async_1, instantiation_1, labels_1, keyboard_1, windows_2, history_1, workspaces_1, uri_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var telemetryFrom = 'menu';
    var CodeMenu = /** @class */ (function () {
        function CodeMenu(updateService, instantiationService, configurationService, windowsMainService, windowsService, environmentService, telemetryService, historyMainService, labelService) {
            var _this = this;
            this.updateService = updateService;
            this.configurationService = configurationService;
            this.windowsMainService = windowsMainService;
            this.windowsService = windowsService;
            this.environmentService = environmentService;
            this.telemetryService = telemetryService;
            this.historyMainService = historyMainService;
            this.labelService = labelService;
            this.keys = [
                'files.autoSave',
                'editor.multiCursorModifier',
                'workbench.sideBar.location',
                'workbench.statusBar.visible',
                'workbench.activityBar.visible',
                'window.enableMenuBarMnemonics',
                'window.nativeTabs'
            ];
            this.menuUpdater = new async_1.RunOnceScheduler(function () { return _this.doUpdateMenu(); }, 0);
            this.keybindingsResolver = instantiationService.createInstance(keyboard_1.KeybindingsResolver);
            this.install();
            this.registerListeners();
        }
        CodeMenu.prototype.registerListeners = function () {
            var _this = this;
            // Keep flag when app quits
            electron_1.app.on('will-quit', function () {
                _this.isQuitting = true;
            });
            // Listen to some events from window service to update menu
            this.historyMainService.onRecentlyOpenedChange(function () { return _this.updateMenu(); });
            this.windowsMainService.onWindowsCountChanged(function (e) { return _this.onWindowsCountChanged(e); });
            this.windowsMainService.onActiveWindowChanged(function () { return _this.updateWorkspaceMenuItems(); });
            this.windowsMainService.onWindowReady(function () { return _this.updateWorkspaceMenuItems(); });
            this.windowsMainService.onWindowClose(function () { return _this.updateWorkspaceMenuItems(); });
            // Update when auto save config changes
            this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(e); });
            // Listen to update service
            this.updateService.onStateChange(function () { return _this.updateMenu(); });
            // Listen to keybindings change
            this.keybindingsResolver.onKeybindingsChanged(function () { return _this.updateMenu(); });
        };
        CodeMenu.prototype.onConfigurationUpdated = function (event) {
            if (this.keys.some(function (key) { return event.affectsConfiguration(key); })) {
                this.updateMenu();
            }
        };
        Object.defineProperty(CodeMenu.prototype, "currentAutoSaveSetting", {
            get: function () {
                return this.configurationService.getValue('files.autoSave');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentMultiCursorModifierSetting", {
            get: function () {
                return this.configurationService.getValue('editor.multiCursorModifier');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentSidebarLocation", {
            get: function () {
                return this.configurationService.getValue('workbench.sideBar.location') || 'left';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentStatusbarVisible", {
            get: function () {
                var statusbarVisible = this.configurationService.getValue('workbench.statusBar.visible');
                if (typeof statusbarVisible !== 'boolean') {
                    statusbarVisible = true;
                }
                return statusbarVisible;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentActivityBarVisible", {
            get: function () {
                var activityBarVisible = this.configurationService.getValue('workbench.activityBar.visible');
                if (typeof activityBarVisible !== 'boolean') {
                    activityBarVisible = true;
                }
                return activityBarVisible;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentEnableMenuBarMnemonics", {
            get: function () {
                var enableMenuBarMnemonics = this.configurationService.getValue('window.enableMenuBarMnemonics');
                if (typeof enableMenuBarMnemonics !== 'boolean') {
                    enableMenuBarMnemonics = true;
                }
                return enableMenuBarMnemonics;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeMenu.prototype, "currentEnableNativeTabs", {
            get: function () {
                var enableNativeTabs = this.configurationService.getValue('window.nativeTabs');
                if (typeof enableNativeTabs !== 'boolean') {
                    enableNativeTabs = false;
                }
                return enableNativeTabs;
            },
            enumerable: true,
            configurable: true
        });
        CodeMenu.prototype.updateMenu = function () {
            this.menuUpdater.schedule(); // buffer multiple attempts to update the menu
        };
        CodeMenu.prototype.doUpdateMenu = function () {
            var _this = this;
            // Due to limitations in Electron, it is not possible to update menu items dynamically. The suggested
            // workaround from Electron is to set the application menu again.
            // See also https://github.com/electron/electron/issues/846
            //
            // Run delayed to prevent updating menu while it is open
            if (!this.isQuitting) {
                setTimeout(function () {
                    if (!_this.isQuitting) {
                        _this.install();
                    }
                }, 10 /* delay this because there is an issue with updating a menu when it is open */);
            }
        };
        CodeMenu.prototype.onWindowsCountChanged = function (e) {
            if (!platform_1.isMacintosh) {
                return;
            }
            // Update menu if window count goes from N > 0 or 0 > N to update menu item enablement
            if ((e.oldCount === 0 && e.newCount > 0) || (e.oldCount > 0 && e.newCount === 0)) {
                this.updateMenu();
            }
        };
        CodeMenu.prototype.updateWorkspaceMenuItems = function () {
            var window = this.windowsMainService.getLastActiveWindow();
            var isInWorkspaceContext = window && !!window.openedWorkspace;
            var isInFolderContext = window && !!window.openedFolderUri;
            this.closeWorkspace.visible = isInWorkspaceContext;
            this.closeFolder.visible = !isInWorkspaceContext;
            this.closeFolder.enabled = isInFolderContext || platform_1.isLinux /* https://github.com/Microsoft/vscode/issues/36431 */;
        };
        CodeMenu.prototype.install = function () {
            var _this = this;
            // Menus
            var menubar = new electron_1.Menu();
            // Mac: Application
            var macApplicationMenuItem;
            if (platform_1.isMacintosh) {
                var applicationMenu = new electron_1.Menu();
                macApplicationMenuItem = new electron_1.MenuItem({ label: product_1.default.nameShort, submenu: applicationMenu });
                this.setMacApplicationMenu(applicationMenu);
            }
            // File
            var fileMenu = new electron_1.Menu();
            var fileMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(0, null)), submenu: fileMenu });
            this.setFileMenu(fileMenu);
            // Edit
            var editMenu = new electron_1.Menu();
            var editMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(1, null)), submenu: editMenu });
            this.setEditMenu(editMenu);
            // Selection
            var selectionMenu = new electron_1.Menu();
            var selectionMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(2, null)), submenu: selectionMenu });
            this.setSelectionMenu(selectionMenu);
            // View
            var viewMenu = new electron_1.Menu();
            var viewMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(3, null)), submenu: viewMenu });
            this.setViewMenu(viewMenu);
            // Goto
            var gotoMenu = new electron_1.Menu();
            var gotoMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(4, null)), submenu: gotoMenu });
            this.setGotoMenu(gotoMenu);
            // Debug
            var debugMenu = new electron_1.Menu();
            var debugMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(5, null)), submenu: debugMenu });
            this.setDebugMenu(debugMenu);
            // Terminal
            var terminalMenu = new electron_1.Menu();
            var terminalMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(6, null)), submenu: terminalMenu });
            this.setTerminalMenu(terminalMenu);
            // Mac: Window
            var macWindowMenuItem;
            if (platform_1.isMacintosh) {
                var windowMenu = new electron_1.Menu();
                macWindowMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(7, null)), submenu: windowMenu, role: 'window' });
                this.setMacWindowMenu(windowMenu);
            }
            // Help
            var helpMenu = new electron_1.Menu();
            var helpMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(8, null)), submenu: helpMenu, role: 'help' });
            this.setHelpMenu(helpMenu);
            // Menu Structure
            if (macApplicationMenuItem) {
                menubar.append(macApplicationMenuItem);
            }
            menubar.append(fileMenuItem);
            menubar.append(editMenuItem);
            menubar.append(selectionMenuItem);
            menubar.append(viewMenuItem);
            menubar.append(gotoMenuItem);
            menubar.append(debugMenuItem);
            menubar.append(terminalMenuItem);
            if (macWindowMenuItem) {
                menubar.append(macWindowMenuItem);
            }
            menubar.append(helpMenuItem);
            electron_1.Menu.setApplicationMenu(menubar);
            // Dock Menu
            if (platform_1.isMacintosh && !this.appMenuInstalled) {
                this.appMenuInstalled = true;
                var dockMenu = new electron_1.Menu();
                dockMenu.append(new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(9, null)), click: function () { return _this.windowsMainService.openNewWindow(1 /* DOCK */); } }));
                electron_1.app.dock.setMenu(dockMenu);
            }
        };
        CodeMenu.prototype.setMacApplicationMenu = function (macApplicationMenu) {
            var _this = this;
            var about = new electron_1.MenuItem({ label: nls.localize(10, null, product_1.default.nameLong), role: 'about' });
            var checkForUpdates = this.getUpdateMenuItems();
            var preferences = this.getPreferencesMenu();
            var servicesMenu = new electron_1.Menu();
            var services = new electron_1.MenuItem({ label: nls.localize(11, null), role: 'services', submenu: servicesMenu });
            var hide = new electron_1.MenuItem({ label: nls.localize(12, null, product_1.default.nameLong), role: 'hide', accelerator: 'Command+H' });
            var hideOthers = new electron_1.MenuItem({ label: nls.localize(13, null), role: 'hideothers', accelerator: 'Command+Alt+H' });
            var showAll = new electron_1.MenuItem({ label: nls.localize(14, null), role: 'unhide' });
            var quit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', {
                label: nls.localize(15, null, product_1.default.nameLong), click: function () {
                    if (_this.windowsMainService.getWindowCount() === 0 || !!electron_1.BrowserWindow.getFocusedWindow()) {
                        _this.windowsMainService.quit(); // fix for https://github.com/Microsoft/vscode/issues/39191
                    }
                }
            }));
            var actions = [about];
            actions.push.apply(actions, checkForUpdates);
            actions.push.apply(actions, [
                __separator__(),
                preferences,
                __separator__(),
                services,
                __separator__(),
                hide,
                hideOthers,
                showAll,
                __separator__(),
                quit
            ]);
            actions.forEach(function (i) { return macApplicationMenu.append(i); });
        };
        CodeMenu.prototype.setFileMenu = function (fileMenu) {
            var _this = this;
            var hasNoWindows = (this.windowsMainService.getWindowCount() === 0);
            var newFile;
            if (hasNoWindows) {
                newFile = new electron_1.MenuItem(this.likeAction('workbench.action.files.newUntitledFile', { label: this.mnemonicLabel(nls.localize(16, null)), click: function () { return _this.windowsMainService.openNewWindow(2 /* MENU */); } }));
            }
            else {
                newFile = this.createMenuItem(nls.localize(17, null), 'workbench.action.files.newUntitledFile');
            }
            var open;
            if (hasNoWindows) {
                open = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFileFolder', { label: this.mnemonicLabel(nls.localize(18, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickFileFolderAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
            }
            else {
                open = this.createMenuItem(nls.localize(19, null), ['workbench.action.files.openFileFolder', 'workbench.action.files.openFileFolderInNewWindow']);
            }
            var openWorkspace;
            if (hasNoWindows) {
                openWorkspace = new electron_1.MenuItem(this.likeAction('workbench.action.openWorkspace', { label: this.mnemonicLabel(nls.localize(20, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickWorkspaceAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
            }
            else {
                openWorkspace = this.createMenuItem(nls.localize(21, null), ['workbench.action.openWorkspace', 'workbench.action.openWorkspaceInNewWindow']);
            }
            var openFolder;
            if (hasNoWindows) {
                openFolder = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFolder', { label: this.mnemonicLabel(nls.localize(22, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickFolderAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
            }
            else {
                openFolder = this.createMenuItem(nls.localize(23, null), ['workbench.action.files.openFolder', 'workbench.action.files.openFolderInNewWindow']);
            }
            var openFile;
            if (hasNoWindows) {
                openFile = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFile', { label: this.mnemonicLabel(nls.localize(24, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickFileAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
            }
            else {
                openFile = this.createMenuItem(nls.localize(25, null), ['workbench.action.files.openFile', 'workbench.action.files.openFileInNewWindow']);
            }
            var openRecentMenu = new electron_1.Menu();
            this.setOpenRecentMenu(openRecentMenu);
            var openRecent = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(26, null)), submenu: openRecentMenu, enabled: openRecentMenu.items.length > 0 });
            var saveWorkspaceAs = this.createMenuItem(nls.localize(27, null), 'workbench.action.saveWorkspaceAs');
            var addFolder = this.createMenuItem(nls.localize(28, null), 'workbench.action.addRootFolder');
            var saveFile = this.createMenuItem(nls.localize(29, null), 'workbench.action.files.save');
            var saveFileAs = this.createMenuItem(nls.localize(30, null), 'workbench.action.files.saveAs');
            var saveAllFiles = this.createMenuItem(nls.localize(31, null), 'workbench.action.files.saveAll');
            var autoSaveEnabled = [files_1.AutoSaveConfiguration.AFTER_DELAY, files_1.AutoSaveConfiguration.ON_FOCUS_CHANGE, files_1.AutoSaveConfiguration.ON_WINDOW_CHANGE].some(function (s) { return _this.currentAutoSaveSetting === s; });
            var autoSave = this.createMenuItem(this.mnemonicLabel(nls.localize(32, null)), 'workbench.action.toggleAutoSave', this.windowsMainService.getWindowCount() > 0, autoSaveEnabled);
            var preferences = this.getPreferencesMenu();
            var newWindow = new electron_1.MenuItem(this.likeAction('workbench.action.newWindow', { label: this.mnemonicLabel(nls.localize(33, null)), click: function () { return _this.windowsMainService.openNewWindow(2 /* MENU */); } }));
            var revertFile = this.createMenuItem(nls.localize(34, null), 'workbench.action.files.revert');
            var closeWindow = new electron_1.MenuItem(this.likeAction('workbench.action.closeWindow', { label: this.mnemonicLabel(nls.localize(35, null)), click: function () { return _this.windowsMainService.getLastActiveWindow().win.close(); }, enabled: this.windowsMainService.getWindowCount() > 0 }));
            this.closeWorkspace = this.createMenuItem(nls.localize(36, null), 'workbench.action.closeFolder');
            this.closeFolder = this.createMenuItem(nls.localize(37, null), 'workbench.action.closeFolder');
            var closeEditor = this.createMenuItem(nls.localize(38, null), 'workbench.action.closeActiveEditor');
            var exit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', { label: this.mnemonicLabel(nls.localize(39, null)), click: function () { return _this.windowsMainService.quit(); } }));
            this.updateWorkspaceMenuItems();
            arrays.coalesce([
                newFile,
                newWindow,
                __separator__(),
                platform_1.isMacintosh ? open : null,
                !platform_1.isMacintosh ? openFile : null,
                !platform_1.isMacintosh ? openFolder : null,
                openWorkspace,
                openRecent,
                __separator__(),
                addFolder,
                saveWorkspaceAs,
                __separator__(),
                saveFile,
                saveFileAs,
                saveAllFiles,
                __separator__(),
                autoSave,
                __separator__(),
                !platform_1.isMacintosh ? preferences : null,
                !platform_1.isMacintosh ? __separator__() : null,
                revertFile,
                closeEditor,
                this.closeWorkspace,
                this.closeFolder,
                closeWindow,
                !platform_1.isMacintosh ? __separator__() : null,
                !platform_1.isMacintosh ? exit : null
            ]).forEach(function (item) { return fileMenu.append(item); });
        };
        CodeMenu.prototype.getPreferencesMenu = function () {
            var settings = this.createMenuItem(nls.localize(40, null), 'workbench.action.openSettings');
            var extensions = this.createMenuItem(nls.localize(41, null), 'workbench.view.extensions');
            var kebindingSettings = this.createMenuItem(nls.localize(42, null), 'workbench.action.openGlobalKeybindings');
            var keymapExtensions = this.createMenuItem(nls.localize(43, null), 'workbench.extensions.action.showRecommendedKeymapExtensions');
            var snippetsSettings = this.createMenuItem(nls.localize(44, null), 'workbench.action.openSnippets');
            var colorThemeSelection = this.createMenuItem(nls.localize(45, null), 'workbench.action.selectTheme');
            var iconThemeSelection = this.createMenuItem(nls.localize(46, null), 'workbench.action.selectIconTheme');
            var preferencesMenu = new electron_1.Menu();
            preferencesMenu.append(settings);
            preferencesMenu.append(extensions);
            preferencesMenu.append(__separator__());
            preferencesMenu.append(kebindingSettings);
            preferencesMenu.append(keymapExtensions);
            preferencesMenu.append(__separator__());
            preferencesMenu.append(snippetsSettings);
            preferencesMenu.append(__separator__());
            preferencesMenu.append(colorThemeSelection);
            preferencesMenu.append(iconThemeSelection);
            return new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(47, null)), submenu: preferencesMenu });
        };
        CodeMenu.prototype.setOpenRecentMenu = function (openRecentMenu) {
            var _this = this;
            openRecentMenu.append(this.createMenuItem(nls.localize(48, null), 'workbench.action.reopenClosedEditor'));
            var _a = this.historyMainService.getRecentlyOpened(), workspaces = _a.workspaces, files = _a.files;
            // Workspaces
            if (workspaces.length > 0) {
                openRecentMenu.append(__separator__());
                for (var i = 0; i < CodeMenu.MAX_MENU_RECENT_ENTRIES && i < workspaces.length; i++) {
                    openRecentMenu.append(this.createOpenRecentMenuItem(workspaces[i], 'openRecentWorkspace', false));
                }
            }
            // Files
            if (files.length > 0) {
                openRecentMenu.append(__separator__());
                for (var i = 0; i < CodeMenu.MAX_MENU_RECENT_ENTRIES && i < files.length; i++) {
                    openRecentMenu.append(this.createOpenRecentMenuItem(files[i], 'openRecentFile', true));
                }
            }
            if (workspaces.length || files.length) {
                openRecentMenu.append(__separator__());
                openRecentMenu.append(this.createMenuItem(nls.localize(49, null), 'workbench.action.openRecent'));
                openRecentMenu.append(__separator__());
                openRecentMenu.append(new electron_1.MenuItem(this.likeAction('workbench.action.clearRecentFiles', { label: this.mnemonicLabel(nls.localize(50, null)), click: function () { return _this.historyMainService.clearRecentlyOpened(); } })));
            }
        };
        CodeMenu.prototype.createOpenRecentMenuItem = function (workspace, commandId, isFile) {
            var _this = this;
            var label;
            var uri;
            if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                label = labels_1.unmnemonicLabel(this.labelService.getWorkspaceLabel(workspace, { verbose: true }));
                uri = workspace;
            }
            else if (workspaces_1.isWorkspaceIdentifier(workspace)) {
                label = this.labelService.getWorkspaceLabel(workspace, { verbose: true });
                uri = uri_1.URI.file(workspace.configPath);
            }
            else {
                uri = uri_1.URI.file(workspace);
                label = labels_1.unmnemonicLabel(this.labelService.getUriLabel(uri));
            }
            return new electron_1.MenuItem(this.likeAction(commandId, {
                label: label,
                click: function (menuItem, win, event) {
                    var openInNewWindow = _this.isOptionClick(event);
                    var success = _this.windowsMainService.open({
                        context: 2 /* MENU */,
                        cli: _this.environmentService.args,
                        urisToOpen: [uri],
                        forceNewWindow: openInNewWindow,
                        forceOpenWorkspaceAsFile: isFile
                    }).length > 0;
                    if (!success) {
                        _this.historyMainService.removeFromRecentlyOpened([workspace]);
                    }
                }
            }, false));
        };
        CodeMenu.prototype.isOptionClick = function (event) {
            return event && ((!platform_1.isMacintosh && (event.ctrlKey || event.shiftKey)) || (platform_1.isMacintosh && (event.metaKey || event.altKey)));
        };
        CodeMenu.prototype.createRoleMenuItem = function (label, commandId, role) {
            var options = {
                label: this.mnemonicLabel(label),
                role: role,
                enabled: true
            };
            return new electron_1.MenuItem(this.withKeybinding(commandId, options));
        };
        CodeMenu.prototype.setEditMenu = function (winLinuxEditMenu) {
            var undo;
            var redo;
            var cut;
            var copy;
            var paste;
            if (platform_1.isMacintosh) {
                undo = this.createContextAwareMenuItem(nls.localize(51, null), 'undo', {
                    inDevTools: function (devTools) { return devTools.undo(); },
                    inNoWindow: function () { return electron_1.Menu.sendActionToFirstResponder('undo:'); }
                });
                redo = this.createContextAwareMenuItem(nls.localize(52, null), 'redo', {
                    inDevTools: function (devTools) { return devTools.redo(); },
                    inNoWindow: function () { return electron_1.Menu.sendActionToFirstResponder('redo:'); }
                });
                cut = this.createRoleMenuItem(nls.localize(53, null), 'editor.action.clipboardCutAction', 'cut');
                copy = this.createRoleMenuItem(nls.localize(54, null), 'editor.action.clipboardCopyAction', 'copy');
                paste = this.createRoleMenuItem(nls.localize(55, null), 'editor.action.clipboardPasteAction', 'paste');
            }
            else {
                undo = this.createMenuItem(nls.localize(56, null), 'undo');
                redo = this.createMenuItem(nls.localize(57, null), 'redo');
                cut = this.createMenuItem(nls.localize(58, null), 'editor.action.clipboardCutAction');
                copy = this.createMenuItem(nls.localize(59, null), 'editor.action.clipboardCopyAction');
                paste = this.createMenuItem(nls.localize(60, null), 'editor.action.clipboardPasteAction');
            }
            var find = this.createMenuItem(nls.localize(61, null), 'actions.find');
            var replace = this.createMenuItem(nls.localize(62, null), 'editor.action.startFindReplaceAction');
            var findInFiles = this.createMenuItem(nls.localize(63, null), 'workbench.action.findInFiles');
            var replaceInFiles = this.createMenuItem(nls.localize(64, null), 'workbench.action.replaceInFiles');
            var emmetExpandAbbreviation = this.createMenuItem(nls.localize(65, null), 'editor.emmet.action.expandAbbreviation');
            var showEmmetCommands = this.createMenuItem(nls.localize(66, null), 'workbench.action.showEmmetCommands');
            var toggleLineComment = this.createMenuItem(nls.localize(67, null), 'editor.action.commentLine');
            var toggleBlockComment = this.createMenuItem(nls.localize(68, null), 'editor.action.blockComment');
            [
                undo,
                redo,
                __separator__(),
                cut,
                copy,
                paste,
                __separator__(),
                find,
                replace,
                __separator__(),
                findInFiles,
                replaceInFiles,
                __separator__(),
                toggleLineComment,
                toggleBlockComment,
                emmetExpandAbbreviation,
                showEmmetCommands
            ].forEach(function (item) { return winLinuxEditMenu.append(item); });
        };
        CodeMenu.prototype.setSelectionMenu = function (winLinuxEditMenu) {
            var multiCursorModifierLabel;
            if (this.currentMultiCursorModifierSetting === 'ctrlCmd') {
                multiCursorModifierLabel = nls.localize(69, null); // The default has been overwritten
            }
            else {
                multiCursorModifierLabel = (platform_1.isMacintosh
                    ? nls.localize(70, null)
                    : nls.localize(71, null));
            }
            var multicursorModifier = this.createMenuItem(multiCursorModifierLabel, 'workbench.action.toggleMultiCursorModifier');
            var insertCursorAbove = this.createMenuItem(nls.localize(72, null), 'editor.action.insertCursorAbove');
            var insertCursorBelow = this.createMenuItem(nls.localize(73, null), 'editor.action.insertCursorBelow');
            var insertCursorAtEndOfEachLineSelected = this.createMenuItem(nls.localize(74, null), 'editor.action.insertCursorAtEndOfEachLineSelected');
            var addSelectionToNextFindMatch = this.createMenuItem(nls.localize(75, null), 'editor.action.addSelectionToNextFindMatch');
            var addSelectionToPreviousFindMatch = this.createMenuItem(nls.localize(76, null), 'editor.action.addSelectionToPreviousFindMatch');
            var selectHighlights = this.createMenuItem(nls.localize(77, null), 'editor.action.selectHighlights');
            var copyLinesUp = this.createMenuItem(nls.localize(78, null), 'editor.action.copyLinesUpAction');
            var copyLinesDown = this.createMenuItem(nls.localize(79, null), 'editor.action.copyLinesDownAction');
            var moveLinesUp = this.createMenuItem(nls.localize(80, null), 'editor.action.moveLinesUpAction');
            var moveLinesDown = this.createMenuItem(nls.localize(81, null), 'editor.action.moveLinesDownAction');
            var selectAll;
            if (platform_1.isMacintosh) {
                selectAll = this.createContextAwareMenuItem(nls.localize(82, null), 'editor.action.selectAll', {
                    inDevTools: function (devTools) { return devTools.selectAll(); },
                    inNoWindow: function () { return electron_1.Menu.sendActionToFirstResponder('selectAll:'); }
                });
            }
            else {
                selectAll = this.createMenuItem(nls.localize(83, null), 'editor.action.selectAll');
            }
            var smartSelectGrow = this.createMenuItem(nls.localize(84, null), 'editor.action.smartSelect.grow');
            var smartSelectshrink = this.createMenuItem(nls.localize(85, null), 'editor.action.smartSelect.shrink');
            [
                selectAll,
                smartSelectGrow,
                smartSelectshrink,
                __separator__(),
                copyLinesUp,
                copyLinesDown,
                moveLinesUp,
                moveLinesDown,
                __separator__(),
                multicursorModifier,
                insertCursorAbove,
                insertCursorBelow,
                insertCursorAtEndOfEachLineSelected,
                addSelectionToNextFindMatch,
                addSelectionToPreviousFindMatch,
                selectHighlights,
            ].forEach(function (item) { return winLinuxEditMenu.append(item); });
        };
        CodeMenu.prototype.setViewMenu = function (viewMenu) {
            var _this = this;
            var commands = this.createMenuItem(nls.localize(86, null), 'workbench.action.showCommands');
            var openView = this.createMenuItem(nls.localize(87, null), 'workbench.action.openView');
            // Views
            var explorer = this.createMenuItem(nls.localize(88, null), 'workbench.view.explorer');
            var search = this.createMenuItem(nls.localize(89, null), 'workbench.view.search');
            var scm = this.createMenuItem(nls.localize(90, null), 'workbench.view.scm');
            var debug = this.createMenuItem(nls.localize(91, null), 'workbench.view.debug');
            var extensions = this.createMenuItem(nls.localize(92, null), 'workbench.view.extensions');
            // Panels
            var output = this.createMenuItem(nls.localize(93, null), 'workbench.action.output.toggleOutput');
            var debugConsole = this.createMenuItem(nls.localize(94, null), 'workbench.debug.action.toggleRepl');
            var terminal = this.createMenuItem(nls.localize(95, null), 'workbench.action.terminal.toggleTerminal');
            var problems = this.createMenuItem(nls.localize(96, null), 'workbench.actions.view.problems');
            // Appearance
            var appearanceMenu = new electron_1.Menu();
            var fullscreen = new electron_1.MenuItem(this.withKeybinding('workbench.action.toggleFullScreen', { label: this.mnemonicLabel(nls.localize(97, null)), click: function () { return _this.windowsMainService.getLastActiveWindow().toggleFullScreen(); }, enabled: this.windowsMainService.getWindowCount() > 0 }));
            var toggleZenMode = this.createMenuItem(nls.localize(98, null), 'workbench.action.toggleZenMode');
            var toggleCenteredLayout = this.createMenuItem(nls.localize(99, null), 'workbench.action.toggleCenteredLayout');
            var toggleMenuBar = this.createMenuItem(nls.localize(100, null), 'workbench.action.toggleMenuBar');
            var toggleSidebar = this.createMenuItem(nls.localize(101, null), 'workbench.action.toggleSidebarVisibility');
            var moveSideBarLabel;
            if (this.currentSidebarLocation !== 'right') {
                moveSideBarLabel = nls.localize(102, null);
            }
            else {
                moveSideBarLabel = nls.localize(103, null);
            }
            var moveSidebar = this.createMenuItem(moveSideBarLabel, 'workbench.action.toggleSidebarPosition');
            var togglePanel = this.createMenuItem(nls.localize(104, null), 'workbench.action.togglePanel');
            var statusBarLabel;
            if (this.currentStatusbarVisible) {
                statusBarLabel = nls.localize(105, null);
            }
            else {
                statusBarLabel = nls.localize(106, null);
            }
            var toggleStatusbar = this.createMenuItem(statusBarLabel, 'workbench.action.toggleStatusbarVisibility');
            var activityBarLabel;
            if (this.currentActivityBarVisible) {
                activityBarLabel = nls.localize(107, null);
            }
            else {
                activityBarLabel = nls.localize(108, null);
            }
            var toggleActivtyBar = this.createMenuItem(activityBarLabel, 'workbench.action.toggleActivityBarVisibility');
            var zoomIn = this.createMenuItem(nls.localize(109, null), 'workbench.action.zoomIn');
            var zoomOut = this.createMenuItem(nls.localize(110, null), 'workbench.action.zoomOut');
            var resetZoom = this.createMenuItem(nls.localize(111, null), 'workbench.action.zoomReset');
            arrays.coalesce([
                fullscreen,
                toggleZenMode,
                toggleCenteredLayout,
                platform_1.isWindows || platform_1.isLinux ? toggleMenuBar : void 0,
                __separator__(),
                moveSidebar,
                toggleSidebar,
                togglePanel,
                toggleStatusbar,
                toggleActivtyBar,
                __separator__(),
                zoomIn,
                zoomOut,
                resetZoom
            ]).forEach(function (item) { return appearanceMenu.append(item); });
            var appearance = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(112, null)), submenu: appearanceMenu });
            // Editor Layout
            var editorLayoutMenu = new electron_1.Menu();
            var splitEditorUp = this.createMenuItem(nls.localize(113, null), 'workbench.action.splitEditorUp');
            var splitEditorDown = this.createMenuItem(nls.localize(114, null), 'workbench.action.splitEditorDown');
            var splitEditorLeft = this.createMenuItem(nls.localize(115, null), 'workbench.action.splitEditorLeft');
            var splitEditorRight = this.createMenuItem(nls.localize(116, null), 'workbench.action.splitEditorRight');
            var singleColumnEditorLayout = this.createMenuItem(nls.localize(117, null), 'workbench.action.editorLayoutSingle');
            var twoColumnsEditorLayout = this.createMenuItem(nls.localize(118, null), 'workbench.action.editorLayoutTwoColumns');
            var threeColumnsEditorLayout = this.createMenuItem(nls.localize(119, null), 'workbench.action.editorLayoutThreeColumns');
            var twoRowsEditorLayout = this.createMenuItem(nls.localize(120, null), 'workbench.action.editorLayoutTwoRows');
            var threeRowsEditorLayout = this.createMenuItem(nls.localize(121, null), 'workbench.action.editorLayoutThreeRows');
            var twoByTwoGridEditorLayout = this.createMenuItem(nls.localize(122, null), 'workbench.action.editorLayoutTwoByTwoGrid');
            var twoRowsRightEditorLayout = this.createMenuItem(nls.localize(123, null), 'workbench.action.editorLayoutTwoRowsRight');
            var twoColumnsBottomEditorLayout = this.createMenuItem(nls.localize(124, null), 'workbench.action.editorLayoutTwoColumnsBottom');
            var toggleEditorLayout = this.createMenuItem(nls.localize(125, null), 'workbench.action.toggleEditorGroupLayout');
            [
                splitEditorUp,
                splitEditorDown,
                splitEditorLeft,
                splitEditorRight,
                __separator__(),
                singleColumnEditorLayout,
                twoColumnsEditorLayout,
                threeColumnsEditorLayout,
                twoRowsEditorLayout,
                threeRowsEditorLayout,
                twoByTwoGridEditorLayout,
                twoRowsRightEditorLayout,
                twoColumnsBottomEditorLayout,
                __separator__(),
                toggleEditorLayout
            ].forEach(function (item) { return editorLayoutMenu.append(item); });
            var editorLayout = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(126, null)), submenu: editorLayoutMenu });
            var toggleWordWrap = this.createMenuItem(nls.localize(127, null), 'editor.action.toggleWordWrap');
            var toggleMinimap = this.createMenuItem(nls.localize(128, null), 'editor.action.toggleMinimap');
            var toggleRenderWhitespace = this.createMenuItem(nls.localize(129, null), 'editor.action.toggleRenderWhitespace');
            var toggleRenderControlCharacters = this.createMenuItem(nls.localize(130, null), 'editor.action.toggleRenderControlCharacter');
            var toggleBreadcrumbs = this.createMenuItem(nls.localize(131, null), 'breadcrumbs.toggle');
            arrays.coalesce([
                commands,
                openView,
                __separator__(),
                appearance,
                editorLayout,
                __separator__(),
                explorer,
                search,
                scm,
                debug,
                extensions,
                __separator__(),
                output,
                problems,
                debugConsole,
                terminal,
                __separator__(),
                toggleWordWrap,
                toggleMinimap,
                toggleRenderWhitespace,
                toggleRenderControlCharacters,
                toggleBreadcrumbs
            ]).forEach(function (item) { return viewMenu.append(item); });
        };
        CodeMenu.prototype.setGotoMenu = function (gotoMenu) {
            var back = this.createMenuItem(nls.localize(132, null), 'workbench.action.navigateBack');
            var forward = this.createMenuItem(nls.localize(133, null), 'workbench.action.navigateForward');
            var switchEditorMenu = new electron_1.Menu();
            var nextEditor = this.createMenuItem(nls.localize(134, null), 'workbench.action.nextEditor');
            var previousEditor = this.createMenuItem(nls.localize(135, null), 'workbench.action.previousEditor');
            var nextEditorInGroup = this.createMenuItem(nls.localize(136, null), 'workbench.action.openNextRecentlyUsedEditorInGroup');
            var previousEditorInGroup = this.createMenuItem(nls.localize(137, null), 'workbench.action.openPreviousRecentlyUsedEditorInGroup');
            [
                nextEditor,
                previousEditor,
                __separator__(),
                nextEditorInGroup,
                previousEditorInGroup
            ].forEach(function (item) { return switchEditorMenu.append(item); });
            var switchEditor = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(138, null)), submenu: switchEditorMenu, enabled: true });
            var switchGroupMenu = new electron_1.Menu();
            var focusFirstGroup = this.createMenuItem(nls.localize(139, null), 'workbench.action.focusFirstEditorGroup');
            var focusSecondGroup = this.createMenuItem(nls.localize(140, null), 'workbench.action.focusSecondEditorGroup');
            var focusThirdGroup = this.createMenuItem(nls.localize(141, null), 'workbench.action.focusThirdEditorGroup');
            var focusFourthGroup = this.createMenuItem(nls.localize(142, null), 'workbench.action.focusFourthEditorGroup');
            var focusFifthGroup = this.createMenuItem(nls.localize(143, null), 'workbench.action.focusFifthEditorGroup');
            var nextGroup = this.createMenuItem(nls.localize(144, null), 'workbench.action.focusNextGroup');
            var previousGroup = this.createMenuItem(nls.localize(145, null), 'workbench.action.focusPreviousGroup');
            var focusLeftGroup = this.createMenuItem(nls.localize(146, null), 'workbench.action.focusLeftGroup');
            var focusRightGroup = this.createMenuItem(nls.localize(147, null), 'workbench.action.focusRightGroup');
            var focusAboveGroup = this.createMenuItem(nls.localize(148, null), 'workbench.action.focusAboveGroup');
            var focusBelowGroup = this.createMenuItem(nls.localize(149, null), 'workbench.action.focusBelowGroup');
            [
                focusFirstGroup,
                focusSecondGroup,
                focusThirdGroup,
                focusFourthGroup,
                focusFifthGroup,
                __separator__(),
                nextGroup,
                previousGroup,
                __separator__(),
                focusAboveGroup,
                focusBelowGroup,
                focusLeftGroup,
                focusRightGroup
            ].forEach(function (item) { return switchGroupMenu.append(item); });
            var switchGroup = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(150, null)), submenu: switchGroupMenu, enabled: true });
            var gotoFile = this.createMenuItem(nls.localize(151, null), 'workbench.action.quickOpen');
            var gotoSymbolInFile = this.createMenuItem(nls.localize(152, null), 'workbench.action.gotoSymbol');
            var gotoSymbolInWorkspace = this.createMenuItem(nls.localize(153, null), 'workbench.action.showAllSymbols');
            var gotoDefinition = this.createMenuItem(nls.localize(154, null), 'editor.action.goToDeclaration');
            var gotoTypeDefinition = this.createMenuItem(nls.localize(155, null), 'editor.action.goToTypeDefinition');
            var goToImplementation = this.createMenuItem(nls.localize(156, null), 'editor.action.goToImplementation');
            var gotoLine = this.createMenuItem(nls.localize(157, null), 'workbench.action.gotoLine');
            [
                back,
                forward,
                __separator__(),
                switchEditor,
                switchGroup,
                __separator__(),
                gotoFile,
                gotoSymbolInFile,
                gotoSymbolInWorkspace,
                gotoDefinition,
                gotoTypeDefinition,
                goToImplementation,
                gotoLine
            ].forEach(function (item) { return gotoMenu.append(item); });
        };
        CodeMenu.prototype.setTerminalMenu = function (terminalMenu) {
            var newTerminal = this.createMenuItem(nls.localize(158, null), 'workbench.action.terminal.new');
            var splitTerminal = this.createMenuItem(nls.localize(159, null), 'workbench.action.terminal.split');
            var runActiveFile = this.createMenuItem(nls.localize(160, null), 'workbench.action.terminal.runActiveFile');
            var runSelectedText = this.createMenuItem(nls.localize(161, null), 'workbench.action.terminal.runSelectedText');
            var runTask = this.createMenuItem(nls.localize(162, null), 'workbench.action.tasks.runTask');
            var buildTask = this.createMenuItem(nls.localize(163, null), 'workbench.action.tasks.build');
            var showTasks = this.createMenuItem(nls.localize(164, null), 'workbench.action.tasks.showTasks');
            var restartTask = this.createMenuItem(nls.localize(165, null), 'workbench.action.tasks.restartTask');
            var terminateTask = this.createMenuItem(nls.localize(166, null), 'workbench.action.tasks.terminate');
            var configureTask = this.createMenuItem(nls.localize(167, null), 'workbench.action.tasks.configureTaskRunner');
            var configureBuildTask = this.createMenuItem(nls.localize(168, null), 'workbench.action.tasks.configureDefaultBuildTask');
            var menuItems = [
                newTerminal,
                splitTerminal,
                __separator__(),
                runTask,
                buildTask,
                runActiveFile,
                runSelectedText,
                __separator__(),
                terminateTask,
                restartTask,
                showTasks,
                __separator__(),
                configureTask,
                configureBuildTask
            ];
            menuItems.forEach(function (item) { return terminalMenu.append(item); });
        };
        CodeMenu.prototype.setDebugMenu = function (debugMenu) {
            var start = this.createMenuItem(nls.localize(169, null), 'workbench.action.debug.start');
            var startWithoutDebugging = this.createMenuItem(nls.localize(170, null), 'workbench.action.debug.run');
            var stop = this.createMenuItem(nls.localize(171, null), 'workbench.action.debug.stop');
            var restart = this.createMenuItem(nls.localize(172, null), 'workbench.action.debug.restart');
            var openConfigurations = this.createMenuItem(nls.localize(173, null), 'workbench.action.debug.configure');
            var addConfiguration = this.createMenuItem(nls.localize(174, null), 'debug.addConfiguration');
            var stepOver = this.createMenuItem(nls.localize(175, null), 'workbench.action.debug.stepOver');
            var stepInto = this.createMenuItem(nls.localize(176, null), 'workbench.action.debug.stepInto');
            var stepOut = this.createMenuItem(nls.localize(177, null), 'workbench.action.debug.stepOut');
            var continueAction = this.createMenuItem(nls.localize(178, null), 'workbench.action.debug.continue');
            var toggleBreakpoint = this.createMenuItem(nls.localize(179, null), 'editor.debug.action.toggleBreakpoint');
            var breakpointsMenu = new electron_1.Menu();
            breakpointsMenu.append(this.createMenuItem(nls.localize(180, null), 'editor.debug.action.conditionalBreakpoint'));
            breakpointsMenu.append(this.createMenuItem(nls.localize(181, null), 'editor.debug.action.toggleInlineBreakpoint'));
            breakpointsMenu.append(this.createMenuItem(nls.localize(182, null), 'workbench.debug.viewlet.action.addFunctionBreakpointAction'));
            breakpointsMenu.append(this.createMenuItem(nls.localize(183, null), 'editor.debug.action.toggleLogPoint'));
            var newBreakpoints = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(184, null)), submenu: breakpointsMenu });
            var enableAllBreakpoints = this.createMenuItem(nls.localize(185, null), 'workbench.debug.viewlet.action.enableAllBreakpoints');
            var disableAllBreakpoints = this.createMenuItem(nls.localize(186, null), 'workbench.debug.viewlet.action.disableAllBreakpoints');
            var removeAllBreakpoints = this.createMenuItem(nls.localize(187, null), 'workbench.debug.viewlet.action.removeAllBreakpoints');
            var installAdditionalDebuggers = this.createMenuItem(nls.localize(188, null), 'debug.installAdditionalDebuggers');
            [
                start,
                startWithoutDebugging,
                stop,
                restart,
                __separator__(),
                openConfigurations,
                addConfiguration,
                __separator__(),
                stepOver,
                stepInto,
                stepOut,
                continueAction,
                __separator__(),
                toggleBreakpoint,
                newBreakpoints,
                enableAllBreakpoints,
                disableAllBreakpoints,
                removeAllBreakpoints,
                __separator__(),
                installAdditionalDebuggers
            ].forEach(function (item) { return debugMenu.append(item); });
        };
        CodeMenu.prototype.setMacWindowMenu = function (macWindowMenu) {
            var minimize = new electron_1.MenuItem({ label: nls.localize(189, null), role: 'minimize', accelerator: 'Command+M', enabled: this.windowsMainService.getWindowCount() > 0 });
            var zoom = new electron_1.MenuItem({ label: nls.localize(190, null), role: 'zoom', enabled: this.windowsMainService.getWindowCount() > 0 });
            var bringAllToFront = new electron_1.MenuItem({ label: nls.localize(191, null), role: 'front', enabled: this.windowsMainService.getWindowCount() > 0 });
            var switchWindow = this.createMenuItem(nls.localize(192, null), 'workbench.action.switchWindow');
            var nativeTabMenuItems = [];
            if (this.currentEnableNativeTabs) {
                nativeTabMenuItems.push(this.createMenuItem(nls.localize(193, null), 'workbench.action.newWindowTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(194, null), 'workbench.action.showPreviousWindowTab', 'selectPreviousTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(195, null), 'workbench.action.showNextWindowTab', 'selectNextTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(196, null), 'workbench.action.moveWindowTabToNewWindow', 'moveTabToNewWindow'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(197, null), 'workbench.action.mergeAllWindowTabs', 'mergeAllWindows'));
                nativeTabMenuItems.push.apply(nativeTabMenuItems, [__separator__()].concat(nativeTabMenuItems));
            }
            [
                minimize,
                zoom,
                switchWindow
            ].concat(nativeTabMenuItems, [
                __separator__(),
                bringAllToFront
            ]).forEach(function (item) { return macWindowMenu.append(item); });
        };
        CodeMenu.prototype.toggleDevTools = function () {
            var w = this.windowsMainService.getFocusedWindow();
            if (w && w.win) {
                var contents = w.win.webContents;
                if (platform_1.isMacintosh && w.hasHiddenTitleBarStyle() && !w.win.isFullScreen() && !contents.isDevToolsOpened()) {
                    contents.openDevTools({ mode: 'undocked' }); // due to https://github.com/electron/electron/issues/3647
                }
                else {
                    contents.toggleDevTools();
                }
            }
        };
        CodeMenu.prototype.setHelpMenu = function (helpMenu) {
            var _this = this;
            var toggleDevToolsItem = new electron_1.MenuItem(this.likeAction('workbench.action.toggleDevTools', {
                label: this.mnemonicLabel(nls.localize(198, null)),
                click: function () { return _this.toggleDevTools(); },
                enabled: (this.windowsMainService.getWindowCount() > 0)
            }));
            var showAccessibilityOptions = new electron_1.MenuItem(this.likeAction('accessibilityOptions', {
                label: this.mnemonicLabel(nls.localize(199, null)),
                accelerator: null,
                click: function () {
                    _this.openAccessibilityOptions();
                }
            }, false));
            var openProcessExplorer = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(200, null)), click: function () { return _this.runActionInRenderer('workbench.action.openProcessExplorer'); } });
            var reportIssuesItem = null;
            if (product_1.default.reportIssueUrl) {
                var label = nls.localize(201, null);
                if (this.windowsMainService.getWindowCount() > 0) {
                    reportIssuesItem = this.createMenuItem(label, 'workbench.action.openIssueReporter');
                }
                else {
                    reportIssuesItem = new electron_1.MenuItem({ label: this.mnemonicLabel(label), click: function () { return _this.openUrl(product_1.default.reportIssueUrl, 'openReportIssues'); } });
                }
            }
            var keyboardShortcutsUrl = platform_1.isLinux ? product_1.default.keyboardShortcutsUrlLinux : platform_1.isMacintosh ? product_1.default.keyboardShortcutsUrlMac : product_1.default.keyboardShortcutsUrlWin;
            arrays.coalesce([
                new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(202, null)), click: function () { return _this.runActionInRenderer('workbench.action.showWelcomePage'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }),
                new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(203, null)), click: function () { return _this.runActionInRenderer('workbench.action.showInteractivePlayground'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }),
                product_1.default.documentationUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(204, null)), click: function () { return _this.runActionInRenderer('workbench.action.openDocumentationUrl'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }) : null,
                product_1.default.releaseNotesUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(205, null)), click: function () { return _this.runActionInRenderer('update.showCurrentReleaseNotes'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }) : null,
                __separator__(),
                keyboardShortcutsUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(206, null)), click: function () { return _this.runActionInRenderer('workbench.action.keybindingsReference'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }) : null,
                product_1.default.introductoryVideosUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(207, null)), click: function () { return _this.runActionInRenderer('workbench.action.openIntroductoryVideosUrl'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }) : null,
                product_1.default.tipsAndTricksUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(208, null)), click: function () { return _this.runActionInRenderer('workbench.action.openTipsAndTricksUrl'); }, enabled: (this.windowsMainService.getWindowCount() > 0) }) : null,
                (product_1.default.introductoryVideosUrl || keyboardShortcutsUrl) ? __separator__() : null,
                product_1.default.twitterUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(209, null)), click: function () { return _this.openUrl(product_1.default.twitterUrl, 'openTwitterUrl'); } }) : null,
                product_1.default.requestFeatureUrl ? new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(210, null)), click: function () { return _this.openUrl(product_1.default.requestFeatureUrl, 'openUserVoiceUrl'); } }) : null,
                reportIssuesItem,
                (product_1.default.twitterUrl || product_1.default.requestFeatureUrl || product_1.default.reportIssueUrl) ? __separator__() : null,
                product_1.default.licenseUrl ? new electron_1.MenuItem({
                    label: this.mnemonicLabel(nls.localize(211, null)), click: function () {
                        if (platform_1.language) {
                            var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                            _this.openUrl("" + product_1.default.licenseUrl + queryArgChar + "lang=" + platform_1.language, 'openLicenseUrl');
                        }
                        else {
                            _this.openUrl(product_1.default.licenseUrl, 'openLicenseUrl');
                        }
                    }
                }) : null,
                product_1.default.privacyStatementUrl ? new electron_1.MenuItem({
                    label: this.mnemonicLabel(nls.localize(212, null)), click: function () {
                        if (platform_1.language) {
                            var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                            _this.openUrl("" + product_1.default.privacyStatementUrl + queryArgChar + "lang=" + platform_1.language, 'openPrivacyStatement');
                        }
                        else {
                            _this.openUrl(product_1.default.privacyStatementUrl, 'openPrivacyStatement');
                        }
                    }
                }) : null,
                (product_1.default.licenseUrl || product_1.default.privacyStatementUrl) ? __separator__() : null,
                toggleDevToolsItem,
                openProcessExplorer,
                platform_1.isWindows && product_1.default.quality !== 'stable' ? showAccessibilityOptions : null,
            ]).forEach(function (item) { return helpMenu.append(item); });
            if (!platform_1.isMacintosh) {
                var updateMenuItems = this.getUpdateMenuItems();
                if (updateMenuItems.length) {
                    helpMenu.append(__separator__());
                    updateMenuItems.forEach(function (i) { return helpMenu.append(i); });
                }
                helpMenu.append(__separator__());
                helpMenu.append(new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(213, null)), click: function () { return _this.windowsService.openAboutDialog(); } }));
            }
        };
        CodeMenu.prototype.openAccessibilityOptions = function () {
            var win = new electron_1.BrowserWindow({
                alwaysOnTop: true,
                skipTaskbar: true,
                resizable: false,
                width: 450,
                height: 300,
                show: true,
                title: nls.localize(214, null),
                webPreferences: {
                    disableBlinkFeatures: 'Auxclick'
                }
            });
            win.setMenuBarVisibility(false);
            win.loadURL('chrome://accessibility');
        };
        CodeMenu.prototype.getUpdateMenuItems = function () {
            var _this = this;
            var state = this.updateService.state;
            switch (state.type) {
                case "uninitialized" /* Uninitialized */:
                    return [];
                case "idle" /* Idle */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(215, null), click: function () { return setTimeout(function () {
                                _this.reportMenuActionTelemetry('CheckForUpdate');
                                var focusedWindow = _this.windowsMainService.getFocusedWindow();
                                var context = focusedWindow ? { windowId: focusedWindow.id } : null;
                                _this.updateService.checkForUpdates(context);
                            }, 0); }
                        })];
                case "checking for updates" /* CheckingForUpdates */:
                    return [new electron_1.MenuItem({ label: nls.localize(216, null), enabled: false })];
                case "available for download" /* AvailableForDownload */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(217, null), click: function () {
                                _this.updateService.downloadUpdate();
                            }
                        })];
                case "downloading" /* Downloading */:
                    return [new electron_1.MenuItem({ label: nls.localize(218, null), enabled: false })];
                case "downloaded" /* Downloaded */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(219, null), click: function () {
                                _this.reportMenuActionTelemetry('InstallUpdate');
                                _this.updateService.applyUpdate();
                            }
                        })];
                case "updating" /* Updating */:
                    return [new electron_1.MenuItem({ label: nls.localize(220, null), enabled: false })];
                case "ready" /* Ready */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(221, null), click: function () {
                                _this.reportMenuActionTelemetry('RestartToUpdate');
                                _this.updateService.quitAndInstall();
                            }
                        })];
            }
        };
        CodeMenu.prototype.createMenuItem = function (arg1, arg2, arg3, arg4) {
            var _this = this;
            var label = this.mnemonicLabel(arg1);
            var click = (typeof arg2 === 'function') ? arg2 : function (menuItem, win, event) {
                var commandId = arg2;
                if (Array.isArray(arg2)) {
                    commandId = _this.isOptionClick(event) ? arg2[1] : arg2[0]; // support alternative action if we got multiple action Ids and the option key was pressed while invoking
                }
                _this.runActionInRenderer(commandId);
            };
            var enabled = typeof arg3 === 'boolean' ? arg3 : this.windowsMainService.getWindowCount() > 0;
            var checked = typeof arg4 === 'boolean' ? arg4 : false;
            var options = {
                label: label,
                click: click,
                enabled: enabled
            };
            if (checked) {
                options['type'] = 'checkbox';
                options['checked'] = checked;
            }
            var commandId;
            if (typeof arg2 === 'string') {
                commandId = arg2;
            }
            else if (Array.isArray(arg2)) {
                commandId = arg2[0];
            }
            return new electron_1.MenuItem(this.withKeybinding(commandId, options));
        };
        CodeMenu.prototype.createContextAwareMenuItem = function (label, commandId, clickHandler) {
            var _this = this;
            return new electron_1.MenuItem(this.withKeybinding(commandId, {
                label: this.mnemonicLabel(label),
                enabled: this.windowsMainService.getWindowCount() > 0,
                click: function () {
                    // No Active Window
                    var activeWindow = _this.windowsMainService.getFocusedWindow();
                    if (!activeWindow) {
                        return clickHandler.inNoWindow();
                    }
                    // DevTools focused
                    if (activeWindow.win.webContents.isDevToolsFocused()) {
                        return clickHandler.inDevTools(activeWindow.win.webContents.devToolsWebContents);
                    }
                    // Finally execute command in Window
                    _this.runActionInRenderer(commandId);
                }
            }));
        };
        CodeMenu.prototype.runActionInRenderer = function (id) {
            // We make sure to not run actions when the window has no focus, this helps
            // for https://github.com/Microsoft/vscode/issues/25907 and specifically for
            // https://github.com/Microsoft/vscode/issues/11928
            var activeWindow = this.windowsMainService.getFocusedWindow();
            if (activeWindow) {
                this.windowsMainService.sendToFocused('vscode:runAction', { id: id, from: 'menu' });
            }
        };
        CodeMenu.prototype.withKeybinding = function (commandId, options) {
            var binding = this.keybindingsResolver.getKeybinding(commandId);
            // Apply binding if there is one
            if (binding && binding.label) {
                // if the binding is native, we can just apply it
                if (binding.isNative) {
                    options.accelerator = binding.label;
                }
                // the keybinding is not native so we cannot show it as part of the accelerator of
                // the menu item. we fallback to a different strategy so that we always display it
                else {
                    var bindingIndex = options.label.indexOf('[');
                    if (bindingIndex >= 0) {
                        options.label = options.label.substr(0, bindingIndex) + " [" + binding.label + "]";
                    }
                    else {
                        options.label = options.label + " [" + binding.label + "]";
                    }
                }
            }
            // Unset bindings if there is none
            else {
                options.accelerator = void 0;
            }
            return options;
        };
        CodeMenu.prototype.likeAction = function (commandId, options, setAccelerator) {
            var _this = this;
            if (setAccelerator === void 0) { setAccelerator = !options.accelerator; }
            if (setAccelerator) {
                options = this.withKeybinding(commandId, options);
            }
            var originalClick = options.click;
            options.click = function (item, window, event) {
                _this.reportMenuActionTelemetry(commandId);
                if (originalClick) {
                    originalClick(item, window, event);
                }
            };
            return options;
        };
        CodeMenu.prototype.openUrl = function (url, id) {
            electron_1.shell.openExternal(url);
            this.reportMenuActionTelemetry(id);
        };
        CodeMenu.prototype.reportMenuActionTelemetry = function (id) {
            /* __GDPR__
                "workbenchActionExecuted" : {
                    "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('workbenchActionExecuted', { id: id, from: telemetryFrom });
        };
        CodeMenu.prototype.mnemonicLabel = function (label) {
            return labels_1.mnemonicMenuLabel(label, !this.currentEnableMenuBarMnemonics);
        };
        CodeMenu.MAX_MENU_RECENT_ENTRIES = 10;
        CodeMenu = __decorate([
            __param(0, update_1.IUpdateService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, configuration_1.IConfigurationService),
            __param(3, windows_2.IWindowsMainService),
            __param(4, windows_1.IWindowsService),
            __param(5, environment_1.IEnvironmentService),
            __param(6, telemetry_1.ITelemetryService),
            __param(7, history_1.IHistoryMainService),
            __param(8, label_1.ILabelService)
        ], CodeMenu);
        return CodeMenu;
    }());
    exports.CodeMenu = CodeMenu;
    function __separator__() {
        return new electron_1.MenuItem({ type: 'separator' });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[168/*vs/platform/history/electron-main/historyMainService*/], __M([1/*require*/,0/*exports*/,85/*vs/nls!vs/platform/history/electron-main/historyMainService*/,24/*vs/base/common/arrays*/,28/*vs/platform/state/common/state*/,8/*electron*/,7/*vs/platform/log/common/log*/,31/*vs/base/common/labels*/,5/*vs/base/common/event*/,3/*vs/base/common/platform*/,19/*vs/platform/workspaces/common/workspaces*/,15/*vs/base/common/paths*/,20/*vs/base/common/async*/,32/*vs/base/common/resources*/,6/*vs/base/common/uri*/,30/*vs/base/common/network*/,48/*vs/platform/label/common/label*/]), function (require, exports, nls, arrays, state_1, electron_1, log_1, labels_1, event_1, platform_1, workspaces_1, paths_1, async_1, resources_1, uri_1, network_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var HistoryMainService = /** @class */ (function () {
        function HistoryMainService(stateService, logService, workspacesMainService, labelService) {
            var _this = this;
            this.stateService = stateService;
            this.logService = logService;
            this.workspacesMainService = workspacesMainService;
            this.labelService = labelService;
            this._onRecentlyOpenedChange = new event_1.Emitter();
            this.onRecentlyOpenedChange = this._onRecentlyOpenedChange.event;
            this.macOSRecentDocumentsUpdater = new async_1.RunOnceScheduler(function () { return _this.updateMacOSRecentDocuments(); }, 800);
            this.registerListeners();
        }
        HistoryMainService.prototype.registerListeners = function () {
            var _this = this;
            this.workspacesMainService.onWorkspaceSaved(function (e) { return _this.onWorkspaceSaved(e); });
            this.labelService.onDidRegisterFormatter(function () { return _this._onRecentlyOpenedChange.fire(); });
        };
        HistoryMainService.prototype.onWorkspaceSaved = function (e) {
            // Make sure to add newly saved workspaces to the list of recent workspaces
            this.addRecentlyOpened([e.workspace], []);
        };
        HistoryMainService.prototype.addRecentlyOpened = function (workspaces, files) {
            var _this = this;
            if ((workspaces && workspaces.length > 0) || (files && files.length > 0)) {
                var mru_1 = this.getRecentlyOpened();
                // Workspaces
                if (Array.isArray(workspaces)) {
                    workspaces.forEach(function (workspace) {
                        var isUntitledWorkspace = !workspaces_1.isSingleFolderWorkspaceIdentifier(workspace) && _this.workspacesMainService.isUntitledWorkspace(workspace);
                        if (isUntitledWorkspace) {
                            return; // only store saved workspaces
                        }
                        mru_1.workspaces.unshift(workspace);
                        mru_1.workspaces = arrays.distinct(mru_1.workspaces, function (workspace) { return _this.distinctFn(workspace); });
                        // We do not add to recent documents here because on Windows we do this from a custom
                        // JumpList and on macOS we fill the recent documents in one go from all our data later.
                    });
                }
                // Files
                if (Array.isArray(files)) {
                    files.forEach(function (fileUri) {
                        mru_1.files.unshift(fileUri);
                        mru_1.files = arrays.distinct(mru_1.files, function (file) { return _this.distinctFn(file); });
                        // Add to recent documents (Windows only, macOS later)
                        if (platform_1.isWindows && fileUri.scheme === network_1.Schemas.file) {
                            electron_1.app.addRecentDocument(fileUri.fsPath);
                        }
                    });
                }
                // Make sure its bounded
                mru_1.workspaces = mru_1.workspaces.slice(0, HistoryMainService.MAX_TOTAL_RECENT_ENTRIES);
                mru_1.files = mru_1.files.slice(0, HistoryMainService.MAX_TOTAL_RECENT_ENTRIES);
                this.saveRecentlyOpened(mru_1);
                this._onRecentlyOpenedChange.fire();
                // Schedule update to recent documents on macOS dock
                if (platform_1.isMacintosh) {
                    this.macOSRecentDocumentsUpdater.schedule();
                }
            }
        };
        HistoryMainService.prototype.removeFromRecentlyOpened = function (pathsToRemove) {
            var mru = this.getRecentlyOpened();
            var update = false;
            pathsToRemove.forEach(function (pathToRemove) {
                // Remove workspace
                var index = arrays.firstIndex(mru.workspaces, function (workspace) {
                    if (workspaces_1.isWorkspaceIdentifier(pathToRemove)) {
                        return workspaces_1.isWorkspaceIdentifier(workspace) && paths_1.isEqual(pathToRemove.configPath, workspace.configPath, !platform_1.isLinux /* ignorecase */);
                    }
                    if (workspaces_1.isSingleFolderWorkspaceIdentifier(pathToRemove)) {
                        return workspaces_1.isSingleFolderWorkspaceIdentifier(workspace) && resources_1.isEqual(pathToRemove, workspace);
                    }
                    if (typeof pathToRemove === 'string') {
                        if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                            return workspace.scheme === network_1.Schemas.file && paths_1.isEqual(pathToRemove, workspace.fsPath, !platform_1.isLinux /* ignorecase */);
                        }
                        if (workspaces_1.isWorkspaceIdentifier(workspace)) {
                            return paths_1.isEqual(pathToRemove, workspace.configPath, !platform_1.isLinux /* ignorecase */);
                        }
                    }
                    return false;
                });
                if (index >= 0) {
                    mru.workspaces.splice(index, 1);
                    update = true;
                }
                // Remove file
                index = arrays.firstIndex(mru.files, function (file) {
                    if (pathToRemove instanceof uri_1.URI) {
                        return resources_1.isEqual(file, pathToRemove);
                    }
                    else if (typeof pathToRemove === 'string') {
                        return paths_1.isEqual(file.fsPath, pathToRemove, !platform_1.isLinux /* ignorecase */);
                    }
                    return false;
                });
                if (index >= 0) {
                    mru.files.splice(index, 1);
                    update = true;
                }
            });
            if (update) {
                this.saveRecentlyOpened(mru);
                this._onRecentlyOpenedChange.fire();
                // Schedule update to recent documents on macOS dock
                if (platform_1.isMacintosh) {
                    this.macOSRecentDocumentsUpdater.schedule();
                }
            }
        };
        HistoryMainService.prototype.updateMacOSRecentDocuments = function () {
            if (!platform_1.isMacintosh) {
                return;
            }
            // macOS recent documents in the dock are behaving strangely. the entries seem to get
            // out of sync quickly over time. the attempted fix is to always set the list fresh
            // from our MRU history data. So we clear the documents first and then set the documents
            // again.
            electron_1.app.clearRecentDocuments();
            var mru = this.getRecentlyOpened();
            var maxEntries = HistoryMainService.MAX_MACOS_DOCK_RECENT_ENTRIES;
            // Take up to maxEntries/2 workspaces
            var nEntries = 0;
            for (var i = 0; i < mru.workspaces.length && nEntries < HistoryMainService.MAX_MACOS_DOCK_RECENT_ENTRIES / 2; i++) {
                var workspace = mru.workspaces[i];
                if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                    if (workspace.scheme === network_1.Schemas.file) {
                        electron_1.app.addRecentDocument(workspace.fsPath);
                        nEntries++;
                    }
                }
                else {
                    electron_1.app.addRecentDocument(workspace.configPath);
                    nEntries++;
                }
            }
            // Take up to maxEntries files
            for (var i = 0; i < mru.files.length && nEntries < maxEntries; i++) {
                var file = mru.files[i];
                if (file.scheme === network_1.Schemas.file) {
                    electron_1.app.addRecentDocument(file.fsPath);
                    nEntries++;
                }
            }
        };
        HistoryMainService.prototype.clearRecentlyOpened = function () {
            this.saveRecentlyOpened({ workspaces: [], files: [] });
            electron_1.app.clearRecentDocuments();
            // Event
            this._onRecentlyOpenedChange.fire();
        };
        HistoryMainService.prototype.getRecentlyOpened = function (currentWorkspace, currentFiles) {
            var _this = this;
            var workspaces;
            var files;
            // Get from storage
            var storedRecents = this.getRecentlyOpenedFromStorage();
            if (storedRecents) {
                workspaces = storedRecents.workspaces || [];
                files = storedRecents.files || [];
            }
            else {
                workspaces = [];
                files = [];
            }
            // Add current workspace to beginning if set
            if (currentWorkspace) {
                workspaces.unshift(currentWorkspace);
            }
            // Add currently files to open to the beginning if any
            if (currentFiles) {
                files.unshift.apply(files, currentFiles.map(function (f) { return f.fileUri; }));
            }
            // Clear those dupes
            workspaces = arrays.distinct(workspaces, function (workspace) { return _this.distinctFn(workspace); });
            files = arrays.distinct(files, function (file) { return _this.distinctFn(file); });
            // Hide untitled workspaces
            workspaces = workspaces.filter(function (workspace) { return workspaces_1.isSingleFolderWorkspaceIdentifier(workspace) || !_this.workspacesMainService.isUntitledWorkspace(workspace); });
            return { workspaces: workspaces, files: files };
        };
        HistoryMainService.prototype.distinctFn = function (workspaceOrFile) {
            if (workspaceOrFile instanceof uri_1.URI) {
                return resources_1.getComparisonKey(workspaceOrFile);
            }
            return workspaceOrFile.id;
        };
        HistoryMainService.prototype.getRecentlyOpenedFromStorage = function () {
            var storedRecents = this.stateService.getItem(HistoryMainService.recentlyOpenedStorageKey);
            var result = { workspaces: [], files: [] };
            if (storedRecents) {
                if (Array.isArray(storedRecents.workspaces2)) {
                    for (var _i = 0, _a = storedRecents.workspaces2; _i < _a.length; _i++) {
                        var workspace = _a[_i];
                        if (workspaces_1.isWorkspaceIdentifier(workspace)) {
                            result.workspaces.push(workspace);
                        }
                        else if (typeof workspace === 'string') {
                            result.workspaces.push(uri_1.URI.parse(workspace));
                        }
                    }
                }
                else if (Array.isArray(storedRecents.workspaces)) {
                    // TODO@martin legacy support can be removed at some point (6 month?)
                    // format of 1.25 and before
                    for (var _b = 0, _c = storedRecents.workspaces; _b < _c.length; _b++) {
                        var workspace = _c[_b];
                        if (typeof workspace === 'string') {
                            result.workspaces.push(uri_1.URI.file(workspace));
                        }
                        else if (workspaces_1.isWorkspaceIdentifier(workspace)) {
                            result.workspaces.push(workspace);
                        }
                        else if (workspace && typeof workspace.path === 'string' && typeof workspace.scheme === 'string') {
                            // added by 1.26-insiders
                            result.workspaces.push(uri_1.URI.revive(workspace));
                        }
                    }
                }
                if (Array.isArray(storedRecents.files2)) {
                    for (var _d = 0, _e = storedRecents.files2; _d < _e.length; _d++) {
                        var file = _e[_d];
                        if (typeof file === 'string') {
                            result.files.push(uri_1.URI.parse(file));
                        }
                    }
                }
                else if (Array.isArray(storedRecents.files)) {
                    for (var _f = 0, _g = storedRecents.files; _f < _g.length; _f++) {
                        var file = _g[_f];
                        if (typeof file === 'string') {
                            result.files.push(uri_1.URI.file(file));
                        }
                    }
                }
            }
            return result;
        };
        HistoryMainService.prototype.saveRecentlyOpened = function (recent) {
            var serialized = { workspaces2: [], files2: [] };
            for (var _i = 0, _a = recent.workspaces; _i < _a.length; _i++) {
                var workspace = _a[_i];
                if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                    serialized.workspaces2.push(workspace.toString());
                }
                else {
                    serialized.workspaces2.push(workspace);
                }
            }
            for (var _b = 0, _c = recent.files; _b < _c.length; _b++) {
                var file = _c[_b];
                serialized.files2.push(file.toString());
            }
            this.stateService.setItem(HistoryMainService.recentlyOpenedStorageKey, serialized);
        };
        HistoryMainService.prototype.updateWindowsJumpList = function () {
            var _this = this;
            if (!platform_1.isWindows) {
                return; // only on windows
            }
            var jumpList = [];
            // Tasks
            jumpList.push({
                type: 'tasks',
                items: [
                    {
                        type: 'task',
                        title: nls.localize(0, null),
                        description: nls.localize(1, null),
                        program: process.execPath,
                        args: '-n',
                        iconPath: process.execPath,
                        iconIndex: 0
                    }
                ]
            });
            // Recent Workspaces
            if (this.getRecentlyOpened().workspaces.length > 0) {
                // The user might have meanwhile removed items from the jump list and we have to respect that
                // so we need to update our list of recent paths with the choice of the user to not add them again
                // Also: Windows will not show our custom category at all if there is any entry which was removed
                // by the user! See https://github.com/Microsoft/vscode/issues/15052
                var toRemove = [];
                for (var _i = 0, _a = electron_1.app.getJumpListSettings().removedItems; _i < _a.length; _i++) {
                    var item = _a[_i];
                    var args = item.args;
                    if (args) {
                        var match = /^--folder-uri\s+"([^"]+)"$/.exec(args);
                        if (match) {
                            if (args[0] === '-') {
                                toRemove.push(uri_1.URI.parse(match[1]));
                            }
                            else {
                                var configPath = match[1];
                                toRemove.push({ id: this.workspacesMainService.getWorkspaceId(configPath), configPath: configPath });
                            }
                        }
                    }
                }
                this.removeFromRecentlyOpened(toRemove);
                // Add entries
                jumpList.push({
                    type: 'custom',
                    name: nls.localize(2, null),
                    items: this.getRecentlyOpened().workspaces.slice(0, 7 /* limit number of entries here */).map(function (workspace) {
                        var title = _this.labelService.getWorkspaceLabel(workspace);
                        var description;
                        var args;
                        if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                            description = nls.localize(3, null, labels_1.getBaseLabel(workspace), _this.labelService.getUriLabel(resources_1.dirname(workspace)));
                            args = "--folder-uri \"" + workspace.toString() + "\"";
                        }
                        else {
                            description = nls.localize(4, null);
                            args = "\"" + workspace.configPath + "\"";
                        }
                        return {
                            type: 'task',
                            title: title,
                            description: description,
                            program: process.execPath,
                            args: args,
                            iconPath: 'explorer.exe',
                            iconIndex: 0
                        };
                    }).filter(function (i) { return !!i; })
                });
            }
            // Recent
            jumpList.push({
                type: 'recent' // this enables to show files in the "recent" category
            });
            try {
                electron_1.app.setJumpList(jumpList);
            }
            catch (error) {
                this.logService.warn('#setJumpList', error); // since setJumpList is relatively new API, make sure to guard for errors
            }
        };
        HistoryMainService.MAX_TOTAL_RECENT_ENTRIES = 100;
        HistoryMainService.MAX_MACOS_DOCK_RECENT_ENTRIES = 10;
        HistoryMainService.recentlyOpenedStorageKey = 'openedPathsList';
        HistoryMainService = __decorate([
            __param(0, state_1.IStateService),
            __param(1, log_1.ILogService),
            __param(2, workspaces_1.IWorkspacesMainService),
            __param(3, label_1.ILabelService)
        ], HistoryMainService);
        return HistoryMainService;
    }());
    exports.HistoryMainService = HistoryMainService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[169/*vs/platform/menubar/electron-main/menubar*/], __M([1/*require*/,0/*exports*/,88/*vs/nls!vs/platform/menubar/electron-main/menubar*/,3/*vs/base/common/platform*/,9/*vs/platform/environment/common/environment*/,8/*electron*/,14/*vs/platform/configuration/common/configuration*/,29/*vs/platform/telemetry/common/telemetry*/,33/*vs/platform/update/common/update*/,16/*vs/platform/node/product*/,20/*vs/base/common/async*/,4/*vs/platform/instantiation/common/instantiation*/,31/*vs/base/common/labels*/,25/*vs/platform/windows/electron-main/windows*/,44/*vs/platform/history/common/history*/,19/*vs/platform/workspaces/common/workspaces*/,66/*vs/platform/menubar/common/menubar*/,6/*vs/base/common/uri*/,48/*vs/platform/label/common/label*/]), function (require, exports, nls, platform_1, environment_1, electron_1, configuration_1, telemetry_1, update_1, product_1, async_1, instantiation_1, labels_1, windows_1, history_1, workspaces_1, menubar_1, uri_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var telemetryFrom = 'menu';
    var Menubar = /** @class */ (function () {
        function Menubar(updateService, instantiationService, configurationService, windowsMainService, environmentService, telemetryService, historyMainService, labelService) {
            var _this = this;
            this.updateService = updateService;
            this.configurationService = configurationService;
            this.windowsMainService = windowsMainService;
            this.environmentService = environmentService;
            this.telemetryService = telemetryService;
            this.historyMainService = historyMainService;
            this.labelService = labelService;
            this.menuUpdater = new async_1.RunOnceScheduler(function () { return _this.doUpdateMenu(); }, 0);
            this.keybindings = Object.create(null);
            this.closedLastWindow = false;
            this.install();
            this.registerListeners();
        }
        Menubar.prototype.registerListeners = function () {
            var _this = this;
            // Keep flag when app quits
            electron_1.app.on('will-quit', function () {
                _this.isQuitting = true;
            });
            // // Listen to some events from window service to update menu
            this.historyMainService.onRecentlyOpenedChange(function () { return _this.scheduleUpdateMenu(); });
            this.windowsMainService.onWindowsCountChanged(function (e) { return _this.onWindowsCountChanged(e); });
            // this.windowsMainService.onActiveWindowChanged(() => this.updateWorkspaceMenuItems());
            // this.windowsMainService.onWindowReady(() => this.updateWorkspaceMenuItems());
            // this.windowsMainService.onWindowClose(() => this.updateWorkspaceMenuItems());
            // Update when auto save config changes
            // this.configurationService.onDidChangeConfiguration(e => this.onConfigurationUpdated(e));
            // Listen to update service
            // this.updateService.onStateChange(() => this.updateMenu());
        };
        Object.defineProperty(Menubar.prototype, "currentEnableMenuBarMnemonics", {
            get: function () {
                var enableMenuBarMnemonics = this.configurationService.getValue('window.enableMenuBarMnemonics');
                if (typeof enableMenuBarMnemonics !== 'boolean') {
                    enableMenuBarMnemonics = true;
                }
                return enableMenuBarMnemonics;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Menubar.prototype, "currentEnableNativeTabs", {
            get: function () {
                var enableNativeTabs = this.configurationService.getValue('window.nativeTabs');
                if (typeof enableNativeTabs !== 'boolean') {
                    enableNativeTabs = false;
                }
                return enableNativeTabs;
            },
            enumerable: true,
            configurable: true
        });
        Menubar.prototype.updateMenu = function (menus, windowId, additionalKeybindings) {
            var _this = this;
            this.menubarMenus = menus;
            if (additionalKeybindings) {
                additionalKeybindings.forEach(function (keybinding) {
                    _this.keybindings[keybinding.id] = keybinding;
                });
            }
            this.scheduleUpdateMenu();
        };
        Menubar.prototype.scheduleUpdateMenu = function () {
            this.menuUpdater.schedule(); // buffer multiple attempts to update the menu
        };
        Menubar.prototype.doUpdateMenu = function () {
            var _this = this;
            // Due to limitations in Electron, it is not possible to update menu items dynamically. The suggested
            // workaround from Electron is to set the application menu again.
            // See also https://github.com/electron/electron/issues/846
            //
            // Run delayed to prevent updating menu while it is open
            if (!this.isQuitting) {
                setTimeout(function () {
                    if (!_this.isQuitting) {
                        _this.install();
                    }
                }, 10 /* delay this because there is an issue with updating a menu when it is open */);
            }
        };
        Menubar.prototype.onWindowsCountChanged = function (e) {
            if (!platform_1.isMacintosh) {
                return;
            }
            // Update menu if window count goes from N > 0 or 0 > N to update menu item enablement
            if ((e.oldCount === 0 && e.newCount > 0) || (e.oldCount > 0 && e.newCount === 0)) {
                this.closedLastWindow = e.newCount === 0;
                this.scheduleUpdateMenu();
            }
        };
        Menubar.prototype.install = function () {
            var _this = this;
            // Menus
            var menubar = new electron_1.Menu();
            // Mac: Application
            var macApplicationMenuItem;
            if (platform_1.isMacintosh) {
                var applicationMenu = new electron_1.Menu();
                macApplicationMenuItem = new electron_1.MenuItem({ label: product_1.default.nameShort, submenu: applicationMenu });
                this.setMacApplicationMenu(applicationMenu);
                menubar.append(macApplicationMenuItem);
            }
            // Mac: Dock
            if (platform_1.isMacintosh && !this.appMenuInstalled) {
                this.appMenuInstalled = true;
                var dockMenu = new electron_1.Menu();
                dockMenu.append(new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(0, null)), click: function () { return _this.windowsMainService.openNewWindow(1 /* DOCK */); } }));
                electron_1.app.dock.setMenu(dockMenu);
            }
            // File
            var fileMenu = new electron_1.Menu();
            var fileMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(1, null)), submenu: fileMenu });
            if (this.shouldDrawMenu('File')) {
                if (this.shouldFallback('File')) {
                    this.setFallbackMenuById(fileMenu, 'File');
                }
                else {
                    this.setMenuById(fileMenu, 'File');
                }
                menubar.append(fileMenuItem);
            }
            // Edit
            var editMenu = new electron_1.Menu();
            var editMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(2, null)), submenu: editMenu });
            if (this.shouldDrawMenu('Edit')) {
                this.setMenuById(editMenu, 'Edit');
                menubar.append(editMenuItem);
            }
            // Selection
            var selectionMenu = new electron_1.Menu();
            var selectionMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(3, null)), submenu: selectionMenu });
            if (this.shouldDrawMenu('Selection')) {
                this.setMenuById(selectionMenu, 'Selection');
                menubar.append(selectionMenuItem);
            }
            // View
            var viewMenu = new electron_1.Menu();
            var viewMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(4, null)), submenu: viewMenu });
            if (this.shouldDrawMenu('View')) {
                this.setMenuById(viewMenu, 'View');
                menubar.append(viewMenuItem);
            }
            // Layout
            var layoutMenu = new electron_1.Menu();
            var layoutMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(5, null)), submenu: layoutMenu });
            if (this.shouldDrawMenu('Layout')) {
                this.setMenuById(layoutMenu, 'Layout');
                menubar.append(layoutMenuItem);
            }
            // Go
            var gotoMenu = new electron_1.Menu();
            var gotoMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(6, null)), submenu: gotoMenu });
            if (this.shouldDrawMenu('Go')) {
                this.setMenuById(gotoMenu, 'Go');
                menubar.append(gotoMenuItem);
            }
            // Terminal
            var terminalMenu = new electron_1.Menu();
            var terminalMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(7, null)), submenu: terminalMenu });
            if (this.shouldDrawMenu('Terminal')) {
                this.setMenuById(terminalMenu, 'Terminal');
                menubar.append(terminalMenuItem);
            }
            // Debug
            var debugMenu = new electron_1.Menu();
            var debugMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(8, null)), submenu: debugMenu });
            if (this.shouldDrawMenu('Debug')) {
                this.setMenuById(debugMenu, 'Debug');
                menubar.append(debugMenuItem);
            }
            // Tasks
            var taskMenu = new electron_1.Menu();
            var taskMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(9, null)), submenu: taskMenu });
            if (this.shouldDrawMenu('Tasks')) {
                this.setMenuById(taskMenu, 'Tasks');
                menubar.append(taskMenuItem);
            }
            // Mac: Window
            var macWindowMenuItem;
            if (this.shouldDrawMenu('Window')) {
                var windowMenu = new electron_1.Menu();
                macWindowMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(10, null)), submenu: windowMenu, role: 'window' });
                this.setMacWindowMenu(windowMenu);
            }
            if (macWindowMenuItem) {
                menubar.append(macWindowMenuItem);
            }
            // Preferences
            if (!platform_1.isMacintosh) {
                var preferencesMenu = new electron_1.Menu();
                var preferencesMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(11, null)), submenu: preferencesMenu });
                if (this.shouldDrawMenu('Preferences')) {
                    if (this.shouldFallback('Preferences')) {
                        this.setFallbackMenuById(preferencesMenu, 'Preferences');
                    }
                    else {
                        this.setMenuById(preferencesMenu, 'Preferences');
                    }
                    menubar.append(preferencesMenuItem);
                }
            }
            // Help
            var helpMenu = new electron_1.Menu();
            var helpMenuItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(12, null)), submenu: helpMenu, role: 'help' });
            if (this.shouldDrawMenu('Help')) {
                if (this.shouldFallback('Help')) {
                    this.setFallbackMenuById(helpMenu, 'Help');
                }
                else {
                    this.setMenuById(helpMenu, 'Help');
                }
                menubar.append(helpMenuItem);
            }
            if (menubar.items && menubar.items.length > 0) {
                electron_1.Menu.setApplicationMenu(menubar);
            }
            else {
                electron_1.Menu.setApplicationMenu(null);
            }
        };
        Menubar.prototype.setMacApplicationMenu = function (macApplicationMenu) {
            var _this = this;
            var about = new electron_1.MenuItem({ label: nls.localize(13, null, product_1.default.nameLong), role: 'about' });
            var checkForUpdates = this.getUpdateMenuItems();
            var preferences;
            if (this.shouldDrawMenu('Preferences')) {
                var preferencesMenu = new electron_1.Menu();
                this.setMenuById(preferencesMenu, 'Preferences');
                preferences = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(14, null)), submenu: preferencesMenu });
            }
            var servicesMenu = new electron_1.Menu();
            var services = new electron_1.MenuItem({ label: nls.localize(15, null), role: 'services', submenu: servicesMenu });
            var hide = new electron_1.MenuItem({ label: nls.localize(16, null, product_1.default.nameLong), role: 'hide', accelerator: 'Command+H' });
            var hideOthers = new electron_1.MenuItem({ label: nls.localize(17, null), role: 'hideothers', accelerator: 'Command+Alt+H' });
            var showAll = new electron_1.MenuItem({ label: nls.localize(18, null), role: 'unhide' });
            var quit = new electron_1.MenuItem(this.likeAction('workbench.action.quit', {
                label: nls.localize(19, null, product_1.default.nameLong), click: function () {
                    if (_this.windowsMainService.getWindowCount() === 0 || !!electron_1.BrowserWindow.getFocusedWindow()) {
                        _this.windowsMainService.quit(); // fix for https://github.com/Microsoft/vscode/issues/39191
                    }
                }
            }));
            var actions = [about];
            actions.push.apply(actions, checkForUpdates);
            if (preferences) {
                actions.push.apply(actions, [
                    __separator__(),
                    preferences
                ]);
            }
            actions.push.apply(actions, [
                __separator__(),
                services,
                __separator__(),
                hide,
                hideOthers,
                showAll,
                __separator__(),
                quit
            ]);
            actions.forEach(function (i) { return macApplicationMenu.append(i); });
        };
        Menubar.prototype.shouldDrawMenu = function (menuId) {
            // We need to draw an empty menu to override the electron default
            if (!platform_1.isMacintosh && this.configurationService.getValue('window.titleBarStyle') === 'custom') {
                return false;
            }
            switch (menuId) {
                case 'File':
                case 'Help':
                    if (platform_1.isMacintosh) {
                        return (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow) || (!!this.menubarMenus && !!this.menubarMenus[menuId]);
                    }
                case 'Window':
                    if (platform_1.isMacintosh) {
                        return (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow) || !!this.menubarMenus;
                    }
                default:
                    return this.windowsMainService.getWindowCount() > 0 && (!!this.menubarMenus && !!this.menubarMenus[menuId]);
            }
        };
        Menubar.prototype.shouldFallback = function (menuId) {
            return this.shouldDrawMenu(menuId) && (this.windowsMainService.getWindowCount() === 0 && this.closedLastWindow && platform_1.isMacintosh);
        };
        Menubar.prototype.setFallbackMenuById = function (menu, menuId) {
            var _this = this;
            switch (menuId) {
                case 'File':
                    var newFile = new electron_1.MenuItem(this.likeAction('workbench.action.files.newUntitledFile', { label: this.mnemonicLabel(nls.localize(20, null)), click: function () { return _this.windowsMainService.openNewWindow(2 /* MENU */); } }));
                    var newWindow = new electron_1.MenuItem(this.likeAction('workbench.action.newWindow', { label: this.mnemonicLabel(nls.localize(21, null)), click: function () { return _this.windowsMainService.openNewWindow(2 /* MENU */); } }));
                    var open_1 = new electron_1.MenuItem(this.likeAction('workbench.action.files.openFileFolder', { label: this.mnemonicLabel(nls.localize(22, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickFileFolderAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
                    var openWorkspace = new electron_1.MenuItem(this.likeAction('workbench.action.openWorkspace', { label: this.mnemonicLabel(nls.localize(23, null)), click: function (menuItem, win, event) { return _this.windowsMainService.pickWorkspaceAndOpen({ forceNewWindow: _this.isOptionClick(event), telemetryExtraData: { from: telemetryFrom } }); } }));
                    var openRecentMenu = new electron_1.Menu();
                    this.setFallbackMenuById(openRecentMenu, 'Recent');
                    var openRecent = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(24, null)), submenu: openRecentMenu });
                    menu.append(newFile);
                    menu.append(newWindow);
                    menu.append(__separator__());
                    menu.append(open_1);
                    menu.append(openWorkspace);
                    menu.append(openRecent);
                    break;
                case 'Recent':
                    menu.append(this.createMenuItem(nls.localize(25, null), 'workbench.action.reopenClosedEditor'));
                    this.insertRecentMenuItems(menu);
                    menu.append(__separator__());
                    menu.append(this.createMenuItem(nls.localize(26, null), 'workbench.action.openRecent'));
                    menu.append(__separator__());
                    menu.append(new electron_1.MenuItem(this.likeAction('workbench.action.clearRecentFiles', { label: this.mnemonicLabel(nls.localize(27, null)), click: function () { return _this.historyMainService.clearRecentlyOpened(); } })));
                    break;
                case 'Help':
                    var twitterItem = void 0;
                    if (product_1.default.twitterUrl) {
                        twitterItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(28, null)), click: function () { return _this.openUrl(product_1.default.twitterUrl, 'openTwitterUrl'); } });
                    }
                    var featureRequestsItem = void 0;
                    if (product_1.default.requestFeatureUrl) {
                        featureRequestsItem = new electron_1.MenuItem({ label: this.mnemonicLabel(nls.localize(29, null)), click: function () { return _this.openUrl(product_1.default.requestFeatureUrl, 'openUserVoiceUrl'); } });
                    }
                    var reportIssuesItem = void 0;
                    if (product_1.default.reportIssueUrl) {
                        var label = nls.localize(30, null);
                        reportIssuesItem = new electron_1.MenuItem({ label: this.mnemonicLabel(label), click: function () { return _this.openUrl(product_1.default.reportIssueUrl, 'openReportIssues'); } });
                    }
                    var licenseItem = void 0;
                    if (product_1.default.privacyStatementUrl) {
                        licenseItem = new electron_1.MenuItem({
                            label: this.mnemonicLabel(nls.localize(31, null)), click: function () {
                                if (platform_1.language) {
                                    var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                                    _this.openUrl("" + product_1.default.licenseUrl + queryArgChar + "lang=" + platform_1.language, 'openLicenseUrl');
                                }
                                else {
                                    _this.openUrl(product_1.default.licenseUrl, 'openLicenseUrl');
                                }
                            }
                        });
                    }
                    var privacyStatementItem = void 0;
                    if (product_1.default.privacyStatementUrl) {
                        privacyStatementItem = new electron_1.MenuItem({
                            label: this.mnemonicLabel(nls.localize(32, null)), click: function () {
                                if (platform_1.language) {
                                    var queryArgChar = product_1.default.licenseUrl.indexOf('?') > 0 ? '&' : '?';
                                    _this.openUrl("" + product_1.default.privacyStatementUrl + queryArgChar + "lang=" + platform_1.language, 'openPrivacyStatement');
                                }
                                else {
                                    _this.openUrl(product_1.default.privacyStatementUrl, 'openPrivacyStatement');
                                }
                            }
                        });
                    }
                    if (twitterItem) {
                        menu.append(twitterItem);
                    }
                    if (featureRequestsItem) {
                        menu.append(featureRequestsItem);
                    }
                    if (reportIssuesItem) {
                        menu.append(reportIssuesItem);
                    }
                    if ((twitterItem || featureRequestsItem || reportIssuesItem) && (licenseItem || privacyStatementItem)) {
                        menu.append(__separator__());
                    }
                    if (licenseItem) {
                        menu.append(licenseItem);
                    }
                    if (privacyStatementItem) {
                        menu.append(privacyStatementItem);
                    }
                    break;
            }
        };
        Menubar.prototype.setMenu = function (menu, items) {
            var _this = this;
            items.forEach(function (item) {
                if (menubar_1.isMenubarMenuItemSeparator(item)) {
                    menu.append(__separator__());
                }
                else if (menubar_1.isMenubarMenuItemSubmenu(item)) {
                    var submenu = new electron_1.Menu();
                    var submenuItem = new electron_1.MenuItem({ label: _this.mnemonicLabel(item.label), submenu: submenu });
                    _this.setMenu(submenu, item.submenu.items);
                    menu.append(submenuItem);
                }
                else if (menubar_1.isMenubarMenuItemAction(item)) {
                    if (item.id === 'workbench.action.openRecent') {
                        _this.insertRecentMenuItems(menu);
                    }
                    else if (item.id === 'workbench.action.showAboutDialog') {
                        _this.insertCheckForUpdatesItems(menu);
                    }
                    // Store the keybinding
                    if (item.keybinding) {
                        _this.keybindings[item.id] = item.keybinding;
                    }
                    else if (_this.keybindings[item.id]) {
                        _this.keybindings[item.id] = undefined;
                    }
                    var menuItem = _this.createMenuItem(item.label, item.id, item.enabled, item.checked);
                    menu.append(menuItem);
                }
            });
        };
        Menubar.prototype.setMenuById = function (menu, menuId) {
            if (this.menubarMenus && this.menubarMenus[menuId]) {
                this.setMenu(menu, this.menubarMenus[menuId].items);
            }
        };
        Menubar.prototype.insertCheckForUpdatesItems = function (menu) {
            var updateItems = this.getUpdateMenuItems();
            if (updateItems.length) {
                updateItems.forEach(function (i) { return menu.append(i); });
                menu.append(__separator__());
            }
        };
        Menubar.prototype.insertRecentMenuItems = function (menu) {
            var _a = this.historyMainService.getRecentlyOpened(), workspaces = _a.workspaces, files = _a.files;
            // Workspaces
            if (workspaces.length > 0) {
                for (var i = 0; i < Menubar.MAX_MENU_RECENT_ENTRIES && i < workspaces.length; i++) {
                    menu.append(this.createOpenRecentMenuItem(workspaces[i], 'openRecentWorkspace', false));
                }
                menu.append(__separator__());
            }
            // Files
            if (files.length > 0) {
                for (var i = 0; i < Menubar.MAX_MENU_RECENT_ENTRIES && i < files.length; i++) {
                    menu.append(this.createOpenRecentMenuItem(files[i], 'openRecentFile', true));
                }
                menu.append(__separator__());
            }
        };
        Menubar.prototype.createOpenRecentMenuItem = function (workspaceOrFile, commandId, isFile) {
            var _this = this;
            var label;
            var uri;
            if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspaceOrFile) && !isFile) {
                label = labels_1.unmnemonicLabel(this.labelService.getWorkspaceLabel(workspaceOrFile, { verbose: true }));
                uri = workspaceOrFile;
            }
            else if (workspaces_1.isWorkspaceIdentifier(workspaceOrFile)) {
                label = this.labelService.getWorkspaceLabel(workspaceOrFile, { verbose: true });
                uri = uri_1.URI.file(workspaceOrFile.configPath);
            }
            else {
                label = labels_1.unmnemonicLabel(this.labelService.getUriLabel(workspaceOrFile));
                uri = workspaceOrFile;
            }
            return new electron_1.MenuItem(this.likeAction(commandId, {
                label: label,
                click: function (menuItem, win, event) {
                    var openInNewWindow = _this.isOptionClick(event);
                    var success = _this.windowsMainService.open({
                        context: 2 /* MENU */,
                        cli: _this.environmentService.args,
                        urisToOpen: [uri],
                        forceNewWindow: openInNewWindow,
                        forceOpenWorkspaceAsFile: isFile
                    }).length > 0;
                    if (!success) {
                        _this.historyMainService.removeFromRecentlyOpened([workspaceOrFile]);
                    }
                }
            }, false));
        };
        Menubar.prototype.isOptionClick = function (event) {
            return event && ((!platform_1.isMacintosh && (event.ctrlKey || event.shiftKey)) || (platform_1.isMacintosh && (event.metaKey || event.altKey)));
        };
        Menubar.prototype.createRoleMenuItem = function (label, commandId, role) {
            var options = {
                label: this.mnemonicLabel(label),
                role: role,
                enabled: true
            };
            return new electron_1.MenuItem(this.withKeybinding(commandId, options));
        };
        Menubar.prototype.setMacWindowMenu = function (macWindowMenu) {
            var minimize = new electron_1.MenuItem({ label: nls.localize(33, null), role: 'minimize', accelerator: 'Command+M', enabled: this.windowsMainService.getWindowCount() > 0 });
            var zoom = new electron_1.MenuItem({ label: nls.localize(34, null), role: 'zoom', enabled: this.windowsMainService.getWindowCount() > 0 });
            var bringAllToFront = new electron_1.MenuItem({ label: nls.localize(35, null), role: 'front', enabled: this.windowsMainService.getWindowCount() > 0 });
            var switchWindow = this.createMenuItem(nls.localize(36, null), 'workbench.action.switchWindow');
            var nativeTabMenuItems = [];
            if (this.currentEnableNativeTabs) {
                nativeTabMenuItems.push(this.createMenuItem(nls.localize(37, null), 'workbench.action.newWindowTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(38, null), 'workbench.action.showPreviousWindowTab', 'selectPreviousTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(39, null), 'workbench.action.showNextWindowTab', 'selectNextTab'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(40, null), 'workbench.action.moveWindowTabToNewWindow', 'moveTabToNewWindow'));
                nativeTabMenuItems.push(this.createRoleMenuItem(nls.localize(41, null), 'workbench.action.mergeAllWindowTabs', 'mergeAllWindows'));
                nativeTabMenuItems.push.apply(nativeTabMenuItems, [__separator__()].concat(nativeTabMenuItems));
            }
            [
                minimize,
                zoom,
                switchWindow
            ].concat(nativeTabMenuItems, [
                __separator__(),
                bringAllToFront
            ]).forEach(function (item) { return macWindowMenu.append(item); });
        };
        Menubar.prototype.getUpdateMenuItems = function () {
            var _this = this;
            var state = this.updateService.state;
            switch (state.type) {
                case "uninitialized" /* Uninitialized */:
                    return [];
                case "idle" /* Idle */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(42, null), click: function () { return setTimeout(function () {
                                _this.reportMenuActionTelemetry('CheckForUpdate');
                                var focusedWindow = _this.windowsMainService.getFocusedWindow();
                                var context = focusedWindow ? { windowId: focusedWindow.id } : null;
                                _this.updateService.checkForUpdates(context);
                            }, 0); }
                        })];
                case "checking for updates" /* CheckingForUpdates */:
                    return [new electron_1.MenuItem({ label: nls.localize(43, null), enabled: false })];
                case "available for download" /* AvailableForDownload */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(44, null), click: function () {
                                _this.updateService.downloadUpdate();
                            }
                        })];
                case "downloading" /* Downloading */:
                    return [new electron_1.MenuItem({ label: nls.localize(45, null), enabled: false })];
                case "downloaded" /* Downloaded */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(46, null), click: function () {
                                _this.reportMenuActionTelemetry('InstallUpdate');
                                _this.updateService.applyUpdate();
                            }
                        })];
                case "updating" /* Updating */:
                    return [new electron_1.MenuItem({ label: nls.localize(47, null), enabled: false })];
                case "ready" /* Ready */:
                    return [new electron_1.MenuItem({
                            label: nls.localize(48, null), click: function () {
                                _this.reportMenuActionTelemetry('RestartToUpdate');
                                _this.updateService.quitAndInstall();
                            }
                        })];
            }
        };
        Menubar.prototype.createMenuItem = function (arg1, arg2, arg3, arg4) {
            var _this = this;
            var label = this.mnemonicLabel(arg1);
            var click = (typeof arg2 === 'function') ? arg2 : function (menuItem, win, event) {
                var commandId = arg2;
                if (Array.isArray(arg2)) {
                    commandId = _this.isOptionClick(event) ? arg2[1] : arg2[0]; // support alternative action if we got multiple action Ids and the option key was pressed while invoking
                }
                _this.runActionInRenderer(commandId);
            };
            var enabled = typeof arg3 === 'boolean' ? arg3 : this.windowsMainService.getWindowCount() > 0;
            var checked = typeof arg4 === 'boolean' ? arg4 : false;
            var options = {
                label: label,
                click: click,
                enabled: enabled
            };
            if (checked) {
                options['type'] = 'checkbox';
                options['checked'] = checked;
            }
            var commandId;
            if (typeof arg2 === 'string') {
                commandId = arg2;
            }
            else if (Array.isArray(arg2)) {
                commandId = arg2[0];
            }
            // Add role for special case menu items
            if (platform_1.isMacintosh) {
                if (commandId === 'editor.action.clipboardCutAction') {
                    options['role'] = 'cut';
                }
                else if (commandId === 'editor.action.clipboardCopyAction') {
                    options['role'] = 'copy';
                }
                else if (commandId === 'editor.action.clipboardPasteAction') {
                    options['role'] = 'paste';
                }
            }
            return new electron_1.MenuItem(this.withKeybinding(commandId, options));
        };
        Menubar.prototype.runActionInRenderer = function (id) {
            // We make sure to not run actions when the window has no focus, this helps
            // for https://github.com/Microsoft/vscode/issues/25907 and specifically for
            // https://github.com/Microsoft/vscode/issues/11928
            var activeWindow = this.windowsMainService.getFocusedWindow();
            if (activeWindow) {
                this.windowsMainService.sendToFocused('vscode:runAction', { id: id, from: 'menu' });
            }
        };
        Menubar.prototype.withKeybinding = function (commandId, options) {
            var binding = this.keybindings[commandId];
            // Apply binding if there is one
            if (binding && binding.label) {
                // if the binding is native, we can just apply it
                if (binding.isNative) {
                    options.accelerator = binding.label;
                }
                // the keybinding is not native so we cannot show it as part of the accelerator of
                // the menu item. we fallback to a different strategy so that we always display it
                else {
                    var bindingIndex = options.label.indexOf('[');
                    if (bindingIndex >= 0) {
                        options.label = options.label.substr(0, bindingIndex) + " [" + binding.label + "]";
                    }
                    else {
                        options.label = options.label + " [" + binding.label + "]";
                    }
                }
            }
            // Unset bindings if there is none
            else {
                options.accelerator = void 0;
            }
            return options;
        };
        Menubar.prototype.likeAction = function (commandId, options, setAccelerator) {
            var _this = this;
            if (setAccelerator === void 0) { setAccelerator = !options.accelerator; }
            if (setAccelerator) {
                options = this.withKeybinding(commandId, options);
            }
            var originalClick = options.click;
            options.click = function (item, window, event) {
                _this.reportMenuActionTelemetry(commandId);
                if (originalClick) {
                    originalClick(item, window, event);
                }
            };
            return options;
        };
        Menubar.prototype.openUrl = function (url, id) {
            electron_1.shell.openExternal(url);
            this.reportMenuActionTelemetry(id);
        };
        Menubar.prototype.reportMenuActionTelemetry = function (id) {
            /* __GDPR__
                "workbenchActionExecuted" : {
                    "id" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "from": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('workbenchActionExecuted', { id: id, from: telemetryFrom });
        };
        Menubar.prototype.mnemonicLabel = function (label) {
            return labels_1.mnemonicMenuLabel(label, !this.currentEnableMenuBarMnemonics);
        };
        Menubar.MAX_MENU_RECENT_ENTRIES = 10;
        Menubar = __decorate([
            __param(0, update_1.IUpdateService),
            __param(1, instantiation_1.IInstantiationService),
            __param(2, configuration_1.IConfigurationService),
            __param(3, windows_1.IWindowsMainService),
            __param(4, environment_1.IEnvironmentService),
            __param(5, telemetry_1.ITelemetryService),
            __param(6, history_1.IHistoryMainService),
            __param(7, label_1.ILabelService)
        ], Menubar);
        return Menubar;
    }());
    exports.Menubar = Menubar;
    function __separator__() {
        return new electron_1.MenuItem({ type: 'separator' });
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[170/*vs/platform/menubar/electron-main/menubarService*/], __M([1/*require*/,0/*exports*/,169/*vs/platform/menubar/electron-main/menubar*/,7/*vs/platform/log/common/log*/,2/*vs/base/common/winjs.base*/,4/*vs/platform/instantiation/common/instantiation*/,3/*vs/base/common/platform*/]), function (require, exports, menubar_1, log_1, winjs_base_1, instantiation_1, platform_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var MenubarService = /** @class */ (function () {
        function MenubarService(instantiationService, logService) {
            this.instantiationService = instantiationService;
            this.logService = logService;
            // Install Menu
            if (platform_1.isMacintosh && platform_1.isWindows) {
                this._menubar = this.instantiationService.createInstance(menubar_1.Menubar);
            }
        }
        MenubarService.prototype.updateMenubar = function (windowId, menus, additionalKeybindings) {
            this.logService.trace('menubarService#updateMenubar', windowId);
            if (this._menubar) {
                this._menubar.updateMenu(menus, windowId, additionalKeybindings);
            }
            return winjs_base_1.TPromise.as(null);
        };
        MenubarService = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, log_1.ILogService)
        ], MenubarService);
        return MenubarService;
    }());
    exports.MenubarService = MenubarService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[171/*vs/platform/workspaces/node/workspaces*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/workspaces/common/workspaces*/,3/*vs/base/common/platform*/,11/*path*/,15/*vs/base/common/paths*/,31/*vs/base/common/labels*/]), function (require, exports, workspaces_1, platform_1, path_1, paths_1, labels_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var SLASH = '/';
    /**
     * Given the absolute path to a folder, massage it in a way that it fits
     * into an existing set of workspace folders of a workspace.
     *
     * @param absoluteFolderPath the absolute path of a workspace folder
     * @param targetConfigFolder the folder where the workspace is living in
     * @param existingFolders a set of existing folders of the workspace
     */
    function massageFolderPathForWorkspace(absoluteFolderPath, targetConfigFolder, existingFolders) {
        var useSlashesForPath = shouldUseSlashForPath(existingFolders);
        // Convert path to relative path if the target config folder
        // is a parent of the path.
        if (paths_1.isEqualOrParent(absoluteFolderPath, targetConfigFolder, !platform_1.isLinux)) {
            absoluteFolderPath = path_1.relative(targetConfigFolder, absoluteFolderPath) || '.';
        }
        // Windows gets special treatment:
        // - normalize all paths to get nice casing of drive letters
        // - convert to slashes if we want to use slashes for paths
        if (platform_1.isWindows) {
            if (path_1.isAbsolute(absoluteFolderPath)) {
                if (useSlashesForPath) {
                    absoluteFolderPath = paths_1.normalize(absoluteFolderPath, false /* do not use OS path separator */);
                }
                absoluteFolderPath = labels_1.normalizeDriveLetter(absoluteFolderPath);
            }
            else if (useSlashesForPath) {
                absoluteFolderPath = absoluteFolderPath.replace(/[\\]/g, SLASH);
            }
        }
        return absoluteFolderPath;
    }
    exports.massageFolderPathForWorkspace = massageFolderPathForWorkspace;
    function shouldUseSlashForPath(storedFolders) {
        // Determine which path separator to use:
        // - macOS/Linux: slash
        // - Windows: use slash if already used in that file
        var useSlashesForPath = !platform_1.isWindows;
        if (platform_1.isWindows) {
            storedFolders.forEach(function (folder) {
                if (workspaces_1.isRawFileWorkspaceFolder(folder) && !useSlashesForPath && folder.path.indexOf(SLASH) >= 0) {
                    useSlashesForPath = true;
                }
            });
        }
        return useSlashesForPath;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[172/*vs/platform/workspaces/electron-main/workspacesMainService*/], __M([1/*require*/,0/*exports*/,19/*vs/platform/workspaces/common/workspaces*/,2/*vs/base/common/winjs.base*/,46/*vs/platform/files/common/files*/,9/*vs/platform/environment/common/environment*/,11/*path*/,34/*vs/base/node/pfs*/,21/*fs*/,3/*vs/base/common/platform*/,36/*vs/base/node/extfs*/,5/*vs/base/common/event*/,7/*vs/platform/log/common/log*/,15/*vs/base/common/paths*/,24/*vs/base/common/arrays*/,58/*crypto*/,40/*vs/base/common/json*/,102/*vs/base/common/jsonEdit*/,75/*vs/base/common/jsonFormatter*/,171/*vs/platform/workspaces/node/workspaces*/,74/*vs/platform/workspace/common/workspace*/,6/*vs/base/common/uri*/,30/*vs/base/common/network*/]), function (require, exports, workspaces_1, winjs_base_1, files_1, environment_1, path_1, pfs_1, fs_1, platform_1, extfs_1, event_1, log_1, paths_1, arrays_1, crypto_1, json, jsonEdit, jsonFormatter_1, workspaces_2, workspace_1, uri_1, network_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkspacesMainService = /** @class */ (function () {
        function WorkspacesMainService(environmentService, logService) {
            this.environmentService = environmentService;
            this.logService = logService;
            this.workspacesHome = environmentService.workspacesHome;
            this._onWorkspaceSaved = new event_1.Emitter();
            this._onUntitledWorkspaceDeleted = new event_1.Emitter();
        }
        Object.defineProperty(WorkspacesMainService.prototype, "onWorkspaceSaved", {
            get: function () {
                return this._onWorkspaceSaved.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorkspacesMainService.prototype, "onUntitledWorkspaceDeleted", {
            get: function () {
                return this._onUntitledWorkspaceDeleted.event;
            },
            enumerable: true,
            configurable: true
        });
        WorkspacesMainService.prototype.resolveWorkspace = function (path) {
            var _this = this;
            if (!this.isWorkspacePath(path)) {
                return winjs_base_1.TPromise.as(null); // does not look like a valid workspace config file
            }
            return pfs_1.readFile(path, 'utf8').then(function (contents) { return _this.doResolveWorkspace(path, contents); });
        };
        WorkspacesMainService.prototype.resolveWorkspaceSync = function (path) {
            if (!this.isWorkspacePath(path)) {
                return null; // does not look like a valid workspace config file
            }
            var contents;
            try {
                contents = fs_1.readFileSync(path, 'utf8');
            }
            catch (error) {
                return null; // invalid workspace
            }
            return this.doResolveWorkspace(path, contents);
        };
        WorkspacesMainService.prototype.isWorkspacePath = function (path) {
            return this.isInsideWorkspacesHome(path) || path_1.extname(path) === "." + workspaces_1.WORKSPACE_EXTENSION;
        };
        WorkspacesMainService.prototype.doResolveWorkspace = function (path, contents) {
            try {
                var workspace = this.doParseStoredWorkspace(path, contents);
                return {
                    id: this.getWorkspaceId(path),
                    configPath: path,
                    folders: workspace_1.toWorkspaceFolders(workspace.folders, uri_1.URI.file(path_1.dirname(path)))
                };
            }
            catch (error) {
                this.logService.warn(error.toString());
            }
            return null;
        };
        WorkspacesMainService.prototype.doParseStoredWorkspace = function (path, contents) {
            // Parse workspace file
            var storedWorkspace = json.parse(contents); // use fault tolerant parser
            // Filter out folders which do not have a path or uri set
            if (Array.isArray(storedWorkspace.folders)) {
                storedWorkspace.folders = storedWorkspace.folders.filter(function (folder) { return workspaces_1.isStoredWorkspaceFolder(folder); });
            }
            // Validate
            if (!Array.isArray(storedWorkspace.folders)) {
                throw new Error(path + " looks like an invalid workspace file.");
            }
            return storedWorkspace;
        };
        WorkspacesMainService.prototype.isInsideWorkspacesHome = function (path) {
            return files_1.isParent(path, this.environmentService.workspacesHome, !platform_1.isLinux /* ignore case */);
        };
        WorkspacesMainService.prototype.createWorkspace = function (folders) {
            var _a = this.createUntitledWorkspace(folders), workspace = _a.workspace, configParent = _a.configParent, storedWorkspace = _a.storedWorkspace;
            return pfs_1.mkdirp(configParent).then(function () {
                return pfs_1.writeFile(workspace.configPath, JSON.stringify(storedWorkspace, null, '\t')).then(function () { return workspace; });
            });
        };
        WorkspacesMainService.prototype.createWorkspaceSync = function (folders) {
            var _a = this.createUntitledWorkspace(folders), workspace = _a.workspace, configParent = _a.configParent, storedWorkspace = _a.storedWorkspace;
            if (!fs_1.existsSync(this.workspacesHome)) {
                fs_1.mkdirSync(this.workspacesHome);
            }
            fs_1.mkdirSync(configParent);
            extfs_1.writeFileAndFlushSync(workspace.configPath, JSON.stringify(storedWorkspace, null, '\t'));
            return workspace;
        };
        WorkspacesMainService.prototype.createUntitledWorkspace = function (folders) {
            if (folders === void 0) { folders = []; }
            var randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();
            var untitledWorkspaceConfigFolder = path_1.join(this.workspacesHome, randomId);
            var untitledWorkspaceConfigPath = path_1.join(untitledWorkspaceConfigFolder, workspaces_1.UNTITLED_WORKSPACE_NAME);
            var storedWorkspace = {
                folders: folders.map(function (folder) {
                    var folderResource = folder.uri;
                    var storedWorkspace;
                    // File URI
                    if (folderResource.scheme === network_1.Schemas.file) {
                        storedWorkspace = { path: workspaces_2.massageFolderPathForWorkspace(folderResource.fsPath, untitledWorkspaceConfigFolder, []) };
                    }
                    // Any URI
                    else {
                        storedWorkspace = { uri: folderResource.toString(true) };
                    }
                    if (folder.name) {
                        storedWorkspace.name = folder.name;
                    }
                    return storedWorkspace;
                })
            };
            return {
                workspace: {
                    id: this.getWorkspaceId(untitledWorkspaceConfigPath),
                    configPath: untitledWorkspaceConfigPath
                },
                configParent: untitledWorkspaceConfigFolder,
                storedWorkspace: storedWorkspace
            };
        };
        WorkspacesMainService.prototype.getWorkspaceId = function (workspaceConfigPath) {
            if (!platform_1.isLinux) {
                workspaceConfigPath = workspaceConfigPath.toLowerCase(); // sanitize for platform file system
            }
            return crypto_1.createHash('md5').update(workspaceConfigPath).digest('hex');
        };
        WorkspacesMainService.prototype.isUntitledWorkspace = function (workspace) {
            return this.isInsideWorkspacesHome(workspace.configPath);
        };
        WorkspacesMainService.prototype.saveWorkspace = function (workspace, targetConfigPath) {
            var _this = this;
            // Return early if target is same as source
            if (paths_1.isEqual(workspace.configPath, targetConfigPath, !platform_1.isLinux)) {
                return winjs_base_1.TPromise.as(workspace);
            }
            // Read the contents of the workspace file and resolve it
            return pfs_1.readFile(workspace.configPath).then(function (raw) {
                var rawWorkspaceContents = raw.toString();
                var storedWorkspace;
                try {
                    storedWorkspace = _this.doParseStoredWorkspace(workspace.configPath, rawWorkspaceContents);
                }
                catch (error) {
                    return winjs_base_1.TPromise.wrapError(error);
                }
                var sourceConfigFolder = path_1.dirname(workspace.configPath);
                var targetConfigFolder = path_1.dirname(targetConfigPath);
                // Rewrite absolute paths to relative paths if the target workspace folder
                // is a parent of the location of the workspace file itself. Otherwise keep
                // using absolute paths.
                storedWorkspace.folders.forEach(function (folder) {
                    if (workspaces_1.isRawFileWorkspaceFolder(folder)) {
                        if (!path_1.isAbsolute(folder.path)) {
                            folder.path = path_1.resolve(sourceConfigFolder, folder.path); // relative paths get resolved against the workspace location
                        }
                        folder.path = workspaces_2.massageFolderPathForWorkspace(folder.path, targetConfigFolder, storedWorkspace.folders);
                    }
                });
                // Preserve as much of the existing workspace as possible by using jsonEdit
                // and only changing the folders portion.
                var newRawWorkspaceContents = rawWorkspaceContents;
                var edits = jsonEdit.setProperty(rawWorkspaceContents, ['folders'], storedWorkspace.folders, { insertSpaces: false, tabSize: 4, eol: (platform_1.isLinux || platform_1.isMacintosh) ? '\n' : '\r\n' });
                edits.forEach(function (edit) {
                    newRawWorkspaceContents = jsonFormatter_1.applyEdit(rawWorkspaceContents, edit);
                });
                return pfs_1.writeFile(targetConfigPath, newRawWorkspaceContents).then(function () {
                    var savedWorkspaceIdentifier = { id: _this.getWorkspaceId(targetConfigPath), configPath: targetConfigPath };
                    // Event
                    _this._onWorkspaceSaved.fire({ workspace: savedWorkspaceIdentifier, oldConfigPath: workspace.configPath });
                    // Delete untitled workspace
                    _this.deleteUntitledWorkspaceSync(workspace);
                    return savedWorkspaceIdentifier;
                });
            });
        };
        WorkspacesMainService.prototype.deleteUntitledWorkspaceSync = function (workspace) {
            if (!this.isUntitledWorkspace(workspace)) {
                return; // only supported for untitled workspaces
            }
            // Delete from disk
            this.doDeleteUntitledWorkspaceSync(workspace.configPath);
            // Event
            this._onUntitledWorkspaceDeleted.fire(workspace);
        };
        WorkspacesMainService.prototype.doDeleteUntitledWorkspaceSync = function (configPath) {
            try {
                extfs_1.delSync(path_1.dirname(configPath));
            }
            catch (error) {
                this.logService.warn("Unable to delete untitled workspace " + configPath + " (" + error + ").");
            }
        };
        WorkspacesMainService.prototype.getUntitledWorkspacesSync = function () {
            var _this = this;
            var untitledWorkspacePaths = [];
            try {
                untitledWorkspacePaths = extfs_1.readdirSync(this.workspacesHome).map(function (folder) { return path_1.join(_this.workspacesHome, folder, workspaces_1.UNTITLED_WORKSPACE_NAME); });
            }
            catch (error) {
                if (error && error.code !== 'ENOENT') {
                    this.logService.warn("Unable to read folders in " + this.workspacesHome + " (" + error + ").");
                }
            }
            var untitledWorkspaces = arrays_1.coalesce(untitledWorkspacePaths.map(function (untitledWorkspacePath) {
                var workspace = _this.resolveWorkspaceSync(untitledWorkspacePath);
                if (!workspace) {
                    _this.doDeleteUntitledWorkspaceSync(untitledWorkspacePath);
                    return null; // invalid workspace
                }
                return { id: workspace.id, configPath: untitledWorkspacePath };
            }));
            return untitledWorkspaces;
        };
        WorkspacesMainService = __decorate([
            __param(0, environment_1.IEnvironmentService),
            __param(1, log_1.ILogService)
        ], WorkspacesMainService);
        return WorkspacesMainService;
    }());
    exports.WorkspacesMainService = WorkspacesMainService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[173/*vs/platform/workspaces/node/workspacesIpc*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,6/*vs/base/common/uri*/]), function (require, exports, winjs_base_1, uri_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WorkspacesChannel = /** @class */ (function () {
        function WorkspacesChannel(service) {
            this.service = service;
        }
        WorkspacesChannel.prototype.listen = function (event, arg) {
            throw new Error('No events');
        };
        WorkspacesChannel.prototype.call = function (command, arg) {
            switch (command) {
                case 'createWorkspace': {
                    var rawFolders = arg;
                    var folders = void 0;
                    if (Array.isArray(rawFolders)) {
                        folders = rawFolders.map(function (rawFolder) {
                            return {
                                uri: uri_1.URI.revive(rawFolder.uri),
                                name: rawFolder.name
                            };
                        });
                    }
                    return this.service.createWorkspace(folders);
                }
            }
            return void 0;
        };
        return WorkspacesChannel;
    }());
    exports.WorkspacesChannel = WorkspacesChannel;
    var WorkspacesChannelClient = /** @class */ (function () {
        function WorkspacesChannelClient(channel) {
            this.channel = channel;
        }
        WorkspacesChannelClient.prototype.createWorkspace = function (folders) {
            return winjs_base_1.TPromise.wrap(this.channel.call('createWorkspace', folders));
        };
        return WorkspacesChannelClient;
    }());
    exports.WorkspacesChannelClient = WorkspacesChannelClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



































define(__m[47/*vs/base/node/request*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,22/*vs/base/common/types*/,98/*url*/,21/*fs*/,17/*vs/base/common/objects*/,177/*zlib*/,23/*vs/base/common/errors*/]), function (require, exports, winjs_base_1, types_1, url_1, fs_1, objects_1, zlib_1, errors_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getNodeRequest(options) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, module, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        endpoint = url_1.parse(options.url);
                        if (!(endpoint.protocol === 'https:')) return [3 /*break*/, 2];
                        return [4 /*yield*/, new Promise(function (resolve_1, reject_1) { require(['https'], resolve_1, reject_1); })];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, new Promise(function (resolve_2, reject_2) { require(['http'], resolve_2, reject_2); })];
                    case 3:
                        _a = _b.sent();
                        _b.label = 4;
                    case 4:
                        module = _a;
                        return [2 /*return*/, module.request];
                }
            });
        });
    }
    function request(options, token) {
        var req;
        var rawRequestPromise = options.getRawRequest
            ? winjs_base_1.TPromise.as(options.getRawRequest(options))
            : winjs_base_1.TPromise.wrap(getNodeRequest(options));
        return rawRequestPromise.then(function (rawRequest) {
            return new winjs_base_1.TPromise(function (c, e) {
                var endpoint = url_1.parse(options.url);
                var opts = {
                    hostname: endpoint.hostname,
                    port: endpoint.port ? parseInt(endpoint.port) : (endpoint.protocol === 'https:' ? 443 : 80),
                    protocol: endpoint.protocol,
                    path: endpoint.path,
                    method: options.type || 'GET',
                    headers: options.headers,
                    agent: options.agent,
                    rejectUnauthorized: types_1.isBoolean(options.strictSSL) ? options.strictSSL : true
                };
                if (options.user && options.password) {
                    opts.auth = options.user + ':' + options.password;
                }
                req = rawRequest(opts, function (res) {
                    var followRedirects = types_1.isNumber(options.followRedirects) ? options.followRedirects : 3;
                    if (res.statusCode >= 300 && res.statusCode < 400 && followRedirects > 0 && res.headers['location']) {
                        request(objects_1.assign({}, options, {
                            url: res.headers['location'],
                            followRedirects: followRedirects - 1
                        }), token).then(c, e);
                    }
                    else {
                        var stream = res;
                        if (res.headers['content-encoding'] === 'gzip') {
                            stream = stream.pipe(zlib_1.createGunzip());
                        }
                        c({ res: res, stream: stream });
                    }
                });
                req.on('error', e);
                if (options.timeout) {
                    req.setTimeout(options.timeout);
                }
                if (options.data) {
                    if (typeof options.data === 'string') {
                        req.write(options.data);
                    }
                    else {
                        options.data.pipe(req);
                        return;
                    }
                }
                req.end();
                token.onCancellationRequested(function () {
                    req.abort();
                    e(errors_1.canceled());
                });
            });
        });
    }
    exports.request = request;
    function isSuccess(context) {
        return (context.res.statusCode >= 200 && context.res.statusCode < 300) || context.res.statusCode === 1223;
    }
    function hasNoContent(context) {
        return context.res.statusCode === 204;
    }
    function download(filePath, context) {
        return new winjs_base_1.TPromise(function (c, e) {
            var out = fs_1.createWriteStream(filePath);
            out.once('finish', function () { return c(null); });
            context.stream.once('error', e);
            context.stream.pipe(out);
        });
    }
    exports.download = download;
    function asText(context) {
        return new winjs_base_1.TPromise(function (c, e) {
            if (!isSuccess(context)) {
                return e('Server returned ' + context.res.statusCode);
            }
            if (hasNoContent(context)) {
                return c(null);
            }
            var buffer = [];
            context.stream.on('data', function (d) { return buffer.push(d); });
            context.stream.on('end', function () { return c(buffer.join('')); });
            context.stream.on('error', e);
        });
    }
    exports.asText = asText;
    function asJson(context) {
        return new winjs_base_1.TPromise(function (c, e) {
            if (!isSuccess(context)) {
                return e('Server returned ' + context.res.statusCode);
            }
            if (hasNoContent(context)) {
                return c(null);
            }
            var buffer = [];
            context.stream.on('data', function (d) { return buffer.push(d); });
            context.stream.on('end', function () {
                try {
                    c(JSON.parse(buffer.join('')));
                }
                catch (err) {
                    e(err);
                }
            });
            context.stream.on('error', e);
        });
    }
    exports.asJson = asJson;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




















define(__m[176/*vs/platform/extensionManagement/node/extensionGalleryService*/], __M([1/*require*/,0/*exports*/,26/*os*/,11/*path*/,2/*vs/base/common/winjs.base*/,24/*vs/base/common/arrays*/,23/*vs/base/common/errors*/,96/*vs/platform/extensionManagement/common/extensionManagementUtil*/,17/*vs/base/common/objects*/,42/*vs/platform/request/node/request*/,29/*vs/platform/telemetry/common/telemetry*/,47/*vs/base/node/request*/,50/*vs/platform/node/package*/,16/*vs/platform/node/product*/,118/*vs/platform/extensions/node/extensionValidator*/,9/*vs/platform/environment/common/environment*/,34/*vs/base/node/pfs*/,36/*vs/base/node/extfs*/,39/*vs/base/common/uuid*/,38/*vs/base/common/map*/,35/*vs/base/common/cancellation*/]), function (require, exports, os_1, path, winjs_base_1, arrays_1, errors_1, extensionManagementUtil_1, objects_1, request_1, telemetry_1, request_2, package_1, product_1, extensionValidator_1, environment_1, pfs_1, extfs_1, uuid_1, map_1, cancellation_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Flags;
    (function (Flags) {
        Flags[Flags["None"] = 0] = "None";
        Flags[Flags["IncludeVersions"] = 1] = "IncludeVersions";
        Flags[Flags["IncludeFiles"] = 2] = "IncludeFiles";
        Flags[Flags["IncludeCategoryAndTags"] = 4] = "IncludeCategoryAndTags";
        Flags[Flags["IncludeSharedAccounts"] = 8] = "IncludeSharedAccounts";
        Flags[Flags["IncludeVersionProperties"] = 16] = "IncludeVersionProperties";
        Flags[Flags["ExcludeNonValidated"] = 32] = "ExcludeNonValidated";
        Flags[Flags["IncludeInstallationTargets"] = 64] = "IncludeInstallationTargets";
        Flags[Flags["IncludeAssetUri"] = 128] = "IncludeAssetUri";
        Flags[Flags["IncludeStatistics"] = 256] = "IncludeStatistics";
        Flags[Flags["IncludeLatestVersionOnly"] = 512] = "IncludeLatestVersionOnly";
        Flags[Flags["Unpublished"] = 4096] = "Unpublished";
    })(Flags || (Flags = {}));
    function flagsToString() {
        var flags = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            flags[_i] = arguments[_i];
        }
        return String(flags.reduce(function (r, f) { return r | f; }, 0));
    }
    var FilterType;
    (function (FilterType) {
        FilterType[FilterType["Tag"] = 1] = "Tag";
        FilterType[FilterType["ExtensionId"] = 4] = "ExtensionId";
        FilterType[FilterType["Category"] = 5] = "Category";
        FilterType[FilterType["ExtensionName"] = 7] = "ExtensionName";
        FilterType[FilterType["Target"] = 8] = "Target";
        FilterType[FilterType["Featured"] = 9] = "Featured";
        FilterType[FilterType["SearchText"] = 10] = "SearchText";
        FilterType[FilterType["ExcludeWithFlags"] = 12] = "ExcludeWithFlags";
    })(FilterType || (FilterType = {}));
    var AssetType = {
        Icon: 'Microsoft.VisualStudio.Services.Icons.Default',
        Details: 'Microsoft.VisualStudio.Services.Content.Details',
        Changelog: 'Microsoft.VisualStudio.Services.Content.Changelog',
        Manifest: 'Microsoft.VisualStudio.Code.Manifest',
        VSIX: 'Microsoft.VisualStudio.Services.VSIXPackage',
        License: 'Microsoft.VisualStudio.Services.Content.License',
        Repository: 'Microsoft.VisualStudio.Services.Links.Source'
    };
    var PropertyType = {
        Dependency: 'Microsoft.VisualStudio.Code.ExtensionDependencies',
        ExtensionPack: 'Microsoft.VisualStudio.Code.ExtensionPack',
        Engine: 'Microsoft.VisualStudio.Code.Engine'
    };
    var DefaultPageSize = 10;
    var DefaultQueryState = {
        pageNumber: 1,
        pageSize: DefaultPageSize,
        sortBy: 0 /* NoneOrRelevance */,
        sortOrder: 0 /* Default */,
        flags: Flags.None,
        criteria: [],
        assetTypes: []
    };
    var Query = /** @class */ (function () {
        function Query(state) {
            if (state === void 0) { state = DefaultQueryState; }
            this.state = state;
        }
        Object.defineProperty(Query.prototype, "pageNumber", {
            get: function () { return this.state.pageNumber; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Query.prototype, "pageSize", {
            get: function () { return this.state.pageSize; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Query.prototype, "sortBy", {
            get: function () { return this.state.sortBy; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Query.prototype, "sortOrder", {
            get: function () { return this.state.sortOrder; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Query.prototype, "flags", {
            get: function () { return this.state.flags; },
            enumerable: true,
            configurable: true
        });
        Query.prototype.withPage = function (pageNumber, pageSize) {
            if (pageSize === void 0) { pageSize = this.state.pageSize; }
            return new Query(objects_1.assign({}, this.state, { pageNumber: pageNumber, pageSize: pageSize }));
        };
        Query.prototype.withFilter = function (filterType) {
            var values = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
            }
            var criteria = this.state.criteria.concat(values.map(function (value) { return ({ filterType: filterType, value: value }); }));
            return new Query(objects_1.assign({}, this.state, { criteria: criteria }));
        };
        Query.prototype.withSortBy = function (sortBy) {
            return new Query(objects_1.assign({}, this.state, { sortBy: sortBy }));
        };
        Query.prototype.withSortOrder = function (sortOrder) {
            return new Query(objects_1.assign({}, this.state, { sortOrder: sortOrder }));
        };
        Query.prototype.withFlags = function () {
            var flags = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                flags[_i] = arguments[_i];
            }
            return new Query(objects_1.assign({}, this.state, { flags: flags.reduce(function (r, f) { return r | f; }, 0) }));
        };
        Query.prototype.withAssetTypes = function () {
            var assetTypes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                assetTypes[_i] = arguments[_i];
            }
            return new Query(objects_1.assign({}, this.state, { assetTypes: assetTypes }));
        };
        Object.defineProperty(Query.prototype, "raw", {
            get: function () {
                var _a = this.state, criteria = _a.criteria, pageNumber = _a.pageNumber, pageSize = _a.pageSize, sortBy = _a.sortBy, sortOrder = _a.sortOrder, flags = _a.flags, assetTypes = _a.assetTypes;
                var filters = [{ criteria: criteria, pageNumber: pageNumber, pageSize: pageSize, sortBy: sortBy, sortOrder: sortOrder }];
                return { filters: filters, assetTypes: assetTypes, flags: flags };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Query.prototype, "searchText", {
            get: function () {
                var criterium = this.state.criteria.filter(function (criterium) { return criterium.filterType === FilterType.SearchText; })[0];
                return criterium ? criterium.value : '';
            },
            enumerable: true,
            configurable: true
        });
        return Query;
    }());
    function getStatistic(statistics, name) {
        var result = (statistics || []).filter(function (s) { return s.statisticName === name; })[0];
        return result ? result.value : 0;
    }
    function getCoreTranslationAssets(version) {
        var coreTranslationAssetPrefix = 'Microsoft.VisualStudio.Code.Translation.';
        var result = version.files.filter(function (f) { return f.assetType.indexOf(coreTranslationAssetPrefix) === 0; });
        return result.reduce(function (result, file) {
            result[file.assetType.substring(coreTranslationAssetPrefix.length)] = getVersionAsset(version, file.assetType);
            return result;
        }, {});
    }
    function getVersionAsset(version, type) {
        var result = version.files.filter(function (f) { return f.assetType === type; })[0];
        if (type === AssetType.Repository) {
            if (version.properties) {
                var results = version.properties.filter(function (p) { return p.key === type; });
                var gitRegExp_1 = new RegExp('((git|ssh|http(s)?)|(git@[\w\.]+))(:(//)?)([\w\.@\:/\-~]+)(\.git)(/)?');
                var uri = results.filter(function (r) { return gitRegExp_1.test(r.value); })[0];
                if (!uri) {
                    return {
                        uri: null,
                        fallbackUri: null
                    };
                }
                return {
                    uri: uri.value,
                    fallbackUri: uri.value,
                };
            }
        }
        if (!result) {
            if (type === AssetType.Icon) {
                var uri = require.toUrl('./media/defaultIcon.png');
                return { uri: uri, fallbackUri: uri };
            }
            if (type === AssetType.Repository) {
                return {
                    uri: null,
                    fallbackUri: null
                };
            }
            return null;
        }
        if (type === AssetType.VSIX) {
            return {
                uri: version.fallbackAssetUri + "/" + type + "?redirect=true",
                fallbackUri: version.fallbackAssetUri + "/" + type
            };
        }
        return {
            uri: version.assetUri + "/" + type,
            fallbackUri: version.fallbackAssetUri + "/" + type
        };
    }
    function getExtensions(version, property) {
        var values = version.properties ? version.properties.filter(function (p) { return p.key === property; }) : [];
        var value = values.length > 0 && values[0].value;
        return value ? value.split(',').map(function (v) { return extensionManagementUtil_1.adoptToGalleryExtensionId(v); }) : [];
    }
    function getEngine(version) {
        var values = version.properties ? version.properties.filter(function (p) { return p.key === PropertyType.Engine; }) : [];
        return (values.length > 0 && values[0].value) || '';
    }
    function getIsPreview(flags) {
        return flags.indexOf('preview') !== -1;
    }
    function toExtension(galleryExtension, version, index, query, querySource) {
        var assets = {
            manifest: getVersionAsset(version, AssetType.Manifest),
            readme: getVersionAsset(version, AssetType.Details),
            changelog: getVersionAsset(version, AssetType.Changelog),
            download: getVersionAsset(version, AssetType.VSIX),
            icon: getVersionAsset(version, AssetType.Icon),
            license: getVersionAsset(version, AssetType.License),
            repository: getVersionAsset(version, AssetType.Repository),
            coreTranslations: getCoreTranslationAssets(version)
        };
        return {
            identifier: {
                id: extensionManagementUtil_1.getGalleryExtensionId(galleryExtension.publisher.publisherName, galleryExtension.extensionName),
                uuid: galleryExtension.extensionId
            },
            name: galleryExtension.extensionName,
            version: version.version,
            date: version.lastUpdated,
            displayName: galleryExtension.displayName,
            publisherId: galleryExtension.publisher.publisherId,
            publisher: galleryExtension.publisher.publisherName,
            publisherDisplayName: galleryExtension.publisher.displayName,
            description: galleryExtension.shortDescription || '',
            installCount: getStatistic(galleryExtension.statistics, 'install') + getStatistic(galleryExtension.statistics, 'updateCount'),
            rating: getStatistic(galleryExtension.statistics, 'averagerating'),
            ratingCount: getStatistic(galleryExtension.statistics, 'ratingcount'),
            assets: assets,
            properties: {
                dependencies: getExtensions(version, PropertyType.Dependency),
                extensionPack: getExtensions(version, PropertyType.ExtensionPack),
                engine: getEngine(version)
            },
            /* __GDPR__FRAGMENT__
                "GalleryExtensionTelemetryData2" : {
                    "index" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                    "searchText": { "classification": "CustomerContent", "purpose": "FeatureInsight" },
                    "querySource": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                }
            */
            telemetryData: {
                index: ((query.pageNumber - 1) * query.pageSize) + index,
                searchText: query.searchText,
                querySource: querySource
            },
            preview: getIsPreview(galleryExtension.flags)
        };
    }
    var ExtensionGalleryService = /** @class */ (function () {
        function ExtensionGalleryService(requestService, environmentService, telemetryService) {
            this.requestService = requestService;
            this.environmentService = environmentService;
            this.telemetryService = telemetryService;
            var config = product_1.default.extensionsGallery;
            this.extensionsGalleryUrl = config && config.serviceUrl;
            this.extensionsControlUrl = config && config.controlUrl;
            this.commonHeadersPromise = resolveMarketplaceHeaders(this.environmentService);
        }
        ExtensionGalleryService.prototype.api = function (path) {
            if (path === void 0) { path = ''; }
            return "" + this.extensionsGalleryUrl + path;
        };
        ExtensionGalleryService.prototype.isEnabled = function () {
            return !!this.extensionsGalleryUrl;
        };
        ExtensionGalleryService.prototype.getExtension = function (_a, version) {
            var id = _a.id, uuid = _a.uuid;
            var query = new Query()
                .withFlags(Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)
                .withPage(1, 1)
                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));
            if (uuid) {
                query = query.withFilter(FilterType.ExtensionId, uuid);
            }
            else {
                query = query.withFilter(FilterType.ExtensionName, id);
            }
            return this.queryGallery(query, cancellation_1.CancellationToken.None).then(function (_a) {
                var galleryExtensions = _a.galleryExtensions;
                if (galleryExtensions.length) {
                    var galleryExtension = galleryExtensions[0];
                    var versionAsset = version ? galleryExtension.versions.filter(function (v) { return v.version === version; })[0] : galleryExtension.versions[0];
                    if (versionAsset) {
                        return toExtension(galleryExtension, versionAsset, 0, query);
                    }
                }
                return null;
            });
        };
        ExtensionGalleryService.prototype.query = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (!this.isEnabled()) {
                return winjs_base_1.TPromise.wrapError(new Error('No extension gallery service configured.'));
            }
            var type = options.names ? 'ids' : (options.text ? 'text' : 'all');
            var text = options.text || '';
            var pageSize = objects_1.getOrDefault(options, function (o) { return o.pageSize; }, 50);
            /* __GDPR__
                "galleryService:query" : {
                    "type" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                    "text": { "classification": "CustomerContent", "purpose": "FeatureInsight" }
                }
            */
            this.telemetryService.publicLog('galleryService:query', { type: type, text: text });
            var query = new Query()
                .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)
                .withPage(1, pageSize)
                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished));
            if (text) {
                // Use category filter instead of "category:themes"
                text = text.replace(/\bcategory:("([^"]*)"|([^"]\S*))(\s+|\b|$)/g, function (_, quotedCategory, category) {
                    query = query.withFilter(FilterType.Category, category || quotedCategory);
                    return '';
                });
                // Use tag filter instead of "tag:debuggers"
                text = text.replace(/\btag:("([^"]*)"|([^"]\S*))(\s+|\b|$)/g, function (_, quotedTag, tag) {
                    query = query.withFilter(FilterType.Tag, tag || quotedTag);
                    return '';
                });
                text = text.trim();
                if (text) {
                    text = text.length < 200 ? text : text.substring(0, 200);
                    query = query.withFilter(FilterType.SearchText, text);
                }
                query = query.withSortBy(0 /* NoneOrRelevance */);
            }
            else if (options.ids) {
                query = query.withFilter.apply(query, [FilterType.ExtensionId].concat(options.ids));
            }
            else if (options.names) {
                query = query.withFilter.apply(query, [FilterType.ExtensionName].concat(options.names));
            }
            else {
                query = query.withSortBy(4 /* InstallCount */);
            }
            if (typeof options.sortBy === 'number') {
                query = query.withSortBy(options.sortBy);
            }
            if (typeof options.sortOrder === 'number') {
                query = query.withSortOrder(options.sortOrder);
            }
            return this.queryGallery(query, cancellation_1.CancellationToken.None).then(function (_a) {
                var galleryExtensions = _a.galleryExtensions, total = _a.total;
                var extensions = galleryExtensions.map(function (e, index) { return toExtension(e, e.versions[0], index, query, options.source); });
                var pageSize = query.pageSize;
                var getPage = function (pageIndex, ct) {
                    if (ct.isCancellationRequested) {
                        return winjs_base_1.TPromise.wrapError(errors_1.canceled());
                    }
                    var nextPageQuery = query.withPage(pageIndex + 1);
                    return _this.queryGallery(nextPageQuery, ct)
                        .then(function (_a) {
                        var galleryExtensions = _a.galleryExtensions;
                        return galleryExtensions.map(function (e, index) { return toExtension(e, e.versions[0], index, nextPageQuery, options.source); });
                    });
                };
                return { firstPage: extensions, total: total, pageSize: pageSize, getPage: getPage };
            });
        };
        ExtensionGalleryService.prototype.queryGallery = function (query, token) {
            var _this = this;
            return this.commonHeadersPromise.then(function (commonHeaders) {
                var data = JSON.stringify(query.raw);
                var headers = objects_1.assign({}, commonHeaders, {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json;api-version=3.0-preview.1',
                    'Accept-Encoding': 'gzip',
                    'Content-Length': data.length
                });
                return _this.requestService.request({
                    type: 'POST',
                    url: _this.api('/extensionquery'),
                    data: data,
                    headers: headers
                }, token).then(function (context) {
                    if (context.res.statusCode >= 400 && context.res.statusCode < 500) {
                        return { galleryExtensions: [], total: 0 };
                    }
                    return request_2.asJson(context).then(function (result) {
                        var r = result.results[0];
                        var galleryExtensions = r.extensions;
                        var resultCount = r.resultMetadata && r.resultMetadata.filter(function (m) { return m.metadataType === 'ResultCount'; })[0];
                        var total = resultCount && resultCount.metadataItems.filter(function (i) { return i.name === 'TotalCount'; })[0].count || 0;
                        return { galleryExtensions: galleryExtensions, total: total };
                    });
                });
            });
        };
        ExtensionGalleryService.prototype.reportStatistic = function (publisher, name, version, type) {
            var _this = this;
            if (!this.isEnabled()) {
                return winjs_base_1.TPromise.as(null);
            }
            return this.commonHeadersPromise.then(function (commonHeaders) {
                var headers = __assign({}, commonHeaders, { Accept: '*/*;api-version=4.0-preview.1' });
                return _this.requestService.request({
                    type: 'POST',
                    url: _this.api("/publishers/" + publisher + "/extensions/" + name + "/" + version + "/stats?statType=" + type),
                    headers: headers
                }, cancellation_1.CancellationToken.None).then(null, function () { return null; });
            });
        };
        ExtensionGalleryService.prototype.download = function (extension, operation) {
            var _this = this;
            var zipPath = path.join(os_1.tmpdir(), uuid_1.generateUuid());
            var data = extensionManagementUtil_1.getGalleryExtensionTelemetryData(extension);
            var startTime = new Date().getTime();
            /* __GDPR__
                "galleryService:downloadVSIX" : {
                    "duration": { "classification": "SystemMetaData", "purpose": "PerformanceAndHealth", "isMeasurement": true },
                    "${include}": [
                        "${GalleryExtensionTelemetryData}"
                    ]
                }
            */
            var log = function (duration) { return _this.telemetryService.publicLog('galleryService:downloadVSIX', objects_1.assign(data, { duration: duration })); };
            var operationParam = operation === 1 /* Install */ ? 'install' : operation === 2 /* Update */ ? 'update' : '';
            var downloadAsset = operationParam ? {
                uri: extension.assets.download.uri + "&" + operationParam + "=true",
                fallbackUri: extension.assets.download.fallbackUri + "?" + operationParam + "=true"
            } : extension.assets.download;
            return this.getAsset(downloadAsset)
                .then(function (context) { return request_2.download(zipPath, context); })
                .then(function () { return log(new Date().getTime() - startTime); })
                .then(function () { return zipPath; });
        };
        ExtensionGalleryService.prototype.getReadme = function (extension, token) {
            return this.getAsset(extension.assets.readme, {}, token)
                .then(request_2.asText);
        };
        ExtensionGalleryService.prototype.getManifest = function (extension, token) {
            return this.getAsset(extension.assets.manifest, {}, token)
                .then(request_2.asText)
                .then(JSON.parse);
        };
        ExtensionGalleryService.prototype.getCoreTranslation = function (extension, languageId) {
            var asset = extension.assets.coreTranslations[languageId.toUpperCase()];
            if (asset) {
                return this.getAsset(asset)
                    .then(request_2.asText)
                    .then(JSON.parse);
            }
            return winjs_base_1.TPromise.as(null);
        };
        ExtensionGalleryService.prototype.getChangelog = function (extension, token) {
            return this.getAsset(extension.assets.changelog, {}, token)
                .then(request_2.asText);
        };
        ExtensionGalleryService.prototype.loadAllDependencies = function (extensions, token) {
            return this.getDependenciesReccursively(extensions.map(function (e) { return e.id; }), [], token);
        };
        ExtensionGalleryService.prototype.loadCompatibleVersion = function (extension) {
            var _this = this;
            if (extension.properties.engine && extensionValidator_1.isEngineValid(extension.properties.engine)) {
                return winjs_base_1.TPromise.wrap(extension);
            }
            var query = new Query()
                .withFlags(Flags.IncludeVersions, Flags.IncludeFiles, Flags.IncludeVersionProperties)
                .withPage(1, 1)
                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))
                .withAssetTypes(AssetType.Manifest, AssetType.VSIX)
                .withFilter(FilterType.ExtensionId, extension.identifier.uuid);
            return this.queryGallery(query, cancellation_1.CancellationToken.None)
                .then(function (_a) {
                var galleryExtensions = _a.galleryExtensions;
                var rawExtension = galleryExtensions[0];
                if (!rawExtension) {
                    return null;
                }
                return _this.getLastValidExtensionVersion(rawExtension, rawExtension.versions)
                    .then(function (rawVersion) {
                    if (rawVersion) {
                        extension.properties.dependencies = getExtensions(rawVersion, PropertyType.Dependency);
                        extension.properties.engine = getEngine(rawVersion);
                        extension.assets.download = getVersionAsset(rawVersion, AssetType.VSIX);
                        extension.version = rawVersion.version;
                        return extension;
                    }
                    return null;
                });
            });
        };
        ExtensionGalleryService.prototype.loadDependencies = function (extensionNames, token) {
            var _a;
            if (!extensionNames || extensionNames.length === 0) {
                return winjs_base_1.TPromise.as([]);
            }
            var query = (_a = new Query()
                .withFlags(Flags.IncludeLatestVersionOnly, Flags.IncludeAssetUri, Flags.IncludeStatistics, Flags.IncludeFiles, Flags.IncludeVersionProperties)
                .withPage(1, extensionNames.length)
                .withFilter(FilterType.Target, 'Microsoft.VisualStudio.Code')
                .withFilter(FilterType.ExcludeWithFlags, flagsToString(Flags.Unpublished))
                .withAssetTypes(AssetType.Icon, AssetType.License, AssetType.Details, AssetType.Manifest, AssetType.VSIX)).withFilter.apply(_a, [FilterType.ExtensionName].concat(extensionNames));
            return this.queryGallery(query, token).then(function (result) {
                var dependencies = [];
                var ids = [];
                for (var index = 0; index < result.galleryExtensions.length; index++) {
                    var rawExtension = result.galleryExtensions[index];
                    if (ids.indexOf(rawExtension.extensionId) === -1) {
                        dependencies.push(toExtension(rawExtension, rawExtension.versions[0], index, query, 'dependencies'));
                        ids.push(rawExtension.extensionId);
                    }
                }
                return dependencies;
            });
        };
        ExtensionGalleryService.prototype.getDependenciesReccursively = function (toGet, result, token) {
            var _this = this;
            if (!toGet || !toGet.length) {
                return winjs_base_1.TPromise.wrap(result);
            }
            toGet = result.length ? toGet.filter(function (e) { return !ExtensionGalleryService.hasExtensionByName(result, e); }) : toGet;
            if (!toGet.length) {
                return winjs_base_1.TPromise.wrap(result);
            }
            return this.loadDependencies(toGet, token)
                .then(function (loadedDependencies) {
                var dependenciesSet = new Set();
                for (var _i = 0, loadedDependencies_1 = loadedDependencies; _i < loadedDependencies_1.length; _i++) {
                    var dep = loadedDependencies_1[_i];
                    if (dep.properties.dependencies) {
                        dep.properties.dependencies.forEach(function (d) { return dependenciesSet.add(d); });
                    }
                }
                result = arrays_1.distinct(result.concat(loadedDependencies), function (d) { return d.identifier.uuid; });
                var dependencies = [];
                dependenciesSet.forEach(function (d) { return !ExtensionGalleryService.hasExtensionByName(result, d) && dependencies.push(d); });
                return _this.getDependenciesReccursively(dependencies, result, token);
            });
        };
        ExtensionGalleryService.prototype.getAsset = function (asset, options, token) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (token === void 0) { token = cancellation_1.CancellationToken.None; }
            return this.commonHeadersPromise.then(function (commonHeaders) {
                var baseOptions = { type: 'GET' };
                var headers = objects_1.assign({}, commonHeaders, options.headers || {});
                options = objects_1.assign({}, options, baseOptions, { headers: headers });
                var url = asset.uri;
                var fallbackUrl = asset.fallbackUri;
                var firstOptions = objects_1.assign({}, options, { url: url });
                return _this.requestService.request(firstOptions, token)
                    .then(function (context) {
                    if (context.res.statusCode === 200) {
                        return winjs_base_1.TPromise.as(context);
                    }
                    return request_2.asText(context)
                        .then(function (message) { return winjs_base_1.TPromise.wrapError(new Error("Expected 200, got back " + context.res.statusCode + " instead.\n\n" + message)); });
                })
                    .then(null, function (err) {
                    if (errors_1.isPromiseCanceledError(err)) {
                        return winjs_base_1.TPromise.wrapError(err);
                    }
                    var message = errors_1.getErrorMessage(err);
                    /* __GDPR__
                        "galleryService:requestError" : {
                            "url" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                            "cdn": { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true },
                            "message": { "classification": "CallstackOrException", "purpose": "FeatureInsight" }
                        }
                    */
                    _this.telemetryService.publicLog('galleryService:requestError', { url: url, cdn: true, message: message });
                    /* __GDPR__
                        "galleryService:cdnFallback" : {
                            "url" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                            "message": { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                        }
                    */
                    _this.telemetryService.publicLog('galleryService:cdnFallback', { url: url, message: message });
                    var fallbackOptions = objects_1.assign({}, options, { url: fallbackUrl });
                    return _this.requestService.request(fallbackOptions, token).then(null, function (err) {
                        if (errors_1.isPromiseCanceledError(err)) {
                            return winjs_base_1.TPromise.wrapError(err);
                        }
                        var message = errors_1.getErrorMessage(err);
                        /* __GDPR__
                            "galleryService:requestError" : {
                                "url" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                                "cdn": { "classification": "SystemMetaData", "purpose": "FeatureInsight" },
                                "message": { "classification": "CallstackOrException", "purpose": "FeatureInsight" }
                            }
                        */
                        _this.telemetryService.publicLog('galleryService:requestError', { url: fallbackUrl, cdn: false, message: message });
                        return winjs_base_1.TPromise.wrapError(err);
                    });
                });
            });
        };
        ExtensionGalleryService.prototype.getLastValidExtensionVersion = function (extension, versions) {
            var version = this.getLastValidExtensionVersionFromProperties(extension, versions);
            if (version) {
                return version;
            }
            return this.getLastValidExtensionVersionReccursively(extension, versions);
        };
        ExtensionGalleryService.prototype.getLastValidExtensionVersionFromProperties = function (extension, versions) {
            for (var _i = 0, versions_1 = versions; _i < versions_1.length; _i++) {
                var version = versions_1[_i];
                var engine = getEngine(version);
                if (!engine) {
                    return null;
                }
                if (extensionValidator_1.isEngineValid(engine)) {
                    return winjs_base_1.TPromise.wrap(version);
                }
            }
            return null;
        };
        ExtensionGalleryService.prototype.getLastValidExtensionVersionReccursively = function (extension, versions) {
            var _this = this;
            if (!versions.length) {
                return null;
            }
            var version = versions[0];
            var asset = getVersionAsset(version, AssetType.Manifest);
            var headers = { 'Accept-Encoding': 'gzip' };
            return this.getAsset(asset, { headers: headers })
                .then(function (context) { return request_2.asJson(context); })
                .then(function (manifest) {
                var engine = manifest.engines.vscode;
                if (!extensionValidator_1.isEngineValid(engine)) {
                    return _this.getLastValidExtensionVersionReccursively(extension, versions.slice(1));
                }
                version.properties = version.properties || [];
                version.properties.push({ key: PropertyType.Engine, value: manifest.engines.vscode });
                return version;
            });
        };
        ExtensionGalleryService.hasExtensionByName = function (extensions, name) {
            for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
                var extension = extensions_1[_i];
                if (extension.publisher + "." + extension.name === name) {
                    return true;
                }
            }
            return false;
        };
        ExtensionGalleryService.prototype.getExtensionsReport = function () {
            if (!this.isEnabled()) {
                return winjs_base_1.TPromise.wrapError(new Error('No extension gallery service configured.'));
            }
            if (!this.extensionsControlUrl) {
                return winjs_base_1.TPromise.as([]);
            }
            return this.requestService.request({ type: 'GET', url: this.extensionsControlUrl }, cancellation_1.CancellationToken.None).then(function (context) {
                if (context.res.statusCode !== 200) {
                    return winjs_base_1.TPromise.wrapError(new Error('Could not get extensions report.'));
                }
                return request_2.asJson(context).then(function (result) {
                    var map = new Map();
                    for (var _i = 0, _a = result.malicious; _i < _a.length; _i++) {
                        var id = _a[_i];
                        var ext = map.get(id) || { id: { id: id }, malicious: true, slow: false };
                        ext.malicious = true;
                        map.set(id, ext);
                    }
                    return winjs_base_1.TPromise.as(map_1.values(map));
                });
            });
        };
        ExtensionGalleryService = __decorate([
            __param(0, request_1.IRequestService),
            __param(1, environment_1.IEnvironmentService),
            __param(2, telemetry_1.ITelemetryService)
        ], ExtensionGalleryService);
        return ExtensionGalleryService;
    }());
    exports.ExtensionGalleryService = ExtensionGalleryService;
    function resolveMarketplaceHeaders(environmentService) {
        var marketplaceMachineIdFile = path.join(environmentService.userDataPath, 'machineid');
        return pfs_1.readFile(marketplaceMachineIdFile, 'utf8').then(function (contents) {
            if (uuid_1.isUUID(contents)) {
                return contents;
            }
            return winjs_base_1.TPromise.wrap(null); // invalid marketplace UUID
        }, function (error) {
            return winjs_base_1.TPromise.wrap(null); // error reading ID file
        }).then(function (uuid) {
            if (!uuid) {
                uuid = uuid_1.generateUuid();
                try {
                    extfs_1.writeFileAndFlushSync(marketplaceMachineIdFile, uuid);
                }
                catch (error) {
                    //noop
                }
            }
            return {
                'X-Market-Client-Id': "VSCode " + package_1.default.version,
                'User-Agent': "VSCode " + package_1.default.version,
                'X-Market-User-Id': uuid
            };
        });
    }
    exports.resolveMarketplaceHeaders = resolveMarketplaceHeaders;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[175/*vs/code/electron-main/window*/], __M([1/*require*/,0/*exports*/,11/*path*/,17/*vs/base/common/objects*/,78/*vs/nls!vs/code/electron-main/window*/,6/*vs/base/common/uri*/,28/*vs/platform/state/common/state*/,8/*electron*/,2/*vs/base/common/winjs.base*/,9/*vs/platform/environment/common/environment*/,7/*vs/platform/log/common/log*/,14/*vs/platform/configuration/common/configuration*/,41/*vs/platform/environment/node/argv*/,16/*vs/platform/node/product*/,13/*vs/base/common/lifecycle*/,3/*vs/base/common/platform*/,19/*vs/platform/workspaces/common/workspaces*/,57/*vs/platform/backup/common/backup*/,178/*vs/base/common/performance*/,176/*vs/platform/extensionManagement/node/extensionGalleryService*/,59/*vs/code/electron-main/theme*/]), function (require, exports, path, objects, nls, uri_1, state_1, electron_1, winjs_base_1, environment_1, log_1, configuration_1, argv_1, product_1, lifecycle_1, platform_1, workspaces_1, backup_1, perf, extensionGalleryService_1, theme_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultWindowState = function (mode) {
        if (mode === void 0) { mode = 1 /* Normal */; }
        return {
            width: 1024,
            height: 768,
            mode: mode
        };
    };
    var CodeWindow = /** @class */ (function () {
        function CodeWindow(config, logService, environmentService, configurationService, stateService, workspacesMainService, backupMainService) {
            this.logService = logService;
            this.environmentService = environmentService;
            this.configurationService = configurationService;
            this.stateService = stateService;
            this.workspacesMainService = workspacesMainService;
            this.backupMainService = backupMainService;
            this.touchBarGroups = [];
            this._lastFocusTime = -1;
            this._readyState = 0 /* NONE */;
            this.whenReadyCallbacks = [];
            this.toDispose = [];
            // create browser window
            this.createBrowserWindow(config);
            // respect configured menu bar visibility
            this.onConfigurationUpdated();
            // macOS: touch bar support
            this.createTouchBar();
            // Request handling
            this.handleMarketplaceRequests();
            // Eventing
            this.registerListeners();
        }
        CodeWindow.prototype.createBrowserWindow = function (config) {
            // Load window state
            this.windowState = this.restoreWindowState(config.state);
            // in case we are maximized or fullscreen, only show later after the call to maximize/fullscreen (see below)
            var isFullscreenOrMaximized = (this.windowState.mode === 0 /* Maximized */ || this.windowState.mode === 3 /* Fullscreen */);
            var options = {
                width: this.windowState.width,
                height: this.windowState.height,
                x: this.windowState.x,
                y: this.windowState.y,
                backgroundColor: theme_1.getBackgroundColor(this.stateService),
                minWidth: CodeWindow.MIN_WIDTH,
                minHeight: CodeWindow.MIN_HEIGHT,
                show: !isFullscreenOrMaximized,
                title: product_1.default.nameLong,
                webPreferences: {
                    // By default if Code is in the background, intervals and timeouts get throttled, so we
                    // want to enforce that Code stays in the foreground. This triggers a disable_hidden_
                    // flag that Electron provides via patch:
                    // https://github.com/electron/libchromiumcontent/blob/master/patches/common/chromium/disable_hidden.patch
                    'backgroundThrottling': false
                }
            };
            if (platform_1.isLinux) {
                options.icon = path.join(this.environmentService.appRoot, 'resources/linux/code.png'); // Windows and Mac are better off using the embedded icon(s)
            }
            var windowConfig = this.configurationService.getValue('window');
            if (platform_1.isMacintosh) {
                options.acceptFirstMouse = true; // enabled by default
                if (windowConfig && windowConfig.clickThroughInactive === false) {
                    options.acceptFirstMouse = false;
                }
            }
            var useNativeTabs = false;
            if (platform_1.isMacintosh && windowConfig && windowConfig.nativeTabs === true) {
                options.tabbingIdentifier = product_1.default.nameShort; // this opts in to sierra tabs
                useNativeTabs = true;
            }
            var useCustomTitleStyle = false;
            if (platform_1.isMacintosh) {
                useCustomTitleStyle = !windowConfig || !windowConfig.titleBarStyle || windowConfig.titleBarStyle === 'custom'; // Default to custom on macOS
                var isDev = !this.environmentService.isBuilt || !!config.extensionDevelopmentPath;
                if (isDev) {
                    useCustomTitleStyle = false; // not enabled when developing due to https://github.com/electron/electron/issues/3647
                }
            }
            else {
                if (platform_1.isLinux) {
                    useCustomTitleStyle = windowConfig && windowConfig.titleBarStyle === 'custom';
                }
                else {
                    useCustomTitleStyle = !windowConfig || !windowConfig.titleBarStyle || windowConfig.titleBarStyle === 'custom'; // Default to custom on Windows
                }
            }
            if (useNativeTabs) {
                useCustomTitleStyle = false; // native tabs on sierra do not work with custom title style
            }
            if (useCustomTitleStyle) {
                options.titleBarStyle = 'hidden';
                this.hiddenTitleBarStyle = true;
                if (!platform_1.isMacintosh) {
                    options.frame = false;
                }
            }
            // Create the browser window.
            this._win = new electron_1.BrowserWindow(options);
            this._id = this._win.id;
            if (useCustomTitleStyle) {
                this._win.setSheetOffset(22); // offset dialogs by the height of the custom title bar if we have any
            }
            if (isFullscreenOrMaximized) {
                this._win.maximize();
                if (this.windowState.mode === 3 /* Fullscreen */) {
                    this._win.setFullScreen(true);
                }
                if (!this._win.isVisible()) {
                    this._win.show(); // to reduce flicker from the default window size to maximize, we only show after maximize
                }
            }
            this._lastFocusTime = Date.now(); // since we show directly, we need to set the last focus time too
        };
        CodeWindow.prototype.hasHiddenTitleBarStyle = function () {
            return this.hiddenTitleBarStyle;
        };
        Object.defineProperty(CodeWindow.prototype, "isExtensionDevelopmentHost", {
            get: function () {
                return !!this.config.extensionDevelopmentPath;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "isExtensionTestHost", {
            get: function () {
                return !!this.config.extensionTestsPath;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "extensionDevelopmentPath", {
            get: function () {
                return this.config.extensionDevelopmentPath;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "config", {
            get: function () {
                return this.currentConfig;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "win", {
            get: function () {
                return this._win;
            },
            enumerable: true,
            configurable: true
        });
        CodeWindow.prototype.setRepresentedFilename = function (filename) {
            if (platform_1.isMacintosh) {
                this.win.setRepresentedFilename(filename);
            }
            else {
                this.representedFilename = filename;
            }
        };
        CodeWindow.prototype.getRepresentedFilename = function () {
            if (platform_1.isMacintosh) {
                return this.win.getRepresentedFilename();
            }
            return this.representedFilename;
        };
        CodeWindow.prototype.focus = function () {
            if (!this._win) {
                return;
            }
            if (this._win.isMinimized()) {
                this._win.restore();
            }
            this._win.focus();
        };
        Object.defineProperty(CodeWindow.prototype, "lastFocusTime", {
            get: function () {
                return this._lastFocusTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "backupPath", {
            get: function () {
                return this.currentConfig ? this.currentConfig.backupPath : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "openedWorkspace", {
            get: function () {
                return this.currentConfig ? this.currentConfig.workspace : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeWindow.prototype, "openedFolderUri", {
            get: function () {
                return this.currentConfig ? this.currentConfig.folderUri : void 0;
            },
            enumerable: true,
            configurable: true
        });
        CodeWindow.prototype.setReady = function () {
            this._readyState = 3 /* READY */;
            // inform all waiting promises that we are ready now
            while (this.whenReadyCallbacks.length) {
                this.whenReadyCallbacks.pop()(this);
            }
        };
        CodeWindow.prototype.ready = function () {
            var _this = this;
            return new winjs_base_1.TPromise(function (c) {
                if (_this._readyState === 3 /* READY */) {
                    return c(_this);
                }
                // otherwise keep and call later when we are ready
                _this.whenReadyCallbacks.push(c);
            });
        };
        Object.defineProperty(CodeWindow.prototype, "readyState", {
            get: function () {
                return this._readyState;
            },
            enumerable: true,
            configurable: true
        });
        CodeWindow.prototype.handleMarketplaceRequests = function () {
            var _this = this;
            // Resolve marketplace headers
            this.marketplaceHeadersPromise = extensionGalleryService_1.resolveMarketplaceHeaders(this.environmentService);
            // Inject headers when requests are incoming
            var urls = ['https://marketplace.visualstudio.com/*', 'https://*.vsassets.io/*'];
            this._win.webContents.session.webRequest.onBeforeSendHeaders({ urls: urls }, function (details, cb) {
                _this.marketplaceHeadersPromise.then(function (headers) {
                    cb({ cancel: false, requestHeaders: objects.assign(details.requestHeaders, headers) });
                });
            });
        };
        CodeWindow.prototype.registerListeners = function () {
            var _this = this;
            // Prevent loading of svgs
            this._win.webContents.session.webRequest.onBeforeRequest(null, function (details, callback) {
                if (details.url.indexOf('.svg') > 0) {
                    var uri = uri_1.URI.parse(details.url);
                    if (uri && !uri.scheme.match(/file/i) && uri.path.endsWith('.svg')) {
                        return callback({ cancel: true });
                    }
                }
                return callback({});
            });
            this._win.webContents.session.webRequest.onHeadersReceived(null, function (details, callback) {
                var contentType = (details.responseHeaders['content-type'] || details.responseHeaders['Content-Type']);
                if (contentType && Array.isArray(contentType) && contentType.some(function (x) { return x.toLowerCase().indexOf('image/svg') >= 0; })) {
                    return callback({ cancel: true });
                }
                return callback({ cancel: false, responseHeaders: details.responseHeaders });
            });
            // Remember that we loaded
            this._win.webContents.on('did-finish-load', function () {
                _this._readyState = 1 /* LOADING */;
                // Associate properties from the load request if provided
                if (_this.pendingLoadConfig) {
                    _this.currentConfig = _this.pendingLoadConfig;
                    _this.pendingLoadConfig = null;
                }
                // To prevent flashing, we set the window visible after the page has finished to load but before Code is loaded
                if (_this._win && !_this._win.isVisible()) {
                    if (_this.windowState.mode === 0 /* Maximized */) {
                        _this._win.maximize();
                    }
                    if (!_this._win.isVisible()) { // maximize also makes visible
                        _this._win.show();
                    }
                }
            });
            // App commands support
            this.registerNavigationListenerOn('app-command', 'browser-backward', 'browser-forward', false);
            // Window Focus
            this._win.on('focus', function () {
                _this._lastFocusTime = Date.now();
            });
            // Window (Un)Maximize
            this._win.on('maximize', function (e) {
                if (_this.currentConfig) {
                    _this.currentConfig.maximized = true;
                }
                electron_1.app.emit('browser-window-maximize', e, _this._win);
            });
            this._win.on('unmaximize', function (e) {
                if (_this.currentConfig) {
                    _this.currentConfig.maximized = false;
                }
                electron_1.app.emit('browser-window-unmaximize', e, _this._win);
            });
            // Window Fullscreen
            this._win.on('enter-full-screen', function () {
                _this.sendWhenReady('vscode:enterFullScreen');
            });
            this._win.on('leave-full-screen', function () {
                _this.sendWhenReady('vscode:leaveFullScreen');
            });
            // Window Failed to load
            this._win.webContents.on('did-fail-load', function (event, errorCode, errorDescription, validatedURL, isMainFrame) {
                _this.logService.warn('[electron event]: fail to load, ', errorDescription);
            });
            // Handle configuration changes
            this.toDispose.push(this.configurationService.onDidChangeConfiguration(function (e) { return _this.onConfigurationUpdated(); }));
            // Handle Workspace events
            this.toDispose.push(this.workspacesMainService.onUntitledWorkspaceDeleted(function (e) { return _this.onUntitledWorkspaceDeleted(e); }));
            // TODO@Ben workaround for https://github.com/Microsoft/vscode/issues/13612
            // It looks like smooth scrolling disappears as soon as the window is minimized
            // and maximized again. Touching some window properties "fixes" it, like toggling
            // the visibility of the menu.
            if (platform_1.isWindows) {
                var windowConfig = this.configurationService.getValue('window');
                if (windowConfig && windowConfig.smoothScrollingWorkaround === true) {
                    var minimized_1 = false;
                    var restoreSmoothScrolling_1 = function () {
                        if (minimized_1) {
                            var visibility_1 = _this.getMenuBarVisibility();
                            var temporaryVisibility_1 = (visibility_1 === 'hidden' || visibility_1 === 'toggle') ? 'default' : 'hidden';
                            setTimeout(function () {
                                _this.doSetMenuBarVisibility(temporaryVisibility_1);
                                _this.doSetMenuBarVisibility(visibility_1);
                            }, 0);
                        }
                        minimized_1 = false;
                    };
                    this._win.on('minimize', function () { return minimized_1 = true; });
                    this._win.on('restore', function () { return restoreSmoothScrolling_1(); });
                    this._win.on('maximize', function () { return restoreSmoothScrolling_1(); });
                }
            }
        };
        CodeWindow.prototype.onUntitledWorkspaceDeleted = function (workspace) {
            // Make sure to update our workspace config if we detect that it
            // was deleted
            if (this.openedWorkspace && this.openedWorkspace.id === workspace.id) {
                this.currentConfig.workspace = void 0;
            }
        };
        CodeWindow.prototype.onConfigurationUpdated = function () {
            var newMenuBarVisibility = this.getMenuBarVisibility();
            if (newMenuBarVisibility !== this.currentMenuBarVisibility) {
                this.currentMenuBarVisibility = newMenuBarVisibility;
                this.setMenuBarVisibility(newMenuBarVisibility);
            }
            // Swipe command support (macOS)
            if (platform_1.isMacintosh) {
                var config = this.configurationService.getValue();
                if (config && config.workbench && config.workbench.editor && config.workbench.editor.swipeToNavigate) {
                    this.registerNavigationListenerOn('swipe', 'left', 'right', true);
                }
                else {
                    this._win.removeAllListeners('swipe');
                }
            }
        };
        CodeWindow.prototype.registerNavigationListenerOn = function (command, back, forward, acrossEditors) {
            var _this = this;
            this._win.on(command /* | 'app-command' */, function (e, cmd) {
                if (_this.readyState !== 3 /* READY */) {
                    return; // window must be ready
                }
                if (cmd === back) {
                    _this.send('vscode:runAction', { id: acrossEditors ? 'workbench.action.openPreviousRecentlyUsedEditor' : 'workbench.action.navigateBack', from: 'mouse' });
                }
                else if (cmd === forward) {
                    _this.send('vscode:runAction', { id: acrossEditors ? 'workbench.action.openNextRecentlyUsedEditor' : 'workbench.action.navigateForward', from: 'mouse' });
                }
            });
        };
        CodeWindow.prototype.addTabbedWindow = function (window) {
            if (platform_1.isMacintosh) {
                this._win.addTabbedWindow(window.win);
            }
        };
        CodeWindow.prototype.load = function (config, isReload, disableExtensions) {
            var _this = this;
            // If this is the first time the window is loaded, we associate the paths
            // directly with the window because we assume the loading will just work
            if (this.readyState === 0 /* NONE */) {
                this.currentConfig = config;
            }
            // Otherwise, the window is currently showing a folder and if there is an
            // unload handler preventing the load, we cannot just associate the paths
            // because the loading might be vetoed. Instead we associate it later when
            // the window load event has fired.
            else {
                this.pendingLoadConfig = config;
                this._readyState = 2 /* NAVIGATING */;
            }
            // Add disable-extensions to the config, but do not preserve it on currentConfig or
            // pendingLoadConfig so that it is applied only on this load
            var configuration = objects.assign({}, config);
            if (disableExtensions !== undefined) {
                configuration['disable-extensions'] = disableExtensions;
            }
            // Clear Document Edited if needed
            if (platform_1.isMacintosh && this._win.isDocumentEdited()) {
                if (!isReload || !this.backupMainService.isHotExitEnabled()) {
                    this._win.setDocumentEdited(false);
                }
            }
            // Clear Title and Filename if needed
            if (!isReload) {
                if (this.getRepresentedFilename()) {
                    this.setRepresentedFilename('');
                }
                this._win.setTitle(product_1.default.nameLong);
            }
            // Load URL
            perf.mark('main:loadWindow');
            this._win.loadURL(this.getUrl(configuration));
            // Make window visible if it did not open in N seconds because this indicates an error
            // Only do this when running out of sources and not when running tests
            if (!this.environmentService.isBuilt && !this.environmentService.extensionTestsPath) {
                this.showTimeoutHandle = setTimeout(function () {
                    if (_this._win && !_this._win.isVisible() && !_this._win.isMinimized()) {
                        _this._win.show();
                        _this._win.focus();
                        _this._win.webContents.openDevTools();
                    }
                }, 10000);
            }
        };
        CodeWindow.prototype.reload = function (configuration, cli) {
            // If config is not provided, copy our current one
            if (!configuration) {
                configuration = objects.mixin({}, this.currentConfig);
            }
            // Delete some properties we do not want during reload
            delete configuration.filesToOpen;
            delete configuration.filesToCreate;
            delete configuration.filesToDiff;
            delete configuration.filesToWait;
            // Some configuration things get inherited if the window is being reloaded and we are
            // in extension development mode. These options are all development related.
            if (this.isExtensionDevelopmentHost && cli) {
                configuration.verbose = cli.verbose;
                configuration.debugPluginHost = cli.debugPluginHost;
                configuration.debugBrkPluginHost = cli.debugBrkPluginHost;
                configuration.debugId = cli.debugId;
                configuration['extensions-dir'] = cli['extensions-dir'];
            }
            configuration.isInitialStartup = false; // since this is a reload
            // Load config
            var disableExtensions = cli ? cli['disable-extensions'] : undefined;
            this.load(configuration, true, disableExtensions);
        };
        CodeWindow.prototype.getUrl = function (windowConfiguration) {
            // Set window ID
            windowConfiguration.windowId = this._win.id;
            windowConfiguration.logLevel = this.logService.getLevel();
            // Set zoomlevel
            var windowConfig = this.configurationService.getValue('window');
            var zoomLevel = windowConfig && windowConfig.zoomLevel;
            if (typeof zoomLevel === 'number') {
                windowConfiguration.zoomLevel = zoomLevel;
            }
            // Set fullscreen state
            windowConfiguration.fullscreen = this._win.isFullScreen();
            // Set Accessibility Config
            var autoDetectHighContrast = true;
            if (windowConfig && windowConfig.autoDetectHighContrast === false) {
                autoDetectHighContrast = false;
            }
            windowConfiguration.highContrast = platform_1.isWindows && autoDetectHighContrast && electron_1.systemPreferences.isInvertedColorScheme();
            windowConfiguration.accessibilitySupport = electron_1.app.isAccessibilitySupportEnabled();
            // Title style related
            windowConfiguration.maximized = this._win.isMaximized();
            windowConfiguration.frameless = this.hasHiddenTitleBarStyle() && !platform_1.isMacintosh;
            // Dump Perf Counters
            windowConfiguration.perfEntries = perf.exportEntries();
            // Config (combination of process.argv and window configuration)
            var environment = argv_1.parseArgs(process.argv);
            var config = objects.assign(environment, windowConfiguration);
            for (var key in config) {
                if (config[key] === void 0 || config[key] === null || config[key] === '') {
                    delete config[key]; // only send over properties that have a true value
                }
            }
            return require.toUrl('vs/code/electron-browser/workbench/workbench.html') + "?config=" + encodeURIComponent(JSON.stringify(config));
        };
        CodeWindow.prototype.serializeWindowState = function () {
            if (!this._win) {
                return exports.defaultWindowState();
            }
            // fullscreen gets special treatment
            if (this._win.isFullScreen()) {
                var display = electron_1.screen.getDisplayMatching(this.getBounds());
                var defaultState = exports.defaultWindowState();
                var res = {
                    mode: 3 /* Fullscreen */,
                    display: display ? display.id : void 0,
                    // Still carry over window dimensions from previous sessions
                    // if we can compute it in fullscreen state.
                    // does not seem possible in all cases on Linux for example
                    // (https://github.com/Microsoft/vscode/issues/58218) so we
                    // fallback to the defaults in that case.
                    width: this.windowState.width || defaultState.width,
                    height: this.windowState.height || defaultState.height,
                    x: this.windowState.x || 0,
                    y: this.windowState.y || 0
                };
                return res;
            }
            var state = Object.create(null);
            var mode;
            // get window mode
            if (!platform_1.isMacintosh && this._win.isMaximized()) {
                mode = 0 /* Maximized */;
            }
            else {
                mode = 1 /* Normal */;
            }
            // we don't want to save minimized state, only maximized or normal
            if (mode === 0 /* Maximized */) {
                state.mode = 0 /* Maximized */;
            }
            else {
                state.mode = 1 /* Normal */;
            }
            // only consider non-minimized window states
            if (mode === 1 /* Normal */ || mode === 0 /* Maximized */) {
                var bounds = this.getBounds();
                state.x = bounds.x;
                state.y = bounds.y;
                state.width = bounds.width;
                state.height = bounds.height;
            }
            return state;
        };
        CodeWindow.prototype.restoreWindowState = function (state) {
            if (state) {
                try {
                    state = this.validateWindowState(state);
                }
                catch (err) {
                    this.logService.warn("Unexpected error validating window state: " + err + "\n" + err.stack); // somehow display API can be picky about the state to validate
                }
            }
            if (!state) {
                state = exports.defaultWindowState();
            }
            return state;
        };
        CodeWindow.prototype.validateWindowState = function (state) {
            if (!state) {
                return null;
            }
            if ([state.x, state.y, state.width, state.height].some(function (n) { return typeof n !== 'number'; })) {
                return null;
            }
            if (state.width <= 0 || state.height <= 0) {
                return null;
            }
            var displays = electron_1.screen.getAllDisplays();
            // Single Monitor: be strict about x/y positioning
            if (displays.length === 1) {
                var displayBounds = displays[0].bounds;
                // Careful with maximized: in that mode x/y can well be negative!
                if (state.mode !== 0 /* Maximized */ && displayBounds.width > 0 && displayBounds.height > 0 /* Linux X11 sessions sometimes report wrong display bounds */) {
                    if (state.x < displayBounds.x) {
                        state.x = displayBounds.x; // prevent window from falling out of the screen to the left
                    }
                    if (state.y < displayBounds.y) {
                        state.y = displayBounds.y; // prevent window from falling out of the screen to the top
                    }
                    if (state.x > (displayBounds.x + displayBounds.width)) {
                        state.x = displayBounds.x; // prevent window from falling out of the screen to the right
                    }
                    if (state.y > (displayBounds.y + displayBounds.height)) {
                        state.y = displayBounds.y; // prevent window from falling out of the screen to the bottom
                    }
                    if (state.width > displayBounds.width) {
                        state.width = displayBounds.width; // prevent window from exceeding display bounds width
                    }
                    if (state.height > displayBounds.height) {
                        state.height = displayBounds.height; // prevent window from exceeding display bounds height
                    }
                }
                if (state.mode === 0 /* Maximized */) {
                    return exports.defaultWindowState(0 /* Maximized */); // when maximized, make sure we have good values when the user restores the window
                }
                return state;
            }
            // Multi Montior (fullscreen): try to find the previously used display
            if (state.display && state.mode === 3 /* Fullscreen */) {
                var display_1 = displays.filter(function (d) { return d.id === state.display; })[0];
                if (display_1 && display_1.bounds && typeof display_1.bounds.x === 'number' && typeof display_1.bounds.y === 'number') {
                    var defaults = exports.defaultWindowState(3 /* Fullscreen */); // make sure we have good values when the user restores the window
                    defaults.x = display_1.bounds.x; // carefull to use displays x/y position so that the window ends up on the correct monitor
                    defaults.y = display_1.bounds.y;
                    return defaults;
                }
            }
            // Multi Monitor (non-fullscreen): be less strict because metrics can be crazy
            var bounds = { x: state.x, y: state.y, width: state.width, height: state.height };
            var display = electron_1.screen.getDisplayMatching(bounds);
            if (display && // we have a display matching the desired bounds
                bounds.x < display.bounds.x + display.bounds.width && // prevent window from falling out of the screen to the right
                bounds.y < display.bounds.y + display.bounds.height && // prevent window from falling out of the screen to the bottom
                bounds.x + bounds.width > display.bounds.x && // prevent window from falling out of the screen to the left
                bounds.y + bounds.height > display.bounds.y // prevent window from falling out of the scree nto the top
            ) {
                if (state.mode === 0 /* Maximized */) {
                    var defaults = exports.defaultWindowState(0 /* Maximized */); // when maximized, make sure we have good values when the user restores the window
                    defaults.x = state.x; // carefull to keep x/y position so that the window ends up on the correct monitor
                    defaults.y = state.y;
                    return defaults;
                }
                return state;
            }
            return null;
        };
        CodeWindow.prototype.getBounds = function () {
            var pos = this._win.getPosition();
            var dimension = this._win.getSize();
            return { x: pos[0], y: pos[1], width: dimension[0], height: dimension[1] };
        };
        CodeWindow.prototype.toggleFullScreen = function () {
            var willBeFullScreen = !this._win.isFullScreen();
            // set fullscreen flag on window
            this._win.setFullScreen(willBeFullScreen);
            // respect configured menu bar visibility or default to toggle if not set
            this.setMenuBarVisibility(this.currentMenuBarVisibility, false);
        };
        CodeWindow.prototype.getMenuBarVisibility = function () {
            var windowConfig = this.configurationService.getValue('window');
            if (!windowConfig || !windowConfig.menuBarVisibility) {
                return 'default';
            }
            var menuBarVisibility = windowConfig.menuBarVisibility;
            if (['visible', 'toggle', 'hidden'].indexOf(menuBarVisibility) < 0) {
                menuBarVisibility = 'default';
            }
            return menuBarVisibility;
        };
        CodeWindow.prototype.setMenuBarVisibility = function (visibility, notify) {
            var _this = this;
            if (notify === void 0) { notify = true; }
            if (platform_1.isMacintosh) {
                return; // ignore for macOS platform
            }
            if (visibility === 'toggle') {
                if (notify) {
                    this.send('vscode:showInfoMessage', nls.localize(0, null));
                }
            }
            if (visibility === 'hidden') {
                // for some weird reason that I have no explanation for, the menu bar is not hiding when calling
                // this without timeout (see https://github.com/Microsoft/vscode/issues/19777). there seems to be
                // a timing issue with us opening the first window and the menu bar getting created. somehow the
                // fact that we want to hide the menu without being able to bring it back via Alt key makes Electron
                // still show the menu. Unable to reproduce from a simple Hello World application though...
                setTimeout(function () {
                    _this.doSetMenuBarVisibility(visibility);
                });
            }
            else {
                this.doSetMenuBarVisibility(visibility);
            }
        };
        CodeWindow.prototype.doSetMenuBarVisibility = function (visibility) {
            var isFullscreen = this._win.isFullScreen();
            switch (visibility) {
                case ('default'):
                    this._win.setMenuBarVisibility(!isFullscreen);
                    this._win.setAutoHideMenuBar(isFullscreen);
                    break;
                case ('visible'):
                    this._win.setMenuBarVisibility(true);
                    this._win.setAutoHideMenuBar(false);
                    break;
                case ('toggle'):
                    this._win.setMenuBarVisibility(false);
                    this._win.setAutoHideMenuBar(true);
                    break;
                case ('hidden'):
                    this._win.setMenuBarVisibility(false);
                    this._win.setAutoHideMenuBar(false);
                    break;
            }
        };
        CodeWindow.prototype.onWindowTitleDoubleClick = function () {
            // Respect system settings on mac with regards to title click on windows title
            if (platform_1.isMacintosh) {
                var action = electron_1.systemPreferences.getUserDefault('AppleActionOnDoubleClick', 'string');
                switch (action) {
                    case 'Minimize':
                        this.win.minimize();
                        break;
                    case 'None':
                        break;
                    case 'Maximize':
                    default:
                        this.win.maximize();
                }
            }
            // Linux/Windows: just toggle maximize/minimized state
            else {
                if (this.win.isMaximized()) {
                    this.win.unmaximize();
                }
                else {
                    this.win.maximize();
                }
            }
        };
        CodeWindow.prototype.close = function () {
            if (this._win) {
                this._win.close();
            }
        };
        CodeWindow.prototype.sendWhenReady = function (channel) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            this.ready().then(function () {
                _this.send.apply(_this, [channel].concat(args));
            });
        };
        CodeWindow.prototype.send = function (channel) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a;
            if (this._win) {
                (_a = this._win.webContents).send.apply(_a, [channel].concat(args));
            }
        };
        CodeWindow.prototype.updateTouchBar = function (groups) {
            var _this = this;
            if (!platform_1.isMacintosh) {
                return; // only supported on macOS
            }
            // Update segments for all groups. Setting the segments property
            // of the group directly prevents ugly flickering from happening
            this.touchBarGroups.forEach(function (touchBarGroup, index) {
                var commands = groups[index];
                touchBarGroup.segments = _this.createTouchBarGroupSegments(commands);
            });
        };
        CodeWindow.prototype.createTouchBar = function () {
            if (!platform_1.isMacintosh) {
                return; // only supported on macOS
            }
            // To avoid flickering, we try to reuse the touch bar group
            // as much as possible by creating a large number of groups
            // for reusing later.
            for (var i = 0; i < 10; i++) {
                var groupTouchBar = this.createTouchBarGroup();
                this.touchBarGroups.push(groupTouchBar);
            }
            this._win.setTouchBar(new electron_1.TouchBar({ items: this.touchBarGroups }));
        };
        CodeWindow.prototype.createTouchBarGroup = function (items) {
            var _this = this;
            if (items === void 0) { items = []; }
            // Group Segments
            var segments = this.createTouchBarGroupSegments(items);
            // Group Control
            var control = new electron_1.TouchBar.TouchBarSegmentedControl({
                segments: segments,
                mode: 'buttons',
                segmentStyle: 'automatic',
                change: function (selectedIndex) {
                    _this.sendWhenReady('vscode:runAction', { id: control.segments[selectedIndex].id, from: 'touchbar' });
                }
            });
            return control;
        };
        CodeWindow.prototype.createTouchBarGroupSegments = function (items) {
            if (items === void 0) { items = []; }
            var segments = items.map(function (item) {
                var icon;
                if (item.iconLocation && item.iconLocation.dark.scheme === 'file') {
                    icon = electron_1.nativeImage.createFromPath(uri_1.URI.revive(item.iconLocation.dark).fsPath);
                    if (icon.isEmpty()) {
                        icon = void 0;
                    }
                }
                return {
                    id: item.id,
                    label: !icon ? item.title : void 0,
                    icon: icon
                };
            });
            return segments;
        };
        CodeWindow.prototype.dispose = function () {
            if (this.showTimeoutHandle) {
                clearTimeout(this.showTimeoutHandle);
            }
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this._win = null; // Important to dereference the window object to allow for GC
        };
        CodeWindow.MIN_WIDTH = 200;
        CodeWindow.MIN_HEIGHT = 120;
        CodeWindow = __decorate([
            __param(1, log_1.ILogService),
            __param(2, environment_1.IEnvironmentService),
            __param(3, configuration_1.IConfigurationService),
            __param(4, state_1.IStateService),
            __param(5, workspaces_1.IWorkspacesMainService),
            __param(6, backup_1.IBackupMainService)
        ], CodeWindow);
        return CodeWindow;
    }());
    exports.CodeWindow = CodeWindow;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




















define(__m[155/*vs/code/electron-main/windows*/], __M([1/*require*/,0/*exports*/,11/*path*/,21/*fs*/,79/*vs/nls!vs/code/electron-main/windows*/,24/*vs/base/common/arrays*/,17/*vs/base/common/objects*/,57/*vs/platform/backup/common/backup*/,9/*vs/platform/environment/common/environment*/,28/*vs/platform/state/common/state*/,175/*vs/code/electron-main/window*/,41/*vs/platform/environment/node/argv*/,8/*electron*/,67/*vs/code/node/paths*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,14/*vs/platform/configuration/common/configuration*/,7/*vs/platform/log/common/log*/,160/*vs/code/node/windowsFinder*/,5/*vs/base/common/event*/,16/*vs/platform/node/product*/,29/*vs/platform/telemetry/common/telemetry*/,44/*vs/platform/history/common/history*/,3/*vs/base/common/platform*/,2/*vs/base/common/winjs.base*/,19/*vs/platform/workspaces/common/workspaces*/,4/*vs/platform/instantiation/common/instantiation*/,31/*vs/base/common/labels*/,30/*vs/base/common/network*/,72/*vs/base/common/normalization*/,6/*vs/base/common/uri*/,20/*vs/base/common/async*/,34/*vs/base/node/pfs*/,32/*vs/base/common/resources*/,18/*vs/base/common/strings*/]), function (require, exports, path_1, fs, nls_1, arrays, objects_1, backup_1, environment_1, state_1, window_1, argv_1, electron_1, paths_1, lifecycleMain_1, configuration_1, log_1, windowsFinder_1, event_1, product_1, telemetry_1, history_1, platform_1, winjs_base_1, workspaces_1, instantiation_1, labels_1, network_1, normalization_1, uri_1, async_1, pfs_1, resources_1, strings_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var WindowError;
    (function (WindowError) {
        WindowError[WindowError["UNRESPONSIVE"] = 0] = "UNRESPONSIVE";
        WindowError[WindowError["CRASHED"] = 1] = "CRASHED";
    })(WindowError || (WindowError = {}));
    var WindowsManager = /** @class */ (function () {
        function WindowsManager(machineId, logService, stateService, environmentService, lifecycleService, backupMainService, telemetryService, configurationService, historyMainService, workspacesMainService, instantiationService) {
            this.machineId = machineId;
            this.logService = logService;
            this.stateService = stateService;
            this.environmentService = environmentService;
            this.lifecycleService = lifecycleService;
            this.backupMainService = backupMainService;
            this.configurationService = configurationService;
            this.historyMainService = historyMainService;
            this.workspacesMainService = workspacesMainService;
            this.instantiationService = instantiationService;
            this._onWindowReady = new event_1.Emitter();
            this.onWindowReady = this._onWindowReady.event;
            this._onWindowClose = new event_1.Emitter();
            this.onWindowClose = this._onWindowClose.event;
            this._onWindowLoad = new event_1.Emitter();
            this.onWindowLoad = this._onWindowLoad.event;
            this._onActiveWindowChanged = new event_1.Emitter();
            this.onActiveWindowChanged = this._onActiveWindowChanged.event;
            this._onWindowReload = new event_1.Emitter();
            this.onWindowReload = this._onWindowReload.event;
            this._onWindowsCountChanged = new event_1.Emitter();
            this.onWindowsCountChanged = this._onWindowsCountChanged.event;
            this.windowsState = this.getWindowsState();
            if (!Array.isArray(this.windowsState.openedWindows)) {
                this.windowsState.openedWindows = [];
            }
            this.dialogs = new Dialogs(environmentService, telemetryService, stateService, this);
            this.workspacesManager = new WorkspacesManager(workspacesMainService, backupMainService, environmentService, this);
        }
        WindowsManager.prototype.getWindowsState = function () {
            var _this = this;
            var windowsState = this.stateService.getItem(WindowsManager.windowsStateStorageKey) || { openedWindows: [] };
            if (windowsState.lastActiveWindow) {
                windowsState.lastActiveWindow = this.revive(windowsState.lastActiveWindow);
            }
            if (windowsState.lastPluginDevelopmentHostWindow) {
                windowsState.lastPluginDevelopmentHostWindow = this.revive(windowsState.lastPluginDevelopmentHostWindow);
            }
            if (windowsState.openedWindows) {
                windowsState.openedWindows = windowsState.openedWindows.map(function (windowState) { return _this.revive(windowState); });
            }
            return windowsState;
        };
        WindowsManager.prototype.revive = function (windowState) {
            if (windowState.folderUri) {
                windowState.folderUri = uri_1.URI.revive(windowState.folderUri);
            }
            if (windowState.folderPath) {
                windowState.folderUri = uri_1.URI.file(windowState.folderPath);
            }
            return windowState;
        };
        WindowsManager.prototype.ready = function (initialUserEnv) {
            this.initialUserEnv = initialUserEnv;
            this.registerListeners();
        };
        WindowsManager.prototype.registerListeners = function () {
            var _this = this;
            // React to windows focus changes
            electron_1.app.on('browser-window-focus', function () {
                setTimeout(function () {
                    _this._onActiveWindowChanged.fire(_this.getLastActiveWindow());
                });
            });
            // React to workbench loaded events from windows
            electron_1.ipcMain.on('vscode:workbenchLoaded', function (event, windowId) {
                _this.logService.trace('IPC#vscode-workbenchLoaded');
                var win = _this.getWindowById(windowId);
                if (win) {
                    win.setReady();
                    // Event
                    _this._onWindowReady.fire(win);
                }
            });
            // React to HC color scheme changes (Windows)
            if (platform_1.isWindows) {
                electron_1.systemPreferences.on('inverted-color-scheme-changed', function () {
                    if (electron_1.systemPreferences.isInvertedColorScheme()) {
                        _this.sendToAll('vscode:enterHighContrast');
                    }
                    else {
                        _this.sendToAll('vscode:leaveHighContrast');
                    }
                });
            }
            // Handle various lifecycle events around windows
            this.lifecycleService.onBeforeWindowUnload(function (e) { return _this.onBeforeWindowUnload(e); });
            this.lifecycleService.onBeforeWindowClose(function (win) { return _this.onBeforeWindowClose(win); });
            this.lifecycleService.onBeforeShutdown(function () { return _this.onBeforeShutdown(); });
            this.onWindowsCountChanged(function (e) {
                if (e.newCount - e.oldCount > 0) {
                    // clear last closed window state when a new window opens. this helps on macOS where
                    // otherwise closing the last window, opening a new window and then quitting would
                    // use the state of the previously closed window when restarting.
                    _this.lastClosedWindowState = void 0;
                }
            });
        };
        // Note that onBeforeShutdown() and onBeforeWindowClose() are fired in different order depending on the OS:
        // - macOS: since the app will not quit when closing the last window, you will always first get
        //          the onBeforeShutdown() event followed by N onbeforeWindowClose() events for each window
        // - other: on other OS, closing the last window will quit the app so the order depends on the
        //          user interaction: closing the last window will first trigger onBeforeWindowClose()
        //          and then onBeforeShutdown(). Using the quit action however will first issue onBeforeShutdown()
        //          and then onBeforeWindowClose().
        //
        // Here is the behaviour on different OS dependig on action taken (Electron 1.7.x):
        //
        // Legend
        // -  quit(N): quit application with N windows opened
        // - close(1): close one window via the window close button
        // - closeAll: close all windows via the taskbar command
        // - onBeforeShutdown(N): number of windows reported in this event handler
        // - onBeforeWindowClose(N, M): number of windows reported and quitRequested boolean in this event handler
        //
        // macOS
        // 	-     quit(1): onBeforeShutdown(1), onBeforeWindowClose(1, true)
        // 	-     quit(2): onBeforeShutdown(2), onBeforeWindowClose(2, true), onBeforeWindowClose(2, true)
        // 	-     quit(0): onBeforeShutdown(0)
        // 	-    close(1): onBeforeWindowClose(1, false)
        //
        // Windows
        // 	-     quit(1): onBeforeShutdown(1), onBeforeWindowClose(1, true)
        // 	-     quit(2): onBeforeShutdown(2), onBeforeWindowClose(2, true), onBeforeWindowClose(2, true)
        // 	-    close(1): onBeforeWindowClose(2, false)[not last window]
        // 	-    close(1): onBeforeWindowClose(1, false), onBeforeShutdown(0)[last window]
        // 	- closeAll(2): onBeforeWindowClose(2, false), onBeforeWindowClose(2, false), onBeforeShutdown(0)
        //
        // Linux
        // 	-     quit(1): onBeforeShutdown(1), onBeforeWindowClose(1, true)
        // 	-     quit(2): onBeforeShutdown(2), onBeforeWindowClose(2, true), onBeforeWindowClose(2, true)
        // 	-    close(1): onBeforeWindowClose(2, false)[not last window]
        // 	-    close(1): onBeforeWindowClose(1, false), onBeforeShutdown(0)[last window]
        // 	- closeAll(2): onBeforeWindowClose(2, false), onBeforeWindowClose(2, false), onBeforeShutdown(0)
        //
        WindowsManager.prototype.onBeforeShutdown = function () {
            var _this = this;
            var currentWindowsState = {
                openedWindows: [],
                lastPluginDevelopmentHostWindow: this.windowsState.lastPluginDevelopmentHostWindow,
                lastActiveWindow: this.lastClosedWindowState
            };
            // 1.) Find a last active window (pick any other first window otherwise)
            if (!currentWindowsState.lastActiveWindow) {
                var activeWindow = this.getLastActiveWindow();
                if (!activeWindow || activeWindow.isExtensionDevelopmentHost) {
                    activeWindow = WindowsManager.WINDOWS.filter(function (w) { return !w.isExtensionDevelopmentHost; })[0];
                }
                if (activeWindow) {
                    currentWindowsState.lastActiveWindow = this.toWindowState(activeWindow);
                }
            }
            // 2.) Find extension host window
            var extensionHostWindow = WindowsManager.WINDOWS.filter(function (w) { return w.isExtensionDevelopmentHost && !w.isExtensionTestHost; })[0];
            if (extensionHostWindow) {
                currentWindowsState.lastPluginDevelopmentHostWindow = this.toWindowState(extensionHostWindow);
            }
            // 3.) All windows (except extension host) for N >= 2 to support restoreWindows: all or for auto update
            //
            // Carefull here: asking a window for its window state after it has been closed returns bogus values (width: 0, height: 0)
            // so if we ever want to persist the UI state of the last closed window (window count === 1), it has
            // to come from the stored lastClosedWindowState on Win/Linux at least
            if (this.getWindowCount() > 1) {
                currentWindowsState.openedWindows = WindowsManager.WINDOWS.filter(function (w) { return !w.isExtensionDevelopmentHost; }).map(function (w) { return _this.toWindowState(w); });
            }
            // Persist
            this.stateService.setItem(WindowsManager.windowsStateStorageKey, currentWindowsState);
        };
        // See note on #onBeforeShutdown() for details how these events are flowing
        WindowsManager.prototype.onBeforeWindowClose = function (win) {
            if (this.lifecycleService.isQuitRequested) {
                return; // during quit, many windows close in parallel so let it be handled in the before-quit handler
            }
            // On Window close, update our stored UI state of this window
            var state = this.toWindowState(win);
            if (win.isExtensionDevelopmentHost && !win.isExtensionTestHost) {
                this.windowsState.lastPluginDevelopmentHostWindow = state; // do not let test run window state overwrite our extension development state
            }
            // Any non extension host window with same workspace or folder
            else if (!win.isExtensionDevelopmentHost && (!!win.openedWorkspace || !!win.openedFolderUri)) {
                this.windowsState.openedWindows.forEach(function (o) {
                    var sameWorkspace = win.openedWorkspace && o.workspace && o.workspace.id === win.openedWorkspace.id;
                    var sameFolder = win.openedFolderUri && o.folderUri && resources_1.isEqual(o.folderUri, win.openedFolderUri);
                    if (sameWorkspace || sameFolder) {
                        o.uiState = state.uiState;
                    }
                });
            }
            // On Windows and Linux closing the last window will trigger quit. Since we are storing all UI state
            // before quitting, we need to remember the UI state of this window to be able to persist it.
            // On macOS we keep the last closed window state ready in case the user wants to quit right after or
            // wants to open another window, in which case we use this state over the persisted one.
            if (this.getWindowCount() === 1) {
                this.lastClosedWindowState = state;
            }
        };
        WindowsManager.prototype.toWindowState = function (win) {
            return {
                workspace: win.openedWorkspace,
                folderUri: win.openedFolderUri,
                backupPath: win.backupPath,
                uiState: win.serializeWindowState()
            };
        };
        WindowsManager.prototype.open = function (openConfig) {
            var _this = this;
            this.logService.trace('windowsManager#open');
            openConfig = this.validateOpenConfig(openConfig);
            var pathsToOpen = this.getPathsToOpen(openConfig);
            // When run with --add, take the folders that are to be opened as
            // folders that should be added to the currently active window.
            var foldersToAdd = [];
            if (openConfig.addMode) {
                foldersToAdd = pathsToOpen.filter(function (path) { return !!path.folderUri; }).map(function (path) { return path.folderUri; });
                pathsToOpen = pathsToOpen.filter(function (path) { return !path.folderUri; });
            }
            var filesToOpen = pathsToOpen.filter(function (path) { return !!path.fileUri && !path.createFilePath; });
            var filesToCreate = pathsToOpen.filter(function (path) { return !!path.fileUri && path.createFilePath; });
            // When run with --diff, take the files to open as files to diff
            // if there are exactly two files provided.
            var filesToDiff = [];
            if (openConfig.diffMode && filesToOpen.length === 2) {
                filesToDiff = filesToOpen;
                filesToOpen = [];
                filesToCreate = []; // diff ignores other files that do not exist
            }
            // When run with --wait, make sure we keep the paths to wait for
            var filesToWait;
            if (openConfig.cli.wait && openConfig.cli.waitMarkerFilePath) {
                filesToWait = { paths: filesToDiff.concat(filesToOpen, filesToCreate), waitMarkerFilePath: openConfig.cli.waitMarkerFilePath };
            }
            //
            // These are windows to open to show workspaces
            //
            var workspacesToOpen = arrays.distinct(pathsToOpen.filter(function (win) { return !!win.workspace; }).map(function (win) { return win.workspace; }), function (workspace) { return workspace.id; }); // prevent duplicates
            //
            // These are windows to open to show either folders or files (including diffing files or creating them)
            //
            var foldersToOpen = arrays.distinct(pathsToOpen.filter(function (win) { return win.folderUri && !win.fileUri; }).map(function (win) { return win.folderUri; }), function (folder) { return resources_1.getComparisonKey(folder); }); // prevent duplicates
            //
            // These are windows to restore because of hot-exit or from previous session (only performed once on startup!)
            //
            var foldersToRestore = [];
            var workspacesToRestore = [];
            var emptyToRestore = [];
            if (openConfig.initialStartup && !openConfig.cli.extensionDevelopmentPath && !openConfig.cli['disable-restore-windows']) {
                foldersToRestore = this.backupMainService.getFolderBackupPaths();
                workspacesToRestore = this.backupMainService.getWorkspaceBackups(); // collect from workspaces with hot-exit backups
                workspacesToRestore.push.apply(// collect from workspaces with hot-exit backups
                workspacesToRestore, this.workspacesMainService.getUntitledWorkspacesSync()); // collect from previous window session
                emptyToRestore = this.backupMainService.getEmptyWindowBackupPaths();
                emptyToRestore.push.apply(emptyToRestore, pathsToOpen.filter(function (w) { return !w.workspace && !w.folderUri && w.backupPath; }).map(function (w) { return path_1.basename(w.backupPath); })); // add empty windows with backupPath
                emptyToRestore = arrays.distinct(emptyToRestore); // prevent duplicates
            }
            //
            // These are empty windows to open
            //
            var emptyToOpen = pathsToOpen.filter(function (win) { return !win.workspace && !win.folderUri && !win.fileUri && !win.backupPath; }).length;
            // Open based on config
            var usedWindows = this.doOpen(openConfig, workspacesToOpen, workspacesToRestore, foldersToOpen, foldersToRestore, emptyToRestore, emptyToOpen, filesToOpen, filesToCreate, filesToDiff, filesToWait, foldersToAdd);
            // Make sure to pass focus to the most relevant of the windows if we open multiple
            if (usedWindows.length > 1) {
                var focusLastActive = this.windowsState.lastActiveWindow && !openConfig.forceEmpty && !argv_1.hasArgs(openConfig.cli._) && !argv_1.hasArgs(openConfig.cli['file-uri']) && !argv_1.hasArgs(openConfig.cli['folder-uri']) && !(openConfig.urisToOpen && openConfig.urisToOpen.length);
                var focusLastOpened = true;
                var focusLastWindow = true;
                // 1.) focus last active window if we are not instructed to open any paths
                if (focusLastActive) {
                    var lastActiveWindw = usedWindows.filter(function (w) { return w.backupPath === _this.windowsState.lastActiveWindow.backupPath; });
                    if (lastActiveWindw.length) {
                        lastActiveWindw[0].focus();
                        focusLastOpened = false;
                        focusLastWindow = false;
                    }
                }
                // 2.) if instructed to open paths, focus last window which is not restored
                if (focusLastOpened) {
                    var _loop_1 = function (i) {
                        var usedWindow = usedWindows[i];
                        if ((usedWindow.openedWorkspace && workspacesToRestore.some(function (workspace) { return workspace.id === usedWindow.openedWorkspace.id; })) || // skip over restored workspace
                            (usedWindow.openedFolderUri && foldersToRestore.some(function (folder) { return resources_1.isEqual(folder, usedWindow.openedFolderUri); })) || // skip over restored folder
                            (usedWindow.backupPath && emptyToRestore.some(function (empty) { return empty === path_1.basename(usedWindow.backupPath); })) // skip over restored empty window
                        ) {
                            return "continue";
                        }
                        usedWindow.focus();
                        focusLastWindow = false;
                        return "break";
                    };
                    for (var i = usedWindows.length - 1; i >= 0; i--) {
                        var state_2 = _loop_1(i);
                        if (state_2 === "break")
                            break;
                    }
                }
                // 3.) finally, always ensure to have at least last used window focused
                if (focusLastWindow) {
                    usedWindows[usedWindows.length - 1].focus();
                }
            }
            // Remember in recent document list (unless this opens for extension development)
            // Also do not add paths when files are opened for diffing, only if opened individually
            if (!usedWindows.some(function (w) { return w.isExtensionDevelopmentHost; }) && !openConfig.cli.diff) {
                var recentlyOpenedWorkspaces_1 = [];
                var recentlyOpenedFiles_1 = [];
                pathsToOpen.forEach(function (win) {
                    if (win.workspace || win.folderUri) {
                        recentlyOpenedWorkspaces_1.push(win.workspace || win.folderUri);
                    }
                    else if (win.fileUri) {
                        recentlyOpenedFiles_1.push(win.fileUri);
                    }
                });
                if (!this.environmentService.skipAddToRecentlyOpened) {
                    this.historyMainService.addRecentlyOpened(recentlyOpenedWorkspaces_1, recentlyOpenedFiles_1);
                }
            }
            // If we got started with --wait from the CLI, we need to signal to the outside when the window
            // used for the edit operation is closed or loaded to a different folder so that the waiting
            // process can continue. We do this by deleting the waitMarkerFilePath.
            if (openConfig.context === 0 /* CLI */ && openConfig.cli.wait && openConfig.cli.waitMarkerFilePath && usedWindows.length === 1 && usedWindows[0]) {
                this.waitForWindowCloseOrLoad(usedWindows[0].id).then(function () { return fs.unlink(openConfig.cli.waitMarkerFilePath, function (error) { return void 0; }); });
            }
            return usedWindows;
        };
        WindowsManager.prototype.validateOpenConfig = function (config) {
            // Make sure addMode is only enabled if we have an active window
            if (config.addMode && (config.initialStartup || !this.getLastActiveWindow())) {
                config.addMode = false;
            }
            return config;
        };
        WindowsManager.prototype.doOpen = function (openConfig, workspacesToOpen, workspacesToRestore, foldersToOpen, foldersToRestore, emptyToRestore, emptyToOpen, filesToOpen, filesToCreate, filesToDiff, filesToWait, foldersToAdd) {
            var _this = this;
            var usedWindows = [];
            // Settings can decide if files/folders open in new window or not
            var _a = this.shouldOpenNewWindow(openConfig), openFolderInNewWindow = _a.openFolderInNewWindow, openFilesInNewWindow = _a.openFilesInNewWindow;
            // Handle folders to add by looking for the last active workspace (not on initial startup)
            if (!openConfig.initialStartup && foldersToAdd.length > 0) {
                var lastActiveWindow = this.getLastActiveWindow();
                if (lastActiveWindow) {
                    usedWindows.push(this.doAddFoldersToExistingWidow(lastActiveWindow, foldersToAdd));
                }
                // Reset because we handled them
                foldersToAdd = [];
            }
            // Handle files to open/diff or to create when we dont open a folder and we do not restore any folder/untitled from hot-exit
            var potentialWindowsCount = foldersToOpen.length + foldersToRestore.length + workspacesToOpen.length + workspacesToRestore.length + emptyToRestore.length;
            if (potentialWindowsCount === 0 && (filesToOpen.length > 0 || filesToCreate.length > 0 || filesToDiff.length > 0)) {
                // Find suitable window or folder path to open files in
                var fileToCheck = filesToOpen[0] || filesToCreate[0] || filesToDiff[0];
                var bestWindowOrFolder = windowsFinder_1.findBestWindowOrFolderForFile({
                    windows: WindowsManager.WINDOWS,
                    newWindow: openFilesInNewWindow,
                    reuseWindow: openConfig.forceReuseWindow,
                    context: openConfig.context,
                    fileUri: fileToCheck && fileToCheck.fileUri,
                    workspaceResolver: function (workspace) { return _this.workspacesMainService.resolveWorkspaceSync(workspace.configPath); }
                });
                // We found a window to open the files in
                if (bestWindowOrFolder instanceof window_1.CodeWindow) {
                    // Window is workspace
                    if (bestWindowOrFolder.openedWorkspace) {
                        workspacesToOpen.push(bestWindowOrFolder.openedWorkspace);
                    }
                    // Window is single folder
                    else if (bestWindowOrFolder.openedFolderUri) {
                        foldersToOpen.push(bestWindowOrFolder.openedFolderUri);
                    }
                    // Window is empty
                    else {
                        // Do open files
                        usedWindows.push(this.doOpenFilesInExistingWindow(openConfig, bestWindowOrFolder, filesToOpen, filesToCreate, filesToDiff, filesToWait));
                        // Reset these because we handled them
                        filesToOpen = [];
                        filesToCreate = [];
                        filesToDiff = [];
                        filesToWait = void 0;
                    }
                }
                // Finally, if no window or folder is found, just open the files in an empty window
                else {
                    usedWindows.push(this.openInBrowserWindow({
                        userEnv: openConfig.userEnv,
                        cli: openConfig.cli,
                        initialStartup: openConfig.initialStartup,
                        filesToOpen: filesToOpen,
                        filesToCreate: filesToCreate,
                        filesToDiff: filesToDiff,
                        filesToWait: filesToWait,
                        forceNewWindow: true,
                        forceNewTabbedWindow: openConfig.forceNewTabbedWindow
                    }));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                }
            }
            // Handle workspaces to open (instructed and to restore)
            var allWorkspacesToOpen = arrays.distinct(workspacesToRestore.concat(workspacesToOpen), function (workspace) { return workspace.id; }); // prevent duplicates
            if (allWorkspacesToOpen.length > 0) {
                // Check for existing instances
                var windowsOnWorkspace_1 = arrays.coalesce(allWorkspacesToOpen.map(function (workspaceToOpen) { return windowsFinder_1.findWindowOnWorkspace(WindowsManager.WINDOWS, workspaceToOpen); }));
                if (windowsOnWorkspace_1.length > 0) {
                    var windowOnWorkspace = windowsOnWorkspace_1[0];
                    // Do open files
                    usedWindows.push(this.doOpenFilesInExistingWindow(openConfig, windowOnWorkspace, filesToOpen, filesToCreate, filesToDiff, filesToWait));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                    openFolderInNewWindow = true; // any other folders to open must open in new window then
                }
                // Open remaining ones
                allWorkspacesToOpen.forEach(function (workspaceToOpen) {
                    if (windowsOnWorkspace_1.some(function (win) { return win.openedWorkspace.id === workspaceToOpen.id; })) {
                        return; // ignore folders that are already open
                    }
                    // Do open folder
                    usedWindows.push(_this.doOpenFolderOrWorkspace(openConfig, { workspace: workspaceToOpen }, openFolderInNewWindow, filesToOpen, filesToCreate, filesToDiff, filesToWait));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                    openFolderInNewWindow = true; // any other folders to open must open in new window then
                });
            }
            // Handle folders to open (instructed and to restore)
            var allFoldersToOpen = arrays.distinct(foldersToRestore.concat(foldersToOpen), function (folder) { return resources_1.getComparisonKey(folder); }); // prevent duplicates
            if (allFoldersToOpen.length > 0) {
                // Check for existing instances
                var windowsOnFolderPath_1 = arrays.coalesce(allFoldersToOpen.map(function (folderToOpen) { return windowsFinder_1.findWindowOnWorkspace(WindowsManager.WINDOWS, folderToOpen); }));
                if (windowsOnFolderPath_1.length > 0) {
                    var windowOnFolderPath = windowsOnFolderPath_1[0];
                    // Do open files
                    usedWindows.push(this.doOpenFilesInExistingWindow(openConfig, windowOnFolderPath, filesToOpen, filesToCreate, filesToDiff, filesToWait));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                    openFolderInNewWindow = true; // any other folders to open must open in new window then
                }
                // Open remaining ones
                allFoldersToOpen.forEach(function (folderToOpen) {
                    if (windowsOnFolderPath_1.some(function (win) { return resources_1.isEqual(win.openedFolderUri, folderToOpen); })) {
                        return; // ignore folders that are already open
                    }
                    // Do open folder
                    usedWindows.push(_this.doOpenFolderOrWorkspace(openConfig, { folderUri: folderToOpen }, openFolderInNewWindow, filesToOpen, filesToCreate, filesToDiff, filesToWait));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                    openFolderInNewWindow = true; // any other folders to open must open in new window then
                });
            }
            // Handle empty to restore
            if (emptyToRestore.length > 0) {
                emptyToRestore.forEach(function (emptyWindowBackupFolder) {
                    usedWindows.push(_this.openInBrowserWindow({
                        userEnv: openConfig.userEnv,
                        cli: openConfig.cli,
                        initialStartup: openConfig.initialStartup,
                        filesToOpen: filesToOpen,
                        filesToCreate: filesToCreate,
                        filesToDiff: filesToDiff,
                        filesToWait: filesToWait,
                        forceNewWindow: true,
                        forceNewTabbedWindow: openConfig.forceNewTabbedWindow,
                        emptyWindowBackupFolder: emptyWindowBackupFolder
                    }));
                    // Reset these because we handled them
                    filesToOpen = [];
                    filesToCreate = [];
                    filesToDiff = [];
                    filesToWait = void 0;
                    openFolderInNewWindow = true; // any other folders to open must open in new window then
                });
            }
            // Handle empty to open (only if no other window opened)
            if (usedWindows.length === 0) {
                for (var i = 0; i < emptyToOpen; i++) {
                    usedWindows.push(this.openInBrowserWindow({
                        userEnv: openConfig.userEnv,
                        cli: openConfig.cli,
                        initialStartup: openConfig.initialStartup,
                        forceNewWindow: openFolderInNewWindow,
                        forceNewTabbedWindow: openConfig.forceNewTabbedWindow
                    }));
                    openFolderInNewWindow = true; // any other window to open must open in new window then
                }
            }
            return arrays.distinct(usedWindows);
        };
        WindowsManager.prototype.doOpenFilesInExistingWindow = function (configuration, window, filesToOpen, filesToCreate, filesToDiff, filesToWait) {
            window.focus(); // make sure window has focus
            window.ready().then(function (readyWindow) {
                var termProgram = configuration.userEnv ? configuration.userEnv['TERM_PROGRAM'] : void 0;
                readyWindow.send('vscode:openFiles', { filesToOpen: filesToOpen, filesToCreate: filesToCreate, filesToDiff: filesToDiff, filesToWait: filesToWait, termProgram: termProgram });
            });
            return window;
        };
        WindowsManager.prototype.doAddFoldersToExistingWidow = function (window, foldersToAdd) {
            window.focus(); // make sure window has focus
            window.ready().then(function (readyWindow) {
                readyWindow.send('vscode:addFolders', { foldersToAdd: foldersToAdd });
            });
            return window;
        };
        WindowsManager.prototype.doOpenFolderOrWorkspace = function (openConfig, folderOrWorkspace, forceNewWindow, filesToOpen, filesToCreate, filesToDiff, filesToWait, windowToUse) {
            if (!forceNewWindow && !windowToUse && typeof openConfig.contextWindowId === 'number') {
                windowToUse = this.getWindowById(openConfig.contextWindowId); // fix for https://github.com/Microsoft/vscode/issues/49587
            }
            var browserWindow = this.openInBrowserWindow({
                userEnv: openConfig.userEnv,
                cli: openConfig.cli,
                initialStartup: openConfig.initialStartup,
                workspace: folderOrWorkspace.workspace,
                folderUri: folderOrWorkspace.folderUri,
                filesToOpen: filesToOpen,
                filesToCreate: filesToCreate,
                filesToDiff: filesToDiff,
                filesToWait: filesToWait,
                forceNewWindow: forceNewWindow,
                forceNewTabbedWindow: openConfig.forceNewTabbedWindow,
                windowToUse: windowToUse
            });
            return browserWindow;
        };
        WindowsManager.prototype.getPathsToOpen = function (openConfig) {
            var windowsToOpen;
            var isCommandLineOrAPICall = false;
            // Extract paths: from API
            if (openConfig.urisToOpen && openConfig.urisToOpen.length > 0) {
                windowsToOpen = this.doExtractPathsFromAPI(openConfig);
                isCommandLineOrAPICall = true;
            }
            // Check for force empty
            else if (openConfig.forceEmpty) {
                windowsToOpen = [Object.create(null)];
            }
            // Extract paths: from CLI
            else if (argv_1.hasArgs(openConfig.cli._) || argv_1.hasArgs(openConfig.cli['folder-uri']) || argv_1.hasArgs(openConfig.cli['file-uri'])) {
                windowsToOpen = this.doExtractPathsFromCLI(openConfig.cli);
                isCommandLineOrAPICall = true;
            }
            // Extract windows: from previous session
            else {
                windowsToOpen = this.doGetWindowsFromLastSession();
            }
            // Convert multiple folders into workspace (if opened via API or CLI)
            // This will ensure to open these folders in one window instead of multiple
            // If we are in addMode, we should not do this because in that case all
            // folders should be added to the existing window.
            if (!openConfig.addMode && isCommandLineOrAPICall) {
                var foldersToOpen = windowsToOpen.filter(function (path) { return !!path.folderUri; });
                if (foldersToOpen.length > 1) {
                    var workspace = this.workspacesMainService.createWorkspaceSync(foldersToOpen.map(function (folder) { return ({ uri: folder.folderUri }); }));
                    // Add workspace and remove folders thereby
                    windowsToOpen.push({ workspace: workspace });
                    windowsToOpen = windowsToOpen.filter(function (path) { return !path.folderUri; });
                }
            }
            return windowsToOpen;
        };
        WindowsManager.prototype.doExtractPathsFromAPI = function (openConfig) {
            var pathsToOpen = [];
            var parseOptions = { gotoLineMode: openConfig.cli && openConfig.cli.goto, forceOpenWorkspaceAsFile: openConfig.forceOpenWorkspaceAsFile };
            for (var _i = 0, _a = openConfig.urisToOpen; _i < _a.length; _i++) {
                var pathToOpen = _a[_i];
                if (!pathToOpen) {
                    continue;
                }
                var path = this.parseUri(pathToOpen, openConfig.forceOpenWorkspaceAsFile, parseOptions);
                if (path) {
                    pathsToOpen.push(path);
                }
                else {
                    // Warn about the invalid URI or path
                    var message = void 0, detail = void 0;
                    if (pathToOpen.scheme === network_1.Schemas.file) {
                        message = nls_1.localize(0, null);
                        detail = nls_1.localize(1, null, pathToOpen.fsPath);
                    }
                    else {
                        message = nls_1.localize(2, null);
                        detail = nls_1.localize(3, null, pathToOpen.toString());
                    }
                    var options = {
                        title: product_1.default.nameLong,
                        type: 'info',
                        buttons: [nls_1.localize(4, null)],
                        message: message,
                        detail: detail,
                        noLink: true
                    };
                    this.dialogs.showMessageBox(options, this.getFocusedWindow());
                }
            }
            return pathsToOpen;
        };
        WindowsManager.prototype.doExtractPathsFromCLI = function (cli) {
            var pathsToOpen = [];
            var parseOptions = { ignoreFileNotFound: true, gotoLineMode: cli.goto };
            // folder uris
            var folderUris = argv_1.asArray(cli['folder-uri']);
            for (var _i = 0, folderUris_1 = folderUris; _i < folderUris_1.length; _i++) {
                var folderUri = folderUris_1[_i];
                var path = this.parseUri(this.argToUri(folderUri), false, parseOptions);
                if (path) {
                    pathsToOpen.push(path);
                }
            }
            // file uris
            var fileUris = argv_1.asArray(cli['file-uri']);
            for (var _a = 0, fileUris_1 = fileUris; _a < fileUris_1.length; _a++) {
                var fileUri = fileUris_1[_a];
                var path = this.parseUri(this.argToUri(fileUri), true, parseOptions);
                if (path) {
                    pathsToOpen.push(path);
                }
            }
            // folder or file paths
            var cliArgs = argv_1.asArray(cli._);
            for (var _b = 0, cliArgs_1 = cliArgs; _b < cliArgs_1.length; _b++) {
                var cliArg = cliArgs_1[_b];
                var path = this.parsePath(cliArg, parseOptions);
                if (path) {
                    pathsToOpen.push(path);
                }
            }
            if (pathsToOpen.length) {
                return pathsToOpen;
            }
            // No path provided, return empty to open empty
            return [Object.create(null)];
        };
        WindowsManager.prototype.doGetWindowsFromLastSession = function () {
            var _this = this;
            var restoreWindows = this.getRestoreWindowsSetting();
            var lastActiveWindow = this.windowsState.lastActiveWindow;
            switch (restoreWindows) {
                // none: we always open an empty window
                case 'none':
                    return [Object.create(null)];
                // one: restore last opened workspace/folder or empty window
                case 'one':
                    if (lastActiveWindow) {
                        // workspace
                        var candidateWorkspace = lastActiveWindow.workspace;
                        if (candidateWorkspace) {
                            var validatedWorkspace = this.parsePath(candidateWorkspace.configPath);
                            if (validatedWorkspace && validatedWorkspace.workspace) {
                                return [validatedWorkspace];
                            }
                        }
                        // folder (if path is valid)
                        else if (lastActiveWindow.folderUri) {
                            var validatedFolder = this.parseUri(lastActiveWindow.folderUri, false);
                            if (validatedFolder && validatedFolder.folderUri) {
                                return [validatedFolder];
                            }
                        }
                        // otherwise use backup path to restore empty windows
                        else if (lastActiveWindow.backupPath) {
                            return [{ backupPath: lastActiveWindow.backupPath }];
                        }
                    }
                    break;
                // all: restore all windows
                // folders: restore last opened folders only
                case 'all':
                case 'folders':
                    var windowsToOpen = [];
                    // Workspaces
                    var workspaceCandidates = this.windowsState.openedWindows.filter(function (w) { return !!w.workspace; }).map(function (w) { return w.workspace; });
                    if (lastActiveWindow && lastActiveWindow.workspace) {
                        workspaceCandidates.push(lastActiveWindow.workspace);
                    }
                    windowsToOpen.push.apply(windowsToOpen, workspaceCandidates.map(function (candidate) { return _this.parsePath(candidate.configPath); }).filter(function (window) { return window && window.workspace; }));
                    // Folders
                    var folderCandidates = this.windowsState.openedWindows.filter(function (w) { return !!w.folderUri; }).map(function (w) { return w.folderUri; });
                    if (lastActiveWindow && lastActiveWindow.folderUri) {
                        folderCandidates.push(lastActiveWindow.folderUri);
                    }
                    windowsToOpen.push.apply(windowsToOpen, folderCandidates.map(function (candidate) { return _this.parseUri(candidate, false); }).filter(function (window) { return window && window.folderUri; }));
                    // Windows that were Empty
                    if (restoreWindows === 'all') {
                        var lastOpenedEmpty = this.windowsState.openedWindows.filter(function (w) { return !w.workspace && !w.folderUri && w.backupPath; }).map(function (w) { return w.backupPath; });
                        var lastActiveEmpty = lastActiveWindow && !lastActiveWindow.workspace && !lastActiveWindow.folderUri && lastActiveWindow.backupPath;
                        if (lastActiveEmpty) {
                            lastOpenedEmpty.push(lastActiveEmpty);
                        }
                        windowsToOpen.push.apply(windowsToOpen, lastOpenedEmpty.map(function (backupPath) { return ({ backupPath: backupPath }); }));
                    }
                    if (windowsToOpen.length > 0) {
                        return windowsToOpen;
                    }
                    break;
            }
            // Always fallback to empty window
            return [Object.create(null)];
        };
        WindowsManager.prototype.getRestoreWindowsSetting = function () {
            var restoreWindows;
            if (this.lifecycleService.wasRestarted) {
                restoreWindows = 'all'; // always reopen all windows when an update was applied
            }
            else {
                var windowConfig = this.configurationService.getValue('window');
                restoreWindows = ((windowConfig && windowConfig.restoreWindows) || 'one');
                if (['all', 'folders', 'one', 'none'].indexOf(restoreWindows) === -1) {
                    restoreWindows = 'one';
                }
            }
            return restoreWindows;
        };
        WindowsManager.prototype.argToUri = function (arg) {
            try {
                var uri = uri_1.URI.parse(arg);
                if (!uri.scheme) {
                    this.logService.error("Invalid URI input string, scheme missing: " + arg);
                    return null;
                }
                return uri;
            }
            catch (e) {
                this.logService.error("Invalid URI input string: " + arg + ", " + e.message);
            }
            return null;
        };
        WindowsManager.prototype.parseUri = function (uri, isFile, options) {
            if (!uri || !uri.scheme) {
                return null;
            }
            if (uri.scheme === network_1.Schemas.file) {
                return this.parsePath(uri.fsPath, options);
            }
            // normalize URI
            uri = resources_1.normalizePath(uri);
            if (strings_1.endsWith(uri.path, '/')) {
                uri = uri.with({ path: uri.path.substr(0, uri.path.length - 1) });
            }
            if (isFile) {
                if (options && options.gotoLineMode) {
                    var parsedPath = paths_1.parseLineAndColumnAware(uri.path);
                    return {
                        fileUri: uri.with({ path: parsedPath.path }),
                        lineNumber: parsedPath.line,
                        columnNumber: parsedPath.column
                    };
                }
                return {
                    fileUri: uri
                };
            }
            return {
                folderUri: uri
            };
        };
        WindowsManager.prototype.parsePath = function (anyPath, options) {
            if (!anyPath) {
                return null;
            }
            var parsedPath;
            var gotoLineMode = options && options.gotoLineMode;
            if (options && options.gotoLineMode) {
                parsedPath = paths_1.parseLineAndColumnAware(anyPath);
                anyPath = parsedPath.path;
            }
            var candidate = path_1.normalize(anyPath);
            try {
                var candidateStat = fs.statSync(candidate);
                if (candidateStat) {
                    if (candidateStat.isFile()) {
                        // Workspace (unless disabled via flag)
                        if (!options || !options.forceOpenWorkspaceAsFile) {
                            var workspace = this.workspacesMainService.resolveWorkspaceSync(candidate);
                            if (workspace) {
                                return { workspace: { id: workspace.id, configPath: workspace.configPath } };
                            }
                        }
                        // File
                        return {
                            fileUri: uri_1.URI.file(candidate),
                            lineNumber: gotoLineMode ? parsedPath.line : void 0,
                            columnNumber: gotoLineMode ? parsedPath.column : void 0
                        };
                    }
                    // Folder (we check for isDirectory() because e.g. paths like /dev/null
                    // are neither file nor folder but some external tools might pass them
                    // over to us)
                    else if (candidateStat.isDirectory()) {
                        return {
                            folderUri: uri_1.URI.file(candidate)
                        };
                    }
                }
            }
            catch (error) {
                var fileUri = uri_1.URI.file(candidate);
                this.historyMainService.removeFromRecentlyOpened([fileUri]); // since file does not seem to exist anymore, remove from recent
                if (options && options.ignoreFileNotFound) {
                    return { fileUri: fileUri, createFilePath: true }; // assume this is a file that does not yet exist
                }
            }
            return null;
        };
        WindowsManager.prototype.shouldOpenNewWindow = function (openConfig) {
            // let the user settings override how folders are open in a new window or same window unless we are forced
            var windowConfig = this.configurationService.getValue('window');
            var openFolderInNewWindowConfig = (windowConfig && windowConfig.openFoldersInNewWindow) || 'default' /* default */;
            var openFilesInNewWindowConfig = (windowConfig && windowConfig.openFilesInNewWindow) || 'off' /* default */;
            var openFolderInNewWindow = (openConfig.preferNewWindow || openConfig.forceNewWindow) && !openConfig.forceReuseWindow;
            if (!openConfig.forceNewWindow && !openConfig.forceReuseWindow && (openFolderInNewWindowConfig === 'on' || openFolderInNewWindowConfig === 'off')) {
                openFolderInNewWindow = (openFolderInNewWindowConfig === 'on');
            }
            // let the user settings override how files are open in a new window or same window unless we are forced (not for extension development though)
            var openFilesInNewWindow;
            if (openConfig.forceNewWindow || openConfig.forceReuseWindow) {
                openFilesInNewWindow = openConfig.forceNewWindow && !openConfig.forceReuseWindow;
            }
            else {
                // macOS: by default we open files in a new window if this is triggered via DOCK context
                if (platform_1.isMacintosh) {
                    if (openConfig.context === 1 /* DOCK */) {
                        openFilesInNewWindow = true;
                    }
                }
                // Linux/Windows: by default we open files in the new window unless triggered via DIALOG or MENU context
                else {
                    if (openConfig.context !== 3 /* DIALOG */ && openConfig.context !== 2 /* MENU */) {
                        openFilesInNewWindow = true;
                    }
                }
                // finally check for overrides of default
                if (!openConfig.cli.extensionDevelopmentPath && (openFilesInNewWindowConfig === 'on' || openFilesInNewWindowConfig === 'off')) {
                    openFilesInNewWindow = (openFilesInNewWindowConfig === 'on');
                }
            }
            return { openFolderInNewWindow: openFolderInNewWindow, openFilesInNewWindow: openFilesInNewWindow };
        };
        WindowsManager.prototype.openExtensionDevelopmentHostWindow = function (openConfig) {
            var _this = this;
            // Reload an existing extension development host window on the same path
            // We currently do not allow more than one extension development window
            // on the same extension path.
            var existingWindow = windowsFinder_1.findWindowOnExtensionDevelopmentPath(WindowsManager.WINDOWS, openConfig.cli.extensionDevelopmentPath);
            if (existingWindow) {
                this.reload(existingWindow, openConfig.cli);
                existingWindow.focus(); // make sure it gets focus and is restored
                return;
            }
            var folderUris = argv_1.asArray(openConfig.cli['folder-uri']);
            var fileUris = argv_1.asArray(openConfig.cli['file-uri']);
            var cliArgs = openConfig.cli._;
            // Fill in previously opened workspace unless an explicit path is provided and we are not unit testing
            if (!cliArgs.length && !folderUris.length && !fileUris.length && !openConfig.cli.extensionTestsPath) {
                var extensionDevelopmentWindowState = this.windowsState.lastPluginDevelopmentHostWindow;
                var workspaceToOpen = extensionDevelopmentWindowState && (extensionDevelopmentWindowState.workspace || extensionDevelopmentWindowState.folderUri);
                if (workspaceToOpen) {
                    if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspaceToOpen)) {
                        if (workspaceToOpen.scheme === network_1.Schemas.file) {
                            cliArgs = [workspaceToOpen.fsPath];
                        }
                        else {
                            folderUris = [workspaceToOpen.toString()];
                        }
                    }
                    else {
                        cliArgs = [workspaceToOpen.configPath];
                    }
                }
            }
            // Make sure we are not asked to open a workspace or folder that is already opened
            if (cliArgs.length && cliArgs.some(function (path) { return !!windowsFinder_1.findWindowOnWorkspaceOrFolderUri(WindowsManager.WINDOWS, uri_1.URI.file(path)); })) {
                cliArgs = [];
            }
            if (folderUris.length && folderUris.some(function (uri) { return !!windowsFinder_1.findWindowOnWorkspaceOrFolderUri(WindowsManager.WINDOWS, _this.argToUri(uri)); })) {
                folderUris = [];
            }
            if (fileUris.length && fileUris.some(function (uri) { return !!windowsFinder_1.findWindowOnWorkspaceOrFolderUri(WindowsManager.WINDOWS, _this.argToUri(uri)); })) {
                fileUris = [];
            }
            openConfig.cli._ = cliArgs;
            openConfig.cli['folder-uri'] = folderUris;
            openConfig.cli['file-uri'] = fileUris;
            // Open it
            this.open({ context: openConfig.context, cli: openConfig.cli, forceNewWindow: true, forceEmpty: !cliArgs.length && !folderUris.length && !fileUris.length, userEnv: openConfig.userEnv });
        };
        WindowsManager.prototype.openInBrowserWindow = function (options) {
            var _this = this;
            // Build IWindowConfiguration from config and options
            var configuration = objects_1.mixin({}, options.cli); // inherit all properties from CLI
            configuration.appRoot = this.environmentService.appRoot;
            configuration.machineId = this.machineId;
            configuration.mainPid = process.pid;
            configuration.execPath = process.execPath;
            configuration.userEnv = objects_1.assign({}, this.initialUserEnv, options.userEnv || {});
            configuration.isInitialStartup = options.initialStartup;
            configuration.workspace = options.workspace;
            configuration.folderUri = options.folderUri;
            configuration.filesToOpen = options.filesToOpen;
            configuration.filesToCreate = options.filesToCreate;
            configuration.filesToDiff = options.filesToDiff;
            configuration.filesToWait = options.filesToWait;
            configuration.nodeCachedDataDir = this.environmentService.nodeCachedDataDir;
            // if we know the backup folder upfront (for empty windows to restore), we can set it
            // directly here which helps for restoring UI state associated with that window.
            // For all other cases we first call into registerEmptyWindowBackupSync() to set it before
            // loading the window.
            if (options.emptyWindowBackupFolder) {
                configuration.backupPath = path_1.join(this.environmentService.backupHome, options.emptyWindowBackupFolder);
            }
            var window;
            if (!options.forceNewWindow && !options.forceNewTabbedWindow) {
                window = options.windowToUse || this.getLastActiveWindow();
                if (window) {
                    window.focus();
                }
            }
            // New window
            if (!window) {
                var windowConfig = this.configurationService.getValue('window');
                var state = this.getNewWindowState(configuration);
                // Window state is not from a previous session: only allow fullscreen if we inherit it or user wants fullscreen
                var allowFullscreen = void 0;
                if (state.hasDefaultState) {
                    allowFullscreen = (windowConfig && windowConfig.newWindowDimensions && ['fullscreen', 'inherit'].indexOf(windowConfig.newWindowDimensions) >= 0);
                }
                // Window state is from a previous session: only allow fullscreen when we got updated or user wants to restore
                else {
                    allowFullscreen = this.lifecycleService.wasRestarted || (windowConfig && windowConfig.restoreFullscreen);
                }
                if (state.mode === 3 /* Fullscreen */ && !allowFullscreen) {
                    state.mode = 1 /* Normal */;
                }
                // Create the window
                window = this.instantiationService.createInstance(window_1.CodeWindow, {
                    state: state,
                    extensionDevelopmentPath: configuration.extensionDevelopmentPath,
                    isExtensionTestHost: !!configuration.extensionTestsPath
                });
                // Add as window tab if configured (macOS only)
                if (options.forceNewTabbedWindow) {
                    var activeWindow = this.getLastActiveWindow();
                    if (activeWindow) {
                        activeWindow.addTabbedWindow(window);
                    }
                }
                // Add to our list of windows
                WindowsManager.WINDOWS.push(window);
                // Indicate number change via event
                this._onWindowsCountChanged.fire({ oldCount: WindowsManager.WINDOWS.length - 1, newCount: WindowsManager.WINDOWS.length });
                // Window Events
                window.win.webContents.removeAllListeners('devtools-reload-page'); // remove built in listener so we can handle this on our own
                window.win.webContents.on('devtools-reload-page', function () { return _this.reload(window); });
                window.win.webContents.on('crashed', function () { return _this.onWindowError(window, WindowError.CRASHED); });
                window.win.on('unresponsive', function () { return _this.onWindowError(window, WindowError.UNRESPONSIVE); });
                window.win.on('closed', function () { return _this.onWindowClosed(window); });
                // Lifecycle
                this.lifecycleService.registerWindow(window);
            }
            // Existing window
            else {
                // Some configuration things get inherited if the window is being reused and we are
                // in extension development host mode. These options are all development related.
                var currentWindowConfig = window.config;
                if (!configuration.extensionDevelopmentPath && currentWindowConfig && !!currentWindowConfig.extensionDevelopmentPath) {
                    configuration.extensionDevelopmentPath = currentWindowConfig.extensionDevelopmentPath;
                    configuration.verbose = currentWindowConfig.verbose;
                    configuration.debugBrkPluginHost = currentWindowConfig.debugBrkPluginHost;
                    configuration.debugId = currentWindowConfig.debugId;
                    configuration.debugPluginHost = currentWindowConfig.debugPluginHost;
                    configuration['extensions-dir'] = currentWindowConfig['extensions-dir'];
                }
            }
            // Only load when the window has not vetoed this
            this.lifecycleService.unload(window, 4 /* LOAD */).then(function (veto) {
                if (!veto) {
                    // Register window for backups
                    if (!configuration.extensionDevelopmentPath) {
                        if (configuration.workspace) {
                            configuration.backupPath = _this.backupMainService.registerWorkspaceBackupSync(configuration.workspace);
                        }
                        else if (configuration.folderUri) {
                            configuration.backupPath = _this.backupMainService.registerFolderBackupSync(configuration.folderUri);
                        }
                        else {
                            configuration.backupPath = _this.backupMainService.registerEmptyWindowBackupSync(options.emptyWindowBackupFolder);
                        }
                    }
                    // Load it
                    window.load(configuration);
                    // Signal event
                    _this._onWindowLoad.fire(window.id);
                }
            });
            return window;
        };
        WindowsManager.prototype.getNewWindowState = function (configuration) {
            var lastActive = this.getLastActiveWindow();
            // Restore state unless we are running extension tests
            if (!configuration.extensionTestsPath) {
                // extension development host Window - load from stored settings if any
                if (!!configuration.extensionDevelopmentPath && this.windowsState.lastPluginDevelopmentHostWindow) {
                    return this.windowsState.lastPluginDevelopmentHostWindow.uiState;
                }
                // Known Workspace - load from stored settings
                if (configuration.workspace) {
                    var stateForWorkspace = this.windowsState.openedWindows.filter(function (o) { return o.workspace && o.workspace.id === configuration.workspace.id; }).map(function (o) { return o.uiState; });
                    if (stateForWorkspace.length) {
                        return stateForWorkspace[0];
                    }
                }
                // Known Folder - load from stored settings
                if (configuration.folderUri) {
                    var stateForFolder = this.windowsState.openedWindows.filter(function (o) { return o.folderUri && resources_1.isEqual(o.folderUri, configuration.folderUri); }).map(function (o) { return o.uiState; });
                    if (stateForFolder.length) {
                        return stateForFolder[0];
                    }
                }
                // Empty windows with backups
                else if (configuration.backupPath) {
                    var stateForEmptyWindow = this.windowsState.openedWindows.filter(function (o) { return o.backupPath === configuration.backupPath; }).map(function (o) { return o.uiState; });
                    if (stateForEmptyWindow.length) {
                        return stateForEmptyWindow[0];
                    }
                }
                // First Window
                var lastActiveState = this.lastClosedWindowState || this.windowsState.lastActiveWindow;
                if (!lastActive && lastActiveState) {
                    return lastActiveState.uiState;
                }
            }
            //
            // In any other case, we do not have any stored settings for the window state, so we come up with something smart
            //
            // We want the new window to open on the same display that the last active one is in
            var displayToUse;
            var displays = electron_1.screen.getAllDisplays();
            // Single Display
            if (displays.length === 1) {
                displayToUse = displays[0];
            }
            // Multi Display
            else {
                // on mac there is 1 menu per window so we need to use the monitor where the cursor currently is
                if (platform_1.isMacintosh) {
                    var cursorPoint = electron_1.screen.getCursorScreenPoint();
                    displayToUse = electron_1.screen.getDisplayNearestPoint(cursorPoint);
                }
                // if we have a last active window, use that display for the new window
                if (!displayToUse && lastActive) {
                    displayToUse = electron_1.screen.getDisplayMatching(lastActive.getBounds());
                }
                // fallback to primary display or first display
                if (!displayToUse) {
                    displayToUse = electron_1.screen.getPrimaryDisplay() || displays[0];
                }
            }
            // Compute x/y based on display bounds
            // Note: important to use Math.round() because Electron does not seem to be too happy about
            // display coordinates that are not absolute numbers.
            var state = window_1.defaultWindowState();
            state.x = Math.round(displayToUse.bounds.x + (displayToUse.bounds.width / 2) - (state.width / 2));
            state.y = Math.round(displayToUse.bounds.y + (displayToUse.bounds.height / 2) - (state.height / 2));
            // Check for newWindowDimensions setting and adjust accordingly
            var windowConfig = this.configurationService.getValue('window');
            var ensureNoOverlap = true;
            if (windowConfig && windowConfig.newWindowDimensions) {
                if (windowConfig.newWindowDimensions === 'maximized') {
                    state.mode = 0 /* Maximized */;
                    ensureNoOverlap = false;
                }
                else if (windowConfig.newWindowDimensions === 'fullscreen') {
                    state.mode = 3 /* Fullscreen */;
                    ensureNoOverlap = false;
                }
                else if (windowConfig.newWindowDimensions === 'inherit' && lastActive) {
                    var lastActiveState = lastActive.serializeWindowState();
                    if (lastActiveState.mode === 3 /* Fullscreen */) {
                        state.mode = 3 /* Fullscreen */; // only take mode (fixes https://github.com/Microsoft/vscode/issues/19331)
                    }
                    else {
                        state = lastActiveState;
                    }
                    ensureNoOverlap = false;
                }
            }
            if (ensureNoOverlap) {
                state = this.ensureNoOverlap(state);
            }
            state.hasDefaultState = true; // flag as default state
            return state;
        };
        WindowsManager.prototype.ensureNoOverlap = function (state) {
            if (WindowsManager.WINDOWS.length === 0) {
                return state;
            }
            var existingWindowBounds = WindowsManager.WINDOWS.map(function (win) { return win.getBounds(); });
            while (existingWindowBounds.some(function (b) { return b.x === state.x || b.y === state.y; })) {
                state.x += 30;
                state.y += 30;
            }
            return state;
        };
        WindowsManager.prototype.reload = function (win, cli) {
            var _this = this;
            // Only reload when the window has not vetoed this
            this.lifecycleService.unload(win, 3 /* RELOAD */).then(function (veto) {
                if (!veto) {
                    win.reload(void 0, cli);
                    // Emit
                    _this._onWindowReload.fire(win.id);
                }
            });
        };
        WindowsManager.prototype.closeWorkspace = function (win) {
            this.openInBrowserWindow({
                cli: this.environmentService.args,
                windowToUse: win
            });
        };
        WindowsManager.prototype.saveAndEnterWorkspace = function (win, path) {
            var _this = this;
            return this.workspacesManager.saveAndEnterWorkspace(win, path).then(function (result) { return _this.doEnterWorkspace(win, result); });
        };
        WindowsManager.prototype.enterWorkspace = function (win, path) {
            var _this = this;
            return this.workspacesManager.enterWorkspace(win, path).then(function (result) { return _this.doEnterWorkspace(win, result); });
        };
        WindowsManager.prototype.createAndEnterWorkspace = function (win, folders, path) {
            var _this = this;
            return this.workspacesManager.createAndEnterWorkspace(win, folders, path).then(function (result) { return _this.doEnterWorkspace(win, result); });
        };
        WindowsManager.prototype.doEnterWorkspace = function (win, result) {
            // Mark as recently opened
            this.historyMainService.addRecentlyOpened([result.workspace], []);
            // Trigger Eevent to indicate load of workspace into window
            this._onWindowReady.fire(win);
            return result;
        };
        WindowsManager.prototype.pickWorkspaceAndOpen = function (options) {
            this.workspacesManager.pickWorkspaceAndOpen(options);
        };
        WindowsManager.prototype.onBeforeWindowUnload = function (e) {
            var windowClosing = (e.reason === 1 /* CLOSE */);
            var windowLoading = (e.reason === 4 /* LOAD */);
            if (!windowClosing && !windowLoading) {
                return; // only interested when window is closing or loading
            }
            var workspace = e.window.openedWorkspace;
            if (!workspace || !this.workspacesMainService.isUntitledWorkspace(workspace)) {
                return; // only care about untitled workspaces to ask for saving
            }
            if (e.window.config && !!e.window.config.extensionDevelopmentPath) {
                // do not ask to save workspace when doing extension development
                // but still delete it.
                this.workspacesMainService.deleteUntitledWorkspaceSync(workspace);
                return;
            }
            if (windowClosing && !platform_1.isMacintosh && this.getWindowCount() === 1) {
                return; // Windows/Linux: quits when last window is closed, so do not ask then
            }
            // Handle untitled workspaces with prompt as needed
            e.veto(this.workspacesManager.promptToSaveUntitledWorkspace(this.getWindowById(e.window.id), workspace).then(function (veto) {
                if (veto) {
                    return veto;
                }
                // Bug in electron: somehow we need this timeout so that the window closes properly. That
                // might be related to the fact that the untitled workspace prompt shows up async and this
                // code can execute before the dialog is fully closed which then blocks the window from closing.
                // Issue: https://github.com/Microsoft/vscode/issues/41989
                return async_1.timeout(0).then(function () { return veto; });
            }));
        };
        WindowsManager.prototype.focusLastActive = function (cli, context) {
            var lastActive = this.getLastActiveWindow();
            if (lastActive) {
                lastActive.focus();
                return lastActive;
            }
            // No window - open new empty one
            return this.open({ context: context, cli: cli, forceEmpty: true })[0];
        };
        WindowsManager.prototype.getLastActiveWindow = function () {
            return windowsFinder_1.getLastActiveWindow(WindowsManager.WINDOWS);
        };
        WindowsManager.prototype.openNewWindow = function (context) {
            return this.open({ context: context, cli: this.environmentService.args, forceNewWindow: true, forceEmpty: true });
        };
        WindowsManager.prototype.openNewTabbedWindow = function (context) {
            return this.open({ context: context, cli: this.environmentService.args, forceNewTabbedWindow: true, forceEmpty: true });
        };
        WindowsManager.prototype.waitForWindowCloseOrLoad = function (windowId) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c) {
                function handler(id) {
                    if (id === windowId) {
                        closeListener.dispose();
                        loadListener.dispose();
                        c(null);
                    }
                }
                var closeListener = _this.onWindowClose(function (id) { return handler(id); });
                var loadListener = _this.onWindowLoad(function (id) { return handler(id); });
            });
        };
        WindowsManager.prototype.sendToFocused = function (channel) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var focusedWindow = this.getFocusedWindow() || this.getLastActiveWindow();
            if (focusedWindow) {
                focusedWindow.sendWhenReady.apply(focusedWindow, [channel].concat(args));
            }
        };
        WindowsManager.prototype.sendToAll = function (channel, payload, windowIdsToIgnore) {
            WindowsManager.WINDOWS.forEach(function (w) {
                if (windowIdsToIgnore && windowIdsToIgnore.indexOf(w.id) >= 0) {
                    return; // do not send if we are instructed to ignore it
                }
                w.sendWhenReady(channel, payload);
            });
        };
        WindowsManager.prototype.getFocusedWindow = function () {
            var win = electron_1.BrowserWindow.getFocusedWindow();
            if (win) {
                return this.getWindowById(win.id);
            }
            return null;
        };
        WindowsManager.prototype.getWindowById = function (windowId) {
            var res = WindowsManager.WINDOWS.filter(function (w) { return w.id === windowId; });
            if (res && res.length === 1) {
                return res[0];
            }
            return null;
        };
        WindowsManager.prototype.getWindows = function () {
            return WindowsManager.WINDOWS;
        };
        WindowsManager.prototype.getWindowCount = function () {
            return WindowsManager.WINDOWS.length;
        };
        WindowsManager.prototype.onWindowError = function (window, error) {
            var _this = this;
            this.logService.error(error === WindowError.CRASHED ? '[VS Code]: render process crashed!' : '[VS Code]: detected unresponsive');
            // Unresponsive
            if (error === WindowError.UNRESPONSIVE) {
                this.dialogs.showMessageBox({
                    title: product_1.default.nameLong,
                    type: 'warning',
                    buttons: [labels_1.mnemonicButtonLabel(nls_1.localize(5, null)), labels_1.mnemonicButtonLabel(nls_1.localize(6, null)), labels_1.mnemonicButtonLabel(nls_1.localize(7, null))],
                    message: nls_1.localize(8, null),
                    detail: nls_1.localize(9, null),
                    noLink: true
                }, window).then(function (result) {
                    if (!window.win) {
                        return; // Return early if the window has been going down already
                    }
                    if (result.button === 0) {
                        window.reload();
                    }
                    else if (result.button === 2) {
                        _this.onBeforeWindowClose(window); // 'close' event will not be fired on destroy(), so run it manually
                        window.win.destroy(); // make sure to destroy the window as it is unresponsive
                    }
                });
            }
            // Crashed
            else {
                this.dialogs.showMessageBox({
                    title: product_1.default.nameLong,
                    type: 'warning',
                    buttons: [labels_1.mnemonicButtonLabel(nls_1.localize(10, null)), labels_1.mnemonicButtonLabel(nls_1.localize(11, null))],
                    message: nls_1.localize(12, null),
                    detail: nls_1.localize(13, null),
                    noLink: true
                }, window).then(function (result) {
                    if (!window.win) {
                        return; // Return early if the window has been going down already
                    }
                    if (result.button === 0) {
                        window.reload();
                    }
                    else if (result.button === 1) {
                        _this.onBeforeWindowClose(window); // 'close' event will not be fired on destroy(), so run it manually
                        window.win.destroy(); // make sure to destroy the window as it has crashed
                    }
                });
            }
        };
        WindowsManager.prototype.onWindowClosed = function (win) {
            // Tell window
            win.dispose();
            // Remove from our list so that Electron can clean it up
            var index = WindowsManager.WINDOWS.indexOf(win);
            WindowsManager.WINDOWS.splice(index, 1);
            // Emit
            this._onWindowsCountChanged.fire({ oldCount: WindowsManager.WINDOWS.length + 1, newCount: WindowsManager.WINDOWS.length });
            this._onWindowClose.fire(win.id);
        };
        WindowsManager.prototype.pickFileFolderAndOpen = function (options) {
            this.doPickAndOpen(options, true /* pick folders */, true /* pick files */);
        };
        WindowsManager.prototype.pickFolderAndOpen = function (options) {
            this.doPickAndOpen(options, true /* pick folders */, false /* pick files */);
        };
        WindowsManager.prototype.pickFileAndOpen = function (options) {
            this.doPickAndOpen(options, false /* pick folders */, true /* pick files */);
        };
        WindowsManager.prototype.doPickAndOpen = function (options, pickFolders, pickFiles) {
            var internalOptions = options;
            internalOptions.pickFolders = pickFolders;
            internalOptions.pickFiles = pickFiles;
            if (!internalOptions.dialogOptions) {
                internalOptions.dialogOptions = Object.create(null);
            }
            if (!internalOptions.dialogOptions.title) {
                if (pickFolders && pickFiles) {
                    internalOptions.dialogOptions.title = nls_1.localize(14, null);
                }
                else if (pickFolders) {
                    internalOptions.dialogOptions.title = nls_1.localize(15, null);
                }
                else {
                    internalOptions.dialogOptions.title = nls_1.localize(16, null);
                }
            }
            if (!internalOptions.telemetryEventName) {
                if (pickFolders && pickFiles) {
                    // __GDPR__TODO__ classify event
                    internalOptions.telemetryEventName = 'openFileFolder';
                }
                else if (pickFolders) {
                    internalOptions.telemetryEventName = 'openFolder';
                }
                else {
                    internalOptions.telemetryEventName = 'openFile';
                }
            }
            this.dialogs.pickAndOpen(internalOptions);
        };
        WindowsManager.prototype.showMessageBox = function (options, win) {
            return this.dialogs.showMessageBox(options, win);
        };
        WindowsManager.prototype.showSaveDialog = function (options, win) {
            return this.dialogs.showSaveDialog(options, win);
        };
        WindowsManager.prototype.showOpenDialog = function (options, win) {
            return this.dialogs.showOpenDialog(options, win);
        };
        WindowsManager.prototype.quit = function () {
            var _this = this;
            // If the user selected to exit from an extension development host window, do not quit, but just
            // close the window unless this is the last window that is opened.
            var window = this.getFocusedWindow();
            if (window && window.isExtensionDevelopmentHost && this.getWindowCount() > 1) {
                window.win.close();
            }
            // Otherwise: normal quit
            else {
                setTimeout(function () {
                    _this.lifecycleService.quit();
                }, 10 /* delay to unwind callback stack (IPC) */);
            }
        };
        WindowsManager.windowsStateStorageKey = 'windowsState';
        WindowsManager.WINDOWS = [];
        WindowsManager = __decorate([
            __param(1, log_1.ILogService),
            __param(2, state_1.IStateService),
            __param(3, environment_1.IEnvironmentService),
            __param(4, lifecycleMain_1.ILifecycleService),
            __param(5, backup_1.IBackupMainService),
            __param(6, telemetry_1.ITelemetryService),
            __param(7, configuration_1.IConfigurationService),
            __param(8, history_1.IHistoryMainService),
            __param(9, workspaces_1.IWorkspacesMainService),
            __param(10, instantiation_1.IInstantiationService)
        ], WindowsManager);
        return WindowsManager;
    }());
    exports.WindowsManager = WindowsManager;
    var Dialogs = /** @class */ (function () {
        function Dialogs(environmentService, telemetryService, stateService, windowsMainService) {
            this.environmentService = environmentService;
            this.telemetryService = telemetryService;
            this.stateService = stateService;
            this.windowsMainService = windowsMainService;
            this.mapWindowToDialogQueue = new Map();
            this.noWindowDialogQueue = new async_1.Queue();
        }
        Dialogs.prototype.pickAndOpen = function (options) {
            var _this = this;
            this.getFileOrFolderUris(options).then(function (paths) {
                var numberOfPaths = paths ? paths.length : 0;
                // Telemetry
                if (options.telemetryEventName) {
                    // __GDPR__TODO__ Dynamic event names and dynamic properties. Can not be registered statically.
                    _this.telemetryService.publicLog(options.telemetryEventName, __assign({}, options.telemetryExtraData, { outcome: numberOfPaths ? 'success' : 'canceled', numberOfPaths: numberOfPaths }));
                }
                // Open
                if (numberOfPaths) {
                    _this.windowsMainService.open({
                        context: 3 /* DIALOG */,
                        cli: _this.environmentService.args,
                        urisToOpen: paths,
                        forceNewWindow: options.forceNewWindow,
                        forceOpenWorkspaceAsFile: options.dialogOptions && !objects_1.equals(options.dialogOptions.filters, workspaces_1.WORKSPACE_FILTER)
                    });
                }
            });
        };
        Dialogs.prototype.getFileOrFolderUris = function (options) {
            var _this = this;
            // Ensure dialog options
            if (!options.dialogOptions) {
                options.dialogOptions = Object.create(null);
            }
            // Ensure defaultPath
            if (!options.dialogOptions.defaultPath) {
                options.dialogOptions.defaultPath = this.stateService.getItem(Dialogs.workingDirPickerStorageKey);
            }
            // Ensure properties
            if (typeof options.pickFiles === 'boolean' || typeof options.pickFolders === 'boolean') {
                options.dialogOptions.properties = void 0; // let it override based on the booleans
                if (options.pickFiles && options.pickFolders) {
                    options.dialogOptions.properties = ['multiSelections', 'openDirectory', 'openFile', 'createDirectory'];
                }
            }
            if (!options.dialogOptions.properties) {
                options.dialogOptions.properties = ['multiSelections', options.pickFolders ? 'openDirectory' : 'openFile', 'createDirectory'];
            }
            if (platform_1.isMacintosh) {
                options.dialogOptions.properties.push('treatPackageAsDirectory'); // always drill into .app files
            }
            // Show Dialog
            var focusedWindow = this.windowsMainService.getWindowById(options.windowId) || this.windowsMainService.getFocusedWindow();
            return this.showOpenDialog(options.dialogOptions, focusedWindow).then(function (paths) {
                if (paths && paths.length > 0) {
                    // Remember path in storage for next time
                    _this.stateService.setItem(Dialogs.workingDirPickerStorageKey, path_1.dirname(paths[0]));
                    return paths.map(function (path) { return uri_1.URI.file(path); });
                }
                return void 0;
            });
        };
        Dialogs.prototype.getDialogQueue = function (window) {
            if (!window) {
                return this.noWindowDialogQueue;
            }
            var windowDialogQueue = this.mapWindowToDialogQueue.get(window.id);
            if (!windowDialogQueue) {
                windowDialogQueue = new async_1.Queue();
                this.mapWindowToDialogQueue.set(window.id, windowDialogQueue);
            }
            return windowDialogQueue;
        };
        Dialogs.prototype.showMessageBox = function (options, window) {
            return this.getDialogQueue(window).queue(function () {
                return new winjs_base_1.TPromise(function (c, e) {
                    electron_1.dialog.showMessageBox(window ? window.win : void 0, options, function (response, checkboxChecked) {
                        c({ button: response, checkboxChecked: checkboxChecked });
                    });
                });
            });
        };
        Dialogs.prototype.showSaveDialog = function (options, window) {
            function normalizePath(path) {
                if (path && platform_1.isMacintosh) {
                    path = normalization_1.normalizeNFC(path); // normalize paths returned from the OS
                }
                return path;
            }
            return this.getDialogQueue(window).queue(function () {
                return new winjs_base_1.TPromise(function (c, e) {
                    electron_1.dialog.showSaveDialog(window ? window.win : void 0, options, function (path) {
                        c(normalizePath(path));
                    });
                });
            });
        };
        Dialogs.prototype.showOpenDialog = function (options, window) {
            function normalizePaths(paths) {
                if (paths && paths.length > 0 && platform_1.isMacintosh) {
                    paths = paths.map(function (path) { return normalization_1.normalizeNFC(path); }); // normalize paths returned from the OS
                }
                return paths;
            }
            return this.getDialogQueue(window).queue(function () {
                return new winjs_base_1.TPromise(function (c, e) {
                    // Ensure the path exists (if provided)
                    var validatePathPromise = winjs_base_1.TPromise.as(void 0);
                    if (options.defaultPath) {
                        validatePathPromise = pfs_1.exists(options.defaultPath).then(function (exists) {
                            if (!exists) {
                                options.defaultPath = void 0;
                            }
                        });
                    }
                    // Show dialog and wrap as promise
                    validatePathPromise.then(function () {
                        electron_1.dialog.showOpenDialog(window ? window.win : void 0, options, function (paths) {
                            c(normalizePaths(paths));
                        });
                    });
                });
            });
        };
        Dialogs.workingDirPickerStorageKey = 'pickerWorkingDir';
        return Dialogs;
    }());
    var WorkspacesManager = /** @class */ (function () {
        function WorkspacesManager(workspacesMainService, backupMainService, environmentService, windowsMainService) {
            this.workspacesMainService = workspacesMainService;
            this.backupMainService = backupMainService;
            this.environmentService = environmentService;
            this.windowsMainService = windowsMainService;
        }
        WorkspacesManager.prototype.saveAndEnterWorkspace = function (window, path) {
            if (!window || !window.win || window.readyState !== 3 /* READY */ || !window.openedWorkspace || !path || !this.isValidTargetWorkspacePath(window, path)) {
                return winjs_base_1.TPromise.as(null); // return early if the window is not ready or disposed or does not have a workspace
            }
            return this.doSaveAndOpenWorkspace(window, window.openedWorkspace, path);
        };
        WorkspacesManager.prototype.enterWorkspace = function (window, path) {
            var _this = this;
            if (!window || !window.win || window.readyState !== 3 /* READY */) {
                return winjs_base_1.TPromise.as(null); // return early if the window is not ready or disposed
            }
            return this.isValidTargetWorkspacePath(window, path).then(function (isValid) {
                if (!isValid) {
                    return winjs_base_1.TPromise.as(null); // return early if the workspace is not valid
                }
                return _this.workspacesMainService.resolveWorkspace(path).then(function (workspace) {
                    return _this.doOpenWorkspace(window, workspace);
                });
            });
        };
        WorkspacesManager.prototype.createAndEnterWorkspace = function (window, folders, path) {
            var _this = this;
            if (!window || !window.win || window.readyState !== 3 /* READY */) {
                return winjs_base_1.TPromise.as(null); // return early if the window is not ready or disposed
            }
            return this.isValidTargetWorkspacePath(window, path).then(function (isValid) {
                if (!isValid) {
                    return winjs_base_1.TPromise.as(null); // return early if the workspace is not valid
                }
                return _this.workspacesMainService.createWorkspace(folders).then(function (workspace) {
                    return _this.doSaveAndOpenWorkspace(window, workspace, path);
                });
            });
        };
        WorkspacesManager.prototype.isValidTargetWorkspacePath = function (window, path) {
            if (!path) {
                return winjs_base_1.TPromise.wrap(true);
            }
            if (window.openedWorkspace && window.openedWorkspace.configPath === path) {
                return winjs_base_1.TPromise.wrap(false); // window is already opened on a workspace with that path
            }
            // Prevent overwriting a workspace that is currently opened in another window
            if (windowsFinder_1.findWindowOnWorkspace(this.windowsMainService.getWindows(), { id: this.workspacesMainService.getWorkspaceId(path), configPath: path })) {
                var options = {
                    title: product_1.default.nameLong,
                    type: 'info',
                    buttons: [nls_1.localize(17, null)],
                    message: nls_1.localize(18, null, path_1.basename(path)),
                    detail: nls_1.localize(19, null),
                    noLink: true
                };
                return this.windowsMainService.showMessageBox(options, this.windowsMainService.getFocusedWindow()).then(function () { return false; });
            }
            return winjs_base_1.TPromise.wrap(true); // OK
        };
        WorkspacesManager.prototype.doSaveAndOpenWorkspace = function (window, workspace, path) {
            var _this = this;
            var savePromise;
            if (path) {
                savePromise = this.workspacesMainService.saveWorkspace(workspace, path);
            }
            else {
                savePromise = winjs_base_1.TPromise.as(workspace);
            }
            return savePromise.then(function (workspace) { return _this.doOpenWorkspace(window, workspace); });
        };
        WorkspacesManager.prototype.doOpenWorkspace = function (window, workspace) {
            window.focus();
            // Register window for backups and migrate current backups over
            var backupPath;
            if (!window.config.extensionDevelopmentPath) {
                backupPath = this.backupMainService.registerWorkspaceBackupSync(workspace, window.config.backupPath);
            }
            // Update window configuration properly based on transition to workspace
            window.config.folderUri = void 0;
            window.config.workspace = workspace;
            window.config.backupPath = backupPath;
            return { workspace: workspace, backupPath: backupPath };
        };
        WorkspacesManager.prototype.pickWorkspaceAndOpen = function (options) {
            var window = this.windowsMainService.getWindowById(options.windowId) || this.windowsMainService.getFocusedWindow() || this.windowsMainService.getLastActiveWindow();
            this.windowsMainService.pickFileAndOpen({
                windowId: window ? window.id : void 0,
                dialogOptions: {
                    buttonLabel: labels_1.mnemonicButtonLabel(nls_1.localize(20, null)),
                    title: nls_1.localize(21, null),
                    filters: workspaces_1.WORKSPACE_FILTER,
                    properties: ['openFile'],
                    defaultPath: options.dialogOptions && options.dialogOptions.defaultPath
                },
                forceNewWindow: options.forceNewWindow,
                telemetryEventName: options.telemetryEventName,
                telemetryExtraData: options.telemetryExtraData
            });
        };
        WorkspacesManager.prototype.promptToSaveUntitledWorkspace = function (window, workspace) {
            var _this = this;
            var ConfirmResult;
            (function (ConfirmResult) {
                ConfirmResult[ConfirmResult["SAVE"] = 0] = "SAVE";
                ConfirmResult[ConfirmResult["DONT_SAVE"] = 1] = "DONT_SAVE";
                ConfirmResult[ConfirmResult["CANCEL"] = 2] = "CANCEL";
            })(ConfirmResult || (ConfirmResult = {}));
            var save = { label: labels_1.mnemonicButtonLabel(nls_1.localize(22, null)), result: ConfirmResult.SAVE };
            var dontSave = { label: labels_1.mnemonicButtonLabel(nls_1.localize(23, null)), result: ConfirmResult.DONT_SAVE };
            var cancel = { label: nls_1.localize(24, null), result: ConfirmResult.CANCEL };
            var buttons = [];
            if (platform_1.isWindows) {
                buttons.push(save, dontSave, cancel);
            }
            else if (platform_1.isLinux) {
                buttons.push(dontSave, cancel, save);
            }
            else {
                buttons.push(save, cancel, dontSave);
            }
            var options = {
                title: this.environmentService.appNameLong,
                message: nls_1.localize(25, null),
                detail: nls_1.localize(26, null),
                noLink: true,
                type: 'warning',
                buttons: buttons.map(function (button) { return button.label; }),
                cancelId: buttons.indexOf(cancel)
            };
            if (platform_1.isLinux) {
                options.defaultId = 2;
            }
            return this.windowsMainService.showMessageBox(options, window).then(function (res) {
                switch (buttons[res.button].result) {
                    // Cancel: veto unload
                    case ConfirmResult.CANCEL:
                        return true;
                    // Don't Save: delete workspace
                    case ConfirmResult.DONT_SAVE:
                        _this.workspacesMainService.deleteUntitledWorkspaceSync(workspace);
                        return false;
                    // Save: save workspace, but do not veto unload
                    case ConfirmResult.SAVE: {
                        return _this.windowsMainService.showSaveDialog({
                            buttonLabel: labels_1.mnemonicButtonLabel(nls_1.localize(27, null)),
                            title: nls_1.localize(28, null),
                            filters: workspaces_1.WORKSPACE_FILTER,
                            defaultPath: _this.getUntitledWorkspaceSaveDialogDefaultPath(workspace)
                        }, window).then(function (target) {
                            if (target) {
                                return _this.workspacesMainService.saveWorkspace(workspace, target).then(function () { return false; }, function () { return false; });
                            }
                            return true; // keep veto if no target was provided
                        });
                    }
                }
            });
        };
        WorkspacesManager.prototype.getUntitledWorkspaceSaveDialogDefaultPath = function (workspace) {
            if (workspace) {
                if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {
                    return workspace.scheme === network_1.Schemas.file ? path_1.dirname(workspace.fsPath) : void 0;
                }
                var resolvedWorkspace = this.workspacesMainService.resolveWorkspaceSync(workspace.configPath);
                if (resolvedWorkspace && resolvedWorkspace.folders.length > 0) {
                    for (var _i = 0, _a = resolvedWorkspace.folders; _i < _a.length; _i++) {
                        var folder = _a[_i];
                        if (folder.uri.scheme === network_1.Schemas.file) {
                            return path_1.dirname(folder.uri.fsPath);
                        }
                    }
                }
            }
            return void 0;
        };
        return WorkspacesManager;
    }());
});










define(__m[123/*vs/platform/request/node/requestService*/], __M([1/*require*/,0/*exports*/,2/*vs/base/common/winjs.base*/,17/*vs/base/common/objects*/,47/*vs/base/node/request*/,97/*vs/base/node/proxy*/,14/*vs/platform/configuration/common/configuration*/,7/*vs/platform/log/common/log*/]), function (require, exports, winjs_base_1, objects_1, request_1, proxy_1, configuration_1, log_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * This service exposes the `request` API, while using the global
     * or configured proxy settings.
     */
    var RequestService = /** @class */ (function () {
        function RequestService(configurationService, logService) {
            var _this = this;
            this.logService = logService;
            this.disposables = [];
            this.configure(configurationService.getValue());
            configurationService.onDidChangeConfiguration(function () { return _this.configure(configurationService.getValue()); }, this, this.disposables);
        }
        RequestService.prototype.configure = function (config) {
            this.proxyUrl = config.http && config.http.proxy;
            this.strictSSL = config.http && config.http.proxyStrictSSL;
            this.authorization = config.http && config.http.proxyAuthorization;
        };
        RequestService.prototype.request = function (options, token, requestFn) {
            var _this = this;
            if (requestFn === void 0) { requestFn = request_1.request; }
            this.logService.trace('RequestService#request', options.url);
            var _a = this, proxyUrl = _a.proxyUrl, strictSSL = _a.strictSSL;
            var agentPromise = options.agent ? winjs_base_1.TPromise.wrap(options.agent) : winjs_base_1.TPromise.wrap(proxy_1.getProxyAgent(options.url, { proxyUrl: proxyUrl, strictSSL: strictSSL }));
            return agentPromise.then(function (agent) {
                options.agent = agent;
                options.strictSSL = strictSSL;
                if (_this.authorization) {
                    options.headers = objects_1.assign(options.headers || {}, { 'Proxy-Authorization': _this.authorization });
                }
                return requestFn(options, token);
            });
        };
        RequestService = __decorate([
            __param(0, configuration_1.IConfigurationService),
            __param(1, log_1.ILogService)
        ], RequestService);
        return RequestService;
    }());
    exports.RequestService = RequestService;
});














define(__m[95/*vs/platform/request/electron-main/requestService*/], __M([1/*require*/,0/*exports*/,47/*vs/base/node/request*/,123/*vs/platform/request/node/requestService*/,17/*vs/base/common/objects*/,8/*electron*/]), function (require, exports, request_1, requestService_1, objects_1, electron_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function getRawRequest(options) {
        return electron_1.net.request;
    }
    var RequestService = /** @class */ (function (_super) {
        __extends(RequestService, _super);
        function RequestService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RequestService.prototype.request = function (options, token) {
            return _super.prototype.request.call(this, options, token, function (options) { return request_1.request(objects_1.assign({}, options || {}, { getRawRequest: getRawRequest }), token); });
        };
        return RequestService;
    }(requestService_1.RequestService));
    exports.RequestService = RequestService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[137/*vs/platform/update/electron-main/updateService.linux*/], __M([1/*require*/,0/*exports*/,16/*vs/platform/node/product*/,14/*vs/platform/configuration/common/configuration*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,42/*vs/platform/request/node/request*/,33/*vs/platform/update/common/update*/,29/*vs/platform/telemetry/common/telemetry*/,9/*vs/platform/environment/common/environment*/,7/*vs/platform/log/common/log*/,60/*vs/platform/update/electron-main/abstractUpdateService*/,47/*vs/base/node/request*/,2/*vs/base/common/winjs.base*/,8/*electron*/,35/*vs/base/common/cancellation*/]), function (require, exports, product_1, configuration_1, lifecycleMain_1, request_1, update_1, telemetry_1, environment_1, log_1, abstractUpdateService_1, request_2, winjs_base_1, electron_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var LinuxUpdateService = /** @class */ (function (_super) {
        __extends(LinuxUpdateService, _super);
        function LinuxUpdateService(lifecycleService, configurationService, telemetryService, environmentService, requestService, logService) {
            var _this = _super.call(this, lifecycleService, configurationService, environmentService, requestService, logService) || this;
            _this.telemetryService = telemetryService;
            return _this;
        }
        LinuxUpdateService.prototype.buildUpdateFeedUrl = function (quality) {
            return abstractUpdateService_1.createUpdateURL("linux-" + process.arch, quality);
        };
        LinuxUpdateService.prototype.doCheckForUpdates = function (context) {
            var _this = this;
            if (!this.url) {
                return;
            }
            this.setState(update_1.State.CheckingForUpdates(context));
            this.requestService.request({ url: this.url }, cancellation_1.CancellationToken.None)
                .then(request_2.asJson)
                .then(function (update) {
                if (!update || !update.url || !update.version || !update.productVersion) {
                    /* __GDPR__
                            "update:notAvailable" : {
                                "explicit" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                            }
                        */
                    _this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });
                    _this.setState(update_1.State.Idle(1 /* Archive */));
                }
                else {
                    _this.setState(update_1.State.AvailableForDownload(update));
                }
            })
                .then(null, function (err) {
                _this.logService.error(err);
                /* __GDPR__
                    "update:notAvailable" : {
                        "explicit" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                    }
                    */
                _this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });
                _this.setState(update_1.State.Idle(1 /* Archive */));
            });
        };
        LinuxUpdateService.prototype.doDownloadUpdate = function (state) {
            // Use the download URL if available as we don't currently detect the package type that was
            // installed and the website download page is more useful than the tarball generally.
            if (product_1.default.downloadUrl && product_1.default.downloadUrl.length > 0) {
                electron_1.shell.openExternal(product_1.default.downloadUrl);
            }
            else {
                electron_1.shell.openExternal(state.update.url);
            }
            this.setState(update_1.State.Idle(1 /* Archive */));
            return winjs_base_1.TPromise.as(null);
        };
        LinuxUpdateService = __decorate([
            __param(0, lifecycleMain_1.ILifecycleService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, telemetry_1.ITelemetryService),
            __param(3, environment_1.IEnvironmentService),
            __param(4, request_1.IRequestService),
            __param(5, log_1.ILogService)
        ], LinuxUpdateService);
        return LinuxUpdateService;
    }(abstractUpdateService_1.AbstractUpdateService));
    exports.LinuxUpdateService = LinuxUpdateService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






















define(__m[117/*vs/platform/update/electron-main/updateService.win32*/], __M([1/*require*/,0/*exports*/,21/*fs*/,11/*path*/,34/*vs/base/node/pfs*/,52/*vs/base/common/decorators*/,14/*vs/platform/configuration/common/configuration*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,42/*vs/platform/request/node/request*/,16/*vs/platform/node/product*/,2/*vs/base/common/winjs.base*/,33/*vs/platform/update/common/update*/,29/*vs/platform/telemetry/common/telemetry*/,9/*vs/platform/environment/common/environment*/,7/*vs/platform/log/common/log*/,60/*vs/platform/update/electron-main/abstractUpdateService*/,47/*vs/base/node/request*/,128/*vs/base/node/crypto*/,26/*os*/,53/*child_process*/,8/*electron*/,35/*vs/base/common/cancellation*/]), function (require, exports, fs, path, pfs, decorators_1, configuration_1, lifecycleMain_1, request_1, product_1, winjs_base_1, update_1, telemetry_1, environment_1, log_1, abstractUpdateService_1, request_2, crypto_1, os_1, child_process_1, electron_1, cancellation_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function pollUntil(fn, timeout) {
        if (timeout === void 0) { timeout = 1000; }
        return new winjs_base_1.TPromise(function (c) {
            var poll = function () {
                if (fn()) {
                    c(null);
                }
                else {
                    setTimeout(poll, timeout);
                }
            };
            poll();
        });
    }
    var _updateType = undefined;
    function getUpdateType() {
        if (typeof _updateType === 'undefined') {
            _updateType = fs.existsSync(path.join(path.dirname(process.execPath), 'unins000.exe'))
                ? 0 /* Setup */
                : 1 /* Archive */;
        }
        return _updateType;
    }
    var Win32UpdateService = /** @class */ (function (_super) {
        __extends(Win32UpdateService, _super);
        function Win32UpdateService(lifecycleService, configurationService, telemetryService, environmentService, requestService, logService) {
            var _this = _super.call(this, lifecycleService, configurationService, environmentService, requestService, logService) || this;
            _this.telemetryService = telemetryService;
            if (getUpdateType() === 0 /* Setup */) {
                /* __GDPR__
                    "update:win32SetupTarget" : {
                        "target" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                /* __GDPR__
                    "update:win<NUMBER>SetupTarget" : {
                        "target" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
                    }
                */
                telemetryService.publicLog('update:win32SetupTarget', { target: product_1.default.target });
            }
            return _this;
        }
        Object.defineProperty(Win32UpdateService.prototype, "cachePath", {
            get: function () {
                var result = path.join(os_1.tmpdir(), "vscode-update-" + product_1.default.target + "-" + process.arch);
                return pfs.mkdirp(result, null).then(function () { return result; });
            },
            enumerable: true,
            configurable: true
        });
        Win32UpdateService.prototype.buildUpdateFeedUrl = function (quality) {
            var platform = 'win32';
            if (process.arch === 'x64') {
                platform += '-x64';
            }
            if (getUpdateType() === 1 /* Archive */) {
                platform += '-archive';
            }
            else if (product_1.default.target === 'user') {
                platform += '-user';
            }
            return abstractUpdateService_1.createUpdateURL(platform, quality);
        };
        Win32UpdateService.prototype.doCheckForUpdates = function (context) {
            var _this = this;
            if (!this.url) {
                return;
            }
            this.setState(update_1.State.CheckingForUpdates(context));
            this.requestService.request({ url: this.url }, cancellation_1.CancellationToken.None)
                .then(request_2.asJson)
                .then(function (update) {
                var updateType = getUpdateType();
                if (!update || !update.url || !update.version || !update.productVersion) {
                    /* __GDPR__
                            "update:notAvailable" : {
                                "explicit" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                            }
                        */
                    _this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });
                    _this.setState(update_1.State.Idle(updateType));
                    return winjs_base_1.TPromise.as(null);
                }
                if (updateType === 1 /* Archive */) {
                    _this.setState(update_1.State.AvailableForDownload(update));
                    return winjs_base_1.TPromise.as(null);
                }
                _this.setState(update_1.State.Downloading(update));
                return _this.cleanup(update.version).then(function () {
                    return _this.getUpdatePackagePath(update.version).then(function (updatePackagePath) {
                        return pfs.exists(updatePackagePath).then(function (exists) {
                            if (exists) {
                                return winjs_base_1.TPromise.as(updatePackagePath);
                            }
                            var url = update.url;
                            var hash = update.hash;
                            var downloadPath = updatePackagePath + ".tmp";
                            return _this.requestService.request({ url: url }, cancellation_1.CancellationToken.None)
                                .then(function (context) { return request_2.download(downloadPath, context); })
                                .then(hash ? function () { return crypto_1.checksum(downloadPath, update.hash); } : function () { return null; })
                                .then(function () { return pfs.rename(downloadPath, updatePackagePath); })
                                .then(function () { return updatePackagePath; });
                        });
                    }).then(function (packagePath) {
                        var fastUpdatesEnabled = _this.configurationService.getValue('update.enableWindowsBackgroundUpdates');
                        _this.availableUpdate = { packagePath: packagePath };
                        if (fastUpdatesEnabled && update.supportsFastUpdate) {
                            if (product_1.default.target === 'user') {
                                _this.doApplyUpdate();
                            }
                            else {
                                _this.setState(update_1.State.Downloaded(update));
                            }
                        }
                        else {
                            _this.setState(update_1.State.Ready(update));
                        }
                    });
                });
            })
                .then(null, function (err) {
                _this.logService.error(err);
                /* __GDPR__
                    "update:notAvailable" : {
                        "explicit" : { "classification": "SystemMetaData", "purpose": "FeatureInsight", "isMeasurement": true }
                    }
                    */
                _this.telemetryService.publicLog('update:notAvailable', { explicit: !!context });
                _this.setState(update_1.State.Idle(getUpdateType()));
            });
        };
        Win32UpdateService.prototype.doDownloadUpdate = function (state) {
            electron_1.shell.openExternal(state.update.url);
            this.setState(update_1.State.Idle(getUpdateType()));
            return winjs_base_1.TPromise.as(null);
        };
        Win32UpdateService.prototype.getUpdatePackagePath = function (version) {
            return this.cachePath.then(function (cachePath) { return path.join(cachePath, "CodeSetup-" + product_1.default.quality + "-" + version + ".exe"); });
        };
        Win32UpdateService.prototype.cleanup = function (exceptVersion) {
            if (exceptVersion === void 0) { exceptVersion = null; }
            var filter = exceptVersion ? function (one) { return !(new RegExp(product_1.default.quality + "-" + exceptVersion + "\\.exe$").test(one)); } : function () { return true; };
            return this.cachePath
                .then(function (cachePath) { return pfs.readdir(cachePath)
                .then(function (all) { return winjs_base_1.Promise.join(all
                .filter(filter)
                .map(function (one) { return pfs.unlink(path.join(cachePath, one)).then(null, function () { return null; }); })); }); });
        };
        Win32UpdateService.prototype.doApplyUpdate = function () {
            var _this = this;
            if (this.state.type !== "downloaded" /* Downloaded */ && this.state.type !== "downloading" /* Downloading */) {
                return winjs_base_1.TPromise.as(null);
            }
            if (!this.availableUpdate) {
                return winjs_base_1.TPromise.as(null);
            }
            var update = this.state.update;
            this.setState(update_1.State.Updating(update));
            return this.cachePath.then(function (cachePath) {
                _this.availableUpdate.updateFilePath = path.join(cachePath, "CodeSetup-" + product_1.default.quality + "-" + update.version + ".flag");
                return pfs.writeFile(_this.availableUpdate.updateFilePath, 'flag').then(function () {
                    var child = child_process_1.spawn(_this.availableUpdate.packagePath, ['/verysilent', "/update=\"" + _this.availableUpdate.updateFilePath + "\"", '/nocloseapplications', '/mergetasks=runcode,!desktopicon,!quicklaunchicon'], {
                        detached: true,
                        stdio: ['ignore', 'ignore', 'ignore'],
                        windowsVerbatimArguments: true
                    });
                    child.once('exit', function () {
                        _this.availableUpdate = undefined;
                        _this.setState(update_1.State.Idle(getUpdateType()));
                    });
                    var readyMutexName = product_1.default.win32MutexName + "-ready";
                    var isActive = require.__$__nodeRequire('windows-mutex').isActive;
                    // poll for mutex-ready
                    pollUntil(function () { return isActive(readyMutexName); })
                        .then(function () { return _this.setState(update_1.State.Ready(update)); });
                });
            });
        };
        Win32UpdateService.prototype.doQuitAndInstall = function () {
            if (this.state.type !== "ready" /* Ready */) {
                return;
            }
            this.logService.trace('update#quitAndInstall(): running raw#quitAndInstall()');
            if (this.state.update.supportsFastUpdate && this.availableUpdate.updateFilePath) {
                fs.unlinkSync(this.availableUpdate.updateFilePath);
            }
            else {
                child_process_1.spawn(this.availableUpdate.packagePath, ['/silent', '/mergetasks=runcode,!desktopicon,!quicklaunchicon'], {
                    detached: true,
                    stdio: ['ignore', 'ignore', 'ignore']
                });
            }
        };
        Win32UpdateService.prototype.getUpdateType = function () {
            return getUpdateType();
        };
        __decorate([
            decorators_1.memoize
        ], Win32UpdateService.prototype, "cachePath", null);
        Win32UpdateService = __decorate([
            __param(0, lifecycleMain_1.ILifecycleService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, telemetry_1.ITelemetryService),
            __param(3, environment_1.IEnvironmentService),
            __param(4, request_1.IRequestService),
            __param(5, log_1.ILogService)
        ], Win32UpdateService);
        return Win32UpdateService;
    }(abstractUpdateService_1.AbstractUpdateService));
    exports.Win32UpdateService = Win32UpdateService;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




















define(__m[115/*vs/code/electron-main/app*/], __M([1/*require*/,0/*exports*/,8/*electron*/,3/*vs/base/common/platform*/,155/*vs/code/electron-main/windows*/,69/*vs/platform/windows/common/windows*/,164/*vs/platform/windows/node/windowsIpc*/,158/*vs/platform/windows/electron-main/windowsService*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,148/*vs/code/node/shellEnv*/,33/*vs/platform/update/common/update*/,147/*vs/platform/update/node/updateIpc*/,133/*vs/base/parts/ipc/electron-main/ipc.electron-main*/,51/*vs/base/parts/ipc/node/ipc.net*/,135/*vs/code/electron-main/sharedProcess*/,63/*vs/platform/launch/electron-main/launchService*/,4/*vs/platform/instantiation/common/instantiation*/,61/*vs/platform/instantiation/common/serviceCollection*/,55/*vs/platform/instantiation/common/descriptors*/,7/*vs/platform/log/common/log*/,28/*vs/platform/state/common/state*/,9/*vs/platform/environment/common/environment*/,14/*vs/platform/configuration/common/configuration*/,49/*vs/platform/url/common/url*/,150/*vs/platform/url/node/urlIpc*/,29/*vs/platform/telemetry/common/telemetry*/,139/*vs/platform/telemetry/common/telemetryUtils*/,141/*vs/platform/telemetry/node/telemetryIpc*/,138/*vs/platform/telemetry/common/telemetryService*/,140/*vs/platform/telemetry/node/commonProperties*/,54/*vs/base/parts/ipc/node/ipc*/,16/*vs/platform/node/product*/,50/*vs/platform/node/package*/,153/*vs/code/electron-main/auth*/,13/*vs/base/common/lifecycle*/,2/*vs/base/common/winjs.base*/,25/*vs/platform/windows/electron-main/windows*/,44/*vs/platform/history/common/history*/,22/*vs/base/common/types*/,71/*vs/code/electron-main/keyboard*/,6/*vs/base/common/uri*/,173/*vs/platform/workspaces/node/workspacesIpc*/,19/*vs/platform/workspaces/common/workspaces*/,64/*vs/base/node/id*/,117/*vs/platform/update/electron-main/updateService.win32*/,137/*vs/platform/update/electron-main/updateService.linux*/,144/*vs/platform/update/electron-main/updateService.darwin*/,107/*vs/platform/issue/common/issue*/,108/*vs/platform/issue/node/issueIpc*/,163/*vs/platform/issue/electron-main/issueService*/,113/*vs/platform/log/node/logIpc*/,23/*vs/base/common/errors*/,157/*vs/platform/url/electron-main/electronUrlListener*/,156/*vs/platform/driver/electron-main/driver*/,66/*vs/platform/menubar/common/menubar*/,170/*vs/platform/menubar/electron-main/menubarService*/,116/*vs/platform/menubar/node/menubarIpc*/,48/*vs/platform/label/common/label*/,167/*vs/code/electron-main/menus*/,41/*vs/platform/environment/node/argv*/,20/*vs/base/common/async*/,127/*vs/base/parts/contextmenu/electron-main/contextmenu*/,59/*vs/code/electron-main/theme*/,15/*vs/base/common/paths*/]), function (require, exports, electron_1, platform, windows_1, windows_2, windowsIpc_1, windowsService_1, lifecycleMain_1, shellEnv_1, update_1, updateIpc_1, ipc_electron_main_1, ipc_net_1, sharedProcess_1, launchService_1, instantiation_1, serviceCollection_1, descriptors_1, log_1, state_1, environment_1, configuration_1, url_1, urlIpc_1, telemetry_1, telemetryUtils_1, telemetryIpc_1, telemetryService_1, commonProperties_1, ipc_1, product_1, package_1, auth_1, lifecycle_1, winjs_base_1, windows_3, history_1, types_1, keyboard_1, uri_1, workspacesIpc_1, workspaces_1, id_1, updateService_win32_1, updateService_linux_1, updateService_darwin_1, issue_1, issueIpc_1, issueService_1, logIpc_1, errors, electronUrlListener_1, driver_1, menubar_1, menubarService_1, menubarIpc_1, label_1, menus_1, argv_1, async_1, contextmenu_1, theme_1, paths_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeApplication = /** @class */ (function () {
        function CodeApplication(mainIpcServer, userEnv, instantiationService, logService, environmentService, lifecycleService, configurationService, stateService, historyMainService, labelService) {
            this.mainIpcServer = mainIpcServer;
            this.userEnv = userEnv;
            this.instantiationService = instantiationService;
            this.logService = logService;
            this.environmentService = environmentService;
            this.lifecycleService = lifecycleService;
            this.configurationService = configurationService;
            this.stateService = stateService;
            this.historyMainService = historyMainService;
            this.labelService = labelService;
            this.toDispose = [mainIpcServer, configurationService];
            this.registerListeners();
        }
        CodeApplication.prototype.registerListeners = function () {
            var _this = this;
            // We handle uncaught exceptions here to prevent electron from opening a dialog to the user
            errors.setUnexpectedErrorHandler(function (err) { return _this.onUnexpectedError(err); });
            process.on('uncaughtException', function (err) { return _this.onUnexpectedError(err); });
            process.on('unhandledRejection', function (reason, promise) { return errors.onUnexpectedError(reason); });
            // Contextmenu via IPC support
            contextmenu_1.registerContextMenuListener();
            electron_1.app.on('will-quit', function () {
                _this.logService.trace('App#will-quit: disposing resources');
                _this.dispose();
            });
            electron_1.app.on('accessibility-support-changed', function (event, accessibilitySupportEnabled) {
                if (_this.windowsMainService) {
                    _this.windowsMainService.sendToAll('vscode:accessibilitySupportChanged', accessibilitySupportEnabled);
                }
            });
            electron_1.app.on('activate', function (event, hasVisibleWindows) {
                _this.logService.trace('App#activate');
                // Mac only event: open new window when we get activated
                if (!hasVisibleWindows && _this.windowsMainService) {
                    _this.windowsMainService.openNewWindow(1 /* DOCK */);
                }
            });
            // Security related measures (https://electronjs.org/docs/tutorial/security)
            // DO NOT CHANGE without consulting the documentation
            electron_1.app.on('web-contents-created', function (event, contents) {
                contents.on('will-attach-webview', function (event, webPreferences, params) {
                    // Ensure defaults
                    delete webPreferences.preload;
                    webPreferences.nodeIntegration = false;
                    // Verify URLs being loaded
                    if (_this.isValidWebviewSource(params.src) && _this.isValidWebviewSource(webPreferences.preloadURL)) {
                        return;
                    }
                    delete webPreferences.preloadUrl;
                    // Otherwise prevent loading
                    _this.logService.error('webContents#web-contents-created: Prevented webview attach');
                    event.preventDefault();
                });
                contents.on('will-navigate', function (event) {
                    _this.logService.error('webContents#will-navigate: Prevented webcontent navigation');
                    event.preventDefault();
                });
                contents.on('new-window', function (event, url) {
                    event.preventDefault(); // prevent code that wants to open links
                    electron_1.shell.openExternal(url);
                });
            });
            var macOpenFileURIs = [];
            var runningTimeout = null;
            electron_1.app.on('open-file', function (event, path) {
                _this.logService.trace('App#open-file: ', path);
                event.preventDefault();
                // Keep in array because more might come!
                macOpenFileURIs.push(uri_1.URI.file(path));
                // Clear previous handler if any
                if (runningTimeout !== null) {
                    clearTimeout(runningTimeout);
                    runningTimeout = null;
                }
                // Handle paths delayed in case more are coming!
                runningTimeout = setTimeout(function () {
                    if (_this.windowsMainService) {
                        _this.windowsMainService.open({
                            context: 1 /* DOCK */ /* can also be opening from finder while app is running */,
                            cli: _this.environmentService.args,
                            urisToOpen: macOpenFileURIs,
                            preferNewWindow: true /* dropping on the dock or opening from finder prefers to open in a new window */
                        });
                        macOpenFileURIs = [];
                        runningTimeout = null;
                    }
                }, 100);
            });
            electron_1.app.on('new-window-for-tab', function () {
                _this.windowsMainService.openNewWindow(4 /* DESKTOP */); //macOS native tab "+" button
            });
            electron_1.ipcMain.on('vscode:exit', function (event, code) {
                _this.logService.trace('IPC#vscode:exit', code);
                _this.dispose();
                _this.lifecycleService.kill(code);
            });
            electron_1.ipcMain.on('vscode:fetchShellEnv', function (event) {
                var webContents = event.sender;
                shellEnv_1.getShellEnvironment().then(function (shellEnv) {
                    if (!webContents.isDestroyed()) {
                        webContents.send('vscode:acceptShellEnv', shellEnv);
                    }
                }, function (err) {
                    if (!webContents.isDestroyed()) {
                        webContents.send('vscode:acceptShellEnv', {});
                    }
                    _this.logService.error('Error fetching shell env', err);
                });
            });
            electron_1.ipcMain.on('vscode:broadcast', function (event, windowId, broadcast) {
                if (_this.windowsMainService && broadcast.channel && !types_1.isUndefinedOrNull(broadcast.payload)) {
                    _this.logService.trace('IPC#vscode:broadcast', broadcast.channel, broadcast.payload);
                    // Handle specific events on main side
                    _this.onBroadcast(broadcast.channel, broadcast.payload);
                    // Send to all windows (except sender window)
                    _this.windowsMainService.sendToAll('vscode:broadcast', broadcast, [windowId]);
                }
            });
            electron_1.ipcMain.on('vscode:labelRegisterFormatter', function (event, data) {
                _this.labelService.registerFormatter(data.scheme, data.formatter);
            });
            electron_1.ipcMain.on('vscode:toggleDevTools', function (event) {
                event.sender.toggleDevTools();
            });
            electron_1.ipcMain.on('vscode:openDevTools', function (event) {
                event.sender.openDevTools();
            });
            electron_1.ipcMain.on('vscode:reloadWindow', function (event) {
                event.sender.reload();
            });
            // Keyboard layout changes
            keyboard_1.KeyboardLayoutMonitor.INSTANCE.onDidChangeKeyboardLayout(function () {
                if (_this.windowsMainService) {
                    _this.windowsMainService.sendToAll('vscode:keyboardLayoutChanged', false);
                }
            });
        };
        CodeApplication.prototype.isValidWebviewSource = function (source) {
            if (!source) {
                return false;
            }
            if (source === 'data:text/html;charset=utf-8,%3C%21DOCTYPE%20html%3E%0D%0A%3Chtml%20lang%3D%22en%22%20style%3D%22width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3Chead%3E%0D%0A%09%3Ctitle%3EVirtual%20Document%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%20style%3D%22margin%3A%200%3B%20overflow%3A%20hidden%3B%20width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E') {
                return true;
            }
            var srcUri = uri_1.URI.parse(source).fsPath.toLowerCase();
            var rootUri = uri_1.URI.file(this.environmentService.appRoot).fsPath.toLowerCase();
            return srcUri.startsWith(rootUri + paths_1.nativeSep);
        };
        CodeApplication.prototype.onUnexpectedError = function (err) {
            if (err) {
                // take only the message and stack property
                var friendlyError = {
                    message: err.message,
                    stack: err.stack
                };
                // handle on client side
                if (this.windowsMainService) {
                    this.windowsMainService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));
                }
            }
            this.logService.error("[uncaught exception in main]: " + err);
            if (err.stack) {
                this.logService.error(err.stack);
            }
        };
        CodeApplication.prototype.onBroadcast = function (event, payload) {
            // Theme changes
            if (event === 'vscode:changeColorTheme' && typeof payload === 'string') {
                var data = JSON.parse(payload);
                this.stateService.setItem(theme_1.THEME_STORAGE_KEY, data.baseTheme);
                this.stateService.setItem(theme_1.THEME_BG_STORAGE_KEY, data.background);
            }
        };
        CodeApplication.prototype.startup = function () {
            var _this = this;
            this.logService.debug('Starting VS Code');
            this.logService.debug("from: " + this.environmentService.appRoot);
            this.logService.debug('args:', this.environmentService.args);
            // Make sure we associate the program with the app user model id
            // This will help Windows to associate the running program with
            // any shortcut that is pinned to the taskbar and prevent showing
            // two icons in the taskbar for the same app.
            if (platform.isWindows && product_1.default.win32AppUserModelId) {
                electron_1.app.setAppUserModelId(product_1.default.win32AppUserModelId);
            }
            // Fix native tabs on macOS 10.13
            // macOS enables a compatibility patch for any bundle ID beginning with
            // "com.microsoft.", which breaks native tabs for VS Code when using this
            // identifier (from the official build).
            // Explicitly opt out of the patch here before creating any windows.
            // See: https://github.com/Microsoft/vscode/issues/35361#issuecomment-399794085
            try {
                if (platform.isMacintosh && this.configurationService.getValue('window.nativeTabs') === true && !electron_1.systemPreferences.getUserDefault('NSUseImprovedLayoutPass', 'boolean')) {
                    electron_1.systemPreferences.setUserDefault('NSUseImprovedLayoutPass', 'boolean', true);
                }
            }
            catch (error) {
                this.logService.error(error);
            }
            // Create Electron IPC Server
            this.electronIpcServer = new ipc_electron_main_1.Server();
            // Resolve unique machine ID
            this.logService.trace('Resolving machine identifier...');
            return this.resolveMachineId().then(function (machineId) {
                _this.logService.trace("Resolved machine identifier: " + machineId);
                // Spawn shared process
                _this.sharedProcess = _this.instantiationService.createInstance(sharedProcess_1.SharedProcess, machineId, _this.userEnv);
                _this.sharedProcessClient = _this.sharedProcess.whenReady().then(function () { return ipc_net_1.connect(_this.environmentService.sharedIPCHandle, 'main'); });
                // Services
                var appInstantiationService = _this.initServices(machineId);
                var promise = winjs_base_1.TPromise.as(null);
                // Create driver
                if (_this.environmentService.driverHandle) {
                    driver_1.serve(_this.electronIpcServer, _this.environmentService.driverHandle, _this.environmentService, appInstantiationService).then(function (server) {
                        _this.logService.info('Driver started at:', _this.environmentService.driverHandle);
                        _this.toDispose.push(server);
                    });
                }
                return promise.then(function () {
                    // Setup Auth Handler
                    var authHandler = appInstantiationService.createInstance(auth_1.ProxyAuthHandler);
                    _this.toDispose.push(authHandler);
                    // Open Windows
                    appInstantiationService.invokeFunction(function (accessor) { return _this.openFirstWindow(accessor); });
                    // Post Open Windows Tasks
                    appInstantiationService.invokeFunction(function (accessor) { return _this.afterWindowOpen(accessor); });
                });
            });
        };
        CodeApplication.prototype.resolveMachineId = function () {
            var _this = this;
            var machineId = this.stateService.getItem(CodeApplication.MACHINE_ID_KEY);
            if (machineId) {
                return winjs_base_1.TPromise.wrap(machineId);
            }
            return id_1.getMachineId().then(function (machineId) {
                // Remember in global storage
                _this.stateService.setItem(CodeApplication.MACHINE_ID_KEY, machineId);
                return machineId;
            });
        };
        CodeApplication.prototype.initServices = function (machineId) {
            var services = new serviceCollection_1.ServiceCollection();
            if (process.platform === 'win32') {
                services.set(update_1.IUpdateService, new descriptors_1.SyncDescriptor(updateService_win32_1.Win32UpdateService));
            }
            else if (process.platform === 'linux') {
                services.set(update_1.IUpdateService, new descriptors_1.SyncDescriptor(updateService_linux_1.LinuxUpdateService));
            }
            else if (process.platform === 'darwin') {
                services.set(update_1.IUpdateService, new descriptors_1.SyncDescriptor(updateService_darwin_1.DarwinUpdateService));
            }
            services.set(windows_3.IWindowsMainService, new descriptors_1.SyncDescriptor(windows_1.WindowsManager, machineId));
            services.set(windows_2.IWindowsService, new descriptors_1.SyncDescriptor(windowsService_1.WindowsService, this.sharedProcess));
            services.set(launchService_1.ILaunchService, new descriptors_1.SyncDescriptor(launchService_1.LaunchService));
            services.set(issue_1.IIssueService, new descriptors_1.SyncDescriptor(issueService_1.IssueService, machineId, this.userEnv));
            services.set(menubar_1.IMenubarService, new descriptors_1.SyncDescriptor(menubarService_1.MenubarService));
            // Telemtry
            if (!this.environmentService.isExtensionDevelopment && !this.environmentService.args['disable-telemetry'] && !!product_1.default.enableTelemetry) {
                var channel = ipc_1.getDelayedChannel(this.sharedProcessClient.then(function (c) { return c.getChannel('telemetryAppender'); }));
                var appender = telemetryUtils_1.combinedAppender(new telemetryIpc_1.TelemetryAppenderClient(channel), new telemetryUtils_1.LogAppender(this.logService));
                var commonProperties = commonProperties_1.resolveCommonProperties(product_1.default.commit, package_1.default.version, machineId, this.environmentService.installSourcePath);
                var piiPaths = [this.environmentService.appRoot, this.environmentService.extensionsPath];
                var config = { appender: appender, commonProperties: commonProperties, piiPaths: piiPaths };
                services.set(telemetry_1.ITelemetryService, new descriptors_1.SyncDescriptor(telemetryService_1.TelemetryService, config));
            }
            else {
                services.set(telemetry_1.ITelemetryService, telemetryUtils_1.NullTelemetryService);
            }
            return this.instantiationService.createChild(services);
        };
        CodeApplication.prototype.openFirstWindow = function (accessor) {
            var appInstantiationService = accessor.get(instantiation_1.IInstantiationService);
            // Register more Main IPC services
            var launchService = accessor.get(launchService_1.ILaunchService);
            var launchChannel = new launchService_1.LaunchChannel(launchService);
            this.mainIpcServer.registerChannel('launch', launchChannel);
            // Register more Electron IPC services
            var updateService = accessor.get(update_1.IUpdateService);
            var updateChannel = new updateIpc_1.UpdateChannel(updateService);
            this.electronIpcServer.registerChannel('update', updateChannel);
            var issueService = accessor.get(issue_1.IIssueService);
            var issueChannel = new issueIpc_1.IssueChannel(issueService);
            this.electronIpcServer.registerChannel('issue', issueChannel);
            var workspacesService = accessor.get(workspaces_1.IWorkspacesMainService);
            var workspacesChannel = appInstantiationService.createInstance(workspacesIpc_1.WorkspacesChannel, workspacesService);
            this.electronIpcServer.registerChannel('workspaces', workspacesChannel);
            var windowsService = accessor.get(windows_2.IWindowsService);
            var windowsChannel = new windowsIpc_1.WindowsChannel(windowsService);
            this.electronIpcServer.registerChannel('windows', windowsChannel);
            this.sharedProcessClient.then(function (client) { return client.registerChannel('windows', windowsChannel); });
            var menubarService = accessor.get(menubar_1.IMenubarService);
            var menubarChannel = new menubarIpc_1.MenubarChannel(menubarService);
            this.electronIpcServer.registerChannel('menubar', menubarChannel);
            var urlService = accessor.get(url_1.IURLService);
            var urlChannel = new urlIpc_1.URLServiceChannel(urlService);
            this.electronIpcServer.registerChannel('url', urlChannel);
            // Log level management
            var logLevelChannel = new logIpc_1.LogLevelSetterChannel(accessor.get(log_1.ILogService));
            this.electronIpcServer.registerChannel('loglevel', logLevelChannel);
            this.sharedProcessClient.then(function (client) { return client.registerChannel('loglevel', logLevelChannel); });
            // Lifecycle
            this.lifecycleService.ready();
            // Propagate to clients
            var windowsMainService = this.windowsMainService = accessor.get(windows_3.IWindowsMainService); // TODO@Joao: unfold this
            var args = this.environmentService.args;
            // Create a URL handler which forwards to the last active window
            var activeWindowManager = new windows_2.ActiveWindowManager(windowsService);
            var route = function () { return activeWindowManager.getActiveClientId(); };
            var urlHandlerChannel = this.electronIpcServer.getChannel('urlHandler', { routeCall: route, routeEvent: route });
            var multiplexURLHandler = new urlIpc_1.URLHandlerChannelClient(urlHandlerChannel);
            // On Mac, Code can be running without any open windows, so we must create a window to handle urls,
            // if there is none
            if (platform.isMacintosh) {
                var environmentService_1 = accessor.get(environment_1.IEnvironmentService);
                urlService.registerHandler({
                    handleURL: function (uri) {
                        if (windowsMainService.getWindowCount() === 0) {
                            var cli = __assign({}, environmentService_1.args, { goto: true });
                            var window_1 = windowsMainService.open({ context: 5 /* API */, cli: cli, forceEmpty: true })[0];
                            return window_1.ready().then(function () { return urlService.open(uri); });
                        }
                        return winjs_base_1.TPromise.as(false);
                    }
                });
            }
            // Register the multiple URL handker
            urlService.registerHandler(multiplexURLHandler);
            // Watch Electron URLs and forward them to the UrlService
            var urls = args['open-url'] ? args._urls : [];
            var urlListener = new electronUrlListener_1.ElectronURLListener(urls, urlService, this.windowsMainService);
            this.toDispose.push(urlListener);
            this.windowsMainService.ready(this.userEnv);
            // Open our first window
            var macOpenFiles = global.macOpenFiles;
            var context = !!process.env['VSCODE_CLI'] ? 0 /* CLI */ : 4 /* DESKTOP */;
            var hasCliArgs = argv_1.hasArgs(args._);
            var hasFolderURIs = argv_1.hasArgs(args['folder-uri']);
            var hasFileURIs = argv_1.hasArgs(args['file-uri']);
            if (args['new-window'] && !hasCliArgs && !hasFolderURIs && !hasFileURIs) {
                this.windowsMainService.open({ context: context, cli: args, forceNewWindow: true, forceEmpty: true, initialStartup: true }); // new window if "-n" was used without paths
            }
            else if (macOpenFiles && macOpenFiles.length && !hasCliArgs && !hasFolderURIs && !hasFileURIs) {
                this.windowsMainService.open({ context: 1 /* DOCK */, cli: args, urisToOpen: macOpenFiles.map(function (file) { return uri_1.URI.file(file); }), initialStartup: true }); // mac: open-file event received on startup
            }
            else {
                this.windowsMainService.open({ context: context, cli: args, forceNewWindow: args['new-window'] || (!hasCliArgs && args['unity-launch']), diffMode: args.diff, initialStartup: true }); // default: read paths from cli
            }
        };
        CodeApplication.prototype.afterWindowOpen = function (accessor) {
            var _this = this;
            var windowsMainService = accessor.get(windows_3.IWindowsMainService);
            var windowsMutex = null;
            if (platform.isWindows) {
                // Setup Windows mutex
                try {
                    var Mutex_1 = require.__$__nodeRequire('windows-mutex').Mutex;
                    windowsMutex = new Mutex_1(product_1.default.win32MutexName);
                    this.toDispose.push({ dispose: function () { return windowsMutex.release(); } });
                }
                catch (e) {
                    if (!this.environmentService.isBuilt) {
                        windowsMainService.showMessageBox({
                            title: product_1.default.nameLong,
                            type: 'warning',
                            message: 'Failed to load windows-mutex!',
                            detail: e.toString(),
                            noLink: true
                        });
                    }
                }
                // Ensure Windows foreground love module
                try {
                    // tslint:disable-next-line:no-unused-expression
                    require.__$__nodeRequire('windows-foreground-love');
                }
                catch (e) {
                    if (!this.environmentService.isBuilt) {
                        windowsMainService.showMessageBox({
                            title: product_1.default.nameLong,
                            type: 'warning',
                            message: 'Failed to load windows-foreground-love!',
                            detail: e.toString(),
                            noLink: true
                        });
                    }
                }
            }
            // TODO@sbatten: Remove when switching back to dynamic menu
            // Install Menu
            var instantiationService = accessor.get(instantiation_1.IInstantiationService);
            var configurationService = accessor.get(configuration_1.IConfigurationService);
            var createNativeMenu = true;
            if (platform.isLinux) {
                createNativeMenu = configurationService.getValue('window.titleBarStyle') !== 'custom';
            }
            else if (platform.isWindows) {
                createNativeMenu = configurationService.getValue('window.titleBarStyle') === 'native';
            }
            if (createNativeMenu) {
                instantiationService.createInstance(menus_1.CodeMenu);
            }
            // Jump List
            this.historyMainService.updateWindowsJumpList();
            this.historyMainService.onRecentlyOpenedChange(function () { return _this.historyMainService.updateWindowsJumpList(); });
            // Start shared process after a while
            var sharedProcess = new async_1.RunOnceScheduler(function () { return _this.sharedProcess.spawn(); }, 3000);
            sharedProcess.schedule();
            this.toDispose.push(sharedProcess);
        };
        CodeApplication.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        CodeApplication.MACHINE_ID_KEY = 'telemetry.machineId';
        CodeApplication = __decorate([
            __param(2, instantiation_1.IInstantiationService),
            __param(3, log_1.ILogService),
            __param(4, environment_1.IEnvironmentService),
            __param(5, lifecycleMain_1.ILifecycleService),
            __param(6, configuration_1.IConfigurationService),
            __param(7, state_1.IStateService),
            __param(8, history_1.IHistoryMainService),
            __param(9, label_1.ILabelService)
        ], CodeApplication);
        return CodeApplication;
    }());
    exports.CodeApplication = CodeApplication;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
















































define(__m[185/*vs/code/electron-main/main*/], __M([1/*require*/,0/*exports*/,8/*electron*/,17/*vs/base/common/objects*/,3/*vs/base/common/platform*/,16/*vs/platform/node/product*/,11/*path*/,41/*vs/platform/environment/node/argv*/,34/*vs/base/node/pfs*/,67/*vs/code/node/paths*/,27/*vs/platform/lifecycle/electron-main/lifecycleMain*/,51/*vs/base/parts/ipc/node/ipc.net*/,2/*vs/base/common/winjs.base*/,63/*vs/platform/launch/electron-main/launchService*/,106/*vs/platform/instantiation/common/instantiationService*/,61/*vs/platform/instantiation/common/serviceCollection*/,55/*vs/platform/instantiation/common/descriptors*/,7/*vs/platform/log/common/log*/,136/*vs/platform/state/node/stateService*/,28/*vs/platform/state/common/state*/,57/*vs/platform/backup/common/backup*/,161/*vs/platform/backup/electron-main/backupMainService*/,9/*vs/platform/environment/common/environment*/,124/*vs/platform/environment/node/environmentService*/,14/*vs/platform/configuration/common/configuration*/,131/*vs/platform/configuration/node/configurationService*/,42/*vs/platform/request/node/request*/,95/*vs/platform/request/electron-main/requestService*/,49/*vs/platform/url/common/url*/,149/*vs/platform/url/common/urlService*/,21/*fs*/,115/*vs/code/electron-main/app*/,168/*vs/platform/history/electron-main/historyMainService*/,44/*vs/platform/history/common/history*/,172/*vs/platform/workspaces/electron-main/workspacesMainService*/,19/*vs/platform/workspaces/common/workspaces*/,10/*vs/nls!vs/code/electron-main/main*/,31/*vs/base/common/labels*/,114/*vs/platform/log/node/spdlogService*/,70/*vs/platform/diagnostics/electron-main/diagnosticsService*/,112/*vs/platform/log/common/bufferLog*/,120/*vs/code/electron-main/logUploader*/,23/*vs/base/common/errors*/,100/*vs/platform/dialogs/common/dialogs*/,94/*vs/platform/dialogs/node/dialogService*/,48/*vs/platform/label/common/label*/,146/*vs/code/code.main*/]), function (require, exports, electron_1, objects_1, platform, product_1, path, argv_1, pfs_1, paths_1, lifecycleMain_1, ipc_net_1, winjs_base_1, launchService_1, instantiationService_1, serviceCollection_1, descriptors_1, log_1, stateService_1, state_1, backup_1, backupMainService_1, environment_1, environmentService_1, configuration_1, configurationService_1, request_1, requestService_1, url_1, urlService_1, fs, app_1, historyMainService_1, history_1, workspacesMainService_1, workspaces_1, nls_1, labels_1, spdlogService_1, diagnosticsService_1, bufferLog_1, logUploader_1, errors_1, dialogs_1, dialogService_1, label_1) {
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    function createServices(args, bufferLogService) {
        var services = new serviceCollection_1.ServiceCollection();
        var environmentService = new environmentService_1.EnvironmentService(args, process.execPath);
        var consoleLogService = new log_1.ConsoleLogMainService(log_1.getLogLevel(environmentService));
        var logService = new log_1.MultiplexLogService([consoleLogService, bufferLogService]);
        var labelService = new label_1.LabelService(environmentService, undefined);
        process.once('exit', function () { return logService.dispose(); });
        // Eventually cleanup
        setTimeout(function () { return cleanupOlderLogs(environmentService).then(null, function (err) { return console.error(err); }); }, 10000);
        services.set(environment_1.IEnvironmentService, environmentService);
        services.set(label_1.ILabelService, labelService);
        services.set(log_1.ILogService, logService);
        services.set(workspaces_1.IWorkspacesMainService, new descriptors_1.SyncDescriptor(workspacesMainService_1.WorkspacesMainService));
        services.set(history_1.IHistoryMainService, new descriptors_1.SyncDescriptor(historyMainService_1.HistoryMainService));
        services.set(lifecycleMain_1.ILifecycleService, new descriptors_1.SyncDescriptor(lifecycleMain_1.LifecycleService));
        services.set(state_1.IStateService, new descriptors_1.SyncDescriptor(stateService_1.StateService));
        services.set(configuration_1.IConfigurationService, new descriptors_1.SyncDescriptor(configurationService_1.ConfigurationService));
        services.set(request_1.IRequestService, new descriptors_1.SyncDescriptor(requestService_1.RequestService));
        services.set(url_1.IURLService, new descriptors_1.SyncDescriptor(urlService_1.URLService));
        services.set(backup_1.IBackupMainService, new descriptors_1.SyncDescriptor(backupMainService_1.BackupMainService));
        services.set(dialogs_1.IDialogService, new descriptors_1.SyncDescriptor(dialogService_1.CommandLineDialogService));
        services.set(diagnosticsService_1.IDiagnosticsService, new descriptors_1.SyncDescriptor(diagnosticsService_1.DiagnosticsService));
        return new instantiationService_1.InstantiationService(services, true);
    }
    /**
     * Cleans up older logs, while keeping the 10 most recent ones.
    */
    function cleanupOlderLogs(environmentService) {
        return __awaiter(this, void 0, void 0, function () {
            var currentLog, logsRoot, children, allSessions, oldSessions, toDelete;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentLog = path.basename(environmentService.logsPath);
                        logsRoot = path.dirname(environmentService.logsPath);
                        return [4 /*yield*/, pfs_1.readdir(logsRoot)];
                    case 1:
                        children = _a.sent();
                        allSessions = children.filter(function (name) { return /^\d{8}T\d{6}$/.test(name); });
                        oldSessions = allSessions.sort().filter(function (d, i) { return d !== currentLog; });
                        toDelete = oldSessions.slice(0, Math.max(0, oldSessions.length - 9));
                        return [4 /*yield*/, winjs_base_1.TPromise.join(toDelete.map(function (name) { return pfs_1.rimraf(path.join(logsRoot, name)); }))];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    }
    function createPaths(environmentService) {
        var paths = [
            environmentService.appSettingsHome,
            environmentService.extensionsPath,
            environmentService.nodeCachedDataDir,
            environmentService.logsPath
        ];
        return winjs_base_1.TPromise.join(paths.map(function (p) { return p && pfs_1.mkdirp(p); }));
    }
    var ExpectedError = /** @class */ (function (_super) {
        __extends(ExpectedError, _super);
        function ExpectedError() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isExpected = true;
            return _this;
        }
        return ExpectedError;
    }(Error));
    function setupIPC(accessor) {
        var logService = accessor.get(log_1.ILogService);
        var environmentService = accessor.get(environment_1.IEnvironmentService);
        var requestService = accessor.get(request_1.IRequestService);
        var diagnosticsService = accessor.get(diagnosticsService_1.IDiagnosticsService);
        function allowSetForegroundWindow(service) {
            var promise = winjs_base_1.TPromise.wrap(void 0);
            if (platform.isWindows) {
                promise = service.getMainProcessId()
                    .then(function (processId) {
                    logService.trace('Sending some foreground love to the running instance:', processId);
                    try {
                        var allowSetForegroundWindow_1 = require.__$__nodeRequire('windows-foreground-love').allowSetForegroundWindow;
                        allowSetForegroundWindow_1(processId);
                    }
                    catch (e) {
                        // noop
                    }
                });
            }
            return promise;
        }
        function setup(retry) {
            return ipc_net_1.serve(environmentService.mainIPCHandle).then(function (server) {
                // Print --status usage info
                if (environmentService.args.status) {
                    logService.warn('Warning: The --status argument can only be used if Code is already running. Please run it again after Code has started.');
                    throw new ExpectedError('Terminating...');
                }
                // Log uploader usage info
                if (typeof environmentService.args['upload-logs'] !== 'undefined') {
                    logService.warn('Warning: The --upload-logs argument can only be used if Code is already running. Please run it again after Code has started.');
                    throw new ExpectedError('Terminating...');
                }
                // dock might be hidden at this case due to a retry
                if (platform.isMacintosh) {
                    electron_1.app.dock.show();
                }
                // Set the VSCODE_PID variable here when we are sure we are the first
                // instance to startup. Otherwise we would wrongly overwrite the PID
                process.env['VSCODE_PID'] = String(process.pid);
                return server;
            }, function (err) {
                if (err.code !== 'EADDRINUSE') {
                    return Promise.reject(err);
                }
                // Since we are the second instance, we do not want to show the dock
                if (platform.isMacintosh) {
                    electron_1.app.dock.hide();
                }
                // there's a running instance, let's connect to it
                return ipc_net_1.connect(environmentService.mainIPCHandle, 'main').then(function (client) {
                    // Tests from CLI require to be the only instance currently
                    if (environmentService.extensionTestsPath && !environmentService.debugExtensionHost.break) {
                        var msg = 'Running extension tests from the command line is currently only supported if no other instance of Code is running.';
                        logService.error(msg);
                        client.dispose();
                        return Promise.reject(new Error(msg));
                    }
                    // Show a warning dialog after some timeout if it takes long to talk to the other instance
                    // Skip this if we are running with --wait where it is expected that we wait for a while.
                    // Also skip when gathering diagnostics (--status) which can take a longer time.
                    var startupWarningDialogHandle;
                    if (!environmentService.wait && !environmentService.status && !environmentService.args['upload-logs']) {
                        startupWarningDialogHandle = setTimeout(function () {
                            showStartupWarningDialog(nls_1.localize(0, null, product_1.default.nameShort), nls_1.localize(1, null));
                        }, 10000);
                    }
                    var channel = client.getChannel('launch');
                    var service = new launchService_1.LaunchChannelClient(channel);
                    // Process Info
                    if (environmentService.args.status) {
                        return service.getMainProcessInfo().then(function (info) {
                            return diagnosticsService.printDiagnostics(info).then(function () { return Promise.reject(new ExpectedError()); });
                        });
                    }
                    // Log uploader
                    if (typeof environmentService.args['upload-logs'] !== 'undefined') {
                        return logUploader_1.uploadLogs(channel, requestService, environmentService)
                            .then(function () { return Promise.reject(new ExpectedError()); });
                    }
                    logService.trace('Sending env to running instance...');
                    return allowSetForegroundWindow(service)
                        .then(function () { return service.start(environmentService.args, process.env); })
                        .then(function () { return client.dispose(); })
                        .then(function () {
                        // Now that we started, make sure the warning dialog is prevented
                        if (startupWarningDialogHandle) {
                            clearTimeout(startupWarningDialogHandle);
                        }
                        return Promise.reject(new ExpectedError('Sent env to running instance. Terminating...'));
                    });
                }, function (err) {
                    if (!retry || platform.isWindows || err.code !== 'ECONNREFUSED') {
                        if (err.code === 'EPERM') {
                            showStartupWarningDialog(nls_1.localize(2, null, product_1.default.nameShort), nls_1.localize(3, null));
                        }
                        return Promise.reject(err);
                    }
                    // it happens on Linux and OS X that the pipe is left behind
                    // let's delete it, since we can't connect to it
                    // and then retry the whole thing
                    try {
                        fs.unlinkSync(environmentService.mainIPCHandle);
                    }
                    catch (e) {
                        logService.warn('Could not delete obsolete instance handle', e);
                        return Promise.reject(e);
                    }
                    return setup(false);
                });
            });
        }
        return setup(true);
    }
    function showStartupWarningDialog(message, detail) {
        electron_1.dialog.showMessageBox({
            title: product_1.default.nameLong,
            type: 'warning',
            buttons: [labels_1.mnemonicButtonLabel(nls_1.localize(4, null))],
            message: message,
            detail: detail,
            noLink: true
        });
    }
    function quit(accessor, reason) {
        var logService = accessor.get(log_1.ILogService);
        var lifecycleService = accessor.get(lifecycleMain_1.ILifecycleService);
        var exitCode = 0;
        if (reason) {
            if (reason.isExpected) {
                if (reason.message) {
                    logService.trace(reason.message);
                }
            }
            else {
                exitCode = 1; // signal error to the outside
                if (reason.stack) {
                    logService.error(reason.stack);
                }
                else {
                    logService.error("Startup error: " + reason.toString());
                }
            }
        }
        lifecycleService.kill(exitCode);
    }
    function main() {
        // Set the error handler early enough so that we are not getting the
        // default electron error dialog popping up
        errors_1.setUnexpectedErrorHandler(function (err) { return console.error(err); });
        var args;
        try {
            args = argv_1.parseMainProcessArgv(process.argv);
            args = paths_1.validatePaths(args);
        }
        catch (err) {
            console.error(err.message);
            electron_1.app.exit(1);
            return void 0;
        }
        // We need to buffer the spdlog logs until we are sure
        // we are the only instance running, otherwise we'll have concurrent
        // log file access on Windows
        // https://github.com/Microsoft/vscode/issues/41218
        var bufferLogService = new bufferLog_1.BufferLogService();
        var instantiationService = createServices(args, bufferLogService);
        return instantiationService.invokeFunction(function (accessor) {
            // Patch `process.env` with the instance's environment
            var environmentService = accessor.get(environment_1.IEnvironmentService);
            var instanceEnv = {
                VSCODE_IPC_HOOK: environmentService.mainIPCHandle,
                VSCODE_NLS_CONFIG: process.env['VSCODE_NLS_CONFIG'],
                VSCODE_LOGS: process.env['VSCODE_LOGS']
            };
            if (process.env['VSCODE_PORTABLE']) {
                instanceEnv['VSCODE_PORTABLE'] = process.env['VSCODE_PORTABLE'];
            }
            objects_1.assign(process.env, instanceEnv);
            // Startup
            return instantiationService.invokeFunction(function (a) { return createPaths(a.get(environment_1.IEnvironmentService)); })
                .then(function () { return instantiationService.invokeFunction(setupIPC); })
                .then(function (mainIpcServer) {
                bufferLogService.logger = spdlogService_1.createSpdLogService('main', bufferLogService.getLevel(), environmentService.logsPath);
                return instantiationService.createInstance(app_1.CodeApplication, mainIpcServer, instanceEnv).startup();
            });
        }).then(null, function (err) { return instantiationService.invokeFunction(quit, err); });
    }
    main();
});

}).call(this);
//# sourceMappingURL=main.js.map
